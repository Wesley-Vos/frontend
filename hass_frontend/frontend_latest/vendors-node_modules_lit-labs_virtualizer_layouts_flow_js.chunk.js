"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_layouts_flow_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/layouts/flow.js":
/*!************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/flow.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"flow\": () => (/* binding */ flow),\n/* harmony export */   \"FlowLayout\": () => (/* binding */ FlowLayout)\n/* harmony export */ });\n/* harmony import */ var _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/SizeCache.js */ \"./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\");\n/* harmony import */ var _shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/BaseLayout.js */ \"./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\nconst flow = config => Object.assign({\n  type: FlowLayout\n}, config);\n\nfunction leadingMargin(direction) {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\n\nfunction trailingMargin(direction) {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\n\nfunction offset(direction) {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\n\nfunction collapseMargins(a, b) {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\n\nclass MetricsCache {\n  constructor() {\n    this._childSizeCache = new _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__.SizeCache();\n    this._marginSizeCache = new _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__.SizeCache();\n    this._metricsCache = new Map();\n  }\n\n  update(metrics, direction) {\n    var _a, _b;\n\n    const marginsToUpdate = new Set();\n    Object.keys(metrics).forEach(key => {\n      const k = Number(key);\n\n      this._metricsCache.set(k, metrics[k]);\n\n      this._childSizeCache.set(k, metrics[k][(0,_shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__.dim1)(direction)]);\n\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n\n    for (const k of marginsToUpdate) {\n      const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n      const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n\n  get averageChildSize() {\n    return this._childSizeCache.averageSize;\n  }\n\n  get totalChildSize() {\n    return this._childSizeCache.totalSize;\n  }\n\n  get averageMarginSize() {\n    return this._marginSizeCache.averageSize;\n  }\n\n  get totalMarginSize() {\n    return this._marginSizeCache.totalSize;\n  }\n\n  getLeadingMarginValue(index, direction) {\n    var _a;\n\n    return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n  }\n\n  getChildSize(index) {\n    return this._childSizeCache.getSize(index);\n  }\n\n  getMarginSize(index) {\n    return this._marginSizeCache.getSize(index);\n  }\n\n  clear() {\n    this._childSizeCache.clear();\n\n    this._marginSizeCache.clear();\n\n    this._metricsCache.clear();\n  }\n\n}\n\nclass FlowLayout extends _shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__.BaseLayout {\n  constructor() {\n    super(...arguments);\n    /**\n     * Initial estimate of item size\n     */\n\n    this._itemSize = {\n      width: 100,\n      height: 100\n    };\n    /**\n     * Indices of children mapped to their (position and length) in the scrolling\n     * direction. Used to keep track of children that are in range.\n     */\n\n    this._physicalItems = new Map();\n    /**\n     * Used in tandem with _physicalItems to track children in range across\n     * reflows.\n     */\n\n    this._newPhysicalItems = new Map();\n    /**\n     * Width and height of children by their index.\n     */\n\n    this._metricsCache = new MetricsCache();\n    /**\n     * anchorIdx is the anchor around which we reflow. It is designed to allow\n     * jumping to any point of the scroll size. We choose it once and stick with\n     * it until stable. _first and _last are deduced around it.\n     */\n\n    this._anchorIdx = null;\n    /**\n     * Position in the scrolling direction of the anchor child.\n     */\n\n    this._anchorPos = null;\n    /**\n     * Whether all children in range were in range during the previous reflow.\n     */\n\n    this._stable = true;\n    /**\n     * Whether to remeasure children during the next reflow.\n     */\n\n    this._needsRemeasure = false;\n    this._measureChildren = true;\n    this._estimate = true;\n  } // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n  // })\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n\n\n  get measureChildren() {\n    return this._measureChildren;\n  }\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n\n\n  updateItemSizes(sizes) {\n    this._metricsCache.update(sizes, this.direction); // if (this._nMeasured) {\n    // this._updateItemSize();\n\n\n    this._scheduleReflow(); // }\n\n  }\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n\n\n  _getPhysicalItem(idx) {\n    var _a;\n\n    return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n  }\n\n  _getSize(idx) {\n    const item = this._getPhysicalItem(idx);\n\n    return item && this._metricsCache.getChildSize(idx);\n  }\n\n  _getAverageSize() {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n\n\n  _getPosition(idx) {\n    var _a;\n\n    const item = this._getPhysicalItem(idx);\n\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return idx === 0 ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize : item ? item.pos : averageMarginSize + idx * (averageMarginSize + this._getAverageSize());\n  }\n\n  _calculateAnchor(lower, upper) {\n    if (lower <= 0) {\n      return 0;\n    }\n\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this._totalItems - 1;\n    }\n\n    return Math.max(0, Math.min(this._totalItems - 1, Math.floor((lower + upper) / 2 / this._delta)));\n  }\n\n  _getAnchor(lower, upper) {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n\n    if (this._first < 0) {\n      console.error('_getAnchor: negative _first');\n      return this._calculateAnchor(lower, upper);\n    }\n\n    if (this._last < 0) {\n      console.error('_getAnchor: negative _last');\n      return this._calculateAnchor(lower, upper);\n    }\n\n    const firstItem = this._getPhysicalItem(this._first),\n          lastItem = this._getPhysicalItem(this._last),\n          firstMin = firstItem.pos,\n          lastMin = lastItem.pos,\n          lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    } // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n\n\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n\n      cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n    }\n\n    return candidateIdx;\n  }\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n\n\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this._totalItems === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n  /**\n   * Sets the range to empty.\n   */\n\n\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n\n    this._newPhysicalItems.clear();\n\n    this._physicalItems = items;\n    this._stable = true;\n  }\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n\n\n  _getItems() {\n    var _a, _b;\n\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper; // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n    // If we have a scrollToIndex, we anchor on the given\n    // index and set the scroll position accordingly\n\n    if (this._scrollToIndex >= 0) {\n      this._anchorIdx = Math.min(this._scrollToIndex, this._totalItems - 1);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n\n      this._scrollIfNeeded();\n    } // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n\n\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n\n      return;\n    } // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n\n\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n\n    let anchorSize = this._getSize(this._anchorIdx);\n\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n\n    let anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n    let anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n\n    if (this._anchorIdx === this._totalItems - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    } // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n\n\n    let anchorErr = 0;\n\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n\n    items.set(this._anchorIdx, {\n      pos: this._anchorPos,\n      size: anchorSize\n    });\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos;\n    this._physicalMax = this._anchorPos + anchorSize;\n\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n\n      let margin = this._metricsCache.getMarginSize(this._first + 1);\n\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n\n      this._physicalMin -= size + margin;\n      const pos = this._physicalMin;\n      items.set(this._first, {\n        pos,\n        size\n      });\n\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n\n    while (this._physicalMax < upper && this._last < this._totalItems - 1) {\n      let margin = this._metricsCache.getMarginSize(++this._last);\n\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n\n      let size = this._getSize(this._last);\n\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n\n      const pos = this._physicalMax + margin;\n      items.set(this._last, {\n        pos,\n        size\n      });\n      this._physicalMax += margin + size;\n\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    } // This handles the cases where we were relying on estimated sizes.\n\n\n    const extentErr = this._calculateError();\n\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach(item => item.pos -= extentErr);\n      this._scrollError += extentErr;\n    }\n\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n\n      this._newPhysicalItems.clear();\n\n      this._physicalItems = items;\n    }\n  }\n\n  _calculateError() {\n    var _a, _b;\n\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n\n    if (this._first === 0) {\n      return this._physicalMin - ((_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize);\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this._totalItems - 1) {\n      return this._physicalMax + ((_b = this._metricsCache.getMarginSize(this._totalItems)) !== null && _b !== void 0 ? _b : averageMarginSize) - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return this._physicalMax - this._scrollSize + (this._totalItems - 1 - this._last) * this._delta;\n    }\n\n    return 0;\n  } // TODO: Can this be made to inherit from base, with proper hooks?\n\n\n  _reflow() {\n    const {\n      _first,\n      _last,\n      _scrollSize\n    } = this;\n\n    this._updateScrollSize();\n\n    this._getActiveItems();\n\n    if (this._scrollSize !== _scrollSize) {\n      this._emitScrollSize();\n    }\n\n    this._updateVisibleIndices();\n\n    this._emitRange();\n\n    if (this._first === -1 && this._last === -1) {\n      this._resetReflowState();\n    } else if (this._first !== _first || this._last !== _last || this._needsRemeasure) {\n      this._emitChildPositions();\n\n      this._emitScrollError();\n    } else {\n      this._emitChildPositions();\n\n      this._emitScrollError();\n\n      this._resetReflowState();\n    }\n  }\n\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n\n  _updateScrollSize() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    this._scrollSize = Math.max(1, this._totalItems * (averageMarginSize + this._getAverageSize()) + averageMarginSize);\n  }\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n\n\n  get _delta() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n\n\n  _getItemPosition(idx) {\n    var _a;\n\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize)\n    };\n  }\n  /**\n   * Returns the height and width of the item at idx.\n   */\n\n\n  _getItemSize(idx) {\n    var _a;\n\n    return {\n      [this._sizeDim]: (this._getSize(idx) || this._getAverageSize()) + ((_a = this._metricsCache.getMarginSize(idx + 1)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim]\n    };\n  }\n\n  _viewDim2Changed() {\n    this._needsRemeasure = true;\n\n    this._scheduleReflow();\n  }\n\n  _emitRange() {\n    const remeasure = this._needsRemeasure;\n    const stable = this._stable;\n    this._needsRemeasure = false;\n\n    super._emitRange({\n      remeasure,\n      stable\n    });\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvZmxvdy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7QUFJQTtBQUVBO0FBQ0E7QUFtQkE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUtBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFtREE7O0FBakRBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQXJEQTs7QUF3REE7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7QUFHQTs7QUFDQTtBQUVBOzs7QUFHQTs7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7Ozs7QUFJQTs7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBO0FBRUE7QUFvWEE7QUFoWEE7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTs7O0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTs7QUFFQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUdBOzs7QUFDQTs7O0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOzs7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0E7OztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7OztBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTs7QUFFQTs7O0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBbGFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2xheW91dHMvZmxvdy50cz8xODRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5pbXBvcnQgeyBTaXplQ2FjaGUgfSBmcm9tICcuL3NoYXJlZC9TaXplQ2FjaGUuanMnO1xuaW1wb3J0IHtCYXNlTGF5b3V0LCBCYXNlTGF5b3V0Q29uZmlnLCBkaW0xfSBmcm9tICcuL3NoYXJlZC9CYXNlTGF5b3V0LmpzJztcbmltcG9ydCB7SXRlbUJveCwgUG9zaXRpb25zLCBTaXplLCBNYXJnaW5zLCBtYXJnaW4sIFNjcm9sbERpcmVjdGlvbiwgb2Zmc2V0QXhpc30gZnJvbSAnLi9zaGFyZWQvTGF5b3V0LmpzJztcblxudHlwZSBJdGVtQm91bmRzID0ge1xuICBwb3M6IG51bWJlcixcbiAgc2l6ZTogbnVtYmVyXG59O1xuXG50eXBlIEZsb3dMYXlvdXRDb25zdHJ1Y3RvciA9IHtcbiAgcHJvdG90eXBlOiBGbG93TGF5b3V0LFxuICBuZXcoY29uZmlnPzogQmFzZUxheW91dENvbmZpZyk6IEZsb3dMYXlvdXRcbn1cblxudHlwZSBGbG93TGF5b3V0U3BlY2lmaWVyID0gQmFzZUxheW91dENvbmZpZyAmIHtcbiAgdHlwZTogRmxvd0xheW91dENvbnN0cnVjdG9yXG59XG5cbnR5cGUgRmxvd0xheW91dFNwZWNpZmllckZhY3RvcnkgPSAoY29uZmlnPzogQmFzZUxheW91dENvbmZpZykgPT4gRmxvd0xheW91dFNwZWNpZmllcjtcblxuZXhwb3J0IGNvbnN0IGZsb3c6IEZsb3dMYXlvdXRTcGVjaWZpZXJGYWN0b3J5ID0gKGNvbmZpZz86IEJhc2VMYXlvdXRDb25maWcpID0+IE9iamVjdC5hc3NpZ24oe1xuICB0eXBlOiBGbG93TGF5b3V0XG59LCBjb25maWcpO1xuXG5mdW5jdGlvbiBsZWFkaW5nTWFyZ2luKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogbWFyZ2luIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblRvcCc7XG59XG5cbmZ1bmN0aW9uIHRyYWlsaW5nTWFyZ2luKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogbWFyZ2luIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ21hcmdpblJpZ2h0JyA6ICdtYXJnaW5Cb3R0b20nO1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBvZmZzZXRBeGlzIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3hPZmZzZXQnIDogJ3lPZmZzZXQnO1xufVxuXG5mdW5jdGlvbiBjb2xsYXBzZU1hcmdpbnMoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBtID0gW2EsIGJdLnNvcnQoKTtcbiAgcmV0dXJuIG1bMV0gPD0gMFxuICA/IE1hdGgubWluKC4uLm0pXG4gIDogbVswXSA+PSAwXG4gICAgPyBNYXRoLm1heCguLi5tKVxuICAgIDogbVswXSArIG1bMV07XG59XG5cbmNsYXNzIE1ldHJpY3NDYWNoZSB7XG4gIHByaXZhdGUgX2NoaWxkU2l6ZUNhY2hlID0gbmV3IFNpemVDYWNoZSgpO1xuICBwcml2YXRlIF9tYXJnaW5TaXplQ2FjaGUgPSBuZXcgU2l6ZUNhY2hlKCk7XG4gIHByaXZhdGUgX21ldHJpY3NDYWNoZTogTWFwPG51bWJlciwgU2l6ZSAmIE1hcmdpbnM+ID0gbmV3IE1hcCgpO1xuXG4gIHVwZGF0ZShtZXRyaWNzOiB7W2tleTogbnVtYmVyXTogU2l6ZSAmIE1hcmdpbnN9LCBkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbikge1xuICAgIGNvbnN0IG1hcmdpbnNUb1VwZGF0ZTogU2V0PG51bWJlcj4gPSBuZXcgU2V0KCk7XG4gICAgT2JqZWN0LmtleXMobWV0cmljcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBrID0gTnVtYmVyKGtleSk7XG4gICAgICB0aGlzLl9tZXRyaWNzQ2FjaGUuc2V0KGssIG1ldHJpY3Nba10pO1xuICAgICAgdGhpcy5fY2hpbGRTaXplQ2FjaGUuc2V0KGssIG1ldHJpY3Nba11bZGltMShkaXJlY3Rpb24pXSk7XG4gICAgICBtYXJnaW5zVG9VcGRhdGUuYWRkKGspO1xuICAgICAgbWFyZ2luc1RvVXBkYXRlLmFkZChrICsgMSk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBrIG9mIG1hcmdpbnNUb1VwZGF0ZSkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX21ldHJpY3NDYWNoZS5nZXQoayk/LltsZWFkaW5nTWFyZ2luKGRpcmVjdGlvbildIHx8IDA7XG4gICAgICBjb25zdCBiID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldChrIC0gMSk/Llt0cmFpbGluZ01hcmdpbihkaXJlY3Rpb24pXSB8fCAwO1xuICAgICAgdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLnNldChrLCBjb2xsYXBzZU1hcmdpbnMoYSwgYikpXG4gICAgfVxuICB9XG5cbiAgZ2V0IGF2ZXJhZ2VDaGlsZFNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRTaXplQ2FjaGUuYXZlcmFnZVNpemU7XG4gIH1cblxuICBnZXQgdG90YWxDaGlsZFNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRTaXplQ2FjaGUudG90YWxTaXplO1xuICB9XG5cbiAgZ2V0IGF2ZXJhZ2VNYXJnaW5TaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmdpblNpemVDYWNoZS5hdmVyYWdlU2l6ZTtcbiAgfVxuXG4gIGdldCB0b3RhbE1hcmdpblNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLnRvdGFsU2l6ZTtcbiAgfVxuXG4gIGdldExlYWRpbmdNYXJnaW5WYWx1ZShpbmRleDogbnVtYmVyLCBkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0KGluZGV4KT8uW2xlYWRpbmdNYXJnaW4oZGlyZWN0aW9uKV0gfHwgMDtcbiAgfVxuXG4gIGdldENoaWxkU2l6ZShpbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkU2l6ZUNhY2hlLmdldFNpemUoaW5kZXgpO1xuICB9XG5cbiAgZ2V0TWFyZ2luU2l6ZShpbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmdpblNpemVDYWNoZS5nZXRTaXplKGluZGV4KTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2NoaWxkU2l6ZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fbWV0cmljc0NhY2hlLmNsZWFyKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZsb3dMYXlvdXQgZXh0ZW5kcyBCYXNlTGF5b3V0PEJhc2VMYXlvdXRDb25maWc+IHtcbiAgLyoqXG4gICAqIEluaXRpYWwgZXN0aW1hdGUgb2YgaXRlbSBzaXplXG4gICAqL1xuICBfaXRlbVNpemU6IFNpemUgPSB7d2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDB9O1xuXG4gIC8qKlxuICAgKiBJbmRpY2VzIG9mIGNoaWxkcmVuIG1hcHBlZCB0byB0aGVpciAocG9zaXRpb24gYW5kIGxlbmd0aCkgaW4gdGhlIHNjcm9sbGluZ1xuICAgKiBkaXJlY3Rpb24uIFVzZWQgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiB0aGF0IGFyZSBpbiByYW5nZS5cbiAgICovXG4gIF9waHlzaWNhbEl0ZW1zOiBNYXA8bnVtYmVyLCBJdGVtQm91bmRzPiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogVXNlZCBpbiB0YW5kZW0gd2l0aCBfcGh5c2ljYWxJdGVtcyB0byB0cmFjayBjaGlsZHJlbiBpbiByYW5nZSBhY3Jvc3NcbiAgICogcmVmbG93cy5cbiAgICovXG4gIF9uZXdQaHlzaWNhbEl0ZW1zOiBNYXA8bnVtYmVyLCBJdGVtQm91bmRzPiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogV2lkdGggYW5kIGhlaWdodCBvZiBjaGlsZHJlbiBieSB0aGVpciBpbmRleC5cbiAgICovXG4gIF9tZXRyaWNzQ2FjaGUgPSBuZXcgTWV0cmljc0NhY2hlKCk7XG5cbiAgLyoqXG4gICAqIGFuY2hvcklkeCBpcyB0aGUgYW5jaG9yIGFyb3VuZCB3aGljaCB3ZSByZWZsb3cuIEl0IGlzIGRlc2lnbmVkIHRvIGFsbG93XG4gICAqIGp1bXBpbmcgdG8gYW55IHBvaW50IG9mIHRoZSBzY3JvbGwgc2l6ZS4gV2UgY2hvb3NlIGl0IG9uY2UgYW5kIHN0aWNrIHdpdGhcbiAgICogaXQgdW50aWwgc3RhYmxlLiBfZmlyc3QgYW5kIF9sYXN0IGFyZSBkZWR1Y2VkIGFyb3VuZCBpdC5cbiAgICovXG4gIF9hbmNob3JJZHg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbiBvZiB0aGUgYW5jaG9yIGNoaWxkLlxuICAgKi9cbiAgX2FuY2hvclBvczogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgYWxsIGNoaWxkcmVuIGluIHJhbmdlIHdlcmUgaW4gcmFuZ2UgZHVyaW5nIHRoZSBwcmV2aW91cyByZWZsb3cuXG4gICAqL1xuICBfc3RhYmxlID0gdHJ1ZTtcblxuICAvKipcbiAgICogV2hldGhlciB0byByZW1lYXN1cmUgY2hpbGRyZW4gZHVyaW5nIHRoZSBuZXh0IHJlZmxvdy5cbiAgICovXG4gIF9uZWVkc1JlbWVhc3VyZSA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX21lYXN1cmVDaGlsZHJlbiA9IHRydWU7XG5cbiAgX2VzdGltYXRlID0gdHJ1ZTtcblxuICAvLyBwcm90ZWN0ZWQgX2RlZmF1bHRDb25maWc6IEJhc2VMYXlvdXRDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBzdXBlci5fZGVmYXVsdENvbmZpZywge1xuXG4gIC8vIH0pXG5cbiAgLy8gY29uc3RydWN0b3IoY29uZmlnOiBMYXlvdXQxZENvbmZpZykge1xuICAvLyAgIHN1cGVyKGNvbmZpZyk7XG4gIC8vIH1cblxuICBnZXQgbWVhc3VyZUNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWFzdXJlQ2hpbGRyZW47XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBhdmVyYWdlIHNpemUgb2YgYWxsIGNoaWxkcmVuIHJlcHJlc2VudGVkIGluIHRoZSBzaXplc1xuICAgKiBhcmd1bWVudC5cbiAgICovXG4gIHVwZGF0ZUl0ZW1TaXplcyhzaXplczoge1trZXk6IG51bWJlcl06IEl0ZW1Cb3h9KSB7XG4gICAgdGhpcy5fbWV0cmljc0NhY2hlLnVwZGF0ZShzaXplcyBhcyBTaXplICYgTWFyZ2lucywgdGhpcy5kaXJlY3Rpb24pO1xuICAgIC8vIGlmICh0aGlzLl9uTWVhc3VyZWQpIHtcbiAgICAgIC8vIHRoaXMuX3VwZGF0ZUl0ZW1TaXplKCk7XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgIC8vIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGF2ZXJhZ2UgaXRlbSBzaXplIGJhc2VkIG9uIHRoZSB0b3RhbCBsZW5ndGggYW5kIG51bWJlciBvZiBjaGlsZHJlblxuICAgKiBpbiByYW5nZS5cbiAgICovXG4gIC8vIF91cGRhdGVJdGVtU2l6ZSgpIHtcbiAgLy8gICAvLyBLZWVwIGludGVnZXIgdmFsdWVzLlxuICAvLyAgIHRoaXMuX2l0ZW1TaXplW3RoaXMuX3NpemVEaW1dID0gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VDaGlsZFNpemU7XG4gIC8vIH1cblxuICBfZ2V0UGh5c2ljYWxJdGVtKGlkeDogbnVtYmVyKTogSXRlbUJvdW5kcyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMuZ2V0KGlkeCkgPz8gdGhpcy5fcGh5c2ljYWxJdGVtcy5nZXQoaWR4KTtcbiAgfVxuXG4gIF9nZXRTaXplKGlkeDogbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fZ2V0UGh5c2ljYWxJdGVtKGlkeCk7XG4gICAgcmV0dXJuIGl0ZW0gJiYgdGhpcy5fbWV0cmljc0NhY2hlLmdldENoaWxkU2l6ZShpZHgpO1xuICB9XG5cbiAgX2dldEF2ZXJhZ2VTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX21ldHJpY3NDYWNoZS5hdmVyYWdlQ2hpbGRTaXplIHx8IHRoaXMuX2l0ZW1TaXplW3RoaXMuX3NpemVEaW1dO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICogRXN0aW1hdGVzIGl0IGlmIHRoZSBpdGVtIGF0IGlkeCBpcyBub3QgaW4gdGhlIERPTS5cbiAgICovXG4gIF9nZXRQb3NpdGlvbihpZHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2dldFBoeXNpY2FsSXRlbShpZHgpO1xuICAgIGNvbnN0IHsgYXZlcmFnZU1hcmdpblNpemUgfSA9IHRoaXMuX21ldHJpY3NDYWNoZTtcbiAgICByZXR1cm4gaWR4ID09PSAwXG4gICAgICA/IHRoaXMuX21ldHJpY3NDYWNoZS5nZXRNYXJnaW5TaXplKDApID8/IGF2ZXJhZ2VNYXJnaW5TaXplXG4gICAgICA6IGl0ZW1cbiAgICAgICAgPyBpdGVtLnBvc1xuICAgICAgICA6IGF2ZXJhZ2VNYXJnaW5TaXplICsgaWR4ICogKGF2ZXJhZ2VNYXJnaW5TaXplICsgdGhpcy5fZ2V0QXZlcmFnZVNpemUoKSk7XG4gIH1cblxuICBfY2FsY3VsYXRlQW5jaG9yKGxvd2VyOiBudW1iZXIsIHVwcGVyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChsb3dlciA8PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHVwcGVyID4gdGhpcy5fc2Nyb2xsU2l6ZSAtIHRoaXMuX3ZpZXdEaW0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG90YWxJdGVtcyAtIDE7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgMCxcbiAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICB0aGlzLl90b3RhbEl0ZW1zIC0gMSxcbiAgICAgICAgICAgIE1hdGguZmxvb3IoKChsb3dlciArIHVwcGVyKSAvIDIpIC8gdGhpcy5fZGVsdGEpKSk7XG4gIH1cblxuICBfZ2V0QW5jaG9yKGxvd2VyOiBudW1iZXIsIHVwcGVyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl9waHlzaWNhbEl0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZpcnN0IDwgMCkge1xuICAgICAgY29uc29sZS5lcnJvcignX2dldEFuY2hvcjogbmVnYXRpdmUgX2ZpcnN0Jyk7XG4gICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlQW5jaG9yKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sYXN0IDwgMCkge1xuICAgICAgY29uc29sZS5lcnJvcignX2dldEFuY2hvcjogbmVnYXRpdmUgX2xhc3QnKTtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0odGhpcy5fZmlyc3QpLFxuICAgICAgICAgIGxhc3RJdGVtID0gdGhpcy5fZ2V0UGh5c2ljYWxJdGVtKHRoaXMuX2xhc3QpLFxuICAgICAgICAgIGZpcnN0TWluID0gZmlyc3RJdGVtIS5wb3MsXG4gICAgICAgICAgbGFzdE1pbiA9IGxhc3RJdGVtIS5wb3MsXG4gICAgICAgICAgbGFzdE1heCA9IGxhc3RNaW4gKyB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0Q2hpbGRTaXplKHRoaXMuX2xhc3QpITtcblxuICAgIGlmIChsYXN0TWF4IDwgbG93ZXIpIHtcbiAgICAgIC8vIFdpbmRvdyBpcyBlbnRpcmVseSBwYXN0IHBoeXNpY2FsIGl0ZW1zLCBjYWxjdWxhdGUgbmV3IGFuY2hvclxuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgIH1cbiAgICBpZiAoZmlyc3RNaW4gPiB1cHBlcikge1xuICAgICAgLy8gV2luZG93IGlzIGVudGlyZWx5IGJlZm9yZSBwaHlzaWNhbCBpdGVtcywgY2FsY3VsYXRlIG5ldyBhbmNob3JcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICB9XG4gICAgLy8gV2luZG93IGNvbnRhaW5zIGEgcGh5c2ljYWwgaXRlbVxuICAgIC8vIEZpbmQgb25lLCBzdGFydGluZyB3aXRoIHRoZSBvbmUgdGhhdCB3YXMgcHJldmlvdXNseSBmaXJzdCB2aXNpYmxlXG4gICAgbGV0IGNhbmRpZGF0ZUlkeCA9IHRoaXMuX2ZpcnN0VmlzaWJsZSAtIDE7XG4gICAgbGV0IGNNYXggPSAtSW5maW5pdHk7XG4gICAgd2hpbGUgKGNNYXggPCBsb3dlcikge1xuICAgICAgY29uc3QgY2FuZGlkYXRlID0gdGhpcy5fZ2V0UGh5c2ljYWxJdGVtKCsrY2FuZGlkYXRlSWR4KTtcbiAgICAgIGNNYXggPSBjYW5kaWRhdGUhLnBvcyArIHRoaXMuX21ldHJpY3NDYWNoZS5nZXRDaGlsZFNpemUoY2FuZGlkYXRlSWR4KSE7XG4gICAgfVxuICAgIHJldHVybiBjYW5kaWRhdGVJZHg7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBfZmlyc3QgYW5kIF9sYXN0IGJhc2VkIG9uIGl0ZW1zIHRoYXQgc2hvdWxkIGJlIGluIHRoZSBjdXJyZW50XG4gICAqIHZpZXdlZCByYW5nZS5cbiAgICovXG4gIF9nZXRBY3RpdmVJdGVtcygpIHtcbiAgICBpZiAodGhpcy5fdmlld0RpbTEgPT09IDAgfHwgdGhpcy5fdG90YWxJdGVtcyA9PT0gMCkge1xuICAgICAgdGhpcy5fY2xlYXJJdGVtcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nZXRJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByYW5nZSB0byBlbXB0eS5cbiAgICovXG4gIF9jbGVhckl0ZW1zKCkge1xuICAgIHRoaXMuX2ZpcnN0ID0gLTE7XG4gICAgdGhpcy5fbGFzdCA9IC0xO1xuICAgIHRoaXMuX3BoeXNpY2FsTWluID0gMDtcbiAgICB0aGlzLl9waHlzaWNhbE1heCA9IDA7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zO1xuICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMgPSB0aGlzLl9waHlzaWNhbEl0ZW1zO1xuICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMuY2xlYXIoKTtcbiAgICB0aGlzLl9waHlzaWNhbEl0ZW1zID0gaXRlbXM7XG4gICAgdGhpcy5fc3RhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIC8qXG4gICAqIFVwZGF0ZXMgX2ZpcnN0IGFuZCBfbGFzdCBiYXNlZCBvbiBpdGVtcyB0aGF0IHNob3VsZCBiZSBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAqL1xuICBfZ2V0SXRlbXMoKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zO1xuICAgIHRoaXMuX3N0YWJsZSA9IHRydWU7XG4gICAgbGV0IGxvd2VyLCB1cHBlcjtcblxuICAgIC8vIFRoZSBhbmNob3JJZHggaXMgdGhlIGFuY2hvciBhcm91bmQgd2hpY2ggd2UgcmVmbG93LiBJdCBpcyBkZXNpZ25lZCB0b1xuICAgIC8vIGFsbG93IGp1bXBpbmcgdG8gYW55IHBvaW50IG9mIHRoZSBzY3JvbGwgc2l6ZS4gV2UgY2hvb3NlIGl0IG9uY2UgYW5kXG4gICAgLy8gc3RpY2sgd2l0aCBpdCB1bnRpbCBzdGFibGUuIGZpcnN0IGFuZCBsYXN0IGFyZSBkZWR1Y2VkIGFyb3VuZCBpdC5cblxuICAgIC8vIElmIHdlIGhhdmUgYSBzY3JvbGxUb0luZGV4LCB3ZSBhbmNob3Igb24gdGhlIGdpdmVuXG4gICAgLy8gaW5kZXggYW5kIHNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFjY29yZGluZ2x5XG4gICAgaWYgKHRoaXMuX3Njcm9sbFRvSW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5fYW5jaG9ySWR4ID0gTWF0aC5taW4odGhpcy5fc2Nyb2xsVG9JbmRleCwgdGhpcy5fdG90YWxJdGVtcyAtIDEpO1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gdGhpcy5fZ2V0UG9zaXRpb24odGhpcy5fYW5jaG9ySWR4KTtcbiAgICAgIHRoaXMuX3Njcm9sbElmTmVlZGVkKCk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmRzIG9mIHRoZSByZWdpb24gdG8gYmVcbiAgICAvLyByZW5kZXJlZCwgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XG4gICAgbG93ZXIgPSB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtIHRoaXMuX292ZXJoYW5nOy8vbGVhZGluZ092ZXJoYW5nO1xuICAgIHVwcGVyID0gdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSArIHRoaXMuX292ZXJoYW5nOy8vIHRyYWlsaW5nT3Zlcmhhbmc7XG5cbiAgICBpZiAodXBwZXIgPCAwIHx8IGxvd2VyID4gdGhpcy5fc2Nyb2xsU2l6ZSkge1xuICAgICAgdGhpcy5fY2xlYXJJdGVtcygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFyZSBzY3JvbGxpbmcgdG8gYSBzcGVjaWZpYyBpbmRleCBvciBpZiB3ZSBhcmUgZG9pbmcgYW5vdGhlclxuICAgIC8vIHBhc3MgdG8gc3RhYmlsaXplIGEgcHJldmlvdXNseSBzdGFydGVkIHJlZmxvdywgd2Ugd2lsbCBhbHJlYWR5XG4gICAgLy8gaGF2ZSBhbiBhbmNob3IuIElmIG5vdCwgZXN0YWJsaXNoIGFuIGFuY2hvciBub3cuXG4gICAgaWYgKHRoaXMuX2FuY2hvcklkeCA9PT0gbnVsbCB8fCB0aGlzLl9hbmNob3JQb3MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2FuY2hvcklkeCA9IHRoaXMuX2dldEFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gdGhpcy5fZ2V0UG9zaXRpb24odGhpcy5fYW5jaG9ySWR4KTtcbiAgICB9XG5cbiAgICBsZXQgYW5jaG9yU2l6ZSA9IHRoaXMuX2dldFNpemUodGhpcy5fYW5jaG9ySWR4KTtcbiAgICBpZiAoYW5jaG9yU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgIGFuY2hvclNpemUgPSB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpO1xuICAgIH1cblxuICAgIGxldCBhbmNob3JMZWFkaW5nTWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUodGhpcy5fYW5jaG9ySWR4KSA/PyB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZU1hcmdpblNpemU7XG4gICAgbGV0IGFuY2hvclRyYWlsaW5nTWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUodGhpcy5fYW5jaG9ySWR4ICsgMSkgPz8gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplO1xuXG4gICAgaWYgKHRoaXMuX2FuY2hvcklkeCA9PT0gMCkge1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gYW5jaG9yTGVhZGluZ01hcmdpbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYW5jaG9ySWR4ID09PSB0aGlzLl90b3RhbEl0ZW1zIC0gMSkge1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gdGhpcy5fc2Nyb2xsU2l6ZSAtIGFuY2hvclRyYWlsaW5nTWFyZ2luIC0gYW5jaG9yU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBBbmNob3IgbWlnaHQgYmUgb3V0c2lkZSBib3VuZHMsIHNvIHByZWZlciBjb3JyZWN0aW5nIHRoZSBlcnJvciBhbmQga2VlcFxuICAgIC8vIHRoYXQgYW5jaG9ySWR4LlxuICAgIGxldCBhbmNob3JFcnIgPSAwO1xuXG4gICAgaWYgKHRoaXMuX2FuY2hvclBvcyArIGFuY2hvclNpemUgKyBhbmNob3JUcmFpbGluZ01hcmdpbiA8IGxvd2VyKSB7XG4gICAgICBhbmNob3JFcnIgPSBsb3dlciAtICh0aGlzLl9hbmNob3JQb3MgKyBhbmNob3JTaXplICsgYW5jaG9yVHJhaWxpbmdNYXJnaW4pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hbmNob3JQb3MgLSBhbmNob3JMZWFkaW5nTWFyZ2luID4gdXBwZXIpIHtcbiAgICAgIGFuY2hvckVyciA9IHVwcGVyIC0gKHRoaXMuX2FuY2hvclBvcyAtIGFuY2hvckxlYWRpbmdNYXJnaW4pO1xuICAgIH1cblxuICAgIGlmIChhbmNob3JFcnIpIHtcbiAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uIC09IGFuY2hvckVycjtcbiAgICAgIGxvd2VyIC09IGFuY2hvckVycjtcbiAgICAgIHVwcGVyIC09IGFuY2hvckVycjtcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yICs9IGFuY2hvckVycjtcbiAgICB9XG5cbiAgICBpdGVtcy5zZXQodGhpcy5fYW5jaG9ySWR4LCB7cG9zOiB0aGlzLl9hbmNob3JQb3MsIHNpemU6IGFuY2hvclNpemV9KTtcblxuICAgIHRoaXMuX2ZpcnN0ID0gKHRoaXMuX2xhc3QgPSB0aGlzLl9hbmNob3JJZHgpO1xuICAgIHRoaXMuX3BoeXNpY2FsTWluID0gdGhpcy5fYW5jaG9yUG9zO1xuICAgIHRoaXMuX3BoeXNpY2FsTWF4ID0gdGhpcy5fYW5jaG9yUG9zICsgYW5jaG9yU2l6ZTtcblxuICAgIHdoaWxlICh0aGlzLl9waHlzaWNhbE1pbiA+IGxvd2VyICYmIHRoaXMuX2ZpcnN0ID4gMCkge1xuICAgICAgbGV0IHNpemUgPSB0aGlzLl9nZXRTaXplKC0tdGhpcy5fZmlyc3QpO1xuICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgc2l6ZSA9IHRoaXMuX2dldEF2ZXJhZ2VTaXplKCk7XG4gICAgICB9XG4gICAgICBsZXQgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUodGhpcy5fZmlyc3QgKyAxKTtcbiAgICAgIGlmIChtYXJnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGh5c2ljYWxNaW4gLT0gc2l6ZSArIG1hcmdpbjtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX3BoeXNpY2FsTWluO1xuICAgICAgaXRlbXMuc2V0KHRoaXMuX2ZpcnN0LCB7cG9zLCBzaXplfSk7XG4gICAgICBpZiAodGhpcy5fc3RhYmxlID09PSBmYWxzZSAmJiB0aGlzLl9lc3RpbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMuX3BoeXNpY2FsTWF4IDwgdXBwZXIgJiYgdGhpcy5fbGFzdCA8IHRoaXMuX3RvdGFsSXRlbXMgLSAxKSB7XG4gICAgICBsZXQgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUoKyt0aGlzLl9sYXN0KTtcbiAgICAgIGlmIChtYXJnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplO1xuICAgICAgfVxuICAgICAgbGV0IHNpemUgPSB0aGlzLl9nZXRTaXplKHRoaXMuX2xhc3QpO1xuICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgc2l6ZSA9IHRoaXMuX2dldEF2ZXJhZ2VTaXplKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLl9waHlzaWNhbE1heCArIG1hcmdpbjtcbiAgICAgIGl0ZW1zLnNldCh0aGlzLl9sYXN0LCB7cG9zLCBzaXplfSk7XG4gICAgICB0aGlzLl9waHlzaWNhbE1heCArPSBtYXJnaW4gKyBzaXplO1xuICAgICAgaWYgKHRoaXMuX3N0YWJsZSA9PT0gZmFsc2UgJiYgdGhpcy5fZXN0aW1hdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZXMgd2hlcmUgd2Ugd2VyZSByZWx5aW5nIG9uIGVzdGltYXRlZCBzaXplcy5cbiAgICBjb25zdCBleHRlbnRFcnIgPSB0aGlzLl9jYWxjdWxhdGVFcnJvcigpO1xuICAgIGlmIChleHRlbnRFcnIpIHtcbiAgICAgIHRoaXMuX3BoeXNpY2FsTWluIC09IGV4dGVudEVycjtcbiAgICAgIHRoaXMuX3BoeXNpY2FsTWF4IC09IGV4dGVudEVycjtcbiAgICAgIHRoaXMuX2FuY2hvclBvcyAtPSBleHRlbnRFcnI7XG4gICAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtPSBleHRlbnRFcnI7XG4gICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiBpdGVtLnBvcyAtPSBleHRlbnRFcnIpO1xuICAgICAgdGhpcy5fc2Nyb2xsRXJyb3IgKz0gZXh0ZW50RXJyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGFibGUpIHtcbiAgICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMgPSB0aGlzLl9waHlzaWNhbEl0ZW1zO1xuICAgICAgdGhpcy5fbmV3UGh5c2ljYWxJdGVtcy5jbGVhcigpO1xuICAgICAgdGhpcy5fcGh5c2ljYWxJdGVtcyA9IGl0ZW1zO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVFcnJvcigpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgYXZlcmFnZU1hcmdpblNpemUgfSA9IHRoaXMuX21ldHJpY3NDYWNoZTtcbiAgICBpZiAodGhpcy5fZmlyc3QgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9waHlzaWNhbE1pbiAtICh0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSgwKSA/PyBhdmVyYWdlTWFyZ2luU2l6ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9waHlzaWNhbE1pbiA8PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGh5c2ljYWxNaW4gLSAodGhpcy5fZmlyc3QgKiB0aGlzLl9kZWx0YSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0ID09PSB0aGlzLl90b3RhbEl0ZW1zIC0gMSkge1xuICAgICAgcmV0dXJuICh0aGlzLl9waHlzaWNhbE1heCArICh0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSh0aGlzLl90b3RhbEl0ZW1zKSA/PyBhdmVyYWdlTWFyZ2luU2l6ZSkpIC0gdGhpcy5fc2Nyb2xsU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BoeXNpY2FsTWF4ID49IHRoaXMuX3Njcm9sbFNpemUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHRoaXMuX3BoeXNpY2FsTWF4IC0gdGhpcy5fc2Nyb2xsU2l6ZSkgK1xuICAgICAgICAgICgodGhpcy5fdG90YWxJdGVtcyAtIDEgLSB0aGlzLl9sYXN0KSAqIHRoaXMuX2RlbHRhKSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gVE9ETzogQ2FuIHRoaXMgYmUgbWFkZSB0byBpbmhlcml0IGZyb20gYmFzZSwgd2l0aCBwcm9wZXIgaG9va3M/XG4gIF9yZWZsb3coKSB7XG4gICAgY29uc3Qge19maXJzdCwgX2xhc3QsIF9zY3JvbGxTaXplfSA9IHRoaXM7XG5cbiAgICB0aGlzLl91cGRhdGVTY3JvbGxTaXplKCk7XG4gICAgdGhpcy5fZ2V0QWN0aXZlSXRlbXMoKTtcblxuICAgIGlmICh0aGlzLl9zY3JvbGxTaXplICE9PSBfc2Nyb2xsU2l6ZSkge1xuICAgICAgdGhpcy5fZW1pdFNjcm9sbFNpemUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVWaXNpYmxlSW5kaWNlcygpO1xuICAgIHRoaXMuX2VtaXRSYW5nZSgpO1xuICAgIGlmICh0aGlzLl9maXJzdCA9PT0gLTEgJiYgdGhpcy5fbGFzdCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX3Jlc2V0UmVmbG93U3RhdGUoKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0aGlzLl9maXJzdCAhPT0gX2ZpcnN0IHx8IHRoaXMuX2xhc3QgIT09IF9sYXN0IHx8XG4gICAgICAgIHRoaXMuX25lZWRzUmVtZWFzdXJlKSB7XG4gICAgICB0aGlzLl9lbWl0Q2hpbGRQb3NpdGlvbnMoKTtcbiAgICAgIHRoaXMuX2VtaXRTY3JvbGxFcnJvcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0Q2hpbGRQb3NpdGlvbnMoKTtcbiAgICAgIHRoaXMuX2VtaXRTY3JvbGxFcnJvcigpO1xuICAgICAgdGhpcy5fcmVzZXRSZWZsb3dTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9yZXNldFJlZmxvd1N0YXRlKCkge1xuICAgIHRoaXMuX2FuY2hvcklkeCA9IG51bGw7XG4gICAgdGhpcy5fYW5jaG9yUG9zID0gbnVsbDtcbiAgICB0aGlzLl9zdGFibGUgPSB0cnVlO1xuICB9XG5cbiAgX3VwZGF0ZVNjcm9sbFNpemUoKSB7XG4gICAgY29uc3QgeyBhdmVyYWdlTWFyZ2luU2l6ZSB9ID0gdGhpcy5fbWV0cmljc0NhY2hlO1xuICAgIHRoaXMuX3Njcm9sbFNpemUgPSBNYXRoLm1heCgxLCB0aGlzLl90b3RhbEl0ZW1zICogKGF2ZXJhZ2VNYXJnaW5TaXplICsgdGhpcy5fZ2V0QXZlcmFnZVNpemUoKSkgKyBhdmVyYWdlTWFyZ2luU2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXZlcmFnZSBzaXplIChwcmVjaXNlIG9yIGVzdGltYXRlZCkgb2YgYW4gaXRlbSBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbixcbiAgICogaW5jbHVkaW5nIGFueSBzdXJyb3VuZGluZyBzcGFjZS5cbiAgICovXG4gIHByb3RlY3RlZCBnZXQgX2RlbHRhKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBhdmVyYWdlTWFyZ2luU2l6ZSB9ID0gdGhpcy5fbWV0cmljc0NhY2hlO1xuICAgIHJldHVybiB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpICsgYXZlcmFnZU1hcmdpblNpemU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9wIGFuZCBsZWZ0IHBvc2l0aW9uaW5nIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICovXG4gIF9nZXRJdGVtUG9zaXRpb24oaWR4OiBudW1iZXIpOiBQb3NpdGlvbnMge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5fcG9zaXRpb25EaW1dOiB0aGlzLl9nZXRQb3NpdGlvbihpZHgpLFxuICAgICAgW3RoaXMuX3NlY29uZGFyeVBvc2l0aW9uRGltXTogMCxcbiAgICAgIFtvZmZzZXQodGhpcy5kaXJlY3Rpb24pXTogLSh0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TGVhZGluZ01hcmdpblZhbHVlKGlkeCwgdGhpcy5kaXJlY3Rpb24pID8/IHRoaXMuX21ldHJpY3NDYWNoZS5hdmVyYWdlTWFyZ2luU2l6ZSlcbiAgICB9IGFzIFBvc2l0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICovXG4gIF9nZXRJdGVtU2l6ZShpZHg6IG51bWJlcik6IFNpemUge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5fc2l6ZURpbV06ICh0aGlzLl9nZXRTaXplKGlkeCkgfHwgdGhpcy5fZ2V0QXZlcmFnZVNpemUoKSkgKyAodGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUoaWR4ICsgMSkgPz8gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplKSxcbiAgICAgIFt0aGlzLl9zZWNvbmRhcnlTaXplRGltXTogdGhpcy5faXRlbVNpemVbdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbV1cbiAgICB9IGFzIFNpemU7XG4gIH1cblxuICBfdmlld0RpbTJDaGFuZ2VkKCkge1xuICAgIHRoaXMuX25lZWRzUmVtZWFzdXJlID0gdHJ1ZTtcbiAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICB9XG5cbiAgX2VtaXRSYW5nZSgpIHtcbiAgICBjb25zdCByZW1lYXN1cmUgPSB0aGlzLl9uZWVkc1JlbWVhc3VyZTtcbiAgICBjb25zdCBzdGFibGUgPSB0aGlzLl9zdGFibGU7XG4gICAgdGhpcy5fbmVlZHNSZW1lYXN1cmUgPSBmYWxzZTtcbiAgICBzdXBlci5fZW1pdFJhbmdlKHtyZW1lYXN1cmUsIHN0YWJsZX0pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/flow.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dim1\": () => (/* binding */ dim1),\n/* harmony export */   \"dim2\": () => (/* binding */ dim2),\n/* harmony export */   \"pos1\": () => (/* binding */ pos1),\n/* harmony export */   \"pos2\": () => (/* binding */ pos2),\n/* harmony export */   \"BaseLayout\": () => (/* binding */ BaseLayout)\n/* harmony export */ });\n/* harmony import */ var _polyfillLoaders_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../polyfillLoaders/EventTarget.js */ \"./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nfunction dim1(direction) {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\nfunction dim2(direction) {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\nfunction pos1(direction) {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\nfunction pos2(direction) {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\nclass BaseLayout {\n  constructor(config) {\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n\n    this._direction = null;\n    /**\n     * Dimensions of the viewport.\n     */\n\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    /**\n     * Flag for debouncing asynchnronous reflow requests.\n     */\n\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    /**\n     * Index of the item that has been scrolled to via the public API. When the\n     * viewport is otherwise scrolled, this value is set back to -1.\n     */\n\n    this._scrollToIndex = -1;\n    /**\n     * When a child is scrolled to, the offset from the top of the child and the\n     * top of the viewport. Value is a proportion of the item size.\n     */\n\n    this._scrollToAnchor = 0;\n    /**\n     * The index of the first item intersecting the viewport.\n     */\n\n    this._firstVisible = 0;\n    /**\n     * The index of the last item intersecting the viewport.\n     */\n\n    this._lastVisible = 0;\n    this._eventTargetPromise = (0,_polyfillLoaders_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().then(Ctor => {\n      this._eventTarget = new Ctor();\n    });\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n\n    this._last = -1;\n    /**\n     * Length in the scrolling direction.\n     */\n\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n\n    this._totalItems = 0;\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the viewport to still include\n     * in the active range of items.\n     */\n    // TODO (graynorton): Probably want to make this something we calculate based\n    // on viewport size, item size, other factors, possibly still with a dial of some kind\n\n    this._overhang = 1000;\n    this._eventTarget = null; // Delay setting config so that subclasses do setup work first\n\n    Promise.resolve().then(() => this.config = config || this._defaultConfig);\n  }\n\n  get _defaultConfig() {\n    return {\n      direction: 'vertical'\n    };\n  }\n\n  set config(config) {\n    Object.assign(this, Object.assign({}, this._defaultConfig, config));\n  }\n\n  get config() {\n    return {\n      direction: this.direction\n    };\n  }\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n\n\n  get totalItems() {\n    return this._totalItems;\n  }\n\n  set totalItems(num) {\n    const _num = Number(num);\n\n    if (_num !== this._totalItems) {\n      this._totalItems = _num;\n\n      this._scheduleReflow();\n    }\n  }\n  /**\n   * Primary scrolling direction.\n   */\n\n\n  get direction() {\n    return this._direction;\n  }\n\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n\n      this._triggerReflow();\n    }\n  }\n  /**\n   * Height and width of the viewport.\n   */\n\n\n  get viewportSize() {\n    return this._viewportSize;\n  }\n\n  set viewportSize(dims) {\n    const {\n      _viewDim1,\n      _viewDim2\n    } = this;\n    Object.assign(this._viewportSize, dims);\n\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Scroll offset of the viewport.\n   */\n\n\n  get viewportScroll() {\n    return this._latestCoords;\n  }\n\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n\n    if (oldPos !== this._scrollPosition) {\n      this._scrollPositionChanged(oldPos, this._scrollPosition);\n\n      this._updateVisibleIndices({\n        emit: true\n      });\n    }\n\n    this._checkThresholds();\n  }\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n\n\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n\n      this._reflow();\n    }\n  }\n  /**\n   * Scroll to the child at the given index, and the given position within that\n   * child.\n   */\n\n\n  scrollToIndex(index, position = 'start') {\n    if (!Number.isFinite(index)) return;\n    index = Math.min(this.totalItems, Math.max(0, index));\n    this._scrollToIndex = index;\n\n    if (position === 'nearest') {\n      position = index > this._first + this._num / 2 ? 'end' : 'start';\n    }\n\n    switch (position) {\n      case 'start':\n        this._scrollToAnchor = 0;\n        break;\n\n      case 'center':\n        this._scrollToAnchor = 0.5;\n        break;\n\n      case 'end':\n        this._scrollToAnchor = 1;\n        break;\n\n      default:\n        throw new TypeError('position must be one of: start, center, end, nearest');\n    }\n\n    this._scheduleReflow();\n  }\n\n  async dispatchEvent(evt) {\n    await this._eventTargetPromise;\n\n    this._eventTarget.dispatchEvent(evt);\n  }\n\n  async addEventListener(type, listener, options) {\n    await this._eventTargetPromise;\n\n    this._eventTarget.addEventListener(type, listener, options);\n  }\n\n  async removeEventListener(type, callback, options) {\n    await this._eventTargetPromise;\n\n    this._eventTarget.removeEventListener(type, callback, options);\n  }\n\n  _updateLayout() {// Override\n  } // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n\n\n  get _viewDim1() {\n    return this._viewportSize[this._sizeDim];\n  }\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n\n\n  get _viewDim2() {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n\n  _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n\n  _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n\n    this._scheduleReflow();\n  } // For triggering a reflow based on incoming changes to\n  // the layout config.\n\n\n  _triggerReflow() {\n    this._scheduleLayoutUpdate(); // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n\n\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n\n  _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n\n      this._pendingLayoutUpdate = false;\n    }\n\n    this._updateScrollSize();\n\n    this._getActiveItems();\n\n    this._scrollIfNeeded();\n\n    this._updateVisibleIndices();\n\n    this._emitScrollSize();\n\n    this._emitRange();\n\n    this._emitChildPositions();\n\n    this._emitScrollError();\n  }\n\n  _scrollIfNeeded() {\n    if (this._scrollToIndex === -1) {\n      return;\n    }\n\n    const index = this._scrollToIndex;\n    const anchor = this._scrollToAnchor;\n\n    const pos = this._getItemPosition(index)[this._positionDim];\n\n    const size = this._getItemSize(index)[this._sizeDim];\n\n    const curAnchorPos = this._scrollPosition + this._viewDim1 * anchor;\n    const newAnchorPos = pos + size * anchor; // Ensure scroll position is an integer within scroll bounds.\n\n    const scrollPosition = Math.floor(Math.min(this._scrollSize - this._viewDim1, Math.max(0, this._scrollPosition - curAnchorPos + newAnchorPos)));\n    this._scrollError += this._scrollPosition - scrollPosition;\n    this._scrollPosition = scrollPosition;\n  }\n\n  _emitRange(inProps = undefined) {\n    const detail = Object.assign({\n      first: this._first,\n      last: this._last,\n      num: this._num,\n      stable: true,\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible\n    }, inProps);\n    this.dispatchEvent(new CustomEvent('rangechange', {\n      detail\n    }));\n  }\n\n  _emitScrollSize() {\n    const detail = {\n      [this._sizeDim]: this._scrollSize\n    };\n    this.dispatchEvent(new CustomEvent('scrollsizechange', {\n      detail\n    }));\n  }\n\n  _emitScrollError() {\n    if (this._scrollError) {\n      const detail = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0\n      };\n      this.dispatchEvent(new CustomEvent('scrollerrorchange', {\n        detail\n      }));\n      this._scrollError = 0;\n    }\n  }\n  /**\n   * Get or estimate the top and left positions of items in the current range.\n   * Emit an itempositionchange event with these positions.\n   */\n\n\n  _emitChildPositions() {\n    const detail = {};\n\n    for (let idx = this._first; idx <= this._last; idx++) {\n      detail[idx] = this._getItemPosition(idx);\n    }\n\n    this.dispatchEvent(new CustomEvent('itempositionchange', {\n      detail\n    }));\n  }\n  /**\n   * Number of items to display.\n   */\n\n\n  get _num() {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n\n    return this._last - this._first + 1;\n  }\n\n  _checkThresholds() {\n    if (this._viewDim1 === 0 && this._num > 0) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      }\n    }\n  }\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n\n\n  _updateVisibleIndices(options) {\n    if (this._first === -1 || this._last === -1) return;\n    let firstVisible = this._first;\n\n    while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n      firstVisible++;\n    }\n\n    let lastVisible = this._last;\n\n    while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n      lastVisible--;\n    }\n\n    if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n\n      if (options && options.emit) {\n        this._emitRange();\n      }\n    }\n  }\n\n  _scrollPositionChanged(oldPos, newPos) {\n    // When both values are bigger than the max scroll position, keep the\n    // current _scrollToIndex, otherwise invalidate it.\n    const maxPos = this._scrollSize - this._viewDim1;\n\n    if (oldPos < maxPos || newPos < maxPos) {\n      this._scrollToIndex = -1;\n    }\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL0Jhc2VMYXlvdXQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFJQTtBQUVBO0FBV0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUErSEE7QUE5SEE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTs7QUFFQTs7QUFDQTtBQUVBO0FBRUE7OztBQUdBOztBQUNBO0FBRUE7OztBQUdBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBOzs7QUFHQTs7QUFDQTtBQUVBOzs7QUFHQTs7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBOztBQVVBO0FBQ0E7O0FBVEE7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBOzs7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOztBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBWEE7O0FBY0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUF3QkE7QUFFQTtBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOztBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBOzs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFTQTtBQUNBOztBQUVBOztBQUNBO0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE1ZEEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9zcmMvbGF5b3V0cy9zaGFyZWQvQmFzZUxheW91dC50cz9kZDQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi4vLi4vcG9seWZpbGxMb2FkZXJzL0V2ZW50VGFyZ2V0LmpzJztcbmltcG9ydCB7TGF5b3V0LCBQb3NpdGlvbnMsIFNjcm9sbERpcmVjdGlvbiwgU2l6ZSwgZGltZW5zaW9uLCBwb3NpdGlvbn0gZnJvbSAnLi9MYXlvdXQuanMnO1xuXG50eXBlIFVwZGF0ZVZpc2libGVJbmRpY2VzT3B0aW9ucyA9IHtcbiAgZW1pdD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXNlTGF5b3V0Q29uZmlnIHtcbiAgZGlyZWN0aW9uPzogU2Nyb2xsRGlyZWN0aW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaW0xKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogZGltZW5zaW9uIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3dpZHRoJzogJ2hlaWdodCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaW0yKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogZGltZW5zaW9uIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2hlaWdodCc6ICd3aWR0aCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3MxKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogcG9zaXRpb24ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbGVmdCc6ICd0b3AnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zMihkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbik6IHBvc2l0aW9uIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3RvcCc6ICdsZWZ0Jztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VMYXlvdXQ8QyBleHRlbmRzIEJhc2VMYXlvdXRDb25maWc+IGltcGxlbWVudHMgTGF5b3V0IHtcbiAgLyoqXG4gICAqIFRoZSBsYXN0IHNldCB2aWV3cG9ydCBzY3JvbGwgcG9zaXRpb24uXG4gICAqL1xuICBwcml2YXRlIF9sYXRlc3RDb29yZHM6IFBvc2l0aW9ucyA9IHtsZWZ0OiAwLCB0b3A6IDB9O1xuXG4gIC8qKlxuICAgKiBTY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBfZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogRGltZW5zaW9ucyBvZiB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcml2YXRlIF92aWV3cG9ydFNpemU6IFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIGRlYm91bmNpbmcgYXN5bmNobnJvbm91cyByZWZsb3cgcmVxdWVzdHMuXG4gICAqL1xuICBwcml2YXRlIF9wZW5kaW5nUmVmbG93ID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfcGVuZGluZ0xheW91dFVwZGF0ZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgaXRlbSB0aGF0IGhhcyBiZWVuIHNjcm9sbGVkIHRvIHZpYSB0aGUgcHVibGljIEFQSS4gV2hlbiB0aGVcbiAgICogdmlld3BvcnQgaXMgb3RoZXJ3aXNlIHNjcm9sbGVkLCB0aGlzIHZhbHVlIGlzIHNldCBiYWNrIHRvIC0xLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zY3JvbGxUb0luZGV4ID0gLTE7XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBjaGlsZCBpcyBzY3JvbGxlZCB0bywgdGhlIG9mZnNldCBmcm9tIHRoZSB0b3Agb2YgdGhlIGNoaWxkIGFuZCB0aGVcbiAgICogdG9wIG9mIHRoZSB2aWV3cG9ydC4gVmFsdWUgaXMgYSBwcm9wb3J0aW9uIG9mIHRoZSBpdGVtIHNpemUuXG4gICAqL1xuICBwcml2YXRlIF9zY3JvbGxUb0FuY2hvciA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbSBpbnRlcnNlY3RpbmcgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9maXJzdFZpc2libGUgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGxhc3QgaXRlbSBpbnRlcnNlY3RpbmcgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9sYXN0VmlzaWJsZSA9IDA7XG5cbiAgcHJpdmF0ZSBfZXZlbnRUYXJnZXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+ID0gKEV2ZW50VGFyZ2V0KCkudGhlbigoQ3RvcikgPT4ge1xuICAgIHRoaXMuX2V2ZW50VGFyZ2V0ID0gbmV3IEN0b3IoKTtcbiAgfSkpO1xuXG4gIC8qKlxuICAgKiBQaXhlbCBvZmZzZXQgaW4gdGhlIHNjcm9sbCBkaXJlY3Rpb24gb2YgdGhlIGZpcnN0IGNoaWxkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9waHlzaWNhbE1pbiA9IDA7XG5cbiAgLyoqXG4gICAqIFBpeGVsIG9mZnNldCBpbiB0aGUgc2Nyb2xsIGRpcmVjdGlvbiBvZiB0aGUgbGFzdCBjaGlsZC5cbiAgICovXG4gIHByb3RlY3RlZCBfcGh5c2ljYWxNYXggPSAwO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgZmlyc3QgY2hpbGQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2ZpcnN0ID0gLTE7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBsYXN0IGNoaWxkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9sYXN0ID0gLTE7XG5cbiAgLyoqXG4gICAqIExlbmd0aCBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBfc2l6ZURpbTogZGltZW5zaW9uID0gJ2hlaWdodCc7XG5cbiAgLyoqXG4gICAqIExlbmd0aCBpbiB0aGUgbm9uLXNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NlY29uZGFyeVNpemVEaW06IGRpbWVuc2lvbiA9ICd3aWR0aCc7XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9wb3NpdGlvbkRpbTogcG9zaXRpb24gPSAndG9wJztcblxuICAvKipcbiAgICogUG9zaXRpb24gaW4gdGhlIG5vbi1zY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zZWNvbmRhcnlQb3NpdGlvbkRpbTogcG9zaXRpb24gPSAnbGVmdCc7XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgc2Nyb2xsIG9mZnNldCBpbiBwaXhlbHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3Njcm9sbFBvc2l0aW9uID0gMDtcblxuICAvKipcbiAgICogRGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgc2Nyb2xsIG9mZnNldCBhbmQgc2Nyb2xsIG9mZnNldCBjYWxjdWxhdGVkIGR1ZVxuICAgKiB0byBhIHJlZmxvdy5cbiAgICovXG4gIHByb3RlY3RlZCBfc2Nyb2xsRXJyb3IgPSAwO1xuXG4gIC8qKlxuICAgKiBUb3RhbCBudW1iZXIgb2YgaXRlbXMgdGhhdCBjb3VsZCBwb3NzaWJseSBiZSBkaXNwbGF5ZWQuIFVzZWQgdG8gaGVscFxuICAgKiBjYWxjdWxhdGUgdGhlIHNjcm9sbCBzaXplLlxuICAgKi9cbiAgcHJvdGVjdGVkIF90b3RhbEl0ZW1zID0gMDtcblxuICAvKipcbiAgICogVGhlIHRvdGFsIChlc3RpbWF0ZWQpIGxlbmd0aCBvZiBhbGwgaXRlbXMgaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3Njcm9sbFNpemUgPSAxO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJleW9uZCB0aGUgdmlld3BvcnQgdG8gc3RpbGwgaW5jbHVkZVxuICAgKiBpbiB0aGUgYWN0aXZlIHJhbmdlIG9mIGl0ZW1zLlxuICAgKi9cbiAgLy8gVE9ETyAoZ3JheW5vcnRvbik6IFByb2JhYmx5IHdhbnQgdG8gbWFrZSB0aGlzIHNvbWV0aGluZyB3ZSBjYWxjdWxhdGUgYmFzZWRcbiAgLy8gb24gdmlld3BvcnQgc2l6ZSwgaXRlbSBzaXplLCBvdGhlciBmYWN0b3JzLCBwb3NzaWJseSBzdGlsbCB3aXRoIGEgZGlhbCBvZiBzb21lIGtpbmRcbiAgcHJvdGVjdGVkIF9vdmVyaGFuZyA9IDEwMDA7XG5cbiAgcHJpdmF0ZSBfZXZlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0IHwgbnVsbCA9IG51bGw7XG5cbiAgcHJvdGVjdGVkIGdldCBfZGVmYXVsdENvbmZpZygpIDogQyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJ1xuICAgIH0gYXMgQ1xuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnPzogQykge1xuICAgIC8vIERlbGF5IHNldHRpbmcgY29uZmlnIHNvIHRoYXQgc3ViY2xhc3NlcyBkbyBzZXR1cCB3b3JrIGZpcnN0XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB0aGlzLl9kZWZhdWx0Q29uZmlnKTtcbiAgfVxuXG4gIHNldCBjb25maWcoY29uZmlnOiBDKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9kZWZhdWx0Q29uZmlnLCBjb25maWcpKTtcbiAgfVxuXG4gIGdldCBjb25maWcoKTogQyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb25cbiAgICB9IGFzIEM7XG4gIH1cblxuICAvKipcbiAgICogTWF4aW11bSBpbmRleCBvZiBjaGlsZHJlbiArIDEsIHRvIGhlbHAgZXN0aW1hdGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBzY3JvbGxcbiAgICogc3BhY2UuXG4gICAqL1xuICBnZXQgdG90YWxJdGVtcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl90b3RhbEl0ZW1zO1xuICB9XG4gIHNldCB0b3RhbEl0ZW1zKG51bSkge1xuICAgIGNvbnN0IF9udW0gPSBOdW1iZXIobnVtKTtcbiAgICBpZiAoX251bSAhPT0gdGhpcy5fdG90YWxJdGVtcykge1xuICAgICAgdGhpcy5fdG90YWxJdGVtcyA9IF9udW07XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmltYXJ5IHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBnZXQgZGlyZWN0aW9uKCk6IFNjcm9sbERpcmVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbiE7XG4gIH1cbiAgc2V0IGRpcmVjdGlvbihkaXIpIHtcbiAgICAvLyBGb3JjZSBpdCB0byBiZSBlaXRoZXIgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbC5cbiAgICBkaXIgPSAoZGlyID09PSAnaG9yaXpvbnRhbCcpID8gZGlyIDogJ3ZlcnRpY2FsJztcbiAgICBpZiAoZGlyICE9PSB0aGlzLl9kaXJlY3Rpb24pIHtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcjtcbiAgICAgIHRoaXMuX3NpemVEaW0gPSAoZGlyID09PSAnaG9yaXpvbnRhbCcpID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbSA9IChkaXIgPT09ICdob3Jpem9udGFsJykgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICB0aGlzLl9wb3NpdGlvbkRpbSA9IChkaXIgPT09ICdob3Jpem9udGFsJykgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHRoaXMuX3NlY29uZGFyeVBvc2l0aW9uRGltID0gKGRpciA9PT0gJ2hvcml6b250YWwnKSA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgdGhpcy5fdHJpZ2dlclJlZmxvdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIGdldCB2aWV3cG9ydFNpemUoKTogU2l6ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2l6ZTtcbiAgfVxuICBzZXQgdmlld3BvcnRTaXplKGRpbXMpIHtcbiAgICBjb25zdCB7X3ZpZXdEaW0xLCBfdmlld0RpbTJ9ID0gdGhpcztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX3ZpZXdwb3J0U2l6ZSwgZGltcyk7XG4gICAgaWYgKF92aWV3RGltMiAhPT0gdGhpcy5fdmlld0RpbTIpIHtcbiAgICAgIC8vIHRoaXMuX3ZpZXdEaW0yQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fc2NoZWR1bGVMYXlvdXRVcGRhdGUoKTtcbiAgICB9IGVsc2UgaWYgKF92aWV3RGltMSAhPT0gdGhpcy5fdmlld0RpbTEpIHtcbiAgICAgIHRoaXMuX2NoZWNrVGhyZXNob2xkcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGwgb2Zmc2V0IG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIGdldCB2aWV3cG9ydFNjcm9sbCgpOiBQb3NpdGlvbnMge1xuICAgIHJldHVybiB0aGlzLl9sYXRlc3RDb29yZHM7XG4gIH1cbiAgc2V0IHZpZXdwb3J0U2Nyb2xsKGNvb3Jkcykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fbGF0ZXN0Q29vcmRzLCBjb29yZHMpO1xuICAgIGNvbnN0IG9sZFBvcyA9IHRoaXMuX3Njcm9sbFBvc2l0aW9uO1xuICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uID0gdGhpcy5fbGF0ZXN0Q29vcmRzW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICBpZiAob2xkUG9zICE9PSB0aGlzLl9zY3JvbGxQb3NpdGlvbikge1xuICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb25DaGFuZ2VkKG9sZFBvcywgdGhpcy5fc2Nyb2xsUG9zaXRpb24pO1xuICAgICAgdGhpcy5fdXBkYXRlVmlzaWJsZUluZGljZXMoe2VtaXQ6IHRydWV9KTtcbiAgICB9XG4gICAgdGhpcy5fY2hlY2tUaHJlc2hvbGRzKCk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIHJlZmxvdyBpZiBvbmUgaGFzIGJlZW4gc2NoZWR1bGVkLlxuICAgKi9cbiAgcmVmbG93SWZOZWVkZWQoZm9yY2U6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGlmIChmb3JjZSB8fCB0aGlzLl9wZW5kaW5nUmVmbG93KSB7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVmbG93ID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWZsb3coKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xsIHRvIHRoZSBjaGlsZCBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2l0aGluIHRoYXRcbiAgICogY2hpbGQuXG4gICAqL1xuICBzY3JvbGxUb0luZGV4KGluZGV4OiBudW1iZXIsIHBvc2l0aW9uID0gJ3N0YXJ0Jykge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGluZGV4KSlcbiAgICAgIHJldHVybjtcbiAgICBpbmRleCA9IE1hdGgubWluKHRoaXMudG90YWxJdGVtcywgTWF0aC5tYXgoMCwgaW5kZXgpKTtcbiAgICB0aGlzLl9zY3JvbGxUb0luZGV4ID0gaW5kZXg7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbmVhcmVzdCcpIHtcbiAgICAgIHBvc2l0aW9uID0gaW5kZXggPiB0aGlzLl9maXJzdCArIHRoaXMuX251bSAvIDIgPyAnZW5kJyA6ICdzdGFydCc7XG4gICAgfVxuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9BbmNob3IgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvQW5jaG9yID0gMC41O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvQW5jaG9yID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ3Bvc2l0aW9uIG11c3QgYmUgb25lIG9mOiBzdGFydCwgY2VudGVyLCBlbmQsIG5lYXJlc3QnKTtcbiAgICB9XG4gICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgfVxuXG4gIGFzeW5jIGRpc3BhdGNoRXZlbnQoZXZ0OiBFdmVudCkge1xuICAgIGF3YWl0IHRoaXMuX2V2ZW50VGFyZ2V0UHJvbWlzZTtcbiAgICB0aGlzLl9ldmVudFRhcmdldCEuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG5cbiAgYXN5bmMgYWRkRXZlbnRMaXN0ZW5lcih0eXBlOiBzdHJpbmcsIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyIHwgRXZlbnRMaXN0ZW5lck9iamVjdCB8IG51bGwsIG9wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCB1bmRlZmluZWQpIHtcbiAgICBhd2FpdCB0aGlzLl9ldmVudFRhcmdldFByb21pc2U7XG4gICAgdGhpcy5fZXZlbnRUYXJnZXQhLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlOiBzdHJpbmcsIGNhbGxiYWNrOiBFdmVudExpc3RlbmVyIHwgRXZlbnRMaXN0ZW5lck9iamVjdCB8IG51bGwsIG9wdGlvbnM/OiBib29sZWFuIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCB1bmRlZmluZWQpIHtcbiAgICBhd2FpdCB0aGlzLl9ldmVudFRhcmdldFByb21pc2U7XG4gICAgdGhpcy5fZXZlbnRUYXJnZXQhLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdG9wIGFuZCBsZWZ0IHBvc2l0aW9uaW5nIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfZ2V0SXRlbVBvc2l0aW9uKGlkeDogbnVtYmVyKTogUG9zaXRpb25zO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgX2ZpcnN0IGFuZCBfbGFzdCBiYXNlZCBvbiBpdGVtcyB0aGF0IHNob3VsZCBiZSBpbiB0aGUgY3VycmVudFxuICAgKiByYW5nZS5cbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfZ2V0QWN0aXZlSXRlbXMoKTogdm9pZFxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfZ2V0SXRlbVNpemUoX2lkeDogbnVtYmVyKTogU2l6ZVxuXG4gICAgLyoqXG4gICAqIENhbGN1bGF0ZXMgKHByZWNpc2VseSBvciBieSBlc3RpbWF0aW5nLCBpZiBuZWVkZWQpIHRoZSB0b3RhbCBsZW5ndGggb2YgYWxsIGl0ZW1zIGluXG4gICAqIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLCBpbmNsdWRpbmcgc3BhY2luZywgY2FjaGluZyB0aGUgdmFsdWUgaW4gdGhlIGBfc2Nyb2xsU2l6ZWAgZmllbGQuXG4gICAqIFxuICAgKiBTaG91bGQgcmV0dXJuIGEgbWluaW11bSB2YWx1ZSBvZiAxIHRvIGVuc3VyZSBhdCBsZWFzdCBvbmUgaXRlbSBpcyByZW5kZXJlZC5cbiAgICogVE9ETyAoZ3JheW5vcnRvbik6IFBvc3NpYmx5IG5vIGxvbmdlciByZXF1aXJlZCwgYnV0IGxlYXZpbmcgaGVyZSB1bnRpbCBpdCBjYW4gYmUgdmVyaWZpZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX3VwZGF0ZVNjcm9sbFNpemUoKTogdm9pZFxuXG4gIHByb3RlY3RlZCBfdXBkYXRlTGF5b3V0KCk6IHZvaWQge1xuICAgIC8vIE92ZXJyaWRlXG4gIH1cblxuICAvLyBwcm90ZWN0ZWQgX3ZpZXdEaW0yQ2hhbmdlZCgpOiB2b2lkIHtcbiAgLy8gICB0aGlzLl9zY2hlZHVsZUxheW91dFVwZGF0ZSgpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIFRoZSBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIHZpZXdwb3J0LCB3aGljaGV2ZXIgY29ycmVzcG9uZHMgdG8gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0IF92aWV3RGltMSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFNpemVbdGhpcy5fc2l6ZURpbV07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGhlaWdodCBvciB3aWR0aCBvZiB0aGUgdmlld3BvcnQsIHdoaWNoZXZlciBkb2VzIE5PVCBjb3JyZXNwb25kIHRvIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBfdmlld0RpbTIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRTaXplW3RoaXMuX3NlY29uZGFyeVNpemVEaW1dO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zY2hlZHVsZVJlZmxvdygpIHtcbiAgICB0aGlzLl9wZW5kaW5nUmVmbG93ID0gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2NoZWR1bGVMYXlvdXRVcGRhdGUoKSB7XG4gICAgdGhpcy5fcGVuZGluZ0xheW91dFVwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgfVxuXG4gIC8vIEZvciB0cmlnZ2VyaW5nIGEgcmVmbG93IGJhc2VkIG9uIGluY29taW5nIGNoYW5nZXMgdG9cbiAgLy8gdGhlIGxheW91dCBjb25maWcuXG4gIHByb3RlY3RlZCBfdHJpZ2dlclJlZmxvdygpIHtcbiAgICB0aGlzLl9zY2hlZHVsZUxheW91dFVwZGF0ZSgpO1xuICAgIC8vIFRPRE8gZ3JheW5vcnRvbkA6IHJlZmxvd0lmTmVlZGVkKCkgaXNuJ3QgcmVhbGx5IHN1cHBvc2VkXG4gICAgLy8gdG8gYmUgY2FsbGVkIGludGVybmFsbHkuIEFkZHJlc3MgaW4gbGFyZ2VyIGNsZWFudXBcbiAgICAvLyBvZiB2aXJ0dWFsaXplciAvIGxheW91dCBpbnRlcmFjdGlvbiBwYXR0ZXJuLlxuICAgIC8vIHRoaXMucmVmbG93SWZOZWVkZWQodHJ1ZSk7XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLnJlZmxvd0lmTmVlZGVkKCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9yZWZsb3coKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdMYXlvdXRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUxheW91dCgpO1xuICAgICAgdGhpcy5fcGVuZGluZ0xheW91dFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVTY3JvbGxTaXplKCk7XG4gICAgdGhpcy5fZ2V0QWN0aXZlSXRlbXMoKTtcbiAgICB0aGlzLl9zY3JvbGxJZk5lZWRlZCgpO1xuICAgIHRoaXMuX3VwZGF0ZVZpc2libGVJbmRpY2VzKCk7XG4gICAgdGhpcy5fZW1pdFNjcm9sbFNpemUoKTtcbiAgICB0aGlzLl9lbWl0UmFuZ2UoKTtcbiAgICB0aGlzLl9lbWl0Q2hpbGRQb3NpdGlvbnMoKTtcbiAgICB0aGlzLl9lbWl0U2Nyb2xsRXJyb3IoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2Nyb2xsSWZOZWVkZWQoKSB7XG4gICAgaWYgKHRoaXMuX3Njcm9sbFRvSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc2Nyb2xsVG9JbmRleDtcbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLl9zY3JvbGxUb0FuY2hvcjtcbiAgICBjb25zdCBwb3MgPSB0aGlzLl9nZXRJdGVtUG9zaXRpb24oaW5kZXgpW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0SXRlbVNpemUoaW5kZXgpW3RoaXMuX3NpemVEaW1dO1xuXG4gICAgY29uc3QgY3VyQW5jaG9yUG9zID0gdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSAqIGFuY2hvcjtcbiAgICBjb25zdCBuZXdBbmNob3JQb3MgPSBwb3MgKyBzaXplICogYW5jaG9yO1xuICAgIC8vIEVuc3VyZSBzY3JvbGwgcG9zaXRpb24gaXMgYW4gaW50ZWdlciB3aXRoaW4gc2Nyb2xsIGJvdW5kcy5cbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5taW4oXG4gICAgICAgIHRoaXMuX3Njcm9sbFNpemUgLSB0aGlzLl92aWV3RGltMSxcbiAgICAgICAgTWF0aC5tYXgoMCwgdGhpcy5fc2Nyb2xsUG9zaXRpb24gLSBjdXJBbmNob3JQb3MgKyBuZXdBbmNob3JQb3MpKSk7XG4gICAgdGhpcy5fc2Nyb2xsRXJyb3IgKz0gdGhpcy5fc2Nyb2xsUG9zaXRpb24gLSBzY3JvbGxQb3NpdGlvbjtcbiAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiA9IHNjcm9sbFBvc2l0aW9uO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lbWl0UmFuZ2UoaW5Qcm9wczogdW5rbm93biA9IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGRldGFpbCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBmaXJzdDogdGhpcy5fZmlyc3QsXG4gICAgICAgICAgbGFzdDogdGhpcy5fbGFzdCxcbiAgICAgICAgICBudW06IHRoaXMuX251bSxcbiAgICAgICAgICBzdGFibGU6IHRydWUsXG4gICAgICAgICAgZmlyc3RWaXNpYmxlOiB0aGlzLl9maXJzdFZpc2libGUsXG4gICAgICAgICAgbGFzdFZpc2libGU6IHRoaXMuX2xhc3RWaXNpYmxlLFxuICAgICAgICB9LFxuICAgICAgICBpblByb3BzKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdyYW5nZWNoYW5nZScsIHtkZXRhaWx9KSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2VtaXRTY3JvbGxTaXplKCkge1xuICAgIGNvbnN0IGRldGFpbCA9IHtcbiAgICAgIFt0aGlzLl9zaXplRGltXTogdGhpcy5fc2Nyb2xsU2l6ZSxcbiAgICB9O1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3Njcm9sbHNpemVjaGFuZ2UnLCB7ZGV0YWlsfSkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lbWl0U2Nyb2xsRXJyb3IoKSB7XG4gICAgaWYgKHRoaXMuX3Njcm9sbEVycm9yKSB7XG4gICAgICBjb25zdCBkZXRhaWwgPSB7XG4gICAgICAgIFt0aGlzLl9wb3NpdGlvbkRpbV06IHRoaXMuX3Njcm9sbEVycm9yLFxuICAgICAgICBbdGhpcy5fc2Vjb25kYXJ5UG9zaXRpb25EaW1dOiAwLFxuICAgICAgfTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3Njcm9sbGVycm9yY2hhbmdlJywge2RldGFpbH0pKTtcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIGVzdGltYXRlIHRoZSB0b3AgYW5kIGxlZnQgcG9zaXRpb25zIG9mIGl0ZW1zIGluIHRoZSBjdXJyZW50IHJhbmdlLlxuICAgKiBFbWl0IGFuIGl0ZW1wb3NpdGlvbmNoYW5nZSBldmVudCB3aXRoIHRoZXNlIHBvc2l0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBfZW1pdENoaWxkUG9zaXRpb25zKCkge1xuICAgIGNvbnN0IGRldGFpbDoge1trZXk6IG51bWJlcl06IFBvc2l0aW9uc30gPSB7fTtcbiAgICBmb3IgKGxldCBpZHggPSB0aGlzLl9maXJzdDsgaWR4IDw9IHRoaXMuX2xhc3Q7IGlkeCsrKSB7XG4gICAgICBkZXRhaWxbaWR4XSA9IHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihpZHgpO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdpdGVtcG9zaXRpb25jaGFuZ2UnLCB7ZGV0YWlsfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBpdGVtcyB0byBkaXNwbGF5LlxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgX251bSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl9maXJzdCA9PT0gLTEgfHwgdGhpcy5fbGFzdCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGFzdCAtIHRoaXMuX2ZpcnN0ICsgMTtcbiAgfVxuXG4gIHByaXZhdGUgX2NoZWNrVGhyZXNob2xkcygpIHtcbiAgICBpZiAodGhpcy5fdmlld0RpbTEgPT09IDAgJiYgdGhpcy5fbnVtID4gMCkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWluID0gTWF0aC5tYXgoMCwgdGhpcy5fc2Nyb2xsUG9zaXRpb24gLSB0aGlzLl9vdmVyaGFuZyk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1pbihcbiAgICAgICAgICB0aGlzLl9zY3JvbGxTaXplLFxuICAgICAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uICsgdGhpcy5fdmlld0RpbTEgKyB0aGlzLl9vdmVyaGFuZyk7XG4gICAgICBpZiAodGhpcy5fcGh5c2ljYWxNaW4gPiBtaW4gfHwgdGhpcy5fcGh5c2ljYWxNYXggPCBtYXgpIHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgaW5kaWNlcyBvZiB0aGUgZmlyc3QgYW5kIGxhc3QgaXRlbXMgdG8gaW50ZXJzZWN0IHRoZSB2aWV3cG9ydC5cbiAgICogRW1pdCBhIHZpc2libGVpbmRpY2VzY2hhbmdlIGV2ZW50IHdoZW4gZWl0aGVyIGluZGV4IGNoYW5nZXMuXG4gICAqL1xuICAgcHJvdGVjdGVkIF91cGRhdGVWaXNpYmxlSW5kaWNlcyhvcHRpb25zPzogVXBkYXRlVmlzaWJsZUluZGljZXNPcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX2ZpcnN0ID09PSAtMSB8fCB0aGlzLl9sYXN0ID09PSAtMSkgcmV0dXJuO1xuXG4gICAgbGV0IGZpcnN0VmlzaWJsZSA9IHRoaXMuX2ZpcnN0O1xuICAgIHdoaWxlIChcbiAgICAgIGZpcnN0VmlzaWJsZSA8IHRoaXMuX2xhc3QgJiZcbiAgICAgIE1hdGgucm91bmQoXG4gICAgICAgIHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihmaXJzdFZpc2libGUpW3RoaXMuX3Bvc2l0aW9uRGltXSArXG4gICAgICAgIHRoaXMuX2dldEl0ZW1TaXplKGZpcnN0VmlzaWJsZSlbdGhpcy5fc2l6ZURpbV1cbiAgICAgIClcbiAgICAgIDw9XG4gICAgICBNYXRoLnJvdW5kICh0aGlzLl9zY3JvbGxQb3NpdGlvbilcbiAgICAgKSB7XG4gICAgICBmaXJzdFZpc2libGUrKztcbiAgICB9XG5cbiAgICBsZXQgbGFzdFZpc2libGUgPSB0aGlzLl9sYXN0O1xuICAgIHdoaWxlIChcbiAgICAgIGxhc3RWaXNpYmxlID4gdGhpcy5fZmlyc3QgJiZcbiAgICAgIE1hdGgucm91bmQodGhpcy5fZ2V0SXRlbVBvc2l0aW9uKGxhc3RWaXNpYmxlKVt0aGlzLl9wb3NpdGlvbkRpbV0pXG4gICAgICA+PVxuICAgICAgTWF0aC5yb3VuZCh0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdEaW0xKVxuICAgICkge1xuICAgICAgbGFzdFZpc2libGUtLTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3RWaXNpYmxlICE9PSB0aGlzLl9maXJzdFZpc2libGUgfHwgbGFzdFZpc2libGUgIT09IHRoaXMuX2xhc3RWaXNpYmxlKSB7XG4gICAgICB0aGlzLl9maXJzdFZpc2libGUgPSBmaXJzdFZpc2libGU7XG4gICAgICB0aGlzLl9sYXN0VmlzaWJsZSA9IGxhc3RWaXNpYmxlO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbWl0KSB7XG4gICAgICAgIHRoaXMuX2VtaXRSYW5nZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3Njcm9sbFBvc2l0aW9uQ2hhbmdlZChvbGRQb3M6IG51bWJlciwgbmV3UG9zOiBudW1iZXIpIHtcbiAgICAvLyBXaGVuIGJvdGggdmFsdWVzIGFyZSBiaWdnZXIgdGhhbiB0aGUgbWF4IHNjcm9sbCBwb3NpdGlvbiwga2VlcCB0aGVcbiAgICAvLyBjdXJyZW50IF9zY3JvbGxUb0luZGV4LCBvdGhlcndpc2UgaW52YWxpZGF0ZSBpdC5cbiAgICBjb25zdCBtYXhQb3MgPSB0aGlzLl9zY3JvbGxTaXplIC0gdGhpcy5fdmlld0RpbTE7XG4gICAgaWYgKG9sZFBvcyA8IG1heFBvcyB8fCBuZXdQb3MgPCBtYXhQb3MpIHtcbiAgICAgIHRoaXMuX3Njcm9sbFRvSW5kZXggPSAtMTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SizeCache\": () => (/* binding */ SizeCache)\n/* harmony export */ });\nclass SizeCache {\n  constructor(config) {\n    this._map = new Map();\n    this._roundAverageSize = true;\n    this.totalSize = 0;\n\n    if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === false) {\n      this._roundAverageSize = false;\n    }\n  }\n\n  set(index, value) {\n    const prev = this._map.get(index) || 0;\n\n    this._map.set(index, value);\n\n    this.totalSize += value - prev;\n  }\n\n  get averageSize() {\n    if (this._map.size > 0) {\n      const average = this.totalSize / this._map.size;\n      return this._roundAverageSize ? Math.round(average) : average;\n    }\n\n    return 0;\n  }\n\n  getSize(index) {\n    return this._map.get(index);\n  }\n\n  clear() {\n    this._map.clear();\n\n    this.totalSize = 0;\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL1NpemVDYWNoZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBSUE7QUFLQTtBQUpBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBbENBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vc3JjL2xheW91dHMvc2hhcmVkL1NpemVDYWNoZS50cz83Y2IzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgU2l6ZUNhY2hlQ29uZmlnIHtcbiAgICByb3VuZEF2ZXJhZ2VTaXplPzogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgU2l6ZUNhY2hlIHtcbiAgICBwcml2YXRlIF9tYXA6IE1hcDxudW1iZXIgfCBzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG4gICAgcHJpdmF0ZSBfcm91bmRBdmVyYWdlU2l6ZSA9IHRydWU7XG4gICAgdG90YWxTaXplOiBudW1iZXIgPSAwO1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnPzogU2l6ZUNhY2hlQ29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWc/LnJvdW5kQXZlcmFnZVNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3VuZEF2ZXJhZ2VTaXplID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gIFxuICAgIHNldChpbmRleDogbnVtYmVyIHwgc3RyaW5nLCB2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICBjb25zdCBwcmV2ID0gdGhpcy5fbWFwLmdldChpbmRleCkgfHwgMDtcbiAgICAgIHRoaXMuX21hcC5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICAgIHRoaXMudG90YWxTaXplICs9IHZhbHVlIC0gcHJldjtcbiAgICB9XG4gIFxuICAgIGdldCBhdmVyYWdlU2l6ZSgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5fbWFwLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBhdmVyYWdlID0gdGhpcy50b3RhbFNpemUgLyB0aGlzLl9tYXAuc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3VuZEF2ZXJhZ2VTaXplXG4gICAgICAgICAgICA/IE1hdGgucm91bmQoYXZlcmFnZSlcbiAgICAgICAgICAgIDogYXZlcmFnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gIFxuICAgIGdldFNpemUoaW5kZXg6IG51bWJlciB8IHN0cmluZykge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoaW5kZXgpO1xuICAgIH1cbiAgXG4gICAgY2xlYXIoKSB7XG4gICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICAgIHRoaXMudG90YWxTaXplID0gMDtcbiAgICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EventTarget)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _ET;\n\nlet ET;\nasync function EventTarget() {\n  return ET || init();\n}\n\nasync function init() {\n  _ET = window.EventTarget;\n\n  try {\n    new _ET();\n  } catch (_a) {\n    _ET = (await __webpack_require__.e(/*! import() */ \"vendors-node_modules_event-target-shim_dist_event-target-shim_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! event-target-shim */ \"./node_modules/event-target-shim/dist/event-target-shim.js\", 19))).default.EventTarget;\n  }\n\n  return ET = _ET;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL3BvbHlmaWxsTG9hZGVycy9FdmVudFRhcmdldC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7QUFJQTtBQVFBOztBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTs7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3BvbHlmaWxsTG9hZGVycy9FdmVudFRhcmdldC50cz9jMWMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG50eXBlIEV2ZW50VGFyZ2V0TW9kdWxlID0gdHlwZW9mIGltcG9ydCgnZXZlbnQtdGFyZ2V0LXNoaW0nKTtcblxuaW50ZXJmYWNlIEV2ZW50VGFyZ2V0Q29uc3RydWN0b3Ige1xuICAgIG5ldygpOiBFdmVudFRhcmdldFxufVxuXG5sZXQgX0VUOiBFdmVudFRhcmdldE1vZHVsZSB8IEV2ZW50VGFyZ2V0Q29uc3RydWN0b3I7XG5sZXQgRVQ6IEV2ZW50VGFyZ2V0Q29uc3RydWN0b3I7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICAgIHJldHVybiBFVCB8fCBpbml0KCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgX0VUID0gd2luZG93LkV2ZW50VGFyZ2V0O1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBfRVQoKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICBfRVQgPSAoYXdhaXQgaW1wb3J0KCdldmVudC10YXJnZXQtc2hpbScpKS5FdmVudFRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIChFVCA9IF9FVCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js\n");

/***/ })

}]);