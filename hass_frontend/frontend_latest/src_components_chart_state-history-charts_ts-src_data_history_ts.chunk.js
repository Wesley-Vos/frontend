"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["src_components_chart_state-history-charts_ts-src_data_history_ts"],{

/***/ "./src/common/config/is_component_loaded.ts":
/*!**************************************************!*\
  !*** ./src/common/config/is_component_loaded.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isComponentLoaded\": () => (/* binding */ isComponentLoaded)\n/* harmony export */ });\n/** Return if a component is loaded. */\nconst isComponentLoaded = (hass, component) => hass && hass.config.components.includes(component);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL2NvbmZpZy9pc19jb21wb25lbnRfbG9hZGVkLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9zcmMvY29tbW9uL2NvbmZpZy9pc19jb21wb25lbnRfbG9hZGVkLnRzP2Y4OWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSG9tZUFzc2lzdGFudCB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuXG4vKiogUmV0dXJuIGlmIGEgY29tcG9uZW50IGlzIGxvYWRlZC4gKi9cbmV4cG9ydCBjb25zdCBpc0NvbXBvbmVudExvYWRlZCA9IChcbiAgaGFzczogSG9tZUFzc2lzdGFudCxcbiAgY29tcG9uZW50OiBzdHJpbmdcbik6IGJvb2xlYW4gPT4gaGFzcyAmJiBoYXNzLmNvbmZpZy5jb21wb25lbnRzLmluY2x1ZGVzKGNvbXBvbmVudCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/common/config/is_component_loaded.ts\n");

/***/ }),

/***/ "./src/components/chart/state-history-chart-line.ts":
/*!**********************************************************!*\
  !*** ./src/components/chart/state-history-chart-line.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators */ \"./node_modules/lit/decorators.js\");\n/* harmony import */ var _common_color_colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/color/colors */ \"./src/common/color/colors.ts\");\n/* harmony import */ var _common_number_format_number__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/number/format_number */ \"./src/common/number/format_number.ts\");\n/* harmony import */ var _ha_chart_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ha-chart-base */ \"./src/components/chart/ha-chart-base.ts\");\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function () { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function (O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function (F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function (receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function (elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function (element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function (element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function (elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function (element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function (elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function (elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function (elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function (elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function (obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function (constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function (obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function (other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nconst safeParseFloat = value => {\n  const parsed = parseFloat(value);\n  return isFinite(parsed) ? parsed : null;\n};\n\nlet StateHistoryChartLine = _decorate(null, function (_initialize, _LitElement) {\n  class StateHistoryChartLine extends _LitElement {\n    constructor(...args) {\n      super(...args);\n\n      _initialize(this);\n    }\n\n  }\n\n  return {\n    F: StateHistoryChartLine,\n    d: [{\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"data\",\n\n      value() {\n        return [];\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)()],\n      key: \"names\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)()],\n      key: \"unit\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)()],\n      key: \"identifier\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        type: Boolean\n      })],\n      key: \"isSingleDevice\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"endTime\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_chartData\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_chartOptions\",\n      value: void 0\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html`\n      <ha-chart-base\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        chart-type=\"line\"\n      ></ha-chart-base>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        if (!this.hasUpdated) {\n          this._chartOptions = {\n            parsing: false,\n            animation: false,\n            scales: {\n              x: {\n                type: \"time\",\n                adapters: {\n                  date: {\n                    locale: this.hass.locale\n                  }\n                },\n                ticks: {\n                  maxRotation: 0,\n                  sampleSize: 5,\n                  autoSkipPadding: 20,\n                  major: {\n                    enabled: true\n                  },\n                  font: context => context.tick && context.tick.major ? {\n                    weight: \"bold\"\n                  } : {}\n                },\n                time: {\n                  tooltipFormat: \"datetimeseconds\"\n                }\n              },\n              y: {\n                ticks: {\n                  maxTicksLimit: 7\n                },\n                title: {\n                  display: true,\n                  text: this.unit\n                }\n              }\n            },\n            plugins: {\n              tooltip: {\n                mode: \"nearest\",\n                callbacks: {\n                  label: context => `${context.dataset.label}: ${(0,_common_number_format_number__WEBPACK_IMPORTED_MODULE_3__.formatNumber)(context.parsed.y, this.hass.locale)} ${this.unit}`\n                }\n              },\n              filler: {\n                propagate: true\n              },\n              legend: {\n                display: !this.isSingleDevice,\n                labels: {\n                  usePointStyle: true\n                }\n              }\n            },\n            hover: {\n              mode: \"nearest\"\n            },\n            elements: {\n              line: {\n                tension: 0.1,\n                borderWidth: 1.5\n              },\n              point: {\n                hitRadius: 5\n              }\n            },\n            // @ts-expect-error\n            locale: (0,_common_number_format_number__WEBPACK_IMPORTED_MODULE_3__.numberFormatToLocale)(this.hass.locale)\n          };\n        }\n\n        if (changedProps.has(\"data\")) {\n          this._generateData();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_generateData\",\n      value: function _generateData() {\n        let colorIndex = 0;\n        const computedStyles = getComputedStyle(this);\n        const entityStates = this.data;\n        const datasets = [];\n        let endTime;\n\n        if (entityStates.length === 0) {\n          return;\n        }\n\n        endTime = this.endTime || // Get the highest date from the last date of each device\n        new Date(Math.max(...entityStates.map(devSts => new Date(devSts.states[devSts.states.length - 1].last_changed).getTime())));\n\n        if (endTime > new Date()) {\n          endTime = new Date();\n        }\n\n        const names = this.names || {};\n        entityStates.forEach(states => {\n          const domain = states.domain;\n          const name = names[states.entity_id] || states.name; // array containing [value1, value2, etc]\n\n          let prevValues = null;\n          const data = [];\n\n          const pushData = (timestamp, datavalues) => {\n            if (!datavalues) return;\n\n            if (timestamp > endTime) {\n              // Drop data points that are after the requested endTime. This could happen if\n              // endTime is \"now\" and client time is not in sync with server time.\n              return;\n            }\n\n            data.forEach((d, i) => {\n              if (datavalues[i] === null && prevValues && prevValues[i] !== null) {\n                // null data values show up as gaps in the chart.\n                // If the current value for the dataset is null and the previous\n                // value of the data set is not null, then add an 'end' point\n                // to the chart for the previous value. Otherwise the gap will\n                // be too big. It will go from the start of the previous data\n                // value until the start of the next data value.\n                d.data.push({\n                  x: timestamp.getTime(),\n                  y: prevValues[i]\n                });\n              }\n\n              d.data.push({\n                x: timestamp.getTime(),\n                y: datavalues[i]\n              });\n            });\n            prevValues = datavalues;\n          };\n\n          const addDataSet = (nameY, fill = false, color) => {\n            if (!color) {\n              color = (0,_common_color_colors__WEBPACK_IMPORTED_MODULE_2__.getGraphColorByIndex)(colorIndex, computedStyles);\n              colorIndex++;\n            }\n\n            data.push({\n              label: nameY,\n              fill: fill ? \"origin\" : false,\n              borderColor: color,\n              backgroundColor: color + \"7F\",\n              stepped: \"before\",\n              pointRadius: 0,\n              data: []\n            });\n          };\n\n          if (domain === \"thermostat\" || domain === \"climate\" || domain === \"water_heater\") {\n            const hasHvacAction = states.states.some(entityState => {\n              var _entityState$attribut;\n\n              return (_entityState$attribut = entityState.attributes) === null || _entityState$attribut === void 0 ? void 0 : _entityState$attribut.hvac_action;\n            });\n            const isHeating = domain === \"climate\" && hasHvacAction ? entityState => {\n              var _entityState$attribut2;\n\n              return ((_entityState$attribut2 = entityState.attributes) === null || _entityState$attribut2 === void 0 ? void 0 : _entityState$attribut2.hvac_action) === \"heating\";\n            } : entityState => entityState.state === \"heat\";\n            const isCooling = domain === \"climate\" && hasHvacAction ? entityState => {\n              var _entityState$attribut3;\n\n              return ((_entityState$attribut3 = entityState.attributes) === null || _entityState$attribut3 === void 0 ? void 0 : _entityState$attribut3.hvac_action) === \"cooling\";\n            } : entityState => entityState.state === \"cool\";\n            const hasHeat = states.states.some(isHeating);\n            const hasCool = states.states.some(isCooling); // We differentiate between thermostats that have a target temperature\n            // range versus ones that have just a target temperature\n            // Using step chart by step-before so manually interpolation not needed.\n\n            const hasTargetRange = states.states.some(entityState => entityState.attributes && entityState.attributes.target_temp_high !== entityState.attributes.target_temp_low);\n            addDataSet(`${this.hass.localize(\"ui.card.climate.current_temperature\", {\n              name: name\n            })}`);\n\n            if (hasHeat) {\n              addDataSet(`${this.hass.localize(\"ui.card.climate.heating\", {\n                name: name\n              })}`, true, computedStyles.getPropertyValue(\"--state-climate-heat-color\")); // The \"heating\" series uses steppedArea to shade the area below the current\n              // temperature when the thermostat is calling for heat.\n            }\n\n            if (hasCool) {\n              addDataSet(`${this.hass.localize(\"ui.card.climate.cooling\", {\n                name: name\n              })}`, true, computedStyles.getPropertyValue(\"--state-climate-cool-color\")); // The \"cooling\" series uses steppedArea to shade the area below the current\n              // temperature when the thermostat is calling for heat.\n            }\n\n            if (hasTargetRange) {\n              addDataSet(`${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n                name: name,\n                mode: this.hass.localize(\"ui.card.climate.high\")\n              })}`);\n              addDataSet(`${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n                name: name,\n                mode: this.hass.localize(\"ui.card.climate.low\")\n              })}`);\n            } else {\n              addDataSet(`${this.hass.localize(\"ui.card.climate.target_temperature_entity\", {\n                name: name\n              })}`);\n            }\n\n            states.states.forEach(entityState => {\n              if (!entityState.attributes) return;\n              const curTemp = safeParseFloat(entityState.attributes.current_temperature);\n              const series = [curTemp];\n\n              if (hasHeat) {\n                series.push(isHeating(entityState) ? curTemp : null);\n              }\n\n              if (hasCool) {\n                series.push(isCooling(entityState) ? curTemp : null);\n              }\n\n              if (hasTargetRange) {\n                const targetHigh = safeParseFloat(entityState.attributes.target_temp_high);\n                const targetLow = safeParseFloat(entityState.attributes.target_temp_low);\n                series.push(targetHigh, targetLow);\n                pushData(new Date(entityState.last_changed), series);\n              } else {\n                const target = safeParseFloat(entityState.attributes.temperature);\n                series.push(target);\n                pushData(new Date(entityState.last_changed), series);\n              }\n            });\n          } else if (domain === \"humidifier\") {\n            addDataSet(`${this.hass.localize(\"ui.card.humidifier.target_humidity_entity\", {\n              name: name\n            })}`);\n            addDataSet(`${this.hass.localize(\"ui.card.humidifier.on_entity\", {\n              name: name\n            })}`, true);\n            states.states.forEach(entityState => {\n              if (!entityState.attributes) return;\n              const target = safeParseFloat(entityState.attributes.humidity);\n              const series = [target];\n              series.push(entityState.state === \"on\" ? target : null);\n              pushData(new Date(entityState.last_changed), series);\n            });\n          } else {\n            addDataSet(name);\n            let lastValue;\n            let lastDate;\n            let lastNullDate = null; // Process chart data.\n            // When state is `unknown`, calculate the value and break the line.\n\n            states.states.forEach(entityState => {\n              const value = safeParseFloat(entityState.state);\n              const date = new Date(entityState.last_changed);\n\n              if (value !== null && lastNullDate) {\n                var _lastDate;\n\n                const dateTime = date.getTime();\n                const lastNullDateTime = lastNullDate.getTime();\n                const lastDateTime = (_lastDate = lastDate) === null || _lastDate === void 0 ? void 0 : _lastDate.getTime();\n                const tmpValue = (value - lastValue) * ((lastNullDateTime - lastDateTime) / (dateTime - lastDateTime)) + lastValue;\n                pushData(lastNullDate, [tmpValue]);\n                pushData(new Date(lastNullDateTime + 1), [null]);\n                pushData(date, [value]);\n                lastDate = date;\n                lastValue = value;\n                lastNullDate = null;\n              } else if (value !== null && lastNullDate === null) {\n                pushData(date, [value]);\n                lastDate = date;\n                lastValue = value;\n              } else if (value === null && lastNullDate === null && lastValue !== undefined) {\n                lastNullDate = date;\n              }\n            });\n          } // Add an entry for final values\n\n\n          pushData(endTime, prevValues); // Concat two arrays\n\n          Array.prototype.push.apply(datasets, data);\n        });\n        this._chartData = {\n          datasets\n        };\n      }\n    }]\n  };\n}, lit__WEBPACK_IMPORTED_MODULE_0__.LitElement);\n\ncustomElements.define(\"state-history-chart-line\", StateHistoryChartLine);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jaGFydC9zdGF0ZS1oaXN0b3J5LWNoYXJ0LWxpbmUudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7OztBQUFBOzs7QUFDQTtBQUFBO0FBQUE7Ozs7O0FBRUE7QUFBQTtBQUFBOzs7O0FBQUE7Ozs7O0FBRUE7Ozs7QUFBQTs7Ozs7QUFFQTs7Ozs7QUFFQTs7Ozs7QUFFQTtBQUFBO0FBQUE7Ozs7QUFBQTs7Ozs7QUFFQTtBQUFBO0FBQUE7Ozs7O0FBRUE7Ozs7O0FBRUE7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBO0FBQUE7QUFUQTtBQVlBO0FBQ0E7QUFEQTtBQW5CQTtBQXVCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSkE7QUF4QkE7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFVQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFkQTtBQXFCQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBTEE7QUFTQTtBQUNBO0FBdkVBO0FBeUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBOztBQVNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBOztBQUVBO0FBS0E7QUFDQTs7QUFBQTtBQUFBO0FBR0E7QUFFQTs7QUFBQTtBQUFBO0FBR0E7QUFFQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUVBO0FBRUE7O0FBQ0E7QUFNQTtBQUVBO0FBREE7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRUE7QUFEQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQURBO0FBSUE7QUFFQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTs7O0FBdldBOztBQXlXQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vc3JjL2NvbXBvbmVudHMvY2hhcnQvc3RhdGUtaGlzdG9yeS1jaGFydC1saW5lLnRzPzNkMGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDaGFydERhdGEsIENoYXJ0RGF0YXNldCwgQ2hhcnRPcHRpb25zIH0gZnJvbSBcImNoYXJ0LmpzXCI7XG5pbXBvcnQgeyBodG1sLCBMaXRFbGVtZW50LCBQcm9wZXJ0eVZhbHVlcyB9IGZyb20gXCJsaXRcIjtcbmltcG9ydCB7IHByb3BlcnR5LCBzdGF0ZSB9IGZyb20gXCJsaXQvZGVjb3JhdG9yc1wiO1xuaW1wb3J0IHsgZ2V0R3JhcGhDb2xvckJ5SW5kZXggfSBmcm9tIFwiLi4vLi4vY29tbW9uL2NvbG9yL2NvbG9yc1wiO1xuaW1wb3J0IHtcbiAgZm9ybWF0TnVtYmVyLFxuICBudW1iZXJGb3JtYXRUb0xvY2FsZSxcbn0gZnJvbSBcIi4uLy4uL2NvbW1vbi9udW1iZXIvZm9ybWF0X251bWJlclwiO1xuaW1wb3J0IHsgTGluZUNoYXJ0RW50aXR5LCBMaW5lQ2hhcnRTdGF0ZSB9IGZyb20gXCIuLi8uLi9kYXRhL2hpc3RvcnlcIjtcbmltcG9ydCB7IEhvbWVBc3Npc3RhbnQgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCBcIi4vaGEtY2hhcnQtYmFzZVwiO1xuXG5jb25zdCBzYWZlUGFyc2VGbG9hdCA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgcmV0dXJuIGlzRmluaXRlKHBhcnNlZCkgPyBwYXJzZWQgOiBudWxsO1xufTtcblxuY2xhc3MgU3RhdGVIaXN0b3J5Q2hhcnRMaW5lIGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gIEBwcm9wZXJ0eSh7IGF0dHJpYnV0ZTogZmFsc2UgfSkgcHVibGljIGhhc3MhOiBIb21lQXNzaXN0YW50O1xuXG4gIEBwcm9wZXJ0eSh7IGF0dHJpYnV0ZTogZmFsc2UgfSkgcHVibGljIGRhdGE6IExpbmVDaGFydEVudGl0eVtdID0gW107XG5cbiAgQHByb3BlcnR5KCkgcHVibGljIG5hbWVzOiBib29sZWFuIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IGZhbHNlO1xuXG4gIEBwcm9wZXJ0eSgpIHB1YmxpYyB1bml0Pzogc3RyaW5nO1xuXG4gIEBwcm9wZXJ0eSgpIHB1YmxpYyBpZGVudGlmaWVyPzogc3RyaW5nO1xuXG4gIEBwcm9wZXJ0eSh7IHR5cGU6IEJvb2xlYW4gfSkgcHVibGljIGlzU2luZ2xlRGV2aWNlID0gZmFsc2U7XG5cbiAgQHByb3BlcnR5KHsgYXR0cmlidXRlOiBmYWxzZSB9KSBwdWJsaWMgZW5kVGltZT86IERhdGU7XG5cbiAgQHN0YXRlKCkgcHJpdmF0ZSBfY2hhcnREYXRhPzogQ2hhcnREYXRhPFwibGluZVwiPjtcblxuICBAc3RhdGUoKSBwcml2YXRlIF9jaGFydE9wdGlvbnM/OiBDaGFydE9wdGlvbnM8XCJsaW5lXCI+O1xuXG4gIHByb3RlY3RlZCByZW5kZXIoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8aGEtY2hhcnQtYmFzZVxuICAgICAgICAuZGF0YT0ke3RoaXMuX2NoYXJ0RGF0YX1cbiAgICAgICAgLm9wdGlvbnM9JHt0aGlzLl9jaGFydE9wdGlvbnN9XG4gICAgICAgIGNoYXJ0LXR5cGU9XCJsaW5lXCJcbiAgICAgID48L2hhLWNoYXJ0LWJhc2U+XG4gICAgYDtcbiAgfVxuXG4gIHB1YmxpYyB3aWxsVXBkYXRlKGNoYW5nZWRQcm9wczogUHJvcGVydHlWYWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaGFzVXBkYXRlZCkge1xuICAgICAgdGhpcy5fY2hhcnRPcHRpb25zID0ge1xuICAgICAgICBwYXJzaW5nOiBmYWxzZSxcbiAgICAgICAgYW5pbWF0aW9uOiBmYWxzZSxcbiAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgeDoge1xuICAgICAgICAgICAgdHlwZTogXCJ0aW1lXCIsXG4gICAgICAgICAgICBhZGFwdGVyczoge1xuICAgICAgICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmhhc3MubG9jYWxlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICAgIG1heFJvdGF0aW9uOiAwLFxuICAgICAgICAgICAgICBzYW1wbGVTaXplOiA1LFxuICAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxuICAgICAgICAgICAgICBtYWpvcjoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZvbnQ6IChjb250ZXh0KSA9PlxuICAgICAgICAgICAgICAgIGNvbnRleHQudGljayAmJiBjb250ZXh0LnRpY2subWFqb3JcbiAgICAgICAgICAgICAgICAgID8gKHsgd2VpZ2h0OiBcImJvbGRcIiB9IGFzIGFueSlcbiAgICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZToge1xuICAgICAgICAgICAgICB0b29sdGlwRm9ybWF0OiBcImRhdGV0aW1lc2Vjb25kc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICAgIG1heFRpY2tzTGltaXQ6IDcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgdGV4dDogdGhpcy51bml0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwbHVnaW5zOiB7XG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgbW9kZTogXCJuZWFyZXN0XCIsXG4gICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgbGFiZWw6IChjb250ZXh0KSA9PlxuICAgICAgICAgICAgICAgIGAke2NvbnRleHQuZGF0YXNldC5sYWJlbH06ICR7Zm9ybWF0TnVtYmVyKFxuICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXJzZWQueSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuaGFzcy5sb2NhbGVcbiAgICAgICAgICAgICAgICApfSAke3RoaXMudW5pdH1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGxlcjoge1xuICAgICAgICAgICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAhdGhpcy5pc1NpbmdsZURldmljZSxcbiAgICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgICB1c2VQb2ludFN0eWxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIG1vZGU6IFwibmVhcmVzdFwiLFxuICAgICAgICB9LFxuICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgIHRlbnNpb246IDAuMSxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLjUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgaGl0UmFkaXVzOiA1LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbG9jYWxlOiBudW1iZXJGb3JtYXRUb0xvY2FsZSh0aGlzLmhhc3MubG9jYWxlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkUHJvcHMuaGFzKFwiZGF0YVwiKSkge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVEYXRhKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZ2VuZXJhdGVEYXRhKCkge1xuICAgIGxldCBjb2xvckluZGV4ID0gMDtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUodGhpcyk7XG4gICAgY29uc3QgZW50aXR5U3RhdGVzID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGRhdGFzZXRzOiBDaGFydERhdGFzZXQ8XCJsaW5lXCI+W10gPSBbXTtcbiAgICBsZXQgZW5kVGltZTogRGF0ZTtcblxuICAgIGlmIChlbnRpdHlTdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZW5kVGltZSA9XG4gICAgICB0aGlzLmVuZFRpbWUgfHxcbiAgICAgIC8vIEdldCB0aGUgaGlnaGVzdCBkYXRlIGZyb20gdGhlIGxhc3QgZGF0ZSBvZiBlYWNoIGRldmljZVxuICAgICAgbmV3IERhdGUoXG4gICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgIC4uLmVudGl0eVN0YXRlcy5tYXAoKGRldlN0cykgPT5cbiAgICAgICAgICAgIG5ldyBEYXRlKFxuICAgICAgICAgICAgICBkZXZTdHMuc3RhdGVzW2RldlN0cy5zdGF0ZXMubGVuZ3RoIC0gMV0ubGFzdF9jaGFuZ2VkXG4gICAgICAgICAgICApLmdldFRpbWUoKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICBpZiAoZW5kVGltZSA+IG5ldyBEYXRlKCkpIHtcbiAgICAgIGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5uYW1lcyB8fCB7fTtcbiAgICBlbnRpdHlTdGF0ZXMuZm9yRWFjaCgoc3RhdGVzKSA9PiB7XG4gICAgICBjb25zdCBkb21haW4gPSBzdGF0ZXMuZG9tYWluO1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW3N0YXRlcy5lbnRpdHlfaWRdIHx8IHN0YXRlcy5uYW1lO1xuICAgICAgLy8gYXJyYXkgY29udGFpbmluZyBbdmFsdWUxLCB2YWx1ZTIsIGV0Y11cbiAgICAgIGxldCBwcmV2VmFsdWVzOiBhbnlbXSB8IG51bGwgPSBudWxsO1xuXG4gICAgICBjb25zdCBkYXRhOiBDaGFydERhdGFzZXQ8XCJsaW5lXCI+W10gPSBbXTtcblxuICAgICAgY29uc3QgcHVzaERhdGEgPSAodGltZXN0YW1wOiBEYXRlLCBkYXRhdmFsdWVzOiBhbnlbXSB8IG51bGwpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhdmFsdWVzKSByZXR1cm47XG4gICAgICAgIGlmICh0aW1lc3RhbXAgPiBlbmRUaW1lKSB7XG4gICAgICAgICAgLy8gRHJvcCBkYXRhIHBvaW50cyB0aGF0IGFyZSBhZnRlciB0aGUgcmVxdWVzdGVkIGVuZFRpbWUuIFRoaXMgY291bGQgaGFwcGVuIGlmXG4gICAgICAgICAgLy8gZW5kVGltZSBpcyBcIm5vd1wiIGFuZCBjbGllbnQgdGltZSBpcyBub3QgaW4gc3luYyB3aXRoIHNlcnZlciB0aW1lLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgICBpZiAoZGF0YXZhbHVlc1tpXSA9PT0gbnVsbCAmJiBwcmV2VmFsdWVzICYmIHByZXZWYWx1ZXNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG51bGwgZGF0YSB2YWx1ZXMgc2hvdyB1cCBhcyBnYXBzIGluIHRoZSBjaGFydC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHZhbHVlIGZvciB0aGUgZGF0YXNldCBpcyBudWxsIGFuZCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIHZhbHVlIG9mIHRoZSBkYXRhIHNldCBpcyBub3QgbnVsbCwgdGhlbiBhZGQgYW4gJ2VuZCcgcG9pbnRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBjaGFydCBmb3IgdGhlIHByZXZpb3VzIHZhbHVlLiBPdGhlcndpc2UgdGhlIGdhcCB3aWxsXG4gICAgICAgICAgICAvLyBiZSB0b28gYmlnLiBJdCB3aWxsIGdvIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwcmV2aW91cyBkYXRhXG4gICAgICAgICAgICAvLyB2YWx1ZSB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgZGF0YSB2YWx1ZS5cbiAgICAgICAgICAgIGQuZGF0YS5wdXNoKHsgeDogdGltZXN0YW1wLmdldFRpbWUoKSwgeTogcHJldlZhbHVlc1tpXSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZC5kYXRhLnB1c2goeyB4OiB0aW1lc3RhbXAuZ2V0VGltZSgpLCB5OiBkYXRhdmFsdWVzW2ldIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldlZhbHVlcyA9IGRhdGF2YWx1ZXM7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBhZGREYXRhU2V0ID0gKG5hbWVZOiBzdHJpbmcsIGZpbGwgPSBmYWxzZSwgY29sb3I/OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgIGNvbG9yID0gZ2V0R3JhcGhDb2xvckJ5SW5kZXgoY29sb3JJbmRleCwgY29tcHV0ZWRTdHlsZXMpO1xuICAgICAgICAgIGNvbG9ySW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgIGxhYmVsOiBuYW1lWSxcbiAgICAgICAgICBmaWxsOiBmaWxsID8gXCJvcmlnaW5cIiA6IGZhbHNlLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBjb2xvcixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yICsgXCI3RlwiLFxuICAgICAgICAgIHN0ZXBwZWQ6IFwiYmVmb3JlXCIsXG4gICAgICAgICAgcG9pbnRSYWRpdXM6IDAsXG4gICAgICAgICAgZGF0YTogW10sXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaWYgKFxuICAgICAgICBkb21haW4gPT09IFwidGhlcm1vc3RhdFwiIHx8XG4gICAgICAgIGRvbWFpbiA9PT0gXCJjbGltYXRlXCIgfHxcbiAgICAgICAgZG9tYWluID09PSBcIndhdGVyX2hlYXRlclwiXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgaGFzSHZhY0FjdGlvbiA9IHN0YXRlcy5zdGF0ZXMuc29tZShcbiAgICAgICAgICAoZW50aXR5U3RhdGUpID0+IGVudGl0eVN0YXRlLmF0dHJpYnV0ZXM/Lmh2YWNfYWN0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaXNIZWF0aW5nID1cbiAgICAgICAgICBkb21haW4gPT09IFwiY2xpbWF0ZVwiICYmIGhhc0h2YWNBY3Rpb25cbiAgICAgICAgICAgID8gKGVudGl0eVN0YXRlOiBMaW5lQ2hhcnRTdGF0ZSkgPT5cbiAgICAgICAgICAgICAgICBlbnRpdHlTdGF0ZS5hdHRyaWJ1dGVzPy5odmFjX2FjdGlvbiA9PT0gXCJoZWF0aW5nXCJcbiAgICAgICAgICAgIDogKGVudGl0eVN0YXRlOiBMaW5lQ2hhcnRTdGF0ZSkgPT4gZW50aXR5U3RhdGUuc3RhdGUgPT09IFwiaGVhdFwiO1xuICAgICAgICBjb25zdCBpc0Nvb2xpbmcgPVxuICAgICAgICAgIGRvbWFpbiA9PT0gXCJjbGltYXRlXCIgJiYgaGFzSHZhY0FjdGlvblxuICAgICAgICAgICAgPyAoZW50aXR5U3RhdGU6IExpbmVDaGFydFN0YXRlKSA9PlxuICAgICAgICAgICAgICAgIGVudGl0eVN0YXRlLmF0dHJpYnV0ZXM/Lmh2YWNfYWN0aW9uID09PSBcImNvb2xpbmdcIlxuICAgICAgICAgICAgOiAoZW50aXR5U3RhdGU6IExpbmVDaGFydFN0YXRlKSA9PiBlbnRpdHlTdGF0ZS5zdGF0ZSA9PT0gXCJjb29sXCI7XG5cbiAgICAgICAgY29uc3QgaGFzSGVhdCA9IHN0YXRlcy5zdGF0ZXMuc29tZShpc0hlYXRpbmcpO1xuICAgICAgICBjb25zdCBoYXNDb29sID0gc3RhdGVzLnN0YXRlcy5zb21lKGlzQ29vbGluZyk7XG4gICAgICAgIC8vIFdlIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGVybW9zdGF0cyB0aGF0IGhhdmUgYSB0YXJnZXQgdGVtcGVyYXR1cmVcbiAgICAgICAgLy8gcmFuZ2UgdmVyc3VzIG9uZXMgdGhhdCBoYXZlIGp1c3QgYSB0YXJnZXQgdGVtcGVyYXR1cmVcblxuICAgICAgICAvLyBVc2luZyBzdGVwIGNoYXJ0IGJ5IHN0ZXAtYmVmb3JlIHNvIG1hbnVhbGx5IGludGVycG9sYXRpb24gbm90IG5lZWRlZC5cbiAgICAgICAgY29uc3QgaGFzVGFyZ2V0UmFuZ2UgPSBzdGF0ZXMuc3RhdGVzLnNvbWUoXG4gICAgICAgICAgKGVudGl0eVN0YXRlKSA9PlxuICAgICAgICAgICAgZW50aXR5U3RhdGUuYXR0cmlidXRlcyAmJlxuICAgICAgICAgICAgZW50aXR5U3RhdGUuYXR0cmlidXRlcy50YXJnZXRfdGVtcF9oaWdoICE9PVxuICAgICAgICAgICAgICBlbnRpdHlTdGF0ZS5hdHRyaWJ1dGVzLnRhcmdldF90ZW1wX2xvd1xuICAgICAgICApO1xuICAgICAgICBhZGREYXRhU2V0KFxuICAgICAgICAgIGAke3RoaXMuaGFzcy5sb2NhbGl6ZShcInVpLmNhcmQuY2xpbWF0ZS5jdXJyZW50X3RlbXBlcmF0dXJlXCIsIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgfSl9YFxuICAgICAgICApO1xuICAgICAgICBpZiAoaGFzSGVhdCkge1xuICAgICAgICAgIGFkZERhdGFTZXQoXG4gICAgICAgICAgICBgJHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmNsaW1hdGUuaGVhdGluZ1wiLCB7IG5hbWU6IG5hbWUgfSl9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1zdGF0ZS1jbGltYXRlLWhlYXQtY29sb3JcIilcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vIFRoZSBcImhlYXRpbmdcIiBzZXJpZXMgdXNlcyBzdGVwcGVkQXJlYSB0byBzaGFkZSB0aGUgYXJlYSBiZWxvdyB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIHRlbXBlcmF0dXJlIHdoZW4gdGhlIHRoZXJtb3N0YXQgaXMgY2FsbGluZyBmb3IgaGVhdC5cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ29vbCkge1xuICAgICAgICAgIGFkZERhdGFTZXQoXG4gICAgICAgICAgICBgJHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmNsaW1hdGUuY29vbGluZ1wiLCB7IG5hbWU6IG5hbWUgfSl9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1zdGF0ZS1jbGltYXRlLWNvb2wtY29sb3JcIilcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vIFRoZSBcImNvb2xpbmdcIiBzZXJpZXMgdXNlcyBzdGVwcGVkQXJlYSB0byBzaGFkZSB0aGUgYXJlYSBiZWxvdyB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIHRlbXBlcmF0dXJlIHdoZW4gdGhlIHRoZXJtb3N0YXQgaXMgY2FsbGluZyBmb3IgaGVhdC5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNUYXJnZXRSYW5nZSkge1xuICAgICAgICAgIGFkZERhdGFTZXQoXG4gICAgICAgICAgICBgJHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmNsaW1hdGUudGFyZ2V0X3RlbXBlcmF0dXJlX21vZGVcIiwge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBtb2RlOiB0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmNsaW1hdGUuaGlnaFwiKSxcbiAgICAgICAgICAgIH0pfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIGFkZERhdGFTZXQoXG4gICAgICAgICAgICBgJHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmNsaW1hdGUudGFyZ2V0X3RlbXBlcmF0dXJlX21vZGVcIiwge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBtb2RlOiB0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmNsaW1hdGUubG93XCIpLFxuICAgICAgICAgICAgfSl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkRGF0YVNldChcbiAgICAgICAgICAgIGAke3RoaXMuaGFzcy5sb2NhbGl6ZShcInVpLmNhcmQuY2xpbWF0ZS50YXJnZXRfdGVtcGVyYXR1cmVfZW50aXR5XCIsIHtcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIH0pfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGVzLnN0YXRlcy5mb3JFYWNoKChlbnRpdHlTdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmICghZW50aXR5U3RhdGUuYXR0cmlidXRlcykgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGN1clRlbXAgPSBzYWZlUGFyc2VGbG9hdChcbiAgICAgICAgICAgIGVudGl0eVN0YXRlLmF0dHJpYnV0ZXMuY3VycmVudF90ZW1wZXJhdHVyZVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgc2VyaWVzID0gW2N1clRlbXBdO1xuICAgICAgICAgIGlmIChoYXNIZWF0KSB7XG4gICAgICAgICAgICBzZXJpZXMucHVzaChpc0hlYXRpbmcoZW50aXR5U3RhdGUpID8gY3VyVGVtcCA6IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzQ29vbCkge1xuICAgICAgICAgICAgc2VyaWVzLnB1c2goaXNDb29saW5nKGVudGl0eVN0YXRlKSA/IGN1clRlbXAgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc1RhcmdldFJhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRIaWdoID0gc2FmZVBhcnNlRmxvYXQoXG4gICAgICAgICAgICAgIGVudGl0eVN0YXRlLmF0dHJpYnV0ZXMudGFyZ2V0X3RlbXBfaGlnaFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExvdyA9IHNhZmVQYXJzZUZsb2F0KFxuICAgICAgICAgICAgICBlbnRpdHlTdGF0ZS5hdHRyaWJ1dGVzLnRhcmdldF90ZW1wX2xvd1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNlcmllcy5wdXNoKHRhcmdldEhpZ2gsIHRhcmdldExvdyk7XG4gICAgICAgICAgICBwdXNoRGF0YShuZXcgRGF0ZShlbnRpdHlTdGF0ZS5sYXN0X2NoYW5nZWQpLCBzZXJpZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBzYWZlUGFyc2VGbG9hdChlbnRpdHlTdGF0ZS5hdHRyaWJ1dGVzLnRlbXBlcmF0dXJlKTtcbiAgICAgICAgICAgIHNlcmllcy5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICBwdXNoRGF0YShuZXcgRGF0ZShlbnRpdHlTdGF0ZS5sYXN0X2NoYW5nZWQpLCBzZXJpZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGRvbWFpbiA9PT0gXCJodW1pZGlmaWVyXCIpIHtcbiAgICAgICAgYWRkRGF0YVNldChcbiAgICAgICAgICBgJHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmh1bWlkaWZpZXIudGFyZ2V0X2h1bWlkaXR5X2VudGl0eVwiLCB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIH0pfWBcbiAgICAgICAgKTtcbiAgICAgICAgYWRkRGF0YVNldChcbiAgICAgICAgICBgJHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmh1bWlkaWZpZXIub25fZW50aXR5XCIsIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgfSl9YCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG5cbiAgICAgICAgc3RhdGVzLnN0YXRlcy5mb3JFYWNoKChlbnRpdHlTdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmICghZW50aXR5U3RhdGUuYXR0cmlidXRlcykgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNhZmVQYXJzZUZsb2F0KGVudGl0eVN0YXRlLmF0dHJpYnV0ZXMuaHVtaWRpdHkpO1xuICAgICAgICAgIGNvbnN0IHNlcmllcyA9IFt0YXJnZXRdO1xuICAgICAgICAgIHNlcmllcy5wdXNoKGVudGl0eVN0YXRlLnN0YXRlID09PSBcIm9uXCIgPyB0YXJnZXQgOiBudWxsKTtcbiAgICAgICAgICBwdXNoRGF0YShuZXcgRGF0ZShlbnRpdHlTdGF0ZS5sYXN0X2NoYW5nZWQpLCBzZXJpZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZERhdGFTZXQobmFtZSk7XG5cbiAgICAgICAgbGV0IGxhc3RWYWx1ZTogbnVtYmVyO1xuICAgICAgICBsZXQgbGFzdERhdGU6IERhdGU7XG4gICAgICAgIGxldCBsYXN0TnVsbERhdGU6IERhdGUgfCBudWxsID0gbnVsbDtcblxuICAgICAgICAvLyBQcm9jZXNzIGNoYXJ0IGRhdGEuXG4gICAgICAgIC8vIFdoZW4gc3RhdGUgaXMgYHVua25vd25gLCBjYWxjdWxhdGUgdGhlIHZhbHVlIGFuZCBicmVhayB0aGUgbGluZS5cbiAgICAgICAgc3RhdGVzLnN0YXRlcy5mb3JFYWNoKChlbnRpdHlTdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gc2FmZVBhcnNlRmxvYXQoZW50aXR5U3RhdGUuc3RhdGUpO1xuICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShlbnRpdHlTdGF0ZS5sYXN0X2NoYW5nZWQpO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBsYXN0TnVsbERhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVUaW1lID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0TnVsbERhdGVUaW1lID0gbGFzdE51bGxEYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3REYXRlVGltZSA9IGxhc3REYXRlPy5nZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCB0bXBWYWx1ZSA9XG4gICAgICAgICAgICAgICh2YWx1ZSAtIGxhc3RWYWx1ZSkgKlxuICAgICAgICAgICAgICAgICgobGFzdE51bGxEYXRlVGltZSAtIGxhc3REYXRlVGltZSkgL1xuICAgICAgICAgICAgICAgICAgKGRhdGVUaW1lIC0gbGFzdERhdGVUaW1lKSkgK1xuICAgICAgICAgICAgICBsYXN0VmFsdWU7XG4gICAgICAgICAgICBwdXNoRGF0YShsYXN0TnVsbERhdGUsIFt0bXBWYWx1ZV0pO1xuICAgICAgICAgICAgcHVzaERhdGEobmV3IERhdGUobGFzdE51bGxEYXRlVGltZSArIDEpLCBbbnVsbF0pO1xuICAgICAgICAgICAgcHVzaERhdGEoZGF0ZSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICBsYXN0RGF0ZSA9IGRhdGU7XG4gICAgICAgICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGxhc3ROdWxsRGF0ZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBsYXN0TnVsbERhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHB1c2hEYXRhKGRhdGUsIFt2YWx1ZV0pO1xuICAgICAgICAgICAgbGFzdERhdGUgPSBkYXRlO1xuICAgICAgICAgICAgbGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHZhbHVlID09PSBudWxsICYmXG4gICAgICAgICAgICBsYXN0TnVsbERhdGUgPT09IG51bGwgJiZcbiAgICAgICAgICAgIGxhc3RWYWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBsYXN0TnVsbERhdGUgPSBkYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhbiBlbnRyeSBmb3IgZmluYWwgdmFsdWVzXG4gICAgICBwdXNoRGF0YShlbmRUaW1lLCBwcmV2VmFsdWVzKTtcblxuICAgICAgLy8gQ29uY2F0IHR3byBhcnJheXNcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRhdGFzZXRzLCBkYXRhKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NoYXJ0RGF0YSA9IHtcbiAgICAgIGRhdGFzZXRzLFxuICAgIH07XG4gIH1cbn1cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShcInN0YXRlLWhpc3RvcnktY2hhcnQtbGluZVwiLCBTdGF0ZUhpc3RvcnlDaGFydExpbmUpO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBIVE1MRWxlbWVudFRhZ05hbWVNYXAge1xuICAgIFwic3RhdGUtaGlzdG9yeS1jaGFydC1saW5lXCI6IFN0YXRlSGlzdG9yeUNoYXJ0TGluZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/chart/state-history-chart-line.ts\n");

/***/ }),

/***/ "./src/components/chart/state-history-chart-timeline.ts":
/*!**************************************************************!*\
  !*** ./src/components/chart/state-history-chart-timeline.ts ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StateHistoryChartTimeline\": () => (/* binding */ StateHistoryChartTimeline)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators */ \"./node_modules/lit/decorators.js\");\n/* harmony import */ var _common_color_colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/color/colors */ \"./src/common/color/colors.ts\");\n/* harmony import */ var _common_datetime_format_date_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/datetime/format_date_time */ \"./src/common/datetime/format_date_time.ts\");\n/* harmony import */ var _common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/entity/compute_domain */ \"./src/common/entity/compute_domain.ts\");\n/* harmony import */ var _common_number_format_number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/number/format_number */ \"./src/common/number/format_number.ts\");\n/* harmony import */ var _common_util_compute_rtl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/util/compute_rtl */ \"./src/common/util/compute_rtl.ts\");\n/* harmony import */ var _ha_chart_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ha-chart-base */ \"./src/components/chart/ha-chart-base.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_common_datetime_format_date_time__WEBPACK_IMPORTED_MODULE_3__]);\n_common_datetime_format_date_time__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function () { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function (O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function (F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function (receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function (elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function (element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function (element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function (elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function (element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function (elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function (elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function (elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function (elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function (obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function (constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function (obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function (other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\n/** Binary sensor device classes for which the static colors for on/off are NOT inverted.\n *  List the ones were \"on\" = good or normal state => should be rendered \"green\".\n *  Note: It is now a \"not inverted\" list (compared to the past) since we now have more inverted ones.\n */\nconst BINARY_SENSOR_DEVICE_CLASS_COLOR_NOT_INVERTED = new Set([\"battery_charging\", \"connectivity\", \"light\", \"moving\", \"plug\", \"power\", \"presence\", \"running\"]);\nconst STATIC_STATE_COLORS = new Set([\"on\", \"off\", \"home\", \"not_home\", \"unavailable\", \"unknown\", \"idle\"]);\nconst stateColorMap = new Map();\nlet colorIndex = 0;\n\nconst invertOnOff = entityState => entityState && (0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_4__.computeDomain)(entityState.entity_id) === \"binary_sensor\" && \"device_class\" in entityState.attributes && !BINARY_SENSOR_DEVICE_CLASS_COLOR_NOT_INVERTED.has(entityState.attributes.device_class);\n\nconst getColor = (stateString, entityState, computedStyles) => {\n  // Inversion is only valid for \"on\" or \"off\" state\n  if ((stateString === \"on\" || stateString === \"off\") && invertOnOff(entityState)) {\n    stateString = stateString === \"on\" ? \"off\" : \"on\";\n  }\n\n  if (stateColorMap.has(stateString)) {\n    return stateColorMap.get(stateString);\n  }\n\n  if (STATIC_STATE_COLORS.has(stateString)) {\n    const color = computedStyles.getPropertyValue(`--state-${stateString}-color`);\n    stateColorMap.set(stateString, color);\n    return color;\n  }\n\n  const color = (0,_common_color_colors__WEBPACK_IMPORTED_MODULE_2__.getGraphColorByIndex)(colorIndex, computedStyles);\n  colorIndex++;\n  stateColorMap.set(stateString, color);\n  return color;\n};\n\nlet StateHistoryChartTimeline = _decorate([(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.customElement)(\"state-history-chart-timeline\")], function (_initialize, _LitElement) {\n  class StateHistoryChartTimeline extends _LitElement {\n    constructor(...args) {\n      super(...args);\n\n      _initialize(this);\n    }\n\n  }\n\n  return {\n    F: StateHistoryChartTimeline,\n    d: [{\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"data\",\n\n      value() {\n        return [];\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)()],\n      key: \"names\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)()],\n      key: \"unit\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)()],\n      key: \"identifier\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        type: Boolean\n      })],\n      key: \"isSingleDevice\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"endTime\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_chartData\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.state)()],\n      key: \"_chartOptions\",\n      value: void 0\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html`\n      <ha-chart-base\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .height=${this.data.length * 30 + 30}\n        chart-type=\"timeline\"\n      ></ha-chart-base>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        if (!this.hasUpdated) {\n          this._chartOptions = {\n            maintainAspectRatio: false,\n            parsing: false,\n            animation: false,\n            scales: {\n              x: {\n                type: \"timeline\",\n                position: \"bottom\",\n                adapters: {\n                  date: {\n                    locale: this.hass.locale\n                  }\n                },\n                ticks: {\n                  autoSkip: true,\n                  maxRotation: 0,\n                  sampleSize: 5,\n                  autoSkipPadding: 20,\n                  major: {\n                    enabled: true\n                  },\n                  font: context => context.tick && context.tick.major ? {\n                    weight: \"bold\"\n                  } : {}\n                },\n                grid: {\n                  offset: false\n                },\n                time: {\n                  tooltipFormat: \"datetimeseconds\"\n                }\n              },\n              y: {\n                type: \"category\",\n                barThickness: 20,\n                offset: true,\n                grid: {\n                  display: false,\n                  drawBorder: false,\n                  drawTicks: false\n                },\n                ticks: {\n                  display: this.data.length !== 1\n                },\n                afterSetDimensions: y => {\n                  y.maxWidth = y.chart.width * 0.18;\n                },\n                position: (0,_common_util_compute_rtl__WEBPACK_IMPORTED_MODULE_6__.computeRTL)(this.hass) ? \"right\" : \"left\"\n              }\n            },\n            plugins: {\n              tooltip: {\n                mode: \"nearest\",\n                callbacks: {\n                  title: context => context[0].chart.data.labels[context[0].datasetIndex],\n                  beforeBody: context => context[0].dataset.label || \"\",\n                  label: item => {\n                    const d = item.dataset.data[item.dataIndex];\n                    return [d.label || \"\", (0,_common_datetime_format_date_time__WEBPACK_IMPORTED_MODULE_3__.formatDateTimeWithSeconds)(d.start, this.hass.locale), (0,_common_datetime_format_date_time__WEBPACK_IMPORTED_MODULE_3__.formatDateTimeWithSeconds)(d.end, this.hass.locale)];\n                  },\n                  labelColor: item => ({\n                    borderColor: item.dataset.data[item.dataIndex].color,\n                    backgroundColor: item.dataset.data[item.dataIndex].color\n                  })\n                }\n              },\n              filler: {\n                propagate: true\n              }\n            },\n            // @ts-expect-error\n            locale: (0,_common_number_format_number__WEBPACK_IMPORTED_MODULE_5__.numberFormatToLocale)(this.hass.locale)\n          };\n        }\n\n        if (changedProps.has(\"data\")) {\n          this._generateData();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_generateData\",\n      value: function _generateData() {\n        const computedStyles = getComputedStyle(this);\n        let stateHistory = this.data;\n\n        if (!stateHistory) {\n          stateHistory = [];\n        }\n\n        const startTime = new Date(stateHistory.reduce((minTime, stateInfo) => Math.min(minTime, new Date(stateInfo.data[0].last_changed).getTime()), new Date().getTime())); // end time is Math.max(startTime, last_event)\n\n        let endTime = this.endTime || new Date(stateHistory.reduce((maxTime, stateInfo) => Math.max(maxTime, new Date(stateInfo.data[stateInfo.data.length - 1].last_changed).getTime()), startTime.getTime()));\n\n        if (endTime > new Date()) {\n          endTime = new Date();\n        }\n\n        const labels = [];\n        const datasets = [];\n        const names = this.names || {}; // stateHistory is a list of lists of sorted state objects\n\n        stateHistory.forEach(stateInfo => {\n          let newLastChanged;\n          let prevState = null;\n          let locState = null;\n          let prevLastChanged = startTime;\n          const entityDisplay = names[stateInfo.entity_id] || stateInfo.name;\n          const dataRow = [];\n          stateInfo.data.forEach(entityState => {\n            let newState = entityState.state;\n            const timeStamp = new Date(entityState.last_changed);\n\n            if (!newState) {\n              newState = null;\n            }\n\n            if (timeStamp > endTime) {\n              // Drop datapoints that are after the requested endTime. This could happen if\n              // endTime is 'now' and client time is not in sync with server time.\n              return;\n            }\n\n            if (prevState === null) {\n              prevState = newState;\n              locState = entityState.state_localize;\n              prevLastChanged = new Date(entityState.last_changed);\n            } else if (newState !== prevState) {\n              newLastChanged = new Date(entityState.last_changed);\n              dataRow.push({\n                start: prevLastChanged,\n                end: newLastChanged,\n                label: locState,\n                color: getColor(prevState, this.hass.states[stateInfo.entity_id], computedStyles)\n              });\n              prevState = newState;\n              locState = entityState.state_localize;\n              prevLastChanged = newLastChanged;\n            }\n          });\n\n          if (prevState !== null) {\n            dataRow.push({\n              start: prevLastChanged,\n              end: endTime,\n              label: locState,\n              color: getColor(prevState, this.hass.states[stateInfo.entity_id], computedStyles)\n            });\n          }\n\n          datasets.push({\n            data: dataRow,\n            label: stateInfo.entity_id\n          });\n          labels.push(entityDisplay);\n        });\n        this._chartData = {\n          labels: labels,\n          datasets: datasets\n        };\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.css`\n      ha-chart-base {\n        --chart-max-height: none;\n      }\n    `;\n      }\n    }]\n  };\n}, lit__WEBPACK_IMPORTED_MODULE_0__.LitElement);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jaGFydC9zdGF0ZS1oaXN0b3J5LWNoYXJ0LXRpbWVsaW5lLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFVQTtBQUVBOztBQUVBOztBQVFBO0FBS0E7QUFDQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQURBO0FBQ0E7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFIQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBV0E7QUFBQTtBQVhBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFhQTtBQUFBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUJBO0FBQUE7QUFBQTtBQUFBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTtBQUFBO0FBVkE7QUFhQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUF4QkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQTdCQTtBQStDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUhBO0FBZEE7QUFGQTtBQXlCQTtBQUNBO0FBREE7QUExQkE7QUE4QkE7QUFDQTtBQWxGQTtBQW9GQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhIQTtBQUFBO0FBQUE7QUFBQTtBQTJIQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFTQTs7QUFlQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFVQTs7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBck9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN09BO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vc3JjL2NvbXBvbmVudHMvY2hhcnQvc3RhdGUtaGlzdG9yeS1jaGFydC10aW1lbGluZS50cz81YzUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2hhcnREYXRhLCBDaGFydERhdGFzZXQsIENoYXJ0T3B0aW9ucyB9IGZyb20gXCJjaGFydC5qc1wiO1xuaW1wb3J0IHsgSGFzc0VudGl0eSB9IGZyb20gXCJob21lLWFzc2lzdGFudC1qcy13ZWJzb2NrZXRcIjtcbmltcG9ydCB7IGNzcywgQ1NTUmVzdWx0R3JvdXAsIGh0bWwsIExpdEVsZW1lbnQsIFByb3BlcnR5VmFsdWVzIH0gZnJvbSBcImxpdFwiO1xuaW1wb3J0IHsgY3VzdG9tRWxlbWVudCwgcHJvcGVydHksIHN0YXRlIH0gZnJvbSBcImxpdC9kZWNvcmF0b3JzXCI7XG5pbXBvcnQgeyBnZXRHcmFwaENvbG9yQnlJbmRleCB9IGZyb20gXCIuLi8uLi9jb21tb24vY29sb3IvY29sb3JzXCI7XG5pbXBvcnQgeyBmb3JtYXREYXRlVGltZVdpdGhTZWNvbmRzIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9kYXRldGltZS9mb3JtYXRfZGF0ZV90aW1lXCI7XG5pbXBvcnQgeyBjb21wdXRlRG9tYWluIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9lbnRpdHkvY29tcHV0ZV9kb21haW5cIjtcbmltcG9ydCB7IG51bWJlckZvcm1hdFRvTG9jYWxlIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9udW1iZXIvZm9ybWF0X251bWJlclwiO1xuaW1wb3J0IHsgY29tcHV0ZVJUTCB9IGZyb20gXCIuLi8uLi9jb21tb24vdXRpbC9jb21wdXRlX3J0bFwiO1xuaW1wb3J0IHsgVGltZWxpbmVFbnRpdHkgfSBmcm9tIFwiLi4vLi4vZGF0YS9oaXN0b3J5XCI7XG5pbXBvcnQgeyBIb21lQXNzaXN0YW50IH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgXCIuL2hhLWNoYXJ0LWJhc2VcIjtcbmltcG9ydCB0eXBlIHsgVGltZUxpbmVEYXRhIH0gZnJvbSBcIi4vdGltZWxpbmUtY2hhcnQvY29uc3RcIjtcblxuLyoqIEJpbmFyeSBzZW5zb3IgZGV2aWNlIGNsYXNzZXMgZm9yIHdoaWNoIHRoZSBzdGF0aWMgY29sb3JzIGZvciBvbi9vZmYgYXJlIE5PVCBpbnZlcnRlZC5cbiAqICBMaXN0IHRoZSBvbmVzIHdlcmUgXCJvblwiID0gZ29vZCBvciBub3JtYWwgc3RhdGUgPT4gc2hvdWxkIGJlIHJlbmRlcmVkIFwiZ3JlZW5cIi5cbiAqICBOb3RlOiBJdCBpcyBub3cgYSBcIm5vdCBpbnZlcnRlZFwiIGxpc3QgKGNvbXBhcmVkIHRvIHRoZSBwYXN0KSBzaW5jZSB3ZSBub3cgaGF2ZSBtb3JlIGludmVydGVkIG9uZXMuXG4gKi9cbmNvbnN0IEJJTkFSWV9TRU5TT1JfREVWSUNFX0NMQVNTX0NPTE9SX05PVF9JTlZFUlRFRCA9IG5ldyBTZXQoW1xuICBcImJhdHRlcnlfY2hhcmdpbmdcIixcbiAgXCJjb25uZWN0aXZpdHlcIixcbiAgXCJsaWdodFwiLFxuICBcIm1vdmluZ1wiLFxuICBcInBsdWdcIixcbiAgXCJwb3dlclwiLFxuICBcInByZXNlbmNlXCIsXG4gIFwicnVubmluZ1wiLFxuXSk7XG5cbmNvbnN0IFNUQVRJQ19TVEFURV9DT0xPUlMgPSBuZXcgU2V0KFtcbiAgXCJvblwiLFxuICBcIm9mZlwiLFxuICBcImhvbWVcIixcbiAgXCJub3RfaG9tZVwiLFxuICBcInVuYXZhaWxhYmxlXCIsXG4gIFwidW5rbm93blwiLFxuICBcImlkbGVcIixcbl0pO1xuXG5jb25zdCBzdGF0ZUNvbG9yTWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xuXG5sZXQgY29sb3JJbmRleCA9IDA7XG5cbmNvbnN0IGludmVydE9uT2ZmID0gKGVudGl0eVN0YXRlPzogSGFzc0VudGl0eSkgPT5cbiAgZW50aXR5U3RhdGUgJiZcbiAgY29tcHV0ZURvbWFpbihlbnRpdHlTdGF0ZS5lbnRpdHlfaWQpID09PSBcImJpbmFyeV9zZW5zb3JcIiAmJlxuICBcImRldmljZV9jbGFzc1wiIGluIGVudGl0eVN0YXRlLmF0dHJpYnV0ZXMgJiZcbiAgIUJJTkFSWV9TRU5TT1JfREVWSUNFX0NMQVNTX0NPTE9SX05PVF9JTlZFUlRFRC5oYXMoXG4gICAgZW50aXR5U3RhdGUuYXR0cmlidXRlcy5kZXZpY2VfY2xhc3MhXG4gICk7XG5cbmNvbnN0IGdldENvbG9yID0gKFxuICBzdGF0ZVN0cmluZzogc3RyaW5nLFxuICBlbnRpdHlTdGF0ZTogSGFzc0VudGl0eSxcbiAgY29tcHV0ZWRTdHlsZXM6IENTU1N0eWxlRGVjbGFyYXRpb25cbikgPT4ge1xuICAvLyBJbnZlcnNpb24gaXMgb25seSB2YWxpZCBmb3IgXCJvblwiIG9yIFwib2ZmXCIgc3RhdGVcbiAgaWYgKFxuICAgIChzdGF0ZVN0cmluZyA9PT0gXCJvblwiIHx8IHN0YXRlU3RyaW5nID09PSBcIm9mZlwiKSAmJlxuICAgIGludmVydE9uT2ZmKGVudGl0eVN0YXRlKVxuICApIHtcbiAgICBzdGF0ZVN0cmluZyA9IHN0YXRlU3RyaW5nID09PSBcIm9uXCIgPyBcIm9mZlwiIDogXCJvblwiO1xuICB9XG4gIGlmIChzdGF0ZUNvbG9yTWFwLmhhcyhzdGF0ZVN0cmluZykpIHtcbiAgICByZXR1cm4gc3RhdGVDb2xvck1hcC5nZXQoc3RhdGVTdHJpbmcpO1xuICB9XG4gIGlmIChTVEFUSUNfU1RBVEVfQ09MT1JTLmhhcyhzdGF0ZVN0cmluZykpIHtcbiAgICBjb25zdCBjb2xvciA9IGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoXG4gICAgICBgLS1zdGF0ZS0ke3N0YXRlU3RyaW5nfS1jb2xvcmBcbiAgICApO1xuICAgIHN0YXRlQ29sb3JNYXAuc2V0KHN0YXRlU3RyaW5nLCBjb2xvcik7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIGNvbnN0IGNvbG9yID0gZ2V0R3JhcGhDb2xvckJ5SW5kZXgoY29sb3JJbmRleCwgY29tcHV0ZWRTdHlsZXMpO1xuICBjb2xvckluZGV4Kys7XG4gIHN0YXRlQ29sb3JNYXAuc2V0KHN0YXRlU3RyaW5nLCBjb2xvcik7XG4gIHJldHVybiBjb2xvcjtcbn07XG5cbkBjdXN0b21FbGVtZW50KFwic3RhdGUtaGlzdG9yeS1jaGFydC10aW1lbGluZVwiKVxuZXhwb3J0IGNsYXNzIFN0YXRlSGlzdG9yeUNoYXJ0VGltZWxpbmUgZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAgQHByb3BlcnR5KHsgYXR0cmlidXRlOiBmYWxzZSB9KSBwdWJsaWMgaGFzcyE6IEhvbWVBc3Npc3RhbnQ7XG5cbiAgQHByb3BlcnR5KHsgYXR0cmlidXRlOiBmYWxzZSB9KSBwdWJsaWMgZGF0YTogVGltZWxpbmVFbnRpdHlbXSA9IFtdO1xuXG4gIEBwcm9wZXJ0eSgpIHB1YmxpYyBuYW1lczogYm9vbGVhbiB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBmYWxzZTtcblxuICBAcHJvcGVydHkoKSBwdWJsaWMgdW5pdD86IHN0cmluZztcblxuICBAcHJvcGVydHkoKSBwdWJsaWMgaWRlbnRpZmllcj86IHN0cmluZztcblxuICBAcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuIH0pIHB1YmxpYyBpc1NpbmdsZURldmljZSA9IGZhbHNlO1xuXG4gIEBwcm9wZXJ0eSh7IGF0dHJpYnV0ZTogZmFsc2UgfSkgcHVibGljIGVuZFRpbWU/OiBEYXRlO1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX2NoYXJ0RGF0YT86IENoYXJ0RGF0YTxcInRpbWVsaW5lXCI+O1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX2NoYXJ0T3B0aW9ucz86IENoYXJ0T3B0aW9uczxcInRpbWVsaW5lXCI+O1xuXG4gIHByb3RlY3RlZCByZW5kZXIoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8aGEtY2hhcnQtYmFzZVxuICAgICAgICAuZGF0YT0ke3RoaXMuX2NoYXJ0RGF0YX1cbiAgICAgICAgLm9wdGlvbnM9JHt0aGlzLl9jaGFydE9wdGlvbnN9XG4gICAgICAgIC5oZWlnaHQ9JHt0aGlzLmRhdGEubGVuZ3RoICogMzAgKyAzMH1cbiAgICAgICAgY2hhcnQtdHlwZT1cInRpbWVsaW5lXCJcbiAgICAgID48L2hhLWNoYXJ0LWJhc2U+XG4gICAgYDtcbiAgfVxuXG4gIHB1YmxpYyB3aWxsVXBkYXRlKGNoYW5nZWRQcm9wczogUHJvcGVydHlWYWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaGFzVXBkYXRlZCkge1xuICAgICAgdGhpcy5fY2hhcnRPcHRpb25zID0ge1xuICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcbiAgICAgICAgcGFyc2luZzogZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvbjogZmFsc2UsXG4gICAgICAgIHNjYWxlczoge1xuICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgIHR5cGU6IFwidGltZWxpbmVcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLFxuICAgICAgICAgICAgYWRhcHRlcnM6IHtcbiAgICAgICAgICAgICAgZGF0ZToge1xuICAgICAgICAgICAgICAgIGxvY2FsZTogdGhpcy5oYXNzLmxvY2FsZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgICAgICAgICAgbWF4Um90YXRpb246IDAsXG4gICAgICAgICAgICAgIHNhbXBsZVNpemU6IDUsXG4gICAgICAgICAgICAgIGF1dG9Ta2lwUGFkZGluZzogMjAsXG4gICAgICAgICAgICAgIG1ham9yOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZm9udDogKGNvbnRleHQpID0+XG4gICAgICAgICAgICAgICAgY29udGV4dC50aWNrICYmIGNvbnRleHQudGljay5tYWpvclxuICAgICAgICAgICAgICAgICAgPyAoeyB3ZWlnaHQ6IFwiYm9sZFwiIH0gYXMgYW55KVxuICAgICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZToge1xuICAgICAgICAgICAgICB0b29sdGlwRm9ybWF0OiBcImRhdGV0aW1lc2Vjb25kc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgICAgIGJhclRoaWNrbmVzczogMjAsXG4gICAgICAgICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICBkcmF3Qm9yZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgZHJhd1RpY2tzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiB0aGlzLmRhdGEubGVuZ3RoICE9PSAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyU2V0RGltZW5zaW9uczogKHkpID0+IHtcbiAgICAgICAgICAgICAgeS5tYXhXaWR0aCA9IHkuY2hhcnQud2lkdGggKiAwLjE4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBjb21wdXRlUlRMKHRoaXMuaGFzcykgPyBcInJpZ2h0XCIgOiBcImxlZnRcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwbHVnaW5zOiB7XG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgbW9kZTogXCJuZWFyZXN0XCIsXG4gICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgdGl0bGU6IChjb250ZXh0KSA9PlxuICAgICAgICAgICAgICAgIGNvbnRleHQhWzBdLmNoYXJ0IS5kYXRhIS5sYWJlbHMhW1xuICAgICAgICAgICAgICAgICAgY29udGV4dFswXS5kYXRhc2V0SW5kZXhcbiAgICAgICAgICAgICAgICBdIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgYmVmb3JlQm9keTogKGNvbnRleHQpID0+IGNvbnRleHRbMF0uZGF0YXNldC5sYWJlbCB8fCBcIlwiLFxuICAgICAgICAgICAgICBsYWJlbDogKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gaXRlbS5kYXRhc2V0LmRhdGFbaXRlbS5kYXRhSW5kZXhdIGFzIFRpbWVMaW5lRGF0YTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgZC5sYWJlbCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgZm9ybWF0RGF0ZVRpbWVXaXRoU2Vjb25kcyhkLnN0YXJ0LCB0aGlzLmhhc3MubG9jYWxlKSxcbiAgICAgICAgICAgICAgICAgIGZvcm1hdERhdGVUaW1lV2l0aFNlY29uZHMoZC5lbmQsIHRoaXMuaGFzcy5sb2NhbGUpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxhYmVsQ29sb3I6IChpdGVtKSA9PiAoe1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAoaXRlbS5kYXRhc2V0LmRhdGFbaXRlbS5kYXRhSW5kZXhdIGFzIFRpbWVMaW5lRGF0YSlcbiAgICAgICAgICAgICAgICAgIC5jb2xvciEsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAoXG4gICAgICAgICAgICAgICAgICBpdGVtLmRhdGFzZXQuZGF0YVtpdGVtLmRhdGFJbmRleF0gYXMgVGltZUxpbmVEYXRhXG4gICAgICAgICAgICAgICAgKS5jb2xvciEsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGxlcjoge1xuICAgICAgICAgICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbG9jYWxlOiBudW1iZXJGb3JtYXRUb0xvY2FsZSh0aGlzLmhhc3MubG9jYWxlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkUHJvcHMuaGFzKFwiZGF0YVwiKSkge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVEYXRhKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZ2VuZXJhdGVEYXRhKCkge1xuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICBsZXQgc3RhdGVIaXN0b3J5ID0gdGhpcy5kYXRhO1xuXG4gICAgaWYgKCFzdGF0ZUhpc3RvcnkpIHtcbiAgICAgIHN0YXRlSGlzdG9yeSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKFxuICAgICAgc3RhdGVIaXN0b3J5LnJlZHVjZShcbiAgICAgICAgKG1pblRpbWUsIHN0YXRlSW5mbykgPT5cbiAgICAgICAgICBNYXRoLm1pbihtaW5UaW1lLCBuZXcgRGF0ZShzdGF0ZUluZm8uZGF0YVswXS5sYXN0X2NoYW5nZWQpLmdldFRpbWUoKSksXG4gICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIGVuZCB0aW1lIGlzIE1hdGgubWF4KHN0YXJ0VGltZSwgbGFzdF9ldmVudClcbiAgICBsZXQgZW5kVGltZSA9XG4gICAgICB0aGlzLmVuZFRpbWUgfHxcbiAgICAgIG5ldyBEYXRlKFxuICAgICAgICBzdGF0ZUhpc3RvcnkucmVkdWNlKFxuICAgICAgICAgIChtYXhUaW1lLCBzdGF0ZUluZm8pID0+XG4gICAgICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAgICAgbWF4VGltZSxcbiAgICAgICAgICAgICAgbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgc3RhdGVJbmZvLmRhdGFbc3RhdGVJbmZvLmRhdGEubGVuZ3RoIC0gMV0ubGFzdF9jaGFuZ2VkXG4gICAgICAgICAgICAgICkuZ2V0VGltZSgpXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHN0YXJ0VGltZS5nZXRUaW1lKClcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgIGlmIChlbmRUaW1lID4gbmV3IERhdGUoKSkge1xuICAgICAgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRzOiBDaGFydERhdGFzZXQ8XCJ0aW1lbGluZVwiPltdID0gW107XG4gICAgY29uc3QgbmFtZXMgPSB0aGlzLm5hbWVzIHx8IHt9O1xuICAgIC8vIHN0YXRlSGlzdG9yeSBpcyBhIGxpc3Qgb2YgbGlzdHMgb2Ygc29ydGVkIHN0YXRlIG9iamVjdHNcbiAgICBzdGF0ZUhpc3RvcnkuZm9yRWFjaCgoc3RhdGVJbmZvKSA9PiB7XG4gICAgICBsZXQgbmV3TGFzdENoYW5nZWQ6IERhdGU7XG4gICAgICBsZXQgcHJldlN0YXRlOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgIGxldCBsb2NTdGF0ZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICBsZXQgcHJldkxhc3RDaGFuZ2VkID0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgZW50aXR5RGlzcGxheTogc3RyaW5nID1cbiAgICAgICAgbmFtZXNbc3RhdGVJbmZvLmVudGl0eV9pZF0gfHwgc3RhdGVJbmZvLm5hbWU7XG5cbiAgICAgIGNvbnN0IGRhdGFSb3c6IFRpbWVMaW5lRGF0YVtdID0gW107XG4gICAgICBzdGF0ZUluZm8uZGF0YS5mb3JFYWNoKChlbnRpdHlTdGF0ZSkgPT4ge1xuICAgICAgICBsZXQgbmV3U3RhdGU6IHN0cmluZyB8IG51bGwgPSBlbnRpdHlTdGF0ZS5zdGF0ZTtcbiAgICAgICAgY29uc3QgdGltZVN0YW1wID0gbmV3IERhdGUoZW50aXR5U3RhdGUubGFzdF9jaGFuZ2VkKTtcbiAgICAgICAgaWYgKCFuZXdTdGF0ZSkge1xuICAgICAgICAgIG5ld1N0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVN0YW1wID4gZW5kVGltZSkge1xuICAgICAgICAgIC8vIERyb3AgZGF0YXBvaW50cyB0aGF0IGFyZSBhZnRlciB0aGUgcmVxdWVzdGVkIGVuZFRpbWUuIFRoaXMgY291bGQgaGFwcGVuIGlmXG4gICAgICAgICAgLy8gZW5kVGltZSBpcyAnbm93JyBhbmQgY2xpZW50IHRpbWUgaXMgbm90IGluIHN5bmMgd2l0aCBzZXJ2ZXIgdGltZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHByZXZTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgIGxvY1N0YXRlID0gZW50aXR5U3RhdGUuc3RhdGVfbG9jYWxpemU7XG4gICAgICAgICAgcHJldkxhc3RDaGFuZ2VkID0gbmV3IERhdGUoZW50aXR5U3RhdGUubGFzdF9jaGFuZ2VkKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXdTdGF0ZSAhPT0gcHJldlN0YXRlKSB7XG4gICAgICAgICAgbmV3TGFzdENoYW5nZWQgPSBuZXcgRGF0ZShlbnRpdHlTdGF0ZS5sYXN0X2NoYW5nZWQpO1xuXG4gICAgICAgICAgZGF0YVJvdy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBwcmV2TGFzdENoYW5nZWQsXG4gICAgICAgICAgICBlbmQ6IG5ld0xhc3RDaGFuZ2VkLFxuICAgICAgICAgICAgbGFiZWw6IGxvY1N0YXRlLFxuICAgICAgICAgICAgY29sb3I6IGdldENvbG9yKFxuICAgICAgICAgICAgICBwcmV2U3RhdGUsXG4gICAgICAgICAgICAgIHRoaXMuaGFzcy5zdGF0ZXNbc3RhdGVJbmZvLmVudGl0eV9pZF0sXG4gICAgICAgICAgICAgIGNvbXB1dGVkU3R5bGVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcHJldlN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgbG9jU3RhdGUgPSBlbnRpdHlTdGF0ZS5zdGF0ZV9sb2NhbGl6ZTtcbiAgICAgICAgICBwcmV2TGFzdENoYW5nZWQgPSBuZXdMYXN0Q2hhbmdlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YVJvdy5wdXNoKHtcbiAgICAgICAgICBzdGFydDogcHJldkxhc3RDaGFuZ2VkLFxuICAgICAgICAgIGVuZDogZW5kVGltZSxcbiAgICAgICAgICBsYWJlbDogbG9jU3RhdGUsXG4gICAgICAgICAgY29sb3I6IGdldENvbG9yKFxuICAgICAgICAgICAgcHJldlN0YXRlLFxuICAgICAgICAgICAgdGhpcy5oYXNzLnN0YXRlc1tzdGF0ZUluZm8uZW50aXR5X2lkXSxcbiAgICAgICAgICAgIGNvbXB1dGVkU3R5bGVzXG4gICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRhc2V0cy5wdXNoKHtcbiAgICAgICAgZGF0YTogZGF0YVJvdyxcbiAgICAgICAgbGFiZWw6IHN0YXRlSW5mby5lbnRpdHlfaWQsXG4gICAgICB9KTtcbiAgICAgIGxhYmVscy5wdXNoKGVudGl0eURpc3BsYXkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY2hhcnREYXRhID0ge1xuICAgICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgICBkYXRhc2V0czogZGF0YXNldHMsXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCk6IENTU1Jlc3VsdEdyb3VwIHtcbiAgICByZXR1cm4gY3NzYFxuICAgICAgaGEtY2hhcnQtYmFzZSB7XG4gICAgICAgIC0tY2hhcnQtbWF4LWhlaWdodDogbm9uZTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIEhUTUxFbGVtZW50VGFnTmFtZU1hcCB7XG4gICAgXCJzdGF0ZS1oaXN0b3J5LWNoYXJ0LXRpbWVsaW5lXCI6IFN0YXRlSGlzdG9yeUNoYXJ0VGltZWxpbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/chart/state-history-chart-timeline.ts\n");

/***/ }),

/***/ "./src/components/chart/state-history-charts.ts":
/*!******************************************************!*\
  !*** ./src/components/chart/state-history-charts.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators */ \"./node_modules/lit/decorators.js\");\n/* harmony import */ var _common_config_is_component_loaded__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/config/is_component_loaded */ \"./src/common/config/is_component_loaded.ts\");\n/* harmony import */ var _state_history_chart_line__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./state-history-chart-line */ \"./src/components/chart/state-history-chart-line.ts\");\n/* harmony import */ var _state_history_chart_timeline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./state-history-chart-timeline */ \"./src/components/chart/state-history-chart-timeline.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_state_history_chart_timeline__WEBPACK_IMPORTED_MODULE_4__]);\n_state_history_chart_timeline__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function () { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function (O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function (F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function (receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function (elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function (element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function (element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function (elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function (element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function (elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function (elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function (elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function (elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function (obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function (constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function (obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function (other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\nlet StateHistoryCharts = _decorate([(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.customElement)(\"state-history-charts\")], function (_initialize, _LitElement) {\n  class StateHistoryCharts extends _LitElement {\n    constructor(...args) {\n      super(...args);\n\n      _initialize(this);\n    }\n\n  }\n\n  return {\n    F: StateHistoryCharts,\n    d: [{\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"historyData\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        type: Boolean\n      })],\n      key: \"names\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        attribute: false\n      })],\n      key: \"endTime\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        type: Boolean,\n        attribute: \"up-to-now\"\n      })],\n      key: \"upToNow\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        type: Boolean,\n        attribute: \"no-single\"\n      })],\n      key: \"noSingle\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_1__.property)({\n        type: Boolean\n      })],\n      key: \"isLoadingData\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        if (!(0,_common_config_is_component_loaded__WEBPACK_IMPORTED_MODULE_2__.isComponentLoaded)(this.hass, \"history\")) {\n          return lit__WEBPACK_IMPORTED_MODULE_0__.html` <div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.history_disabled\")}\n      </div>`;\n        }\n\n        if (this.isLoadingData && !this.historyData) {\n          return lit__WEBPACK_IMPORTED_MODULE_0__.html` <div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.loading_history\")}\n      </div>`;\n        }\n\n        if (this._isHistoryEmpty()) {\n          return lit__WEBPACK_IMPORTED_MODULE_0__.html` <div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.no_history_found\")}\n      </div>`;\n        }\n\n        const computedEndTime = this.upToNow ? new Date() : this.endTime || new Date();\n        return lit__WEBPACK_IMPORTED_MODULE_0__.html`\n      ${this.historyData.timeline.length ? lit__WEBPACK_IMPORTED_MODULE_0__.html`\n            <state-history-chart-timeline\n              .hass=${this.hass}\n              .data=${this.historyData.timeline}\n              .endTime=${computedEndTime}\n              .noSingle=${this.noSingle}\n              .names=${this.names}\n            ></state-history-chart-timeline>\n          ` : lit__WEBPACK_IMPORTED_MODULE_0__.html``}\n      ${this.historyData.line.map(line => lit__WEBPACK_IMPORTED_MODULE_0__.html`\n          <state-history-chart-line\n            .hass=${this.hass}\n            .unit=${line.unit}\n            .data=${line.data}\n            .identifier=${line.identifier}\n            .isSingleDevice=${!this.noSingle && line.data && line.data.length === 1}\n            .endTime=${computedEndTime}\n            .names=${this.names}\n          ></state-history-chart-line>\n        `)}\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"shouldUpdate\",\n      value: function shouldUpdate(changedProps) {\n        return !(changedProps.size === 1 && changedProps.has(\"hass\"));\n      }\n    }, {\n      kind: \"method\",\n      key: \"_isHistoryEmpty\",\n      value: function _isHistoryEmpty() {\n        const historyDataEmpty = !this.historyData || !this.historyData.timeline || !this.historyData.line || this.historyData.timeline.length === 0 && this.historyData.line.length === 0;\n        return !this.isLoadingData && historyDataEmpty;\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_0__.css`\n      :host {\n        display: block;\n        /* height of single timeline chart = 60px */\n        min-height: 60px;\n      }\n      .info {\n        text-align: center;\n        line-height: 60px;\n        color: var(--secondary-text-color);\n      }\n    `;\n      }\n    }]\n  };\n}, lit__WEBPACK_IMPORTED_MODULE_0__.LitElement);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jaGFydC9zdGF0ZS1oaXN0b3J5LWNoYXJ0cy50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBUUE7QUFDQTtBQUdBO0FBQ0E7O0FBR0E7QUFEQTtBQUNBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7O0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7Ozs7QUFFQTtBQUFBO0FBQUE7Ozs7O0FBRUE7QUFBQTtBQUFBOzs7O0FBQUE7Ozs7O0FBRUE7QUFBQTtBQUFBOzs7OztBQUVBO0FBQUE7QUFBQTtBQUFBOzs7O0FBQUE7Ozs7O0FBRUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFBQTs7Ozs7QUFFQTtBQUFBO0FBQUE7Ozs7QUFBQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBTUE7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUEvRkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL3NyYy9jb21wb25lbnRzL2NoYXJ0L3N0YXRlLWhpc3RvcnktY2hhcnRzLnRzP2NjZDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgY3NzLFxuICBDU1NSZXN1bHRHcm91cCxcbiAgaHRtbCxcbiAgTGl0RWxlbWVudCxcbiAgUHJvcGVydHlWYWx1ZXMsXG4gIFRlbXBsYXRlUmVzdWx0LFxufSBmcm9tIFwibGl0XCI7XG5pbXBvcnQgeyBjdXN0b21FbGVtZW50LCBwcm9wZXJ0eSB9IGZyb20gXCJsaXQvZGVjb3JhdG9yc1wiO1xuaW1wb3J0IHsgaXNDb21wb25lbnRMb2FkZWQgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2NvbmZpZy9pc19jb21wb25lbnRfbG9hZGVkXCI7XG5pbXBvcnQgeyBIaXN0b3J5UmVzdWx0IH0gZnJvbSBcIi4uLy4uL2RhdGEvaGlzdG9yeVwiO1xuaW1wb3J0IHR5cGUgeyBIb21lQXNzaXN0YW50IH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgXCIuL3N0YXRlLWhpc3RvcnktY2hhcnQtbGluZVwiO1xuaW1wb3J0IFwiLi9zdGF0ZS1oaXN0b3J5LWNoYXJ0LXRpbWVsaW5lXCI7XG5cbkBjdXN0b21FbGVtZW50KFwic3RhdGUtaGlzdG9yeS1jaGFydHNcIilcbmNsYXNzIFN0YXRlSGlzdG9yeUNoYXJ0cyBleHRlbmRzIExpdEVsZW1lbnQge1xuICBAcHJvcGVydHkoeyBhdHRyaWJ1dGU6IGZhbHNlIH0pIHB1YmxpYyBoYXNzITogSG9tZUFzc2lzdGFudDtcblxuICBAcHJvcGVydHkoeyBhdHRyaWJ1dGU6IGZhbHNlIH0pIHB1YmxpYyBoaXN0b3J5RGF0YSE6IEhpc3RvcnlSZXN1bHQ7XG5cbiAgQHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KSBwdWJsaWMgbmFtZXMgPSBmYWxzZTtcblxuICBAcHJvcGVydHkoeyBhdHRyaWJ1dGU6IGZhbHNlIH0pIHB1YmxpYyBlbmRUaW1lPzogRGF0ZTtcblxuICBAcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuLCBhdHRyaWJ1dGU6IFwidXAtdG8tbm93XCIgfSkgcHVibGljIHVwVG9Ob3cgPSBmYWxzZTtcblxuICBAcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuLCBhdHRyaWJ1dGU6IFwibm8tc2luZ2xlXCIgfSkgcHVibGljIG5vU2luZ2xlID0gZmFsc2U7XG5cbiAgQHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KSBwdWJsaWMgaXNMb2FkaW5nRGF0YSA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCByZW5kZXIoKTogVGVtcGxhdGVSZXN1bHQge1xuICAgIGlmICghaXNDb21wb25lbnRMb2FkZWQodGhpcy5oYXNzLCBcImhpc3RvcnlcIikpIHtcbiAgICAgIHJldHVybiBodG1sYCA8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuICAgICAgICAke3RoaXMuaGFzcy5sb2NhbGl6ZShcInVpLmNvbXBvbmVudHMuaGlzdG9yeV9jaGFydHMuaGlzdG9yeV9kaXNhYmxlZFwiKX1cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNMb2FkaW5nRGF0YSAmJiAhdGhpcy5oaXN0b3J5RGF0YSkge1xuICAgICAgcmV0dXJuIGh0bWxgIDxkaXYgY2xhc3M9XCJpbmZvXCI+XG4gICAgICAgICR7dGhpcy5oYXNzLmxvY2FsaXplKFwidWkuY29tcG9uZW50cy5oaXN0b3J5X2NoYXJ0cy5sb2FkaW5nX2hpc3RvcnlcIil9XG4gICAgICA8L2Rpdj5gO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0hpc3RvcnlFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gaHRtbGAgPGRpdiBjbGFzcz1cImluZm9cIj5cbiAgICAgICAgJHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jb21wb25lbnRzLmhpc3RvcnlfY2hhcnRzLm5vX2hpc3RvcnlfZm91bmRcIil9XG4gICAgICA8L2Rpdj5gO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXB1dGVkRW5kVGltZSA9IHRoaXMudXBUb05vd1xuICAgICAgPyBuZXcgRGF0ZSgpXG4gICAgICA6IHRoaXMuZW5kVGltZSB8fCBuZXcgRGF0ZSgpO1xuXG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICAke3RoaXMuaGlzdG9yeURhdGEudGltZWxpbmUubGVuZ3RoXG4gICAgICAgID8gaHRtbGBcbiAgICAgICAgICAgIDxzdGF0ZS1oaXN0b3J5LWNoYXJ0LXRpbWVsaW5lXG4gICAgICAgICAgICAgIC5oYXNzPSR7dGhpcy5oYXNzfVxuICAgICAgICAgICAgICAuZGF0YT0ke3RoaXMuaGlzdG9yeURhdGEudGltZWxpbmV9XG4gICAgICAgICAgICAgIC5lbmRUaW1lPSR7Y29tcHV0ZWRFbmRUaW1lfVxuICAgICAgICAgICAgICAubm9TaW5nbGU9JHt0aGlzLm5vU2luZ2xlfVxuICAgICAgICAgICAgICAubmFtZXM9JHt0aGlzLm5hbWVzfVxuICAgICAgICAgICAgPjwvc3RhdGUtaGlzdG9yeS1jaGFydC10aW1lbGluZT5cbiAgICAgICAgICBgXG4gICAgICAgIDogaHRtbGBgfVxuICAgICAgJHt0aGlzLmhpc3RvcnlEYXRhLmxpbmUubWFwKFxuICAgICAgICAobGluZSkgPT4gaHRtbGBcbiAgICAgICAgICA8c3RhdGUtaGlzdG9yeS1jaGFydC1saW5lXG4gICAgICAgICAgICAuaGFzcz0ke3RoaXMuaGFzc31cbiAgICAgICAgICAgIC51bml0PSR7bGluZS51bml0fVxuICAgICAgICAgICAgLmRhdGE9JHtsaW5lLmRhdGF9XG4gICAgICAgICAgICAuaWRlbnRpZmllcj0ke2xpbmUuaWRlbnRpZmllcn1cbiAgICAgICAgICAgIC5pc1NpbmdsZURldmljZT0keyF0aGlzLm5vU2luZ2xlICYmXG4gICAgICAgICAgICBsaW5lLmRhdGEgJiZcbiAgICAgICAgICAgIGxpbmUuZGF0YS5sZW5ndGggPT09IDF9XG4gICAgICAgICAgICAuZW5kVGltZT0ke2NvbXB1dGVkRW5kVGltZX1cbiAgICAgICAgICAgIC5uYW1lcz0ke3RoaXMubmFtZXN9XG4gICAgICAgICAgPjwvc3RhdGUtaGlzdG9yeS1jaGFydC1saW5lPlxuICAgICAgICBgXG4gICAgICApfVxuICAgIGA7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2hvdWxkVXBkYXRlKGNoYW5nZWRQcm9wczogUHJvcGVydHlWYWx1ZXMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIShjaGFuZ2VkUHJvcHMuc2l6ZSA9PT0gMSAmJiBjaGFuZ2VkUHJvcHMuaGFzKFwiaGFzc1wiKSk7XG4gIH1cblxuICBwcml2YXRlIF9pc0hpc3RvcnlFbXB0eSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBoaXN0b3J5RGF0YUVtcHR5ID1cbiAgICAgICF0aGlzLmhpc3RvcnlEYXRhIHx8XG4gICAgICAhdGhpcy5oaXN0b3J5RGF0YS50aW1lbGluZSB8fFxuICAgICAgIXRoaXMuaGlzdG9yeURhdGEubGluZSB8fFxuICAgICAgKHRoaXMuaGlzdG9yeURhdGEudGltZWxpbmUubGVuZ3RoID09PSAwICYmXG4gICAgICAgIHRoaXMuaGlzdG9yeURhdGEubGluZS5sZW5ndGggPT09IDApO1xuICAgIHJldHVybiAhdGhpcy5pc0xvYWRpbmdEYXRhICYmIGhpc3RvcnlEYXRhRW1wdHk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0eWxlcygpOiBDU1NSZXN1bHRHcm91cCB7XG4gICAgcmV0dXJuIGNzc2BcbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIC8qIGhlaWdodCBvZiBzaW5nbGUgdGltZWxpbmUgY2hhcnQgPSA2MHB4ICovXG4gICAgICAgIG1pbi1oZWlnaHQ6IDYwcHg7XG4gICAgICB9XG4gICAgICAuaW5mbyB7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDYwcHg7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1zZWNvbmRhcnktdGV4dC1jb2xvcik7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBIVE1MRWxlbWVudFRhZ05hbWVNYXAge1xuICAgIFwic3RhdGUtaGlzdG9yeS1jaGFydHNcIjogU3RhdGVIaXN0b3J5Q2hhcnRzO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/chart/state-history-charts.ts\n");

/***/ }),

/***/ "./src/data/history.ts":
/*!*****************************!*\
  !*** ./src/data/history.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"entityIdHistoryNeedsAttributes\": () => (/* binding */ entityIdHistoryNeedsAttributes),\n/* harmony export */   \"fetchRecent\": () => (/* binding */ fetchRecent),\n/* harmony export */   \"fetchDate\": () => (/* binding */ fetchDate),\n/* harmony export */   \"computeHistory\": () => (/* binding */ computeHistory),\n/* harmony export */   \"getStatisticIds\": () => (/* binding */ getStatisticIds),\n/* harmony export */   \"getStatisticMetadata\": () => (/* binding */ getStatisticMetadata),\n/* harmony export */   \"fetchStatistics\": () => (/* binding */ fetchStatistics),\n/* harmony export */   \"validateStatistics\": () => (/* binding */ validateStatistics),\n/* harmony export */   \"updateStatisticsMetadata\": () => (/* binding */ updateStatisticsMetadata),\n/* harmony export */   \"clearStatistics\": () => (/* binding */ clearStatistics),\n/* harmony export */   \"calculateStatisticSumGrowth\": () => (/* binding */ calculateStatisticSumGrowth),\n/* harmony export */   \"calculateStatisticsSumGrowth\": () => (/* binding */ calculateStatisticsSumGrowth),\n/* harmony export */   \"statisticsHaveType\": () => (/* binding */ statisticsHaveType),\n/* harmony export */   \"adjustStatisticsSum\": () => (/* binding */ adjustStatisticsSum)\n/* harmony export */ });\n/* harmony import */ var _common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/entity/compute_domain */ \"./src/common/entity/compute_domain.ts\");\n/* harmony import */ var _common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/entity/compute_state_display */ \"./src/common/entity/compute_state_display.ts\");\n/* harmony import */ var _common_entity_compute_state_domain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/entity/compute_state_domain */ \"./src/common/entity/compute_state_domain.ts\");\n/* harmony import */ var _common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/entity/compute_state_name */ \"./src/common/entity/compute_state_name.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__]);\n_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\n\n\n\n\nconst DOMAINS_USE_LAST_UPDATED = [\"climate\", \"humidifier\", \"water_heater\"];\nconst NEED_ATTRIBUTE_DOMAINS = [\"climate\", \"humidifier\", \"input_datetime\", \"thermostat\", \"water_heater\"];\nconst LINE_ATTRIBUTES_TO_KEEP = [\"temperature\", \"current_temperature\", \"target_temp_low\", \"target_temp_high\", \"hvac_action\", \"humidity\", \"mode\"];\nconst entityIdHistoryNeedsAttributes = (hass, entityId) => !hass.states[entityId] || NEED_ATTRIBUTE_DOMAINS.includes((0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId));\nconst fetchRecent = (hass, entityId, startTime, endTime, skipInitialState = false, significantChangesOnly, minimalResponse = true, noAttributes) => {\n  let url = \"history/period\";\n\n  if (startTime) {\n    url += \"/\" + startTime.toISOString();\n  }\n\n  url += \"?filter_entity_id=\" + entityId;\n\n  if (endTime) {\n    url += \"&end_time=\" + endTime.toISOString();\n  }\n\n  if (skipInitialState) {\n    url += \"&skip_initial_state\";\n  }\n\n  if (significantChangesOnly !== undefined) {\n    url += `&significant_changes_only=${Number(significantChangesOnly)}`;\n  }\n\n  if (minimalResponse) {\n    url += \"&minimal_response\";\n  }\n\n  if (noAttributes) {\n    url += \"&no_attributes\";\n  }\n\n  return hass.callApi(\"GET\", url);\n};\nconst fetchDate = (hass, startTime, endTime, entityId) => hass.callApi(\"GET\", `history/period/${startTime.toISOString()}?end_time=${endTime.toISOString()}&minimal_response${entityId ? `&filter_entity_id=${entityId}` : ``}${entityId && !entityIdHistoryNeedsAttributes(hass, entityId) ? `&no_attributes` : ``}`);\n\nconst equalState = (obj1, obj2) => obj1.state === obj2.state && (!obj1.attributes || !obj2.attributes || LINE_ATTRIBUTES_TO_KEEP.every(attr => obj1.attributes[attr] === obj2.attributes[attr]));\n\nconst processTimelineEntity = (localize, language, states) => {\n  const data = [];\n  const last_element = states.length - 1;\n\n  for (const state of states) {\n    if (data.length > 0 && state.state === data[data.length - 1].state) {\n      continue;\n    } // Copy the data from the last element as its the newest\n    // and is only needed to localize the data\n\n\n    if (!state.entity_id) {\n      state.attributes = states[last_element].attributes;\n      state.entity_id = states[last_element].entity_id;\n    }\n\n    data.push({\n      state_localize: (0,_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__.computeStateDisplay)(localize, state, language),\n      state: state.state,\n      last_changed: state.last_changed\n    });\n  }\n\n  return {\n    name: (0,_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_3__.computeStateName)(states[0]),\n    entity_id: states[0].entity_id,\n    data\n  };\n};\n\nconst processLineChartEntities = (unit, entities) => {\n  const data = [];\n\n  for (const states of entities) {\n    const last = states[states.length - 1];\n    const domain = (0,_common_entity_compute_state_domain__WEBPACK_IMPORTED_MODULE_2__.computeStateDomain)(last);\n    const processedStates = [];\n\n    for (const state of states) {\n      let processedState;\n\n      if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n        processedState = {\n          state: state.state,\n          last_changed: state.last_updated,\n          attributes: {}\n        };\n\n        for (const attr of LINE_ATTRIBUTES_TO_KEEP) {\n          if (attr in state.attributes) {\n            processedState.attributes[attr] = state.attributes[attr];\n          }\n        }\n      } else {\n        processedState = state;\n      }\n\n      if (processedStates.length > 1 && equalState(processedState, processedStates[processedStates.length - 1]) && equalState(processedState, processedStates[processedStates.length - 2])) {\n        continue;\n      }\n\n      processedStates.push(processedState);\n    }\n\n    data.push({\n      domain,\n      name: (0,_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_3__.computeStateName)(last),\n      entity_id: last.entity_id,\n      states: processedStates\n    });\n  }\n\n  return {\n    unit,\n    identifier: entities.map(states => states[0].entity_id).join(\"\"),\n    data\n  };\n};\n\nconst stateUsesUnits = state => \"unit_of_measurement\" in state.attributes || \"state_class\" in state.attributes;\n\nconst computeHistory = (hass, stateHistory, localize) => {\n  const lineChartDevices = {};\n  const timelineDevices = [];\n\n  if (!stateHistory) {\n    return {\n      line: [],\n      timeline: []\n    };\n  }\n\n  stateHistory.forEach(stateInfo => {\n    if (stateInfo.length === 0) {\n      return;\n    }\n\n    const entityId = stateInfo[0].entity_id;\n    const currentState = entityId in hass.states ? hass.states[entityId] : undefined;\n    const stateWithUnitorStateClass = !currentState && stateInfo.find(state => state.attributes && stateUsesUnits(state));\n    let unit;\n\n    if (currentState && stateUsesUnits(currentState)) {\n      unit = currentState.attributes.unit_of_measurement || \" \";\n    } else if (stateWithUnitorStateClass) {\n      unit = stateWithUnitorStateClass.attributes.unit_of_measurement || \" \";\n    } else {\n      unit = {\n        climate: hass.config.unit_system.temperature,\n        counter: \"#\",\n        humidifier: \"%\",\n        input_number: \"#\",\n        number: \"#\",\n        water_heater: hass.config.unit_system.temperature\n      }[(0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId)];\n    }\n\n    if (!unit) {\n      timelineDevices.push(processTimelineEntity(localize, hass.locale, stateInfo));\n    } else if (unit in lineChartDevices) {\n      lineChartDevices[unit].push(stateInfo);\n    } else {\n      lineChartDevices[unit] = [stateInfo];\n    }\n  });\n  const unitStates = Object.keys(lineChartDevices).map(unit => processLineChartEntities(unit, lineChartDevices[unit]));\n  return {\n    line: unitStates,\n    timeline: timelineDevices\n  };\n}; // Statistics\n\nconst getStatisticIds = (hass, statistic_type) => hass.callWS({\n  type: \"history/list_statistic_ids\",\n  statistic_type\n});\nconst getStatisticMetadata = (hass, statistic_ids) => hass.callWS({\n  type: \"recorder/get_statistics_metadata\",\n  statistic_ids\n});\nconst fetchStatistics = (hass, startTime, endTime, statistic_ids, period = \"hour\") => hass.callWS({\n  type: \"history/statistics_during_period\",\n  start_time: startTime.toISOString(),\n  end_time: endTime === null || endTime === void 0 ? void 0 : endTime.toISOString(),\n  statistic_ids,\n  period\n});\nconst validateStatistics = hass => hass.callWS({\n  type: \"recorder/validate_statistics\"\n});\nconst updateStatisticsMetadata = (hass, statistic_id, unit_of_measurement) => hass.callWS({\n  type: \"recorder/update_statistics_metadata\",\n  statistic_id,\n  unit_of_measurement\n});\nconst clearStatistics = (hass, statistic_ids) => hass.callWS({\n  type: \"recorder/clear_statistics\",\n  statistic_ids\n});\nconst calculateStatisticSumGrowth = values => {\n  if (!values || values.length < 2) {\n    return null;\n  }\n\n  const endSum = values[values.length - 1].sum;\n\n  if (endSum === null) {\n    return null;\n  }\n\n  const startSum = values[0].sum;\n\n  if (startSum === null) {\n    return endSum;\n  }\n\n  return endSum - startSum;\n};\nconst calculateStatisticsSumGrowth = (data, stats) => {\n  let totalGrowth = null;\n\n  for (const stat of stats) {\n    if (!(stat in data)) {\n      continue;\n    }\n\n    const statGrowth = calculateStatisticSumGrowth(data[stat]);\n\n    if (statGrowth === null) {\n      continue;\n    }\n\n    if (totalGrowth === null) {\n      totalGrowth = statGrowth;\n    } else {\n      totalGrowth += statGrowth;\n    }\n  }\n\n  return totalGrowth;\n};\nconst statisticsHaveType = (stats, type) => stats.some(stat => stat[type] !== null);\nconst adjustStatisticsSum = (hass, statistic_id, start_time, adjustment) => hass.callWS({\n  type: \"recorder/adjust_sum_statistics\",\n  statistic_id,\n  start_time,\n  adjustment\n});\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGF0YS9oaXN0b3J5LnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQU9BO0FBOEhBO0FBT0E7QUFVQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7O0FBaUJBOztBQVdBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUVBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQVFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBRUE7O0FBSUE7QUFLQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBSUE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUtBO0FBQ0E7QUFGQTtBQUtBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFFQTtBQURBO0FBSUE7QUFNQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vc3JjL2RhdGEvaGlzdG9yeS50cz80YTUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc3NFbnRpdHkgfSBmcm9tIFwiaG9tZS1hc3Npc3RhbnQtanMtd2Vic29ja2V0XCI7XG5pbXBvcnQgeyBjb21wdXRlRG9tYWluIH0gZnJvbSBcIi4uL2NvbW1vbi9lbnRpdHkvY29tcHV0ZV9kb21haW5cIjtcbmltcG9ydCB7IGNvbXB1dGVTdGF0ZURpc3BsYXkgfSBmcm9tIFwiLi4vY29tbW9uL2VudGl0eS9jb21wdXRlX3N0YXRlX2Rpc3BsYXlcIjtcbmltcG9ydCB7IGNvbXB1dGVTdGF0ZURvbWFpbiB9IGZyb20gXCIuLi9jb21tb24vZW50aXR5L2NvbXB1dGVfc3RhdGVfZG9tYWluXCI7XG5pbXBvcnQgeyBjb21wdXRlU3RhdGVOYW1lIH0gZnJvbSBcIi4uL2NvbW1vbi9lbnRpdHkvY29tcHV0ZV9zdGF0ZV9uYW1lXCI7XG5pbXBvcnQgeyBMb2NhbGl6ZUZ1bmMgfSBmcm9tIFwiLi4vY29tbW9uL3RyYW5zbGF0aW9ucy9sb2NhbGl6ZVwiO1xuaW1wb3J0IHsgSG9tZUFzc2lzdGFudCB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgRnJvbnRlbmRMb2NhbGVEYXRhIH0gZnJvbSBcIi4vdHJhbnNsYXRpb25cIjtcblxuY29uc3QgRE9NQUlOU19VU0VfTEFTVF9VUERBVEVEID0gW1wiY2xpbWF0ZVwiLCBcImh1bWlkaWZpZXJcIiwgXCJ3YXRlcl9oZWF0ZXJcIl07XG5jb25zdCBORUVEX0FUVFJJQlVURV9ET01BSU5TID0gW1xuICBcImNsaW1hdGVcIixcbiAgXCJodW1pZGlmaWVyXCIsXG4gIFwiaW5wdXRfZGF0ZXRpbWVcIixcbiAgXCJ0aGVybW9zdGF0XCIsXG4gIFwid2F0ZXJfaGVhdGVyXCIsXG5dO1xuY29uc3QgTElORV9BVFRSSUJVVEVTX1RPX0tFRVAgPSBbXG4gIFwidGVtcGVyYXR1cmVcIixcbiAgXCJjdXJyZW50X3RlbXBlcmF0dXJlXCIsXG4gIFwidGFyZ2V0X3RlbXBfbG93XCIsXG4gIFwidGFyZ2V0X3RlbXBfaGlnaFwiLFxuICBcImh2YWNfYWN0aW9uXCIsXG4gIFwiaHVtaWRpdHlcIixcbiAgXCJtb2RlXCIsXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmVDaGFydFN0YXRlIHtcbiAgc3RhdGU6IHN0cmluZztcbiAgbGFzdF9jaGFuZ2VkOiBzdHJpbmc7XG4gIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmVDaGFydEVudGl0eSB7XG4gIGRvbWFpbjogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVudGl0eV9pZDogc3RyaW5nO1xuICBzdGF0ZXM6IExpbmVDaGFydFN0YXRlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZUNoYXJ0VW5pdCB7XG4gIHVuaXQ6IHN0cmluZztcbiAgaWRlbnRpZmllcjogc3RyaW5nO1xuICBkYXRhOiBMaW5lQ2hhcnRFbnRpdHlbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lbGluZVN0YXRlIHtcbiAgc3RhdGVfbG9jYWxpemU6IHN0cmluZztcbiAgc3RhdGU6IHN0cmluZztcbiAgbGFzdF9jaGFuZ2VkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZWxpbmVFbnRpdHkge1xuICBuYW1lOiBzdHJpbmc7XG4gIGVudGl0eV9pZDogc3RyaW5nO1xuICBkYXRhOiBUaW1lbGluZVN0YXRlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVJlc3VsdCB7XG4gIGxpbmU6IExpbmVDaGFydFVuaXRbXTtcbiAgdGltZWxpbmU6IFRpbWVsaW5lRW50aXR5W107XG59XG5cbmV4cG9ydCB0eXBlIFN0YXRpc3RpY1R5cGUgPSBcInN1bVwiIHwgXCJtaW5cIiB8IFwibWF4XCIgfCBcIm1lYW5cIjtcblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aXN0aWNzIHtcbiAgW3N0YXRpc3RpY0lkOiBzdHJpbmddOiBTdGF0aXN0aWNWYWx1ZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY1ZhbHVlIHtcbiAgc3RhdGlzdGljX2lkOiBzdHJpbmc7XG4gIHN0YXJ0OiBzdHJpbmc7XG4gIGVuZDogc3RyaW5nO1xuICBsYXN0X3Jlc2V0OiBzdHJpbmcgfCBudWxsO1xuICBtYXg6IG51bWJlciB8IG51bGw7XG4gIG1lYW46IG51bWJlciB8IG51bGw7XG4gIG1pbjogbnVtYmVyIHwgbnVsbDtcbiAgc3VtOiBudW1iZXIgfCBudWxsO1xuICBzdGF0ZTogbnVtYmVyIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aXN0aWNzTWV0YURhdGEge1xuICB1bml0X29mX21lYXN1cmVtZW50OiBzdHJpbmc7XG4gIHN0YXRpc3RpY19pZDogc3RyaW5nO1xuICBzb3VyY2U6IHN0cmluZztcbiAgbmFtZT86IHN0cmluZyB8IG51bGw7XG4gIGhhc19zdW06IGJvb2xlYW47XG4gIGhhc19tZWFuOiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdCA9XG4gIHwgU3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHROb1N0YXRlXG4gIHwgU3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRFbnRpdHlOb3RSZWNvcmRlZFxuICB8IFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0RW50aXR5Tm9Mb25nZXJSZWNvcmRlZFxuICB8IFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0VW5zdXBwb3J0ZWRTdGF0ZUNsYXNzXG4gIHwgU3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRVbml0c0NoYW5nZWRcbiAgfCBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdFVuc3VwcG9ydGVkVW5pdE1ldGFkYXRhXG4gIHwgU3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRVbnN1cHBvcnRlZFVuaXRTdGF0ZTtcblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdE5vU3RhdGUge1xuICB0eXBlOiBcIm5vX3N0YXRlXCI7XG4gIGRhdGE6IHsgc3RhdGlzdGljX2lkOiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdEVudGl0eU5vTG9uZ2VyUmVjb3JkZWQge1xuICB0eXBlOiBcImVudGl0eV9ub19sb25nZXJfcmVjb3JkZWRcIjtcbiAgZGF0YTogeyBzdGF0aXN0aWNfaWQ6IHN0cmluZyB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0RW50aXR5Tm90UmVjb3JkZWQge1xuICB0eXBlOiBcImVudGl0eV9ub3RfcmVjb3JkZWRcIjtcbiAgZGF0YTogeyBzdGF0aXN0aWNfaWQ6IHN0cmluZyB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0VW5zdXBwb3J0ZWRTdGF0ZUNsYXNzIHtcbiAgdHlwZTogXCJ1bnN1cHBvcnRlZF9zdGF0ZV9jbGFzc1wiO1xuICBkYXRhOiB7IHN0YXRpc3RpY19pZDogc3RyaW5nOyBzdGF0ZV9jbGFzczogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRVbml0c0NoYW5nZWQge1xuICB0eXBlOiBcInVuaXRzX2NoYW5nZWRcIjtcbiAgZGF0YTogeyBzdGF0aXN0aWNfaWQ6IHN0cmluZzsgc3RhdGVfdW5pdDogc3RyaW5nOyBtZXRhZGF0YV91bml0OiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdFVuc3VwcG9ydGVkVW5pdE1ldGFkYXRhIHtcbiAgdHlwZTogXCJ1bnN1cHBvcnRlZF91bml0X21ldGFkYXRhXCI7XG4gIGRhdGE6IHtcbiAgICBzdGF0aXN0aWNfaWQ6IHN0cmluZztcbiAgICBkZXZpY2VfY2xhc3M6IHN0cmluZztcbiAgICBtZXRhZGF0YV91bml0OiBzdHJpbmc7XG4gICAgc3VwcG9ydGVkX3VuaXQ6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdFVuc3VwcG9ydGVkVW5pdFN0YXRlIHtcbiAgdHlwZTogXCJ1bnN1cHBvcnRlZF91bml0X3N0YXRlXCI7XG4gIGRhdGE6IHsgc3RhdGlzdGljX2lkOiBzdHJpbmc7IGRldmljZV9jbGFzczogc3RyaW5nOyBtZXRhZGF0YV91bml0OiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aXN0aWNzVmFsaWRhdGlvblJlc3VsdHMge1xuICBbc3RhdGlzdGljSWQ6IHN0cmluZ106IFN0YXRpc3RpY3NWYWxpZGF0aW9uUmVzdWx0W107XG59XG5cbmV4cG9ydCBjb25zdCBlbnRpdHlJZEhpc3RvcnlOZWVkc0F0dHJpYnV0ZXMgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIGVudGl0eUlkOiBzdHJpbmdcbikgPT5cbiAgIWhhc3Muc3RhdGVzW2VudGl0eUlkXSB8fFxuICBORUVEX0FUVFJJQlVURV9ET01BSU5TLmluY2x1ZGVzKGNvbXB1dGVEb21haW4oZW50aXR5SWQpKTtcblxuZXhwb3J0IGNvbnN0IGZldGNoUmVjZW50ID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBlbnRpdHlJZDogc3RyaW5nLFxuICBzdGFydFRpbWU6IERhdGUsXG4gIGVuZFRpbWU6IERhdGUsXG4gIHNraXBJbml0aWFsU3RhdGUgPSBmYWxzZSxcbiAgc2lnbmlmaWNhbnRDaGFuZ2VzT25seT86IGJvb2xlYW4sXG4gIG1pbmltYWxSZXNwb25zZSA9IHRydWUsXG4gIG5vQXR0cmlidXRlcz86IGJvb2xlYW5cbik6IFByb21pc2U8SGFzc0VudGl0eVtdW10+ID0+IHtcbiAgbGV0IHVybCA9IFwiaGlzdG9yeS9wZXJpb2RcIjtcbiAgaWYgKHN0YXJ0VGltZSkge1xuICAgIHVybCArPSBcIi9cIiArIHN0YXJ0VGltZS50b0lTT1N0cmluZygpO1xuICB9XG4gIHVybCArPSBcIj9maWx0ZXJfZW50aXR5X2lkPVwiICsgZW50aXR5SWQ7XG4gIGlmIChlbmRUaW1lKSB7XG4gICAgdXJsICs9IFwiJmVuZF90aW1lPVwiICsgZW5kVGltZS50b0lTT1N0cmluZygpO1xuICB9XG4gIGlmIChza2lwSW5pdGlhbFN0YXRlKSB7XG4gICAgdXJsICs9IFwiJnNraXBfaW5pdGlhbF9zdGF0ZVwiO1xuICB9XG4gIGlmIChzaWduaWZpY2FudENoYW5nZXNPbmx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmwgKz0gYCZzaWduaWZpY2FudF9jaGFuZ2VzX29ubHk9JHtOdW1iZXIoc2lnbmlmaWNhbnRDaGFuZ2VzT25seSl9YDtcbiAgfVxuICBpZiAobWluaW1hbFJlc3BvbnNlKSB7XG4gICAgdXJsICs9IFwiJm1pbmltYWxfcmVzcG9uc2VcIjtcbiAgfVxuICBpZiAobm9BdHRyaWJ1dGVzKSB7XG4gICAgdXJsICs9IFwiJm5vX2F0dHJpYnV0ZXNcIjtcbiAgfVxuICByZXR1cm4gaGFzcy5jYWxsQXBpKFwiR0VUXCIsIHVybCk7XG59O1xuXG5leHBvcnQgY29uc3QgZmV0Y2hEYXRlID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBzdGFydFRpbWU6IERhdGUsXG4gIGVuZFRpbWU6IERhdGUsXG4gIGVudGl0eUlkPzogc3RyaW5nXG4pOiBQcm9taXNlPEhhc3NFbnRpdHlbXVtdPiA9PlxuICBoYXNzLmNhbGxBcGkoXG4gICAgXCJHRVRcIixcbiAgICBgaGlzdG9yeS9wZXJpb2QvJHtzdGFydFRpbWUudG9JU09TdHJpbmcoKX0/ZW5kX3RpbWU9JHtlbmRUaW1lLnRvSVNPU3RyaW5nKCl9Jm1pbmltYWxfcmVzcG9uc2Uke1xuICAgICAgZW50aXR5SWQgPyBgJmZpbHRlcl9lbnRpdHlfaWQ9JHtlbnRpdHlJZH1gIDogYGBcbiAgICB9JHtcbiAgICAgIGVudGl0eUlkICYmICFlbnRpdHlJZEhpc3RvcnlOZWVkc0F0dHJpYnV0ZXMoaGFzcywgZW50aXR5SWQpXG4gICAgICAgID8gYCZub19hdHRyaWJ1dGVzYFxuICAgICAgICA6IGBgXG4gICAgfWBcbiAgKTtcblxuY29uc3QgZXF1YWxTdGF0ZSA9IChvYmoxOiBMaW5lQ2hhcnRTdGF0ZSwgb2JqMjogTGluZUNoYXJ0U3RhdGUpID0+XG4gIG9iajEuc3RhdGUgPT09IG9iajIuc3RhdGUgJiZcbiAgLy8gT25seSBjb21wYXJlIGF0dHJpYnV0ZXMgaWYgYm90aCBzdGF0ZXMgaGF2ZSBhbiBhdHRyaWJ1dGVzIG9iamVjdC5cbiAgLy8gV2hlbiBgbWluaW1hbF9yZXNwb25zZWAgaXMgc2VudCwgb25seSB0aGUgZmlyc3QgYW5kIGxhc3Qgc3RhdGVcbiAgLy8gd2lsbCBoYXZlIGF0dHJpYnV0ZXMgZXhjZXB0IGZvciBkb21haW5zIGluIERPTUFJTlNfVVNFX0xBU1RfVVBEQVRFRC5cbiAgKCFvYmoxLmF0dHJpYnV0ZXMgfHxcbiAgICAhb2JqMi5hdHRyaWJ1dGVzIHx8XG4gICAgTElORV9BVFRSSUJVVEVTX1RPX0tFRVAuZXZlcnkoXG4gICAgICAoYXR0cikgPT4gb2JqMS5hdHRyaWJ1dGVzIVthdHRyXSA9PT0gb2JqMi5hdHRyaWJ1dGVzIVthdHRyXVxuICAgICkpO1xuXG5jb25zdCBwcm9jZXNzVGltZWxpbmVFbnRpdHkgPSAoXG4gIGxvY2FsaXplOiBMb2NhbGl6ZUZ1bmMsXG4gIGxhbmd1YWdlOiBGcm9udGVuZExvY2FsZURhdGEsXG4gIHN0YXRlczogSGFzc0VudGl0eVtdXG4pOiBUaW1lbGluZUVudGl0eSA9PiB7XG4gIGNvbnN0IGRhdGE6IFRpbWVsaW5lU3RhdGVbXSA9IFtdO1xuICBjb25zdCBsYXN0X2VsZW1lbnQgPSBzdGF0ZXMubGVuZ3RoIC0gMTtcblxuICBmb3IgKGNvbnN0IHN0YXRlIG9mIHN0YXRlcykge1xuICAgIGlmIChkYXRhLmxlbmd0aCA+IDAgJiYgc3RhdGUuc3RhdGUgPT09IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zdGF0ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQ29weSB0aGUgZGF0YSBmcm9tIHRoZSBsYXN0IGVsZW1lbnQgYXMgaXRzIHRoZSBuZXdlc3RcbiAgICAvLyBhbmQgaXMgb25seSBuZWVkZWQgdG8gbG9jYWxpemUgdGhlIGRhdGFcbiAgICBpZiAoIXN0YXRlLmVudGl0eV9pZCkge1xuICAgICAgc3RhdGUuYXR0cmlidXRlcyA9IHN0YXRlc1tsYXN0X2VsZW1lbnRdLmF0dHJpYnV0ZXM7XG4gICAgICBzdGF0ZS5lbnRpdHlfaWQgPSBzdGF0ZXNbbGFzdF9lbGVtZW50XS5lbnRpdHlfaWQ7XG4gICAgfVxuXG4gICAgZGF0YS5wdXNoKHtcbiAgICAgIHN0YXRlX2xvY2FsaXplOiBjb21wdXRlU3RhdGVEaXNwbGF5KGxvY2FsaXplLCBzdGF0ZSwgbGFuZ3VhZ2UpLFxuICAgICAgc3RhdGU6IHN0YXRlLnN0YXRlLFxuICAgICAgbGFzdF9jaGFuZ2VkOiBzdGF0ZS5sYXN0X2NoYW5nZWQsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGNvbXB1dGVTdGF0ZU5hbWUoc3RhdGVzWzBdKSxcbiAgICBlbnRpdHlfaWQ6IHN0YXRlc1swXS5lbnRpdHlfaWQsXG4gICAgZGF0YSxcbiAgfTtcbn07XG5cbmNvbnN0IHByb2Nlc3NMaW5lQ2hhcnRFbnRpdGllcyA9IChcbiAgdW5pdCxcbiAgZW50aXRpZXM6IEhhc3NFbnRpdHlbXVtdXG4pOiBMaW5lQ2hhcnRVbml0ID0+IHtcbiAgY29uc3QgZGF0YTogTGluZUNoYXJ0RW50aXR5W10gPSBbXTtcblxuICBmb3IgKGNvbnN0IHN0YXRlcyBvZiBlbnRpdGllcykge1xuICAgIGNvbnN0IGxhc3Q6IEhhc3NFbnRpdHkgPSBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGRvbWFpbiA9IGNvbXB1dGVTdGF0ZURvbWFpbihsYXN0KTtcbiAgICBjb25zdCBwcm9jZXNzZWRTdGF0ZXM6IExpbmVDaGFydFN0YXRlW10gPSBbXTtcblxuICAgIGZvciAoY29uc3Qgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICBsZXQgcHJvY2Vzc2VkU3RhdGU6IExpbmVDaGFydFN0YXRlO1xuXG4gICAgICBpZiAoRE9NQUlOU19VU0VfTEFTVF9VUERBVEVELmluY2x1ZGVzKGRvbWFpbikpIHtcbiAgICAgICAgcHJvY2Vzc2VkU3RhdGUgPSB7XG4gICAgICAgICAgc3RhdGU6IHN0YXRlLnN0YXRlLFxuICAgICAgICAgIGxhc3RfY2hhbmdlZDogc3RhdGUubGFzdF91cGRhdGVkLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBMSU5FX0FUVFJJQlVURVNfVE9fS0VFUCkge1xuICAgICAgICAgIGlmIChhdHRyIGluIHN0YXRlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHByb2Nlc3NlZFN0YXRlLmF0dHJpYnV0ZXMhW2F0dHJdID0gc3RhdGUuYXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NlZFN0YXRlID0gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzc2VkU3RhdGVzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgZXF1YWxTdGF0ZShcbiAgICAgICAgICBwcm9jZXNzZWRTdGF0ZSxcbiAgICAgICAgICBwcm9jZXNzZWRTdGF0ZXNbcHJvY2Vzc2VkU3RhdGVzLmxlbmd0aCAtIDFdXG4gICAgICAgICkgJiZcbiAgICAgICAgZXF1YWxTdGF0ZShwcm9jZXNzZWRTdGF0ZSwgcHJvY2Vzc2VkU3RhdGVzW3Byb2Nlc3NlZFN0YXRlcy5sZW5ndGggLSAyXSlcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzc2VkU3RhdGVzLnB1c2gocHJvY2Vzc2VkU3RhdGUpO1xuICAgIH1cblxuICAgIGRhdGEucHVzaCh7XG4gICAgICBkb21haW4sXG4gICAgICBuYW1lOiBjb21wdXRlU3RhdGVOYW1lKGxhc3QpLFxuICAgICAgZW50aXR5X2lkOiBsYXN0LmVudGl0eV9pZCxcbiAgICAgIHN0YXRlczogcHJvY2Vzc2VkU3RhdGVzLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1bml0LFxuICAgIGlkZW50aWZpZXI6IGVudGl0aWVzLm1hcCgoc3RhdGVzKSA9PiBzdGF0ZXNbMF0uZW50aXR5X2lkKS5qb2luKFwiXCIpLFxuICAgIGRhdGEsXG4gIH07XG59O1xuXG5jb25zdCBzdGF0ZVVzZXNVbml0cyA9IChzdGF0ZTogSGFzc0VudGl0eSkgPT5cbiAgXCJ1bml0X29mX21lYXN1cmVtZW50XCIgaW4gc3RhdGUuYXR0cmlidXRlcyB8fFxuICBcInN0YXRlX2NsYXNzXCIgaW4gc3RhdGUuYXR0cmlidXRlcztcblxuZXhwb3J0IGNvbnN0IGNvbXB1dGVIaXN0b3J5ID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBzdGF0ZUhpc3Rvcnk6IEhhc3NFbnRpdHlbXVtdLFxuICBsb2NhbGl6ZTogTG9jYWxpemVGdW5jXG4pOiBIaXN0b3J5UmVzdWx0ID0+IHtcbiAgY29uc3QgbGluZUNoYXJ0RGV2aWNlczogeyBbdW5pdDogc3RyaW5nXTogSGFzc0VudGl0eVtdW10gfSA9IHt9O1xuICBjb25zdCB0aW1lbGluZURldmljZXM6IFRpbWVsaW5lRW50aXR5W10gPSBbXTtcbiAgaWYgKCFzdGF0ZUhpc3RvcnkpIHtcbiAgICByZXR1cm4geyBsaW5lOiBbXSwgdGltZWxpbmU6IFtdIH07XG4gIH1cblxuICBzdGF0ZUhpc3RvcnkuZm9yRWFjaCgoc3RhdGVJbmZvKSA9PiB7XG4gICAgaWYgKHN0YXRlSW5mby5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbnRpdHlJZCA9IHN0YXRlSW5mb1swXS5lbnRpdHlfaWQ7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID1cbiAgICAgIGVudGl0eUlkIGluIGhhc3Muc3RhdGVzID8gaGFzcy5zdGF0ZXNbZW50aXR5SWRdIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHN0YXRlV2l0aFVuaXRvclN0YXRlQ2xhc3MgPVxuICAgICAgIWN1cnJlbnRTdGF0ZSAmJlxuICAgICAgc3RhdGVJbmZvLmZpbmQoKHN0YXRlKSA9PiBzdGF0ZS5hdHRyaWJ1dGVzICYmIHN0YXRlVXNlc1VuaXRzKHN0YXRlKSk7XG5cbiAgICBsZXQgdW5pdDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBzdGF0ZVVzZXNVbml0cyhjdXJyZW50U3RhdGUpKSB7XG4gICAgICB1bml0ID0gY3VycmVudFN0YXRlLmF0dHJpYnV0ZXMudW5pdF9vZl9tZWFzdXJlbWVudCB8fCBcIiBcIjtcbiAgICB9IGVsc2UgaWYgKHN0YXRlV2l0aFVuaXRvclN0YXRlQ2xhc3MpIHtcbiAgICAgIHVuaXQgPSBzdGF0ZVdpdGhVbml0b3JTdGF0ZUNsYXNzLmF0dHJpYnV0ZXMudW5pdF9vZl9tZWFzdXJlbWVudCB8fCBcIiBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdCA9IHtcbiAgICAgICAgY2xpbWF0ZTogaGFzcy5jb25maWcudW5pdF9zeXN0ZW0udGVtcGVyYXR1cmUsXG4gICAgICAgIGNvdW50ZXI6IFwiI1wiLFxuICAgICAgICBodW1pZGlmaWVyOiBcIiVcIixcbiAgICAgICAgaW5wdXRfbnVtYmVyOiBcIiNcIixcbiAgICAgICAgbnVtYmVyOiBcIiNcIixcbiAgICAgICAgd2F0ZXJfaGVhdGVyOiBoYXNzLmNvbmZpZy51bml0X3N5c3RlbS50ZW1wZXJhdHVyZSxcbiAgICAgIH1bY29tcHV0ZURvbWFpbihlbnRpdHlJZCldO1xuICAgIH1cblxuICAgIGlmICghdW5pdCkge1xuICAgICAgdGltZWxpbmVEZXZpY2VzLnB1c2goXG4gICAgICAgIHByb2Nlc3NUaW1lbGluZUVudGl0eShsb2NhbGl6ZSwgaGFzcy5sb2NhbGUsIHN0YXRlSW5mbylcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh1bml0IGluIGxpbmVDaGFydERldmljZXMpIHtcbiAgICAgIGxpbmVDaGFydERldmljZXNbdW5pdF0ucHVzaChzdGF0ZUluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lQ2hhcnREZXZpY2VzW3VuaXRdID0gW3N0YXRlSW5mb107XG4gICAgfVxuICB9KTtcblxuICBjb25zdCB1bml0U3RhdGVzID0gT2JqZWN0LmtleXMobGluZUNoYXJ0RGV2aWNlcykubWFwKCh1bml0KSA9PlxuICAgIHByb2Nlc3NMaW5lQ2hhcnRFbnRpdGllcyh1bml0LCBsaW5lQ2hhcnREZXZpY2VzW3VuaXRdKVxuICApO1xuXG4gIHJldHVybiB7IGxpbmU6IHVuaXRTdGF0ZXMsIHRpbWVsaW5lOiB0aW1lbGluZURldmljZXMgfTtcbn07XG5cbi8vIFN0YXRpc3RpY3NcblxuZXhwb3J0IGNvbnN0IGdldFN0YXRpc3RpY0lkcyA9IChcbiAgaGFzczogSG9tZUFzc2lzdGFudCxcbiAgc3RhdGlzdGljX3R5cGU/OiBcIm1lYW5cIiB8IFwic3VtXCJcbikgPT5cbiAgaGFzcy5jYWxsV1M8U3RhdGlzdGljc01ldGFEYXRhW10+KHtcbiAgICB0eXBlOiBcImhpc3RvcnkvbGlzdF9zdGF0aXN0aWNfaWRzXCIsXG4gICAgc3RhdGlzdGljX3R5cGUsXG4gIH0pO1xuXG5leHBvcnQgY29uc3QgZ2V0U3RhdGlzdGljTWV0YWRhdGEgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIHN0YXRpc3RpY19pZHM/OiBzdHJpbmdbXVxuKSA9PlxuICBoYXNzLmNhbGxXUzxTdGF0aXN0aWNzTWV0YURhdGFbXT4oe1xuICAgIHR5cGU6IFwicmVjb3JkZXIvZ2V0X3N0YXRpc3RpY3NfbWV0YWRhdGFcIixcbiAgICBzdGF0aXN0aWNfaWRzLFxuICB9KTtcblxuZXhwb3J0IGNvbnN0IGZldGNoU3RhdGlzdGljcyA9IChcbiAgaGFzczogSG9tZUFzc2lzdGFudCxcbiAgc3RhcnRUaW1lOiBEYXRlLFxuICBlbmRUaW1lPzogRGF0ZSxcbiAgc3RhdGlzdGljX2lkcz86IHN0cmluZ1tdLFxuICBwZXJpb2Q6IFwiNW1pbnV0ZVwiIHwgXCJob3VyXCIgfCBcImRheVwiIHwgXCJtb250aFwiID0gXCJob3VyXCJcbikgPT5cbiAgaGFzcy5jYWxsV1M8U3RhdGlzdGljcz4oe1xuICAgIHR5cGU6IFwiaGlzdG9yeS9zdGF0aXN0aWNzX2R1cmluZ19wZXJpb2RcIixcbiAgICBzdGFydF90aW1lOiBzdGFydFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICBlbmRfdGltZTogZW5kVGltZT8udG9JU09TdHJpbmcoKSxcbiAgICBzdGF0aXN0aWNfaWRzLFxuICAgIHBlcmlvZCxcbiAgfSk7XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVN0YXRpc3RpY3MgPSAoaGFzczogSG9tZUFzc2lzdGFudCkgPT5cbiAgaGFzcy5jYWxsV1M8U3RhdGlzdGljc1ZhbGlkYXRpb25SZXN1bHRzPih7XG4gICAgdHlwZTogXCJyZWNvcmRlci92YWxpZGF0ZV9zdGF0aXN0aWNzXCIsXG4gIH0pO1xuXG5leHBvcnQgY29uc3QgdXBkYXRlU3RhdGlzdGljc01ldGFkYXRhID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBzdGF0aXN0aWNfaWQ6IHN0cmluZyxcbiAgdW5pdF9vZl9tZWFzdXJlbWVudDogc3RyaW5nIHwgbnVsbFxuKSA9PlxuICBoYXNzLmNhbGxXUzx2b2lkPih7XG4gICAgdHlwZTogXCJyZWNvcmRlci91cGRhdGVfc3RhdGlzdGljc19tZXRhZGF0YVwiLFxuICAgIHN0YXRpc3RpY19pZCxcbiAgICB1bml0X29mX21lYXN1cmVtZW50LFxuICB9KTtcblxuZXhwb3J0IGNvbnN0IGNsZWFyU3RhdGlzdGljcyA9IChoYXNzOiBIb21lQXNzaXN0YW50LCBzdGF0aXN0aWNfaWRzOiBzdHJpbmdbXSkgPT5cbiAgaGFzcy5jYWxsV1M8dm9pZD4oe1xuICAgIHR5cGU6IFwicmVjb3JkZXIvY2xlYXJfc3RhdGlzdGljc1wiLFxuICAgIHN0YXRpc3RpY19pZHMsXG4gIH0pO1xuXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlU3RhdGlzdGljU3VtR3Jvd3RoID0gKFxuICB2YWx1ZXM6IFN0YXRpc3RpY1ZhbHVlW11cbik6IG51bWJlciB8IG51bGwgPT4ge1xuICBpZiAoIXZhbHVlcyB8fCB2YWx1ZXMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVuZFN1bSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0uc3VtO1xuICBpZiAoZW5kU3VtID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3RhcnRTdW0gPSB2YWx1ZXNbMF0uc3VtO1xuICBpZiAoc3RhcnRTdW0gPT09IG51bGwpIHtcbiAgICByZXR1cm4gZW5kU3VtO1xuICB9XG4gIHJldHVybiBlbmRTdW0gLSBzdGFydFN1bTtcbn07XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVTdGF0aXN0aWNzU3VtR3Jvd3RoID0gKFxuICBkYXRhOiBTdGF0aXN0aWNzLFxuICBzdGF0czogc3RyaW5nW11cbik6IG51bWJlciB8IG51bGwgPT4ge1xuICBsZXQgdG90YWxHcm93dGg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIGZvciAoY29uc3Qgc3RhdCBvZiBzdGF0cykge1xuICAgIGlmICghKHN0YXQgaW4gZGF0YSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzdGF0R3Jvd3RoID0gY2FsY3VsYXRlU3RhdGlzdGljU3VtR3Jvd3RoKGRhdGFbc3RhdF0pO1xuXG4gICAgaWYgKHN0YXRHcm93dGggPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodG90YWxHcm93dGggPT09IG51bGwpIHtcbiAgICAgIHRvdGFsR3Jvd3RoID0gc3RhdEdyb3d0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG90YWxHcm93dGggKz0gc3RhdEdyb3d0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG90YWxHcm93dGg7XG59O1xuXG5leHBvcnQgY29uc3Qgc3RhdGlzdGljc0hhdmVUeXBlID0gKFxuICBzdGF0czogU3RhdGlzdGljVmFsdWVbXSxcbiAgdHlwZTogU3RhdGlzdGljVHlwZVxuKSA9PiBzdGF0cy5zb21lKChzdGF0KSA9PiBzdGF0W3R5cGVdICE9PSBudWxsKTtcblxuZXhwb3J0IGNvbnN0IGFkanVzdFN0YXRpc3RpY3NTdW0gPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIHN0YXRpc3RpY19pZDogc3RyaW5nLFxuICBzdGFydF90aW1lOiBzdHJpbmcsXG4gIGFkanVzdG1lbnQ6IG51bWJlclxuKTogUHJvbWlzZTx2b2lkPiA9PlxuICBoYXNzLmNhbGxXUyh7XG4gICAgdHlwZTogXCJyZWNvcmRlci9hZGp1c3Rfc3VtX3N0YXRpc3RpY3NcIixcbiAgICBzdGF0aXN0aWNfaWQsXG4gICAgc3RhcnRfdGltZSxcbiAgICBhZGp1c3RtZW50LFxuICB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/data/history.ts\n");

/***/ })

}]);