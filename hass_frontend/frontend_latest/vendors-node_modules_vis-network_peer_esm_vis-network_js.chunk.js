"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_vis-network_peer_esm_vis-network_js"],{

/***/ "./node_modules/vis-data/peer/esm/vis-data.js":
/*!****************************************************!*\
  !*** ./node_modules/vis-data/peer/esm/vis-data.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DELETE\": () => (/* binding */ DELETE),\n/* harmony export */   \"DataSet\": () => (/* binding */ DataSet),\n/* harmony export */   \"DataStream\": () => (/* binding */ DataStream),\n/* harmony export */   \"DataView\": () => (/* binding */ DataView),\n/* harmony export */   \"Queue\": () => (/* binding */ Queue),\n/* harmony export */   \"createNewDataPipeFrom\": () => (/* binding */ createNewDataPipeFrom),\n/* harmony export */   \"isDataSetLike\": () => (/* binding */ isDataSetLike),\n/* harmony export */   \"isDataViewLike\": () => (/* binding */ isDataViewLike)\n/* harmony export */ });\n/**\n * vis-data\n * http://visjs.org/\n *\n * Manage unstructured data using DataSet. Add, update, and remove data, and listen for changes in the data.\n *\n * @version 7.1.2\n * @date    2021-01-08T20:37:11.601Z\n *\n * @copyright (c) 2011-2017 Almende B.V, http://almende.com\n * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs\n *\n * @license\n * vis.js is dual licensed under both\n *\n *   1. The Apache 2.0 License\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   and\n *\n *   2. The MIT License\n *      http://opensource.org/licenses/MIT\n *\n * vis.js may be distributed under either license.\n */\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn) {\n  var module = {\n    exports: {}\n  };\n  return fn(module, module.exports), module.exports;\n}\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\n\nvar global$1 = // eslint-disable-next-line no-undef\ncheck(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func\nfunction () {\n  return this;\n}() || Function('return this')();\n\nvar fails = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar descriptors = !fails(function () {\n  return Object.defineProperty({}, 1, {\n    get: function () {\n      return 7;\n    }\n  })[1] != 7;\n});\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug\n\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({\n  1: 2\n}, 1); // `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable\n\nvar f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\nvar objectPropertyIsEnumerable = {\n  f: f\n};\n\nvar createPropertyDescriptor = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar toString = {}.toString;\n\nvar classofRaw = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\nvar split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings\n\nvar indexedObject = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object; // `RequireObjectCoercible` abstract operation\n// https://tc39.github.io/ecma262/#sec-requireobjectcoercible\n\nvar requireObjectCoercible = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n\nvar toIndexedObject = function (it) {\n  return indexedObject(requireObjectCoercible(it));\n};\n\nvar isObject = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n}; // https://tc39.github.io/ecma262/#sec-toprimitive\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\n\n\nvar toPrimitive = function (input, PREFERRED_STRING) {\n  if (!isObject(input)) return input;\n  var fn, val;\n  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nvar has = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\nvar document$1 = global$1.document; // typeof document.createElement is 'object' in old IE\n\nvar EXISTS = isObject(document$1) && isObject(document$1.createElement);\n\nvar documentCreateElement = function (it) {\n  return EXISTS ? document$1.createElement(it) : {};\n};\n\nvar ie8DomDefine = !descriptors && !fails(function () {\n  return Object.defineProperty(documentCreateElement('div'), 'a', {\n    get: function () {\n      return 7;\n    }\n  }).a != 7;\n});\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\n\nvar f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (ie8DomDefine) try {\n    return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) {\n    /* empty */\n  }\n  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);\n};\nvar objectGetOwnPropertyDescriptor = {\n  f: f$1\n};\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\nvar isForced_1 = isForced;\nvar path = {};\n\nvar aFunction = function (it) {\n  if (typeof it != 'function') {\n    throw TypeError(String(it) + ' is not a function');\n  }\n\n  return it;\n};\n\nvar functionBindContext = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n\n  switch (length) {\n    case 0:\n      return function () {\n        return fn.call(that);\n      };\n\n    case 1:\n      return function (a) {\n        return fn.call(that, a);\n      };\n\n    case 2:\n      return function (a, b) {\n        return fn.call(that, a, b);\n      };\n\n    case 3:\n      return function (a, b, c) {\n        return fn.call(that, a, b, c);\n      };\n  }\n\n  return function ()\n  /* ...args */\n  {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar anObject = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + ' is not an object');\n  }\n\n  return it;\n};\n\nvar nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method\n// https://tc39.github.io/ecma262/#sec-object.defineproperty\n\nvar f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (ie8DomDefine) try {\n    return nativeDefineProperty(O, P, Attributes);\n  } catch (error) {\n    /* empty */\n  }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\nvar objectDefineProperty = {\n  f: f$2\n};\nvar createNonEnumerableProperty = descriptors ? function (object, key, value) {\n  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\nvar wrapConstructor = function (NativeConstructor) {\n  var Wrapper = function (a, b, c) {\n    if (this instanceof NativeConstructor) {\n      switch (arguments.length) {\n        case 0:\n          return new NativeConstructor();\n\n        case 1:\n          return new NativeConstructor(a);\n\n        case 2:\n          return new NativeConstructor(a, b);\n      }\n\n      return new NativeConstructor(a, b, c);\n    }\n\n    return NativeConstructor.apply(this, arguments);\n  };\n\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\n\n\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var PROTO = options.proto;\n  var nativeSource = GLOBAL ? global$1 : STATIC ? global$1[TARGET] : (global$1[TARGET] || {}).prototype;\n  var target = GLOBAL ? path : path[TARGET] || (path[TARGET] = {});\n  var targetPrototype = target.prototype;\n  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n\n  for (key in source) {\n    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contains in native\n\n    USE_NATIVE = !FORCED && nativeSource && has(nativeSource, key);\n    targetProperty = target[key];\n    if (USE_NATIVE) if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor$1(nativeSource, key);\n      nativeProperty = descriptor && descriptor.value;\n    } else nativeProperty = nativeSource[key]; // export native or implementation\n\n    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];\n    if (USE_NATIVE && typeof targetProperty === typeof sourceProperty) continue; // bind timers to global for call from export context\n\n    if (options.bind && USE_NATIVE) resultProperty = functionBindContext(sourceProperty, global$1); // wrap global constructors for prevent changs in this version\n    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty); // make static versions for prototype methods\n    else if (PROTO && typeof sourceProperty == 'function') resultProperty = functionBindContext(Function.call, sourceProperty); // default case\n    else resultProperty = sourceProperty; // add a flag to not completely full polyfills\n\n    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {\n      createNonEnumerableProperty(resultProperty, 'sham', true);\n    }\n\n    target[key] = resultProperty;\n\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';\n\n      if (!has(path, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});\n      } // export virtual prototype methods\n\n\n      path[VIRTUAL_PROTOTYPE][key] = sourceProperty; // export real prototype methods\n\n      if (options.real && targetPrototype && !targetPrototype[key]) {\n        createNonEnumerableProperty(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n}; // https://tc39.github.io/ecma262/#sec-isarray\n\n\nvar isArray = Array.isArray || function isArray(arg) {\n  return classofRaw(arg) == 'Array';\n};\n\nvar ceil = Math.ceil;\nvar floor = Math.floor; // `ToInteger` abstract operation\n// https://tc39.github.io/ecma262/#sec-tointeger\n\nvar toInteger = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\nvar min = Math.min; // `ToLength` abstract operation\n// https://tc39.github.io/ecma262/#sec-tolength\n\nvar toLength = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n}; // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray\n\n\nvar flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {\n  var targetIndex = start;\n  var sourceIndex = 0;\n  var mapFn = mapper ? functionBindContext(mapper, thisArg, 3) : false;\n  var element;\n\n  while (sourceIndex < sourceLen) {\n    if (sourceIndex in source) {\n      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];\n\n      if (depth > 0 && isArray(element)) {\n        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;\n      } else {\n        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');\n        target[targetIndex] = element;\n      }\n\n      targetIndex++;\n    }\n\n    sourceIndex++;\n  }\n\n  return targetIndex;\n};\n\nvar flattenIntoArray_1 = flattenIntoArray; // https://tc39.github.io/ecma262/#sec-toobject\n\nvar toObject = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n\nvar setGlobal = function (key, value) {\n  try {\n    createNonEnumerableProperty(global$1, key, value);\n  } catch (error) {\n    global$1[key] = value;\n  }\n\n  return value;\n};\n\nvar SHARED = '__core-js_shared__';\nvar store = global$1[SHARED] || setGlobal(SHARED, {});\nvar sharedStore = store;\nvar shared = createCommonjsModule(function (module) {\n  (module.exports = function (key, value) {\n    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});\n  })('versions', []).push({\n    version: '3.7.0',\n    mode: 'pure',\n    copyright: '© 2020 Denis Pushkarev (zloirock.ru)'\n  });\n});\nvar id = 0;\nvar postfix = Math.random();\n\nvar uid = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {\n  // Chrome 38 Symbol has incorrect toString conversion\n  // eslint-disable-next-line no-undef\n  return !String(Symbol());\n});\nvar useSymbolAsUid = nativeSymbol // eslint-disable-next-line no-undef\n&& !Symbol.sham // eslint-disable-next-line no-undef\n&& typeof Symbol.iterator == 'symbol';\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol$1 = global$1.Symbol;\nvar createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;\n\nvar wellKnownSymbol = function (name) {\n  if (!has(WellKnownSymbolsStore, name)) {\n    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n  }\n\n  return WellKnownSymbolsStore[name];\n};\n\nvar SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation\n// https://tc39.github.io/ecma262/#sec-arrayspeciescreate\n\nvar arraySpeciesCreate = function (originalArray, length) {\n  var C;\n\n  if (isArray(originalArray)) {\n    C = originalArray.constructor; // cross-realm fallback\n\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  }\n\n  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n}; // https://github.com/tc39/proposal-flatMap\n\n\n_export({\n  target: 'Array',\n  proto: true\n}, {\n  flatMap: function flatMap(callbackfn\n  /* , thisArg */\n  ) {\n    var O = toObject(this);\n    var sourceLen = toLength(O.length);\n    var A;\n    aFunction(callbackfn);\n    A = arraySpeciesCreate(O, 0);\n    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    return A;\n  }\n});\n\nvar entryVirtual = function (CONSTRUCTOR) {\n  return path[CONSTRUCTOR + 'Prototype'];\n};\n\nvar flatMap = entryVirtual('Array').flatMap;\nvar ArrayPrototype = Array.prototype;\n\nvar flatMap_1 = function (it) {\n  var own = it.flatMap;\n  return it === ArrayPrototype || it instanceof Array && own === ArrayPrototype.flatMap ? flatMap : own;\n};\n\nvar flatMap$1 = flatMap_1;\nvar flatMap$2 = flatMap$1;\nvar push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation\n\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = indexedObject(O);\n    var boundFunction = functionBindContext(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var value, result;\n\n    for (; length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3:\n            return true;\n          // some\n\n          case 5:\n            return value;\n          // find\n\n          case 6:\n            return index;\n          // findIndex\n\n          case 2:\n            push.call(target, value);\n          // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nvar arrayIteration = {\n  // `Array.prototype.forEach` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6)\n};\n\nvar aFunction$1 = function (variable) {\n  return typeof variable == 'function' ? variable : undefined;\n};\n\nvar getBuiltIn = function (namespace, method) {\n  return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global$1[namespace]) : path[namespace] && path[namespace][method] || global$1[namespace] && global$1[namespace][method];\n};\n\nvar engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';\nvar process = global$1.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  version = match[0] + match[1];\n} else if (engineUserAgent) {\n  match = engineUserAgent.match(/Edge\\/(\\d+)/);\n\n  if (!match || match[1] >= 74) {\n    match = engineUserAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = match[1];\n  }\n}\n\nvar engineV8Version = version && +version;\nvar SPECIES$1 = wellKnownSymbol('species');\n\nvar arrayMethodHasSpeciesSupport = function (METHOD_NAME) {\n  // We can't use this feature detection in V8 since it causes\n  // deoptimization and serious performance degradation\n  // https://github.com/zloirock/core-js/issues/677\n  return engineV8Version >= 51 || !fails(function () {\n    var array = [];\n    var constructor = array.constructor = {};\n\n    constructor[SPECIES$1] = function () {\n      return {\n        foo: 1\n      };\n    };\n\n    return array[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\n\nvar defineProperty = Object.defineProperty;\nvar cache = {};\n\nvar thrower = function (it) {\n  throw it;\n};\n\nvar arrayMethodUsesToLength = function (METHOD_NAME, options) {\n  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];\n  if (!options) options = {};\n  var method = [][METHOD_NAME];\n  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;\n  var argument0 = has(options, 0) ? options[0] : thrower;\n  var argument1 = has(options, 1) ? options[1] : undefined;\n  return cache[METHOD_NAME] = !!method && !fails(function () {\n    if (ACCESSORS && !descriptors) return true;\n    var O = {\n      length: -1\n    };\n    if (ACCESSORS) defineProperty(O, 1, {\n      enumerable: true,\n      get: thrower\n    });else O[1] = 1;\n    method.call(O, argument0, argument1);\n  });\n};\n\nvar $map = arrayIteration.map;\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map'); // FF49- issue\n\nvar USES_TO_LENGTH = arrayMethodUsesToLength('map'); // `Array.prototype.map` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH\n}, {\n  map: function map(callbackfn\n  /* , thisArg */\n  ) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar map = entryVirtual('Array').map;\nvar ArrayPrototype$1 = Array.prototype;\n\nvar map_1 = function (it) {\n  var own = it.map;\n  return it === ArrayPrototype$1 || it instanceof Array && own === ArrayPrototype$1.map ? map : own;\n};\n\nvar map$1 = map_1;\nvar map$2 = map$1;\nvar $filter = arrayIteration.filter;\nvar HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('filter'); // Edge 14- issue\n\nvar USES_TO_LENGTH$1 = arrayMethodUsesToLength('filter'); // `Array.prototype.filter` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.filter\n// with adding support of @@species\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$1\n}, {\n  filter: function filter(callbackfn\n  /* , thisArg */\n  ) {\n    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar filter = entryVirtual('Array').filter;\nvar ArrayPrototype$2 = Array.prototype;\n\nvar filter_1 = function (it) {\n  var own = it.filter;\n  return it === ArrayPrototype$2 || it instanceof Array && own === ArrayPrototype$2.filter ? filter : own;\n};\n\nvar filter$1 = filter_1;\nvar filter$2 = filter$1;\n\nvar createMethod$1 = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aFunction(callbackfn);\n    var O = toObject(that);\n    var self = indexedObject(O);\n    var length = toLength(O.length);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n\n      index += i;\n\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw TypeError('Reduce of empty array with no initial value');\n      }\n    }\n\n    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n\n    return memo;\n  };\n};\n\nvar arrayReduce = {\n  // `Array.prototype.reduce` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n  left: createMethod$1(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright\n  right: createMethod$1(true)\n};\n\nvar arrayMethodIsStrict = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call,no-throw-literal\n    method.call(null, argument || function () {\n      throw 1;\n    }, 1);\n  });\n};\n\nvar engineIsNode = classofRaw(global$1.process) == 'process';\nvar $reduce = arrayReduce.left;\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\nvar USES_TO_LENGTH$2 = arrayMethodUsesToLength('reduce', {\n  1: 0\n}); // Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\n\nvar CHROME_BUG = !engineIsNode && engineV8Version > 79 && engineV8Version < 83; // `Array.prototype.reduce` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !STRICT_METHOD || !USES_TO_LENGTH$2 || CHROME_BUG\n}, {\n  reduce: function reduce(callbackfn\n  /* , initialValue */\n  ) {\n    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar reduce = entryVirtual('Array').reduce;\nvar ArrayPrototype$3 = Array.prototype;\n\nvar reduce_1 = function (it) {\n  var own = it.reduce;\n  return it === ArrayPrototype$3 || it instanceof Array && own === ArrayPrototype$3.reduce ? reduce : own;\n};\n\nvar reduce$1 = reduce_1;\nvar reduce$2 = reduce$1;\nvar slice = [].slice;\nvar factories = {};\n\nvar construct = function (C, argsLength, args) {\n  if (!(argsLength in factories)) {\n    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func\n\n\n    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');\n  }\n\n  return factories[argsLength](C, args);\n}; // `Function.prototype.bind` method implementation\n// https://tc39.github.io/ecma262/#sec-function.prototype.bind\n\n\nvar functionBind = Function.bind || function bind(that\n/* , ...args */\n) {\n  var fn = aFunction(this);\n  var partArgs = slice.call(arguments, 1);\n\n  var boundFunction = function bound()\n  /* args... */\n  {\n    var args = partArgs.concat(slice.call(arguments));\n    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);\n  };\n\n  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;\n  return boundFunction;\n}; // https://tc39.github.io/ecma262/#sec-function.prototype.bind\n\n\n_export({\n  target: 'Function',\n  proto: true\n}, {\n  bind: functionBind\n});\n\nvar bind = entryVirtual('Function').bind;\nvar FunctionPrototype = Function.prototype;\n\nvar bind_1 = function (it) {\n  var own = it.bind;\n  return it === FunctionPrototype || it instanceof Function && own === FunctionPrototype.bind ? bind : own;\n};\n\nvar bind$1 = bind_1;\nvar bind$2 = bind$1;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar classCallCheck = _classCallCheck; // https://tc39.github.io/ecma262/#sec-object.defineproperty\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: !descriptors,\n  sham: !descriptors\n}, {\n  defineProperty: objectDefineProperty.f\n});\n\nvar defineProperty_1 = createCommonjsModule(function (module) {\n  var Object = path.Object;\n\n  var defineProperty = module.exports = function defineProperty(it, key, desc) {\n    return Object.defineProperty(it, key, desc);\n  };\n\n  if (Object.defineProperty.sham) defineProperty.sham = true;\n});\nvar defineProperty$1 = defineProperty_1;\nvar defineProperty$2 = defineProperty$1;\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    defineProperty$2(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar createClass = _createClass;\n/**\r\n * Create new data pipe.\r\n *\r\n * @param from - The source data set or data view.\r\n *\r\n * @remarks\r\n * Example usage:\r\n * ```typescript\r\n * interface AppItem {\r\n *   whoami: string;\r\n *   appData: unknown;\r\n *   visData: VisItem;\r\n * }\r\n * interface VisItem {\r\n *   id: number;\r\n *   label: string;\r\n *   color: string;\r\n *   x: number;\r\n *   y: number;\r\n * }\r\n *\r\n * const ds1 = new DataSet<AppItem, \"whoami\">([], { fieldId: \"whoami\" });\r\n * const ds2 = new DataSet<VisItem, \"id\">();\r\n *\r\n * const pipe = createNewDataPipeFrom(ds1)\r\n *   .filter((item): boolean => item.enabled === true)\r\n *   .map<VisItem, \"id\">((item): VisItem => item.visData)\r\n *   .to(ds2);\r\n *\r\n * pipe.start();\r\n * ```\r\n *\r\n * @returns A factory whose methods can be used to configure the pipe.\r\n */\n\nfunction createNewDataPipeFrom(from) {\n  return new DataPipeUnderConstruction(from);\n}\n/**\r\n * Internal implementation of the pipe. This should be accessible only through\r\n * `createNewDataPipeFrom` from the outside.\r\n *\r\n * @typeParam SI - Source item type.\r\n * @typeParam SP - Source item type's id property name.\r\n * @typeParam TI - Target item type.\r\n * @typeParam TP - Target item type's id property name.\r\n */\n\n\nvar SimpleDataPipe = /*#__PURE__*/function () {\n  /**\r\n   * Create a new data pipe.\r\n   *\r\n   * @param _source - The data set or data view that will be observed.\r\n   * @param _transformers - An array of transforming functions to be used to\r\n   * filter or transform the items in the pipe.\r\n   * @param _target - The data set or data view that will receive the items.\r\n   */\n  function SimpleDataPipe(_source, _transformers, _target) {\n    var _context, _context2, _context3;\n\n    classCallCheck(this, SimpleDataPipe);\n    this._source = _source;\n    this._transformers = _transformers;\n    this._target = _target;\n    /**\r\n     * Bound listeners for use with `DataInterface['on' | 'off']`.\r\n     */\n\n    this._listeners = {\n      add: bind$2(_context = this._add).call(_context, this),\n      remove: bind$2(_context2 = this._remove).call(_context2, this),\n      update: bind$2(_context3 = this._update).call(_context3, this)\n    };\n  }\n  /** @inheritDoc */\n\n\n  createClass(SimpleDataPipe, [{\n    key: \"all\",\n    value: function all() {\n      this._target.update(this._transformItems(this._source.get()));\n\n      return this;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._source.on(\"add\", this._listeners.add);\n\n      this._source.on(\"remove\", this._listeners.remove);\n\n      this._source.on(\"update\", this._listeners.update);\n\n      return this;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._source.off(\"add\", this._listeners.add);\n\n      this._source.off(\"remove\", this._listeners.remove);\n\n      this._source.off(\"update\", this._listeners.update);\n\n      return this;\n    }\n    /**\r\n     * Apply the transformers to the items.\r\n     *\r\n     * @param items - The items to be transformed.\r\n     *\r\n     * @returns The transformed items.\r\n     */\n\n  }, {\n    key: \"_transformItems\",\n    value: function _transformItems(items) {\n      var _context4;\n\n      return reduce$2(_context4 = this._transformers).call(_context4, function (items, transform) {\n        return transform(items);\n      }, items);\n    }\n    /**\r\n     * Handle an add event.\r\n     *\r\n     * @param _name - Ignored.\r\n     * @param payload - The payload containing the ids of the added items.\r\n     */\n\n  }, {\n    key: \"_add\",\n    value: function _add(_name, payload) {\n      if (payload == null) {\n        return;\n      }\n\n      this._target.add(this._transformItems(this._source.get(payload.items)));\n    }\n    /**\r\n     * Handle an update event.\r\n     *\r\n     * @param _name - Ignored.\r\n     * @param payload - The payload containing the ids of the updated items.\r\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update(_name, payload) {\n      if (payload == null) {\n        return;\n      }\n\n      this._target.update(this._transformItems(this._source.get(payload.items)));\n    }\n    /**\r\n     * Handle a remove event.\r\n     *\r\n     * @param _name - Ignored.\r\n     * @param payload - The payload containing the data of the removed items.\r\n     */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(_name, payload) {\n      if (payload == null) {\n        return;\n      }\n\n      this._target.remove(this._transformItems(payload.oldData));\n    }\n  }]);\n  return SimpleDataPipe;\n}();\n/**\r\n * Internal implementation of the pipe factory. This should be accessible\r\n * only through `createNewDataPipeFrom` from the outside.\r\n *\r\n * @typeParam TI - Target item type.\r\n * @typeParam TP - Target item type's id property name.\r\n */\n\n\nvar DataPipeUnderConstruction = /*#__PURE__*/function () {\n  /**\r\n   * Create a new data pipe factory. This is an internal constructor that\r\n   * should never be called from outside of this file.\r\n   *\r\n   * @param _source - The source data set or data view for this pipe.\r\n   */\n  function DataPipeUnderConstruction(_source) {\n    classCallCheck(this, DataPipeUnderConstruction);\n    this._source = _source;\n    /**\r\n     * Array transformers used to transform items within the pipe. This is typed\r\n     * as any for the sake of simplicity.\r\n     */\n\n    this._transformers = [];\n  }\n  /**\r\n   * Filter the items.\r\n   *\r\n   * @param callback - A filtering function that returns true if given item\r\n   * should be piped and false if not.\r\n   *\r\n   * @returns This factory for further configuration.\r\n   */\n\n\n  createClass(DataPipeUnderConstruction, [{\n    key: \"filter\",\n    value: function filter(callback) {\n      this._transformers.push(function (input) {\n        return filter$2(input).call(input, callback);\n      });\n\n      return this;\n    }\n    /**\r\n     * Map each source item to a new type.\r\n     *\r\n     * @param callback - A mapping function that takes a source item and returns\r\n     * corresponding mapped item.\r\n     *\r\n     * @typeParam TI - Target item type.\r\n     * @typeParam TP - Target item type's id property name.\r\n     *\r\n     * @returns This factory for further configuration.\r\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(callback) {\n      this._transformers.push(function (input) {\n        return map$2(input).call(input, callback);\n      });\n\n      return this;\n    }\n    /**\r\n     * Map each source item to zero or more items of a new type.\r\n     *\r\n     * @param callback - A mapping function that takes a source item and returns\r\n     * an array of corresponding mapped items.\r\n     *\r\n     * @typeParam TI - Target item type.\r\n     * @typeParam TP - Target item type's id property name.\r\n     *\r\n     * @returns This factory for further configuration.\r\n     */\n\n  }, {\n    key: \"flatMap\",\n    value: function flatMap(callback) {\n      this._transformers.push(function (input) {\n        return flatMap$2(input).call(input, callback);\n      });\n\n      return this;\n    }\n    /**\r\n     * Connect this pipe to given data set.\r\n     *\r\n     * @param target - The data set that will receive the items from this pipe.\r\n     *\r\n     * @returns The pipe connected between given data sets and performing\r\n     * configured transformation on the processed items.\r\n     */\n\n  }, {\n    key: \"to\",\n    value: function to(target) {\n      return new SimpleDataPipe(this._source, this._transformers, target);\n    }\n  }]);\n  return DataPipeUnderConstruction;\n}();\n\nvar defineProperty$3 = defineProperty_1;\nvar defineProperty$4 = defineProperty$3;\nvar max = Math.max;\nvar min$1 = Math.min; // Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n\nvar toAbsoluteIndex = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n};\n\nvar createMethod$2 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value; // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++]; // eslint-disable-next-line no-self-compare\n\n      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not\n    } else for (; length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    }\n    return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n  includes: createMethod$2(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$2(false)\n};\nvar hiddenKeys = {};\nvar indexOf = arrayIncludes.indexOf;\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key); // Don't enum bug & hidden keys\n\n\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n\n  return result;\n}; // IE8- don't enum bug keys\n\n\nvar enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf']; // https://tc39.github.io/ecma262/#sec-object.keys\n\nvar objectKeys = Object.keys || function keys(O) {\n  return objectKeysInternal(O, enumBugKeys);\n}; // https://tc39.github.io/ecma262/#sec-object.defineproperties\n\n\nvar objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n\n  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);\n\n  return O;\n}; // https://tc39.github.io/ecma262/#sec-object.defineproperties\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: !descriptors,\n  sham: !descriptors\n}, {\n  defineProperties: objectDefineProperties\n});\n\nvar defineProperties_1 = createCommonjsModule(function (module) {\n  var Object = path.Object;\n\n  var defineProperties = module.exports = function defineProperties(T, D) {\n    return Object.defineProperties(T, D);\n  };\n\n  if (Object.defineProperties.sham) defineProperties.sham = true;\n});\nvar defineProperties = defineProperties_1;\nvar defineProperties$1 = defineProperties;\nvar hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n\nvar f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return objectKeysInternal(O, hiddenKeys$1);\n};\n\nvar objectGetOwnPropertyNames = {\n  f: f$3\n};\nvar f$4 = Object.getOwnPropertySymbols;\nvar objectGetOwnPropertySymbols = {\n  f: f$4\n};\n\nvar ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = objectGetOwnPropertyNames.f(anObject(it));\n  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\nvar createProperty = function (object, key, value) {\n  var propertyKey = toPrimitive(key);\n  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;\n}; // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors\n\n\n_export({\n  target: 'Object',\n  stat: true,\n  sham: !descriptors\n}, {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIndexedObject(object);\n    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var index = 0;\n    var key, descriptor;\n\n    while (keys.length > index) {\n      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);\n      if (descriptor !== undefined) createProperty(result, key, descriptor);\n    }\n\n    return result;\n  }\n});\n\nvar getOwnPropertyDescriptors = path.Object.getOwnPropertyDescriptors;\nvar getOwnPropertyDescriptors$1 = getOwnPropertyDescriptors;\nvar getOwnPropertyDescriptors$2 = getOwnPropertyDescriptors$1;\nvar nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar FAILS_ON_PRIMITIVES = fails(function () {\n  nativeGetOwnPropertyDescriptor$1(1);\n});\nvar FORCED = !descriptors || FAILS_ON_PRIMITIVES; // `Object.getOwnPropertyDescriptor` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: FORCED,\n  sham: !descriptors\n}, {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {\n    return nativeGetOwnPropertyDescriptor$1(toIndexedObject(it), key);\n  }\n});\n\nvar getOwnPropertyDescriptor_1 = createCommonjsModule(function (module) {\n  var Object = path.Object;\n\n  var getOwnPropertyDescriptor = module.exports = function getOwnPropertyDescriptor(it, key) {\n    return Object.getOwnPropertyDescriptor(it, key);\n  };\n\n  if (Object.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor.sham = true;\n});\nvar getOwnPropertyDescriptor$2 = getOwnPropertyDescriptor_1;\nvar getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor$2;\nvar html = getBuiltIn('document', 'documentElement');\nvar keys = shared('keys');\n\nvar sharedKey = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () {\n  /* empty */\n};\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n\n\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n\n  return temp;\n}; // Create object with fake `null` prototype: use iframe Object with cleared prototype\n\n\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475\n\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n}; // Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\n\n\nvar activeXDocument;\n\nvar NullProtoObject = function () {\n  try {\n    /* global ActiveXObject */\n    activeXDocument = document.domain && new ActiveXObject('htmlfile');\n  } catch (error) {\n    /* ignore */\n  }\n\n  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n  var length = enumBugKeys.length;\n\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true; // `Object.create` method\n// https://tc39.github.io/ecma262/#sec-object.create\n\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null; // add \"__proto__\" for Object.getPrototypeOf polyfill\n\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n\n  return Properties === undefined ? result : objectDefineProperties(result, Properties);\n};\n\nvar nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;\nvar toString$1 = {}.toString;\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return nativeGetOwnPropertyNames(it);\n  } catch (error) {\n    return windowNames.slice();\n  }\n}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\n\nvar f$5 = function getOwnPropertyNames(it) {\n  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));\n};\n\nvar objectGetOwnPropertyNamesExternal = {\n  f: f$5\n};\n\nvar redefine = function (target, key, value, options) {\n  if (options && options.enumerable) target[key] = value;else createNonEnumerableProperty(target, key, value);\n};\n\nvar f$6 = wellKnownSymbol;\nvar wellKnownSymbolWrapped = {\n  f: f$6\n};\nvar defineProperty$5 = objectDefineProperty.f;\n\nvar defineWellKnownSymbol = function (NAME) {\n  var Symbol = path.Symbol || (path.Symbol = {});\n  if (!has(Symbol, NAME)) defineProperty$5(Symbol, NAME, {\n    value: wellKnownSymbolWrapped.f(NAME)\n  });\n};\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\ntest[TO_STRING_TAG] = 'z';\nvar toStringTagSupport = String(test) === '[object z]';\nvar TO_STRING_TAG$1 = wellKnownSymbol('toStringTag'); // ES3 wrong here\n\nvar CORRECT_ARGUMENTS = classofRaw(function () {\n  return arguments;\n}()) == 'Arguments'; // fallback for IE11 Script Access Denied error\n\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) {\n    /* empty */\n  }\n}; // getting tag from ES6+ `Object.prototype.toString`\n\n\nvar classof = toStringTagSupport ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case\n  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case\n  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback\n  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n}; // https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n\nvar objectToString = toStringTagSupport ? {}.toString : function toString() {\n  return '[object ' + classof(this) + ']';\n};\nvar defineProperty$6 = objectDefineProperty.f;\nvar TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');\n\nvar setToStringTag = function (it, TAG, STATIC, SET_METHOD) {\n  if (it) {\n    var target = STATIC ? it : it.prototype;\n\n    if (!has(target, TO_STRING_TAG$2)) {\n      defineProperty$6(target, TO_STRING_TAG$2, {\n        configurable: true,\n        value: TAG\n      });\n    }\n\n    if (SET_METHOD && !toStringTagSupport) {\n      createNonEnumerableProperty(target, 'toString', objectToString);\n    }\n  }\n};\n\nvar functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper\n\nif (typeof sharedStore.inspectSource != 'function') {\n  sharedStore.inspectSource = function (it) {\n    return functionToString.call(it);\n  };\n}\n\nvar inspectSource = sharedStore.inspectSource;\nvar WeakMap = global$1.WeakMap;\nvar nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\nvar WeakMap$1 = global$1.WeakMap;\nvar set, get, has$1;\n\nvar enforce = function (it) {\n  return has$1(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    }\n\n    return state;\n  };\n};\n\nif (nativeWeakMap) {\n  var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$1());\n  var wmget = store$1.get;\n  var wmhas = store$1.has;\n  var wmset = store$1.set;\n\n  set = function (it, metadata) {\n    metadata.facade = it;\n    wmset.call(store$1, it, metadata);\n    return metadata;\n  };\n\n  get = function (it) {\n    return wmget.call(store$1, it) || {};\n  };\n\n  has$1 = function (it) {\n    return wmhas.call(store$1, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n\n  set = function (it, metadata) {\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n\n  get = function (it) {\n    return has(it, STATE) ? it[STATE] : {};\n  };\n\n  has$1 = function (it) {\n    return has(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set,\n  get: get,\n  has: has$1,\n  enforce: enforce,\n  getterFor: getterFor\n};\nvar $forEach = arrayIteration.forEach;\nvar HIDDEN = sharedKey('hidden');\nvar SYMBOL = 'Symbol';\nvar PROTOTYPE$1 = 'prototype';\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\nvar setInternalState = internalState.set;\nvar getInternalState = internalState.getterFor(SYMBOL);\nvar ObjectPrototype = Object[PROTOTYPE$1];\nvar $Symbol = global$1.Symbol;\nvar $stringify = getBuiltIn('JSON', 'stringify');\nvar nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\nvar nativeDefineProperty$1 = objectDefineProperty.f;\nvar nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;\nvar nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;\nvar AllSymbols = shared('symbols');\nvar ObjectPrototypeSymbols = shared('op-symbols');\nvar StringToSymbolRegistry = shared('string-to-symbol-registry');\nvar SymbolToStringRegistry = shared('symbol-to-string-registry');\nvar WellKnownSymbolsStore$1 = shared('wks');\nvar QObject = global$1.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\nvar USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\nvar setSymbolDescriptor = descriptors && fails(function () {\n  return objectCreate(nativeDefineProperty$1({}, 'a', {\n    get: function () {\n      return nativeDefineProperty$1(this, 'a', {\n        value: 7\n      }).a;\n    }\n  })).a != 7;\n}) ? function (O, P, Attributes) {\n  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$2(ObjectPrototype, P);\n  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];\n  nativeDefineProperty$1(O, P, Attributes);\n\n  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {\n    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);\n  }\n} : nativeDefineProperty$1;\n\nvar wrap = function (tag, description) {\n  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);\n  setInternalState(symbol, {\n    type: SYMBOL,\n    tag: tag,\n    description: description\n  });\n  if (!descriptors) symbol.description = description;\n  return symbol;\n};\n\nvar isSymbol = useSymbolAsUid ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return Object(it) instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(O, P, Attributes) {\n  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n  anObject(O);\n  var key = toPrimitive(P, true);\n  anObject(Attributes);\n\n  if (has(AllSymbols, key)) {\n    if (!Attributes.enumerable) {\n      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));\n      O[HIDDEN][key] = true;\n    } else {\n      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n      Attributes = objectCreate(Attributes, {\n        enumerable: createPropertyDescriptor(0, false)\n      });\n    }\n\n    return setSymbolDescriptor(O, key, Attributes);\n  }\n\n  return nativeDefineProperty$1(O, key, Attributes);\n};\n\nvar $defineProperties = function defineProperties(O, Properties) {\n  anObject(O);\n  var properties = toIndexedObject(Properties);\n  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n  $forEach(keys, function (key) {\n    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);\n  });\n  return O;\n};\n\nvar $create = function create(O, Properties) {\n  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);\n};\n\nvar $propertyIsEnumerable = function propertyIsEnumerable(V) {\n  var P = toPrimitive(V, true);\n  var enumerable = nativePropertyIsEnumerable$1.call(this, P);\n  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;\n  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n};\n\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n  var it = toIndexedObject(O);\n  var key = toPrimitive(P, true);\n  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;\n  var descriptor = nativeGetOwnPropertyDescriptor$2(it, key);\n\n  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {\n    descriptor.enumerable = true;\n  }\n\n  return descriptor;\n};\n\nvar $getOwnPropertyNames = function getOwnPropertyNames(O) {\n  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));\n  var result = [];\n  $forEach(names, function (key) {\n    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);\n  });\n  return result;\n};\n\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;\n  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));\n  var result = [];\n  $forEach(names, function (key) {\n    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {\n      result.push(AllSymbols[key]);\n    }\n  });\n  return result;\n}; // `Symbol` constructor\n// https://tc39.github.io/ecma262/#sec-symbol-constructor\n\n\nif (!nativeSymbol) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');\n    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);\n    var tag = uid(description);\n\n    var setter = function (value) {\n      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n    };\n\n    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {\n      configurable: true,\n      set: setter\n    });\n    return wrap(tag, description);\n  };\n\n  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {\n    return getInternalState(this).tag;\n  });\n  redefine($Symbol, 'withoutSetter', function (description) {\n    return wrap(uid(description), description);\n  });\n  objectPropertyIsEnumerable.f = $propertyIsEnumerable;\n  objectDefineProperty.f = $defineProperty;\n  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;\n  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;\n\n  wellKnownSymbolWrapped.f = function (name) {\n    return wrap(wellKnownSymbol(name), name);\n  };\n\n  if (descriptors) {\n    // https://github.com/tc39/proposal-Symbol-description\n    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {\n      configurable: true,\n      get: function description() {\n        return getInternalState(this).description;\n      }\n    });\n  }\n}\n\n_export({\n  global: true,\n  wrap: true,\n  forced: !nativeSymbol,\n  sham: !nativeSymbol\n}, {\n  Symbol: $Symbol\n});\n\n$forEach(objectKeys(WellKnownSymbolsStore$1), function (name) {\n  defineWellKnownSymbol(name);\n});\n\n_export({\n  target: SYMBOL,\n  stat: true,\n  forced: !nativeSymbol\n}, {\n  // `Symbol.for` method\n  // https://tc39.github.io/ecma262/#sec-symbol.for\n  'for': function (key) {\n    var string = String(key);\n    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n    var symbol = $Symbol(string);\n    StringToSymbolRegistry[string] = symbol;\n    SymbolToStringRegistry[symbol] = string;\n    return symbol;\n  },\n  // `Symbol.keyFor` method\n  // https://tc39.github.io/ecma262/#sec-symbol.keyfor\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');\n    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n  },\n  useSetter: function () {\n    USE_SETTER = true;\n  },\n  useSimple: function () {\n    USE_SETTER = false;\n  }\n});\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: !nativeSymbol,\n  sham: !descriptors\n}, {\n  // `Object.create` method\n  // https://tc39.github.io/ecma262/#sec-object.create\n  create: $create,\n  // `Object.defineProperty` method\n  // https://tc39.github.io/ecma262/#sec-object.defineproperty\n  defineProperty: $defineProperty,\n  // `Object.defineProperties` method\n  // https://tc39.github.io/ecma262/#sec-object.defineproperties\n  defineProperties: $defineProperties,\n  // `Object.getOwnPropertyDescriptor` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n});\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: !nativeSymbol\n}, {\n  // `Object.getOwnPropertyNames` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // `Object.getOwnPropertySymbols` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols\n  getOwnPropertySymbols: $getOwnPropertySymbols\n}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\n\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: fails(function () {\n    objectGetOwnPropertySymbols.f(1);\n  })\n}, {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    return objectGetOwnPropertySymbols.f(toObject(it));\n  }\n}); // `JSON.stringify` method behavior with symbols\n// https://tc39.github.io/ecma262/#sec-json.stringify\n\n\nif ($stringify) {\n  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {\n    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}\n\n    return $stringify([symbol]) != '[null]' // WebKit converts symbol values to JSON as null\n    || $stringify({\n      a: symbol\n    }) != '{}' // V8 throws on boxed symbols\n    || $stringify(Object(symbol)) != '{}';\n  });\n\n  _export({\n    target: 'JSON',\n    stat: true,\n    forced: FORCED_JSON_STRINGIFY\n  }, {\n    // eslint-disable-next-line no-unused-vars\n    stringify: function stringify(it, replacer, space) {\n      var args = [it];\n      var index = 1;\n      var $replacer;\n\n      while (arguments.length > index) args.push(arguments[index++]);\n\n      $replacer = replacer;\n      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n\n      if (!isArray(replacer)) replacer = function (key, value) {\n        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n        if (!isSymbol(value)) return value;\n      };\n      args[1] = replacer;\n      return $stringify.apply(null, args);\n    }\n  });\n} // `Symbol.prototype[@@toPrimitive]` method\n// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive\n\n\nif (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {\n  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);\n} // `Symbol.prototype[@@toStringTag]` property\n// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag\n\n\nsetToStringTag($Symbol, SYMBOL);\nhiddenKeys[HIDDEN] = true;\nvar getOwnPropertySymbols = path.Object.getOwnPropertySymbols;\nvar getOwnPropertySymbols$1 = getOwnPropertySymbols;\nvar getOwnPropertySymbols$2 = getOwnPropertySymbols$1;\nvar iterators = {};\nvar correctPrototypeGetter = !fails(function () {\n  function F() {\n    /* empty */\n  }\n\n  F.prototype.constructor = null;\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\nvar IE_PROTO$1 = sharedKey('IE_PROTO');\nvar ObjectPrototype$1 = Object.prototype; // `Object.getPrototypeOf` method\n// https://tc39.github.io/ecma262/#sec-object.getprototypeof\n\nvar objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];\n\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  }\n\n  return O instanceof Object ? ObjectPrototype$1 : null;\n};\nvar ITERATOR = wellKnownSymbol('iterator');\nvar BUGGY_SAFARI_ITERATORS = false; // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\n\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\nif ([].keys) {\n  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`\n\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {\n    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nif (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n\nvar returnThis = function () {\n  return this;\n};\n\nvar createIteratorConstructor = function (IteratorConstructor, NAME, next) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {\n    next: createPropertyDescriptor(1, next)\n  });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\nvar aPossiblePrototype = function (it) {\n  if (!isObject(it) && it !== null) {\n    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n  }\n\n  return it;\n}; // https://tc39.github.io/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n\n/* eslint-disable no-proto */\n\n\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n\n  try {\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n    setter.call(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) {\n    /* empty */\n  }\n\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\nvar IteratorPrototype$2 = iteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$1 = wellKnownSymbol('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis$1 = function () {\n  return this;\n};\n\nvar defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];\n\n    switch (KIND) {\n      case KEYS:\n        return function keys() {\n          return new IteratorConstructor(this, KIND);\n        };\n\n      case VALUES:\n        return function values() {\n          return new IteratorConstructor(this, KIND);\n        };\n\n      case ENTRIES:\n        return function entries() {\n          return new IteratorConstructor(this, KIND);\n        };\n    }\n\n    return function () {\n      return new IteratorConstructor(this);\n    };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY; // fix native\n\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n\n    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      iterators[TO_STRING_TAG] = returnThis$1;\n    }\n  } // fix Array#{values, @@iterator}.name in V8 / FF\n\n\n  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    INCORRECT_VALUES_NAME = true;\n\n    defaultIterator = function values() {\n      return nativeIterator.call(this);\n    };\n  } // define iterator\n\n\n  if (FORCED && IterablePrototype[ITERATOR$1] !== defaultIterator) {\n    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);\n  }\n\n  iterators[NAME] = defaultIterator; // export additional methods\n\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        redefine(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else _export({\n      target: NAME,\n      proto: true,\n      forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME\n    }, methods);\n  }\n\n  return methods;\n};\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$1 = internalState.set;\nvar getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.github.io/ecma262/#sec-createarrayiterator\n\nvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState$1(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated),\n    // target\n    index: 0,\n    // next index\n    kind: kind // kind\n\n  }); // `%ArrayIteratorPrototype%.next` method\n  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState$1(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  if (kind == 'keys') return {\n    value: index,\n    done: false\n  };\n  if (kind == 'values') return {\n    value: target[index],\n    done: false\n  };\n  return {\n    value: [index, target[index]],\n    done: false\n  };\n}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject\n\niterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\n\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\nvar TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');\n\nfor (var COLLECTION_NAME in domIterables) {\n  var Collection = global$1[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n\n  if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG$3) {\n    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);\n  }\n\n  iterators[COLLECTION_NAME] = iterators.Array;\n}\n\nvar createMethod$3 = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = String(requireObjectCoercible($this));\n    var position = toInteger(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = S.charCodeAt(position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nvar stringMultibyte = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod$3(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod$3(true)\n};\nvar charAt = stringMultibyte.charAt;\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState$2 = internalState.set;\nvar getInternalState$2 = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator\n\ndefineIterator(String, 'String', function (iterated) {\n  setInternalState$2(this, {\n    type: STRING_ITERATOR,\n    string: String(iterated),\n    index: 0\n  }); // `%StringIteratorPrototype%.next` method\n  // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState$2(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return {\n    value: undefined,\n    done: true\n  };\n  point = charAt(string, index);\n  state.index += point.length;\n  return {\n    value: point,\n    done: false\n  };\n});\nvar ITERATOR$2 = wellKnownSymbol('iterator');\n\nvar getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || iterators[classof(it)];\n};\n\nvar getIterator = function (it) {\n  var iteratorMethod = getIteratorMethod(it);\n\n  if (typeof iteratorMethod != 'function') {\n    throw TypeError(String(it) + ' is not iterable');\n  }\n\n  return anObject(iteratorMethod.call(it));\n};\n\nvar getIterator_1 = getIterator;\nvar getIterator$1 = getIterator_1;\nvar getIteratorMethod_1 = getIteratorMethod;\nvar getIteratorMethod$1 = getIteratorMethod_1;\n\nvar iteratorClose = function (iterator) {\n  var returnMethod = iterator['return'];\n\n  if (returnMethod !== undefined) {\n    return anObject(returnMethod.call(iterator)).value;\n  }\n};\n\nvar callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)\n  } catch (error) {\n    iteratorClose(iterator);\n    throw error;\n  }\n};\n\nvar ITERATOR$3 = wellKnownSymbol('iterator');\nvar ArrayPrototype$4 = Array.prototype; // check on default Array iterator\n\nvar isArrayIteratorMethod = function (it) {\n  return it !== undefined && (iterators.Array === it || ArrayPrototype$4[ITERATOR$3] === it);\n}; // https://tc39.github.io/ecma262/#sec-array.from\n\n\nvar arrayFrom = function from(arrayLike\n/* , mapfn = undefined, thisArg = undefined */\n) {\n  var O = toObject(arrayLike);\n  var C = typeof this == 'function' ? this : Array;\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var iteratorMethod = getIteratorMethod(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); // if the target is not iterable or it's an array with the default iterator - use a simple case\n\n  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = iteratorMethod.call(O);\n    next = iterator.next;\n    result = new C();\n\n    for (; !(step = next.call(iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty(result, index, value);\n    }\n  } else {\n    length = toLength(O.length);\n    result = new C(length);\n\n    for (; length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty(result, index, value);\n    }\n  }\n\n  result.length = index;\n  return result;\n};\n\nvar ITERATOR$4 = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return {\n        done: !!called++\n      };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n\n  iteratorWithReturn[ITERATOR$4] = function () {\n    return this;\n  }; // eslint-disable-next-line no-throw-literal\n\n\n  Array.from(iteratorWithReturn, function () {\n    throw 2;\n  });\n} catch (error) {\n  /* empty */\n}\n\nvar checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n\n  try {\n    var object = {};\n\n    object[ITERATOR$4] = function () {\n      return {\n        next: function () {\n          return {\n            done: ITERATION_SUPPORT = true\n          };\n        }\n      };\n    };\n\n    exec(object);\n  } catch (error) {\n    /* empty */\n  }\n\n  return ITERATION_SUPPORT;\n};\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  Array.from(iterable);\n}); // `Array.from` method\n// https://tc39.github.io/ecma262/#sec-array.from\n\n_export({\n  target: 'Array',\n  stat: true,\n  forced: INCORRECT_ITERATION\n}, {\n  from: arrayFrom\n});\n\nvar from = path.Array.from;\nvar from$1 = from;\nvar from$2 = from$1; // https://tc39.github.io/ecma262/#sec-array.prototype.fill\n\nvar arrayFill = function fill(value\n/* , start = 0, end = @length */\n) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var argumentsLength = arguments.length;\n  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n\n  while (endPos > index) O[index++] = value;\n\n  return O;\n}; // https://tc39.github.io/ecma262/#sec-array.prototype.fill\n\n\n_export({\n  target: 'Array',\n  proto: true\n}, {\n  fill: arrayFill\n}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\n\nvar fill = entryVirtual('Array').fill;\nvar slice$1 = [].slice;\nvar MSIE = /MSIE .\\./.test(engineUserAgent); // <- dirty ie9- check\n\nvar wrap$1 = function (scheduler) {\n  return function (handler, timeout\n  /* , ...arguments */\n  ) {\n    var boundArgs = arguments.length > 2;\n    var args = boundArgs ? slice$1.call(arguments, 2) : undefined;\n    return scheduler(boundArgs ? function () {\n      // eslint-disable-next-line no-new-func\n      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);\n    } : handler, timeout);\n  };\n}; // ie9- setTimeout & setInterval additional parameters fix\n// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers\n\n\n_export({\n  global: true,\n  bind: true,\n  forced: MSIE\n}, {\n  // `setTimeout` method\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout\n  setTimeout: wrap$1(global$1.setTimeout),\n  // `setInterval` method\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval\n  setInterval: wrap$1(global$1.setInterval)\n});\n\nvar setTimeout$1 = path.setTimeout;\nvar setTimeout$2 = setTimeout$1;\nvar $stringify$1 = getBuiltIn('JSON', 'stringify');\nvar re = /[\\uD800-\\uDFFF]/g;\nvar low = /^[\\uD800-\\uDBFF]$/;\nvar hi = /^[\\uDC00-\\uDFFF]$/;\n\nvar fix = function (match, offset, string) {\n  var prev = string.charAt(offset - 1);\n  var next = string.charAt(offset + 1);\n\n  if (low.test(match) && !hi.test(next) || hi.test(match) && !low.test(prev)) {\n    return '\\\\u' + match.charCodeAt(0).toString(16);\n  }\n\n  return match;\n};\n\nvar FORCED$1 = fails(function () {\n  return $stringify$1('\\uDF06\\uD834') !== '\"\\\\udf06\\\\ud834\"' || $stringify$1('\\uDEAD') !== '\"\\\\udead\"';\n});\n\nif ($stringify$1) {\n  // https://github.com/tc39/proposal-well-formed-stringify\n  _export({\n    target: 'JSON',\n    stat: true,\n    forced: FORCED$1\n  }, {\n    // eslint-disable-next-line no-unused-vars\n    stringify: function stringify(it, replacer, space) {\n      var result = $stringify$1.apply(null, arguments);\n      return typeof result == 'string' ? result.replace(re, fix) : result;\n    }\n  });\n}\n\nif (!path.JSON) path.JSON = {\n  stringify: JSON.stringify\n}; // eslint-disable-next-line no-unused-vars\n\nvar stringify = function stringify(it, replacer, space) {\n  return path.JSON.stringify.apply(null, arguments);\n};\n\nvar stringify$1 = stringify;\nvar stringify$2 = stringify$1; // https://tc39.github.io/ecma262/#sec-object.create\n\n_export({\n  target: 'Object',\n  stat: true,\n  sham: !descriptors\n}, {\n  create: objectCreate\n});\n\nvar Object$1 = path.Object;\n\nvar create = function create(P, D) {\n  return Object$1.create(P, D);\n};\n\nvar create$1 = create;\nvar create$2 = create$1;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    defineProperty$2(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defineProperty$7 = _defineProperty; // a string of all valid unicode whitespaces\n// eslint-disable-next-line max-len\n\nvar whitespaces = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\n\nvar createMethod$4 = function (TYPE) {\n  return function ($this) {\n    var string = String(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nvar stringTrim = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart\n  start: createMethod$4(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend\n  end: createMethod$4(2),\n  // `String.prototype.trim` method\n  // https://tc39.github.io/ecma262/#sec-string.prototype.trim\n  trim: createMethod$4(3)\n};\nvar non = '\\u200B\\u0085\\u180E'; // check that a method works with the correct list\n// of whitespaces and has a correct name\n\nvar stringTrimForced = function (METHOD_NAME) {\n  return fails(function () {\n    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\n\nvar $trim = stringTrim.trim; // `String.prototype.trim` method\n// https://tc39.github.io/ecma262/#sec-string.prototype.trim\n\n_export({\n  target: 'String',\n  proto: true,\n  forced: stringTrimForced('trim')\n}, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n\nvar trim = entryVirtual('String').trim;\nvar $indexOf = arrayIncludes.indexOf;\nvar nativeIndexOf = [].indexOf;\nvar NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;\nvar STRICT_METHOD$1 = arrayMethodIsStrict('indexOf');\nvar USES_TO_LENGTH$3 = arrayMethodUsesToLength('indexOf', {\n  ACCESSORS: true,\n  1: 0\n}); // `Array.prototype.indexOf` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: NEGATIVE_ZERO || !STRICT_METHOD$1 || !USES_TO_LENGTH$3\n}, {\n  indexOf: function indexOf(searchElement\n  /* , fromIndex = 0 */\n  ) {\n    return NEGATIVE_ZERO // convert -0 to +0\n    ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar indexOf$1 = entryVirtual('Array').indexOf;\nvar trim$1 = stringTrim.trim;\nvar $parseInt = global$1.parseInt;\nvar hex = /^[+-]?0[Xx]/;\nvar FORCED$2 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22; // `parseInt` method\n// https://tc39.github.io/ecma262/#sec-parseint-string-radix\n\nvar numberParseInt = FORCED$2 ? function parseInt(string, radix) {\n  var S = trim$1(String(string));\n  return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));\n} : $parseInt; // https://tc39.github.io/ecma262/#sec-parseint-string-radix\n\n_export({\n  global: true,\n  forced: parseInt != numberParseInt\n}, {\n  parseInt: numberParseInt\n});\n\nvar propertyIsEnumerable = objectPropertyIsEnumerable.f; // `Object.{ entries, values }` methods implementation\n\nvar createMethod$5 = function (TO_ENTRIES) {\n  return function (it) {\n    var O = toIndexedObject(it);\n    var keys = objectKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n\n    while (length > i) {\n      key = keys[i++];\n\n      if (!descriptors || propertyIsEnumerable.call(O, key)) {\n        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);\n      }\n    }\n\n    return result;\n  };\n};\n\nvar objectToArray = {\n  // `Object.entries` method\n  // https://tc39.github.io/ecma262/#sec-object.entries\n  entries: createMethod$5(true),\n  // `Object.values` method\n  // https://tc39.github.io/ecma262/#sec-object.values\n  values: createMethod$5(false)\n};\nvar $values = objectToArray.values; // `Object.values` method\n// https://tc39.github.io/ecma262/#sec-object.values\n\n_export({\n  target: 'Object',\n  stat: true\n}, {\n  values: function values(O) {\n    return $values(O);\n  }\n});\n\nvar values = path.Object.values;\nvar FAILS_ON_PRIMITIVES$1 = fails(function () {\n  objectGetPrototypeOf(1);\n}); // `Object.getPrototypeOf` method\n// https://tc39.github.io/ecma262/#sec-object.getprototypeof\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: FAILS_ON_PRIMITIVES$1,\n  sham: !correctPrototypeGetter\n}, {\n  getPrototypeOf: function getPrototypeOf(it) {\n    return objectGetPrototypeOf(toObject(it));\n  }\n});\n\nvar getPrototypeOf = path.Object.getPrototypeOf;\nvar $includes = arrayIncludes.includes;\nvar USES_TO_LENGTH$4 = arrayMethodUsesToLength('indexOf', {\n  ACCESSORS: true,\n  1: 0\n}); // `Array.prototype.includes` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.includes\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !USES_TO_LENGTH$4\n}, {\n  includes: function includes(el\n  /* , fromIndex = 0 */\n  ) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\n\nvar includes = entryVirtual('Array').includes;\nvar MATCH = wellKnownSymbol('match'); // `IsRegExp` abstract operation\n// https://tc39.github.io/ecma262/#sec-isregexp\n\nvar isRegexp = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');\n};\n\nvar notARegexp = function (it) {\n  if (isRegexp(it)) {\n    throw TypeError(\"The method doesn't accept regular expressions\");\n  }\n\n  return it;\n};\n\nvar MATCH$1 = wellKnownSymbol('match');\n\nvar correctIsRegexpLogic = function (METHOD_NAME) {\n  var regexp = /./;\n\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH$1] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) {\n      /* empty */\n    }\n  }\n\n  return false;\n}; // https://tc39.github.io/ecma262/#sec-string.prototype.includes\n\n\n_export({\n  target: 'String',\n  proto: true,\n  forced: !correctIsRegexpLogic('includes')\n}, {\n  includes: function includes(searchString\n  /* , position = 0 */\n  ) {\n    return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar includes$1 = entryVirtual('String').includes;\nvar nativeAssign = Object.assign;\nvar defineProperty$8 = Object.defineProperty; // `Object.assign` method\n// https://tc39.github.io/ecma262/#sec-object.assign\n\nvar objectAssign = !nativeAssign || fails(function () {\n  // should have correct order of operations (Edge bug)\n  if (descriptors && nativeAssign({\n    b: 1\n  }, nativeAssign(defineProperty$8({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$8(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), {\n    b: 2\n  })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)\n\n  var A = {};\n  var B = {}; // eslint-disable-next-line no-undef\n\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) {\n    B[chr] = chr;\n  });\n  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) {\n  // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n  var propertyIsEnumerable = objectPropertyIsEnumerable.f;\n\n  while (argumentsLength > index) {\n    var S = indexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n\n    while (length > j) {\n      key = keys[j++];\n      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n    }\n  }\n\n  return T;\n} : nativeAssign; // https://tc39.github.io/ecma262/#sec-object.assign\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: Object.assign !== objectAssign\n}, {\n  assign: objectAssign\n});\n\nvar assign = path.Object.assign;\nvar assign$1 = assign;\nvar assign$2 = assign$1;\nvar HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('splice');\nvar USES_TO_LENGTH$5 = arrayMethodUsesToLength('splice', {\n  ACCESSORS: true,\n  0: 0,\n  1: 2\n});\nvar max$1 = Math.max;\nvar min$2 = Math.min;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.splice\n// with adding support of @@species\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$5\n}, {\n  splice: function splice(start, deleteCount\n  /* , ...items */\n  ) {\n    var O = toObject(this);\n    var len = toLength(O.length);\n    var actualStart = toAbsoluteIndex(start, len);\n    var argumentsLength = arguments.length;\n    var insertCount, actualDeleteCount, A, k, from, to;\n\n    if (argumentsLength === 0) {\n      insertCount = actualDeleteCount = 0;\n    } else if (argumentsLength === 1) {\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n    } else {\n      insertCount = argumentsLength - 2;\n      actualDeleteCount = min$2(max$1(toInteger(deleteCount), 0), len - actualStart);\n    }\n\n    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {\n      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);\n    }\n\n    A = arraySpeciesCreate(O, actualDeleteCount);\n\n    for (k = 0; k < actualDeleteCount; k++) {\n      from = actualStart + k;\n      if (from in O) createProperty(A, k, O[from]);\n    }\n\n    A.length = actualDeleteCount;\n\n    if (insertCount < actualDeleteCount) {\n      for (k = actualStart; k < len - actualDeleteCount; k++) {\n        from = k + actualDeleteCount;\n        to = k + insertCount;\n        if (from in O) O[to] = O[from];else delete O[to];\n      }\n\n      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];\n    } else if (insertCount > actualDeleteCount) {\n      for (k = len - actualDeleteCount; k > actualStart; k--) {\n        from = k + actualDeleteCount - 1;\n        to = k + insertCount - 1;\n        if (from in O) O[to] = O[from];else delete O[to];\n      }\n    }\n\n    for (k = 0; k < insertCount; k++) {\n      O[k + actualStart] = arguments[k + 2];\n    }\n\n    O.length = len - actualDeleteCount + insertCount;\n    return A;\n  }\n});\n\nvar splice = entryVirtual('Array').splice;\nvar ArrayPrototype$5 = Array.prototype;\n\nvar splice_1 = function (it) {\n  var own = it.splice;\n  return it === ArrayPrototype$5 || it instanceof Array && own === ArrayPrototype$5.splice ? splice : own;\n};\n\nvar splice$1 = splice_1;\nvar splice$2 = splice$1;\nvar nativeReverse = [].reverse;\nvar test$1 = [1, 2]; // `Array.prototype.reverse` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.reverse\n// fix for Safari 12.0 bug\n// https://bugs.webkit.org/show_bug.cgi?id=188794\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: String(test$1) === String(test$1.reverse())\n}, {\n  reverse: function reverse() {\n    // eslint-disable-next-line no-self-assign\n    if (isArray(this)) this.length = this.length;\n    return nativeReverse.call(this);\n  }\n});\n\nvar reverse = entryVirtual('Array').reverse;\nvar ArrayPrototype$6 = Array.prototype;\n\nvar reverse_1 = function (it) {\n  var own = it.reverse;\n  return it === ArrayPrototype$6 || it instanceof Array && own === ArrayPrototype$6.reverse ? reverse : own;\n};\n\nvar reverse$1 = reverse_1;\nvar reverse$2 = reverse$1;\nvar $forEach$1 = arrayIteration.forEach;\nvar STRICT_METHOD$2 = arrayMethodIsStrict('forEach');\nvar USES_TO_LENGTH$6 = arrayMethodUsesToLength('forEach'); // `Array.prototype.forEach` method implementation\n// https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n\nvar arrayForEach = !STRICT_METHOD$2 || !USES_TO_LENGTH$6 ? function forEach(callbackfn\n/* , thisArg */\n) {\n  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n} : [].forEach; // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: [].forEach != arrayForEach\n}, {\n  forEach: arrayForEach\n});\n\nvar forEach = entryVirtual('Array').forEach;\nvar forEach$1 = forEach;\nvar ArrayPrototype$7 = Array.prototype;\nvar DOMIterables = {\n  DOMTokenList: true,\n  NodeList: true\n};\n\nvar forEach_1 = function (it) {\n  var own = it.forEach;\n  return it === ArrayPrototype$7 || it instanceof Array && own === ArrayPrototype$7.forEach // eslint-disable-next-line no-prototype-builtins\n  || DOMIterables.hasOwnProperty(classof(it)) ? forEach$1 : own;\n};\n\nvar forEach$2 = forEach_1; // https://tc39.github.io/ecma262/#sec-array.isarray\n\n_export({\n  target: 'Array',\n  stat: true\n}, {\n  isArray: isArray\n});\n\nvar isArray$1 = path.Array.isArray;\nvar isArray$2 = isArray$1;\nvar isArray$3 = isArray$2;\n\nfunction _arrayWithHoles(arr) {\n  if (isArray$3(arr)) return arr;\n}\n\nvar arrayWithHoles = _arrayWithHoles;\nvar ITERATOR$5 = wellKnownSymbol('iterator');\n\nvar isIterable = function (it) {\n  var O = Object(it);\n  return O[ITERATOR$5] !== undefined || '@@iterator' in O // eslint-disable-next-line no-prototype-builtins\n  || iterators.hasOwnProperty(classof(O));\n};\n\nvar isIterable_1 = isIterable;\nvar isIterable$1 = isIterable_1;\nvar IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');\nvar MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'; // We can't use this feature detection in V8 since it causes\n// deoptimization and serious performance degradation\n// https://github.com/zloirock/core-js/issues/679\n\nvar IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {\n  var array = [];\n  array[IS_CONCAT_SPREADABLE] = false;\n  return array.concat()[0] !== array;\n});\nvar SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');\n\nvar isConcatSpreadable = function (O) {\n  if (!isObject(O)) return false;\n  var spreadable = O[IS_CONCAT_SPREADABLE];\n  return spreadable !== undefined ? !!spreadable : isArray(O);\n};\n\nvar FORCED$3 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.concat\n// with adding support of @@isConcatSpreadable and @@species\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: FORCED$3\n}, {\n  concat: function concat(arg) {\n    // eslint-disable-line no-unused-vars\n    var O = toObject(this);\n    var A = arraySpeciesCreate(O, 0);\n    var n = 0;\n    var i, k, length, len, E;\n\n    for (i = -1, length = arguments.length; i < length; i++) {\n      E = i === -1 ? O : arguments[i];\n\n      if (isConcatSpreadable(E)) {\n        len = toLength(E.length);\n        if (n + len > MAX_SAFE_INTEGER$1) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n\n        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);\n      } else {\n        if (n >= MAX_SAFE_INTEGER$1) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n        createProperty(A, n++, E);\n      }\n    }\n\n    A.length = n;\n    return A;\n  }\n}); // https://tc39.github.io/ecma262/#sec-symbol.asynciterator\n\n\ndefineWellKnownSymbol('asyncIterator'); // https://tc39.github.io/ecma262/#sec-symbol.hasinstance\n\ndefineWellKnownSymbol('hasInstance'); // https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable\n\ndefineWellKnownSymbol('isConcatSpreadable'); // https://tc39.github.io/ecma262/#sec-symbol.iterator\n\ndefineWellKnownSymbol('iterator'); // https://tc39.github.io/ecma262/#sec-symbol.match\n\ndefineWellKnownSymbol('match');\ndefineWellKnownSymbol('matchAll'); // https://tc39.github.io/ecma262/#sec-symbol.replace\n\ndefineWellKnownSymbol('replace'); // https://tc39.github.io/ecma262/#sec-symbol.search\n\ndefineWellKnownSymbol('search'); // https://tc39.github.io/ecma262/#sec-symbol.species\n\ndefineWellKnownSymbol('species'); // https://tc39.github.io/ecma262/#sec-symbol.split\n\ndefineWellKnownSymbol('split'); // https://tc39.github.io/ecma262/#sec-symbol.toprimitive\n\ndefineWellKnownSymbol('toPrimitive'); // https://tc39.github.io/ecma262/#sec-symbol.tostringtag\n\ndefineWellKnownSymbol('toStringTag'); // https://tc39.github.io/ecma262/#sec-symbol.unscopables\n\ndefineWellKnownSymbol('unscopables'); // https://tc39.github.io/ecma262/#sec-json-@@tostringtag\n\nsetToStringTag(global$1.JSON, 'JSON', true);\nvar symbol = path.Symbol; // https://github.com/tc39/proposal-using-statement\n\ndefineWellKnownSymbol('asyncDispose'); // https://github.com/tc39/proposal-using-statement\n\ndefineWellKnownSymbol('dispose'); // https://github.com/tc39/proposal-observable\n\ndefineWellKnownSymbol('observable'); // https://github.com/tc39/proposal-pattern-matching\n\ndefineWellKnownSymbol('patternMatch');\ndefineWellKnownSymbol('replaceAll');\nvar symbol$1 = symbol;\nvar symbol$2 = symbol$1;\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof symbol$2 === \"undefined\" || !isIterable$1(Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = getIterator$1(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nvar iterableToArrayLimit = _iterableToArrayLimit;\nvar from$3 = from;\nvar from$4 = from$3;\nvar HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('slice');\nvar USES_TO_LENGTH$7 = arrayMethodUsesToLength('slice', {\n  ACCESSORS: true,\n  0: 0,\n  1: 2\n});\nvar SPECIES$2 = wellKnownSymbol('species');\nvar nativeSlice = [].slice;\nvar max$2 = Math.max; // `Array.prototype.slice` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.slice\n// fallback for not array-like ES3 strings and DOM objects\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$7\n}, {\n  slice: function slice(start, end) {\n    var O = toIndexedObject(this);\n    var length = toLength(O.length);\n    var k = toAbsoluteIndex(start, length);\n    var fin = toAbsoluteIndex(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible\n\n    var Constructor, result, n;\n\n    if (isArray(O)) {\n      Constructor = O.constructor; // cross-realm fallback\n\n      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {\n        Constructor = undefined;\n      } else if (isObject(Constructor)) {\n        Constructor = Constructor[SPECIES$2];\n        if (Constructor === null) Constructor = undefined;\n      }\n\n      if (Constructor === Array || Constructor === undefined) {\n        return nativeSlice.call(O, k, fin);\n      }\n    }\n\n    result = new (Constructor === undefined ? Array : Constructor)(max$2(fin - k, 0));\n\n    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);\n\n    result.length = n;\n    return result;\n  }\n});\n\nvar slice$2 = entryVirtual('Array').slice;\nvar ArrayPrototype$8 = Array.prototype;\n\nvar slice_1 = function (it) {\n  var own = it.slice;\n  return it === ArrayPrototype$8 || it instanceof Array && own === ArrayPrototype$8.slice ? slice$2 : own;\n};\n\nvar slice$3 = slice_1;\nvar slice$4 = slice$3;\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar arrayLikeToArray = _arrayLikeToArray;\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context;\n\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = slice$4(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from$4(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nvar unsupportedIterableToArray = _unsupportedIterableToArray;\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar nonIterableRest = _nonIterableRest;\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nvar slicedToArray = _slicedToArray; // https://tc39.github.io/ecma262/#sec-date.now\n\n_export({\n  target: 'Date',\n  stat: true\n}, {\n  now: function now() {\n    return new Date().getTime();\n  }\n});\n\nvar now = path.Date.now;\nvar FAILS_ON_PRIMITIVES$2 = fails(function () {\n  objectKeys(1);\n}); // `Object.keys` method\n// https://tc39.github.io/ecma262/#sec-object.keys\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: FAILS_ON_PRIMITIVES$2\n}, {\n  keys: function keys(it) {\n    return objectKeys(toObject(it));\n  }\n});\n\nvar keys$1 = path.Object.keys;\nvar keys$2 = keys$1;\nvar keys$3 = keys$2;\nvar isArray$4 = isArray$1;\nvar isArray$5 = isArray$4;\nvar iterator = wellKnownSymbolWrapped.f('iterator');\nvar iterator$1 = iterator;\nvar iterator$2 = iterator$1;\n\nvar _typeof_1 = createCommonjsModule(function (module) {\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof symbol$2 === \"function\" && typeof iterator$2 === \"symbol\") {\n      module.exports = _typeof = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      module.exports = _typeof = function _typeof(obj) {\n        return obj && typeof symbol$2 === \"function\" && obj.constructor === symbol$2 && obj !== symbol$2.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  module.exports = _typeof;\n}); // https://tc39.github.io/ecma262/#sec-reflect.ownkeys\n\n\n_export({\n  target: 'Reflect',\n  stat: true\n}, {\n  ownKeys: ownKeys\n});\n\nvar ownKeys$1 = path.Reflect.ownKeys;\nvar ownKeys$2 = ownKeys$1;\nvar ownKeys$3 = ownKeys$2;\nvar slice$5 = slice_1;\nvar slice$6 = slice$5;\n\nfunction _arrayWithoutHoles(arr) {\n  if (isArray$3(arr)) return arrayLikeToArray(arr);\n}\n\nvar arrayWithoutHoles = _arrayWithoutHoles;\n\nfunction _iterableToArray(iter) {\n  if (typeof symbol$2 !== \"undefined\" && isIterable$1(Object(iter))) return from$4(iter);\n}\n\nvar iterableToArray = _iterableToArray;\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar nonIterableSpread = _nonIterableSpread;\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nvar toConsumableArray = _toConsumableArray;\nvar concat = entryVirtual('Array').concat;\nvar ArrayPrototype$9 = Array.prototype;\n\nvar concat_1 = function (it) {\n  var own = it.concat;\n  return it === ArrayPrototype$9 || it instanceof Array && own === ArrayPrototype$9.concat ? concat : own;\n};\n\nvar concat$1 = concat_1;\nvar concat$2 = concat$1;\nvar symbol$3 = symbol;\nvar symbol$4 = symbol$3;\nvar componentEmitter = createCommonjsModule(function (module) {\n  /**\r\n   * Expose `Emitter`.\r\n   */\n  {\n    module.exports = Emitter;\n  }\n  /**\r\n   * Initialize a new `Emitter`.\r\n   *\r\n   * @api public\r\n   */\n\n  function Emitter(obj) {\n    if (obj) return mixin(obj);\n  }\n  /**\r\n   * Mixin the emitter properties.\r\n   *\r\n   * @param {Object} obj\r\n   * @return {Object}\r\n   * @api private\r\n   */\n\n\n  function mixin(obj) {\n    for (var key in Emitter.prototype) {\n      obj[key] = Emitter.prototype[key];\n    }\n\n    return obj;\n  }\n  /**\r\n   * Listen on the given `event` with `fn`.\r\n   *\r\n   * @param {String} event\r\n   * @param {Function} fn\r\n   * @return {Emitter}\r\n   * @api public\r\n   */\n\n\n  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {\n    this._callbacks = this._callbacks || {};\n    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);\n    return this;\n  };\n  /**\r\n   * Adds an `event` listener that will be invoked a single\r\n   * time then automatically removed.\r\n   *\r\n   * @param {String} event\r\n   * @param {Function} fn\r\n   * @return {Emitter}\r\n   * @api public\r\n   */\n\n\n  Emitter.prototype.once = function (event, fn) {\n    function on() {\n      this.off(event, on);\n      fn.apply(this, arguments);\n    }\n\n    on.fn = fn;\n    this.on(event, on);\n    return this;\n  };\n  /**\r\n   * Remove the given callback for `event` or all\r\n   * registered callbacks.\r\n   *\r\n   * @param {String} event\r\n   * @param {Function} fn\r\n   * @return {Emitter}\r\n   * @api public\r\n   */\n\n\n  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {\n    this._callbacks = this._callbacks || {}; // all\n\n    if (0 == arguments.length) {\n      this._callbacks = {};\n      return this;\n    } // specific event\n\n\n    var callbacks = this._callbacks['$' + event];\n    if (!callbacks) return this; // remove all handlers\n\n    if (1 == arguments.length) {\n      delete this._callbacks['$' + event];\n      return this;\n    } // remove specific handler\n\n\n    var cb;\n\n    for (var i = 0; i < callbacks.length; i++) {\n      cb = callbacks[i];\n\n      if (cb === fn || cb.fn === fn) {\n        callbacks.splice(i, 1);\n        break;\n      }\n    } // Remove event specific arrays for event types that no\n    // one is subscribed for to avoid memory leak.\n\n\n    if (callbacks.length === 0) {\n      delete this._callbacks['$' + event];\n    }\n\n    return this;\n  };\n  /**\r\n   * Emit `event` with the given args.\r\n   *\r\n   * @param {String} event\r\n   * @param {Mixed} ...\r\n   * @return {Emitter}\r\n   */\n\n\n  Emitter.prototype.emit = function (event) {\n    this._callbacks = this._callbacks || {};\n    var args = new Array(arguments.length - 1),\n        callbacks = this._callbacks['$' + event];\n\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    if (callbacks) {\n      callbacks = callbacks.slice(0);\n\n      for (var i = 0, len = callbacks.length; i < len; ++i) {\n        callbacks[i].apply(this, args);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Return array of callbacks for `event`.\r\n   *\r\n   * @param {String} event\r\n   * @return {Array}\r\n   * @api public\r\n   */\n\n\n  Emitter.prototype.listeners = function (event) {\n    this._callbacks = this._callbacks || {};\n    return this._callbacks['$' + event] || [];\n  };\n  /**\r\n   * Check if this emitter has `event` handlers.\r\n   *\r\n   * @param {String} event\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\n\n\n  Emitter.prototype.hasListeners = function (event) {\n    return !!this.listeners(event).length;\n  };\n});\n/*! Hammer.JS - v2.0.17-rc - 2019-12-16\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\n\n\nvar assign$3;\n\nif (typeof Object.assign !== 'function') {\n  assign$3 = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n} else {\n  assign$3 = Object.assign;\n}\n\nvar assign$1$1 = assign$3;\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n    abs = Math.abs;\nvar now$1 = Date.now;\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n\n    i++;\n  }\n\n  return undefined;\n}\n/* eslint-disable no-new-func, no-nested-ternary */\n\n\nvar win;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = ('ontouchstart' in win);\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\n\nfunction each(obj, iterator, context) {\n  var i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n\n  return val;\n}\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\n\n\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\n\nvar TouchAction = /*#__PURE__*/function () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n\n  var _proto = TouchAction.prototype;\n\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n\n  return TouchAction;\n}();\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\n\n\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  var x = 0;\n  var y = 0;\n  var i = 0;\n\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now$1(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\n\n\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  var firstInput = session.firstInput,\n      firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now$1();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n\n  input.target = target;\n}\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\n\n\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\n\n\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\n\nvar Input = /*#__PURE__*/function () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n\n  var _proto = Input.prototype;\n\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n\n  return Input;\n}();\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\n\n\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n\n      i++;\n    }\n\n    return -1;\n  }\n}\n\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n};\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\n\nvar PointerEventInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n\n  function PointerEventInput() {\n    var _this;\n\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = PointerEventInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n\n  return PointerEventInput;\n}(Input);\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\n\n\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n\n  function TouchInput() {\n    var _this;\n\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;\n\n    return _this;\n  }\n\n  var _proto = TouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return TouchInput;\n}(Input);\n\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n  i = 0;\n\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\n\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n\n  function MouseInput() {\n    var _this;\n\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = MouseInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n\n  return MouseInput;\n}(Input);\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n      touch = _eventData$changedPoi[0];\n\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar TouchMouseInput = /*#__PURE__*/function () {\n  var TouchMouseInput = /*#__PURE__*/function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n\n      _this = _Input.call(this, _manager, callback) || this;\n\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {\n          return;\n        }\n\n        _this.callback(manager, inputEvent, inputData);\n      };\n\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n\n    var _proto = TouchMouseInput.prototype;\n    /**\n     * @private\n     * remove the event listeners\n     */\n\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n\n    return TouchMouseInput;\n  }(Input);\n\n  return TouchMouseInput;\n}();\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n\n  return new Type(manager, inputHandler);\n}\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n\n  return false;\n}\n\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\n\nvar _uniqueId = 1;\n\nfunction uniqueId() {\n  return _uniqueId++;\n}\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\n\n\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n\n  return otherRecognizer;\n}\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n\n  return '';\n}\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\n\nvar Recognizer = /*#__PURE__*/function () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n\n  var _proto = Recognizer.prototype;\n\n  _proto.set = function set(options) {\n    assign$1$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n\n  _proto.reset = function reset() {};\n\n  return Recognizer;\n}();\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\n\nvar TapRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n\n  function TapRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  var _proto = TapRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return TapRecognizer;\n}(Recognizer);\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\n\nvar AttrRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n\n  var _proto = AttrRecognizer.prototype;\n\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n\n      return state | STATE_CHANGED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  return AttrRecognizer;\n}(Recognizer);\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n\n  return '';\n}\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar PanRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n\n  function PanRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n\n  var _proto = PanRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n\n    return actions;\n  };\n\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PanRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar SwipeRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n\n  var _proto = SwipeRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  };\n\n  return SwipeRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar PinchRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PinchRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar RotateRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = RotateRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  return RotateRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\n\nvar PressRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n\n  function PressRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n\n  var _proto = PressRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now$1();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return PressRecognizer;\n}(Recognizer);\n\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\n\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, ['rotate']], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, ['swipe']], [TapRecognizer], [TapRecognizer, {\n  event: 'doubletap',\n  taps: 2\n}, ['tap']], [PressRecognizer]];\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n\n  if (!element.style) {\n    return;\n  }\n\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Manager = /*#__PURE__*/function () {\n  function Manager(element, options) {\n    var _this = this;\n\n    this.options = assign$1$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n\n  var _proto = Manager.prototype;\n\n  _proto.set = function set(options) {\n    assign$1$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    var i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && ( // 1\n      !curRecognizer || recognizer === curRecognizer || // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    var recognizers = this.recognizers;\n\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n\n    var existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    var i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n\n  return Manager;\n}();\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n\n  function SingleTouchInput() {\n    var _this;\n\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n\n  var _proto = SingleTouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return SingleTouchInput;\n}(Input);\n\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\n\n\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n\n    i++;\n  }\n\n  return dest;\n}, 'extend', 'Use `assign`.');\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign$1$1(childP, properties);\n  }\n}\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\n\n\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Hammer = /*#__PURE__*/function () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n\n  Hammer.VERSION = \"2.0.17-rc\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = assign$1$1({}, defaults, {\n    preset: preset\n  });\n  return Hammer;\n}(); //  style loader but by script tag, not by the loader.\n\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$1(o, minLen) {\n  var _context21;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n  var n = slice$6(_context21 = Object.prototype.toString.call(o)).call(_context21, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\n\nfunction _arrayLikeToArray$1(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\r\n * Use this symbol to delete properies in deepObjectAssign.\r\n */\n\n\nvar DELETE = symbol$4(\"DELETE\");\n/**\r\n * Pure version of deepObjectAssign, it doesn't modify any of it's arguments.\r\n *\r\n * @param base - The base object that fullfils the whole interface T.\r\n * @param updates - Updates that may change or delete props.\r\n *\r\n * @returns A brand new instance with all the supplied objects deeply merged.\r\n */\n\nfunction pureDeepObjectAssign(base) {\n  var _context;\n\n  for (var _len = arguments.length, updates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    updates[_key - 1] = arguments[_key];\n  }\n\n  return deepObjectAssign.apply(void 0, concat$2(_context = [{}, base]).call(_context, updates));\n}\n/**\r\n * Deep version of object assign with additional deleting by the DELETE symbol.\r\n *\r\n * @param values - Objects to be deeply merged.\r\n *\r\n * @returns The first object from values.\r\n */\n\n\nfunction deepObjectAssign() {\n  var merged = deepObjectAssignNonentry.apply(void 0, arguments);\n  stripDelete(merged);\n  return merged;\n}\n/**\r\n * Deep version of object assign with additional deleting by the DELETE symbol.\r\n *\r\n * @remarks\r\n * This doesn't strip the DELETE symbols so they may end up in the final object.\r\n *\r\n * @param values - Objects to be deeply merged.\r\n *\r\n * @returns The first object from values.\r\n */\n\n\nfunction deepObjectAssignNonentry() {\n  for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    values[_key2] = arguments[_key2];\n  }\n\n  if (values.length < 2) {\n    return values[0];\n  } else if (values.length > 2) {\n    var _context2;\n\n    return deepObjectAssignNonentry.apply(void 0, concat$2(_context2 = [deepObjectAssign(values[0], values[1])]).call(_context2, toConsumableArray(slice$6(values).call(values, 2))));\n  }\n\n  var a = values[0];\n  var b = values[1];\n\n  var _iterator = _createForOfIteratorHelper(ownKeys$3(b)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var prop = _step.value;\n      if (!Object.prototype.propertyIsEnumerable.call(b, prop)) ;else if (b[prop] === DELETE) {\n        delete a[prop];\n      } else if (a[prop] !== null && b[prop] !== null && _typeof_1(a[prop]) === \"object\" && _typeof_1(b[prop]) === \"object\" && !isArray$5(a[prop]) && !isArray$5(b[prop])) {\n        a[prop] = deepObjectAssignNonentry(a[prop], b[prop]);\n      } else {\n        a[prop] = clone(b[prop]);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return a;\n}\n/**\r\n * Deep clone given object or array. In case of primitive simply return.\r\n *\r\n * @param a - Anything.\r\n *\r\n * @returns Deep cloned object/array or unchanged a.\r\n */\n\n\nfunction clone(a) {\n  if (isArray$5(a)) {\n    return map$2(a).call(a, function (value) {\n      return clone(value);\n    });\n  } else if (_typeof_1(a) === \"object\" && a !== null) {\n    return deepObjectAssignNonentry({}, a);\n  } else {\n    return a;\n  }\n}\n/**\r\n * Strip DELETE from given object.\r\n *\r\n * @param a - Object which may contain DELETE but won't after this is executed.\r\n */\n\n\nfunction stripDelete(a) {\n  for (var _i = 0, _Object$keys = keys$3(a); _i < _Object$keys.length; _i++) {\n    var prop = _Object$keys[_i];\n\n    if (a[prop] === DELETE) {\n      delete a[prop];\n    } else if (_typeof_1(a[prop]) === \"object\" && a[prop] !== null) {\n      stripDelete(a[prop]);\n    }\n  }\n}\n/**\n * Setup a mock hammer.js object, for unit testing.\n *\n * Inspiration: https://github.com/uber/deck.gl/pull/658\n *\n * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}\n */\n\n\nfunction hammerMock() {\n  var noop = function noop() {};\n\n  return {\n    on: noop,\n    off: noop,\n    destroy: noop,\n    emit: noop,\n    get: function get() {\n      return {\n        set: noop\n      };\n    }\n  };\n}\n\nvar Hammer$1 = typeof window !== \"undefined\" ? window.Hammer || Hammer : function () {\n  // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.\n  return hammerMock();\n};\n/**\n * Turn an element into an clickToUse element.\n * When not active, the element has a transparent overlay. When the overlay is\n * clicked, the mode is changed to active.\n * When active, the element is displayed with a blue border around it, and\n * the interactive contents of the element can be used. When clicked outside\n * the element, the elements mode is changed to inactive.\n *\n * @param {Element} container\n * @class Activator\n */\n\nfunction Activator(container) {\n  var _this = this,\n      _context3;\n\n  this._cleanupQueue = [];\n  this.active = false;\n  this._dom = {\n    container: container,\n    overlay: document.createElement(\"div\")\n  };\n\n  this._dom.overlay.classList.add(\"vis-overlay\");\n\n  this._dom.container.appendChild(this._dom.overlay);\n\n  this._cleanupQueue.push(function () {\n    _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);\n  });\n\n  var hammer = Hammer$1(this._dom.overlay);\n  hammer.on(\"tap\", bind$2(_context3 = this._onTapOverlay).call(_context3, this));\n\n  this._cleanupQueue.push(function () {\n    hammer.destroy(); // FIXME: cleaning up hammer instances doesn't work (Timeline not removed\n    // from memory)\n  }); // block all touch events (except tap)\n\n\n  var events = [\"tap\", \"doubletap\", \"press\", \"pinch\", \"pan\", \"panstart\", \"panmove\", \"panend\"];\n  forEach$2(events).call(events, function (event) {\n    hammer.on(event, function (event) {\n      event.srcEvent.stopPropagation();\n    });\n  }); // attach a click event to the window, in order to deactivate when clicking outside the timeline\n\n  if (document && document.body) {\n    this._onClick = function (event) {\n      if (!_hasParent(event.target, container)) {\n        _this.deactivate();\n      }\n    };\n\n    document.body.addEventListener(\"click\", this._onClick);\n\n    this._cleanupQueue.push(function () {\n      document.body.removeEventListener(\"click\", _this._onClick);\n    });\n  } // prepare escape key listener for deactivating when active\n\n\n  this._escListener = function (event) {\n    if (\"key\" in event ? event.key === \"Escape\" : event.keyCode === 27\n    /* the keyCode is for IE11 */\n    ) {\n      _this.deactivate();\n    }\n  };\n} // turn into an event emitter\n\n\ncomponentEmitter(Activator.prototype); // The currently active activator\n\nActivator.current = null;\n/**\n * Destroy the activator. Cleans up all created DOM and event listeners\n */\n\nActivator.prototype.destroy = function () {\n  var _context4, _context5;\n\n  this.deactivate();\n\n  var _iterator2 = _createForOfIteratorHelper(reverse$2(_context4 = splice$2(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var callback = _step2.value;\n      callback();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\n/**\n * Activate the element\n * Overlay is hidden, element is decorated with a blue shadow border\n */\n\n\nActivator.prototype.activate = function () {\n  // we allow only one active activator at a time\n  if (Activator.current) {\n    Activator.current.deactivate();\n  }\n\n  Activator.current = this;\n  this.active = true;\n  this._dom.overlay.style.display = \"none\";\n\n  this._dom.container.classList.add(\"vis-active\");\n\n  this.emit(\"change\");\n  this.emit(\"activate\"); // ugly hack: bind ESC after emitting the events, as the Network rebinds all\n  // keyboard events on a 'change' event\n\n  document.body.addEventListener(\"keydown\", this._escListener);\n};\n/**\n * Deactivate the element\n * Overlay is displayed on top of the element\n */\n\n\nActivator.prototype.deactivate = function () {\n  this.active = false;\n  this._dom.overlay.style.display = \"block\";\n\n  this._dom.container.classList.remove(\"vis-active\");\n\n  document.body.removeEventListener(\"keydown\", this._escListener);\n  this.emit(\"change\");\n  this.emit(\"deactivate\");\n};\n/**\n * Handle a tap event: activate the container\n *\n * @param {Event}  event   The event\n * @private\n */\n\n\nActivator.prototype._onTapOverlay = function (event) {\n  // activate the container\n  this.activate();\n  event.srcEvent.stopPropagation();\n};\n/**\n * Test whether the element has the requested parent element somewhere in\n * its chain of parent nodes.\n *\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @returns {boolean} Returns true when the parent is found somewhere in the\n *                    chain of parent nodes.\n * @private\n */\n\n\nfunction _hasParent(element, parent) {\n  while (element) {\n    if (element === parent) {\n      return true;\n    }\n\n    element = element.parentNode;\n  }\n\n  return false;\n} // utility functions\n\n\nvar nativeConstruct = getBuiltIn('Reflect', 'construct'); // `Reflect.construct` method\n// https://tc39.github.io/ecma262/#sec-reflect.construct\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\n\nvar NEW_TARGET_BUG = fails(function () {\n  function F() {\n    /* empty */\n  }\n\n  return !(nativeConstruct(function () {\n    /* empty */\n  }, [], F) instanceof F);\n});\nvar ARGS_BUG = !fails(function () {\n  nativeConstruct(function () {\n    /* empty */\n  });\n});\nvar FORCED$4 = NEW_TARGET_BUG || ARGS_BUG;\n\n_export({\n  target: 'Reflect',\n  stat: true,\n  forced: FORCED$4,\n  sham: FORCED$4\n}, {\n  construct: function construct(Target, args\n  /* , newTarget */\n  ) {\n    aFunction(Target);\n    anObject(args);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);\n\n    if (Target == newTarget) {\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch (args.length) {\n        case 0:\n          return new Target();\n\n        case 1:\n          return new Target(args[0]);\n\n        case 2:\n          return new Target(args[0], args[1]);\n\n        case 3:\n          return new Target(args[0], args[1], args[2]);\n\n        case 4:\n          return new Target(args[0], args[1], args[2], args[3]);\n      } // w/o altered newTarget, lot of arguments case\n\n\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (functionBind.apply(Target, $args))();\n    } // with altered newTarget, not support built-in constructors\n\n\n    var proto = newTarget.prototype;\n    var instance = objectCreate(isObject(proto) ? proto : Object.prototype);\n    var result = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});\n\nvar construct$1 = path.Reflect.construct;\nvar construct$2 = construct$1;\nvar construct$3 = construct$2;\nvar entries = entryVirtual('Array').entries;\nvar entries$1 = entries;\nvar ArrayPrototype$a = Array.prototype;\nvar DOMIterables$1 = {\n  DOMTokenList: true,\n  NodeList: true\n};\n\nvar entries_1 = function (it) {\n  var own = it.entries;\n  return it === ArrayPrototype$a || it instanceof Array && own === ArrayPrototype$a.entries // eslint-disable-next-line no-prototype-builtins\n  || DOMIterables$1.hasOwnProperty(classof(it)) ? entries$1 : own;\n};\n\nvar entries$2 = entries_1;\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime_1 = createCommonjsModule(function (module) {\n  var runtime = function (exports) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n    function define(obj, key, value) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n      return obj[key];\n    }\n\n    try {\n      // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n      define({}, \"\");\n    } catch (err) {\n      define = function (obj, key, value) {\n        return obj[key] = value;\n      };\n    }\n\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n\n    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n\n    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n\n    function Generator() {}\n\n    function GeneratorFunction() {}\n\n    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n\n\n    var IteratorPrototype = {};\n\n    IteratorPrototype[iteratorSymbol] = function () {\n      return this;\n    };\n\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n    GeneratorFunctionPrototype.constructor = GeneratorFunction;\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"); // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        define(prototype, method, function (arg) {\n          return this._invoke(method, arg);\n        });\n      });\n    }\n\n    exports.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n\n    exports.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n      }\n\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    }; // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n\n\n    exports.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n\n    function AsyncIterator(generator, PromiseImpl) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return PromiseImpl.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n\n          return PromiseImpl.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n\n      var previousPromise;\n\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n\n        return previousPromise = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      } // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n\n\n      this._invoke = enqueue;\n    }\n\n    defineIteratorMethods(AsyncIterator.prototype);\n\n    AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n      return this;\n    };\n\n    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n\n    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n      if (PromiseImpl === void 0) PromiseImpl = Promise;\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          } // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n          return doneResult();\n        }\n\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted; // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    } // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n\n        return ContinueSentinel;\n      }\n\n      var record = tryCatch(method, delegate.iterator, context.arg);\n\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      var info = record.arg;\n\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n        context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      } // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n\n\n      context.delegate = null;\n      return ContinueSentinel;\n    } // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n\n\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\"); // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n    Gp[iteratorSymbol] = function () {\n      return this;\n    };\n\n    Gp.toString = function () {\n      return \"[object Generator]\";\n    };\n\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n\n      this.tryEntries.push(entry);\n    }\n\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n\n    exports.keys = function (object) {\n      var keys = [];\n\n      for (var key in object) {\n        keys.push(key);\n      }\n\n      keys.reverse(); // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        } // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n\n\n        next.done = true;\n        return next;\n      };\n    };\n\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n              next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n\n            next.value = undefined$1;\n            next.done = true;\n            return next;\n          };\n\n          return next.next = next;\n        }\n      } // Return an iterator with no values.\n\n\n      return {\n        next: doneResult\n      };\n    }\n\n    exports.values = values;\n\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n\n    Context.prototype = {\n      constructor: Context,\n      reset: function (skipTempReset) {\n        this.prev = 0;\n        this.next = 0; // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function () {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n\n        return this.rval;\n      },\n      dispatchException: function (exception) {\n        if (this.done) {\n          throw exception;\n        }\n\n        var context = this;\n\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n\n          return !!caught;\n        }\n\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function (type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n\n        return this.complete(record);\n      },\n      complete: function (record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n\n        return ContinueSentinel;\n      },\n      finish: function (finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function (tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n\n            return thrown;\n          }\n        } // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n\n\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function (iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n\n        return ContinueSentinel;\n      }\n    }; // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n\n    return exports;\n  }( // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports);\n\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n});\nvar regenerator = runtime_1;\nvar iterator$3 = iterator;\nvar iterator$4 = iterator$3;\nvar values$1 = entryVirtual('Array').values;\nvar values$2 = values$1;\nvar ArrayPrototype$b = Array.prototype;\nvar DOMIterables$2 = {\n  DOMTokenList: true,\n  NodeList: true\n};\n\nvar values_1 = function (it) {\n  var own = it.values;\n  return it === ArrayPrototype$b || it instanceof Array && own === ArrayPrototype$b.values // eslint-disable-next-line no-prototype-builtins\n  || DOMIterables$2.hasOwnProperty(classof(it)) ? values$2 : own;\n};\n\nvar values$3 = values_1;\nvar test$2 = [];\nvar nativeSort = test$2.sort; // IE8-\n\nvar FAILS_ON_UNDEFINED = fails(function () {\n  test$2.sort(undefined);\n}); // V8 bug\n\nvar FAILS_ON_NULL = fails(function () {\n  test$2.sort(null);\n}); // Old WebKit\n\nvar STRICT_METHOD$3 = arrayMethodIsStrict('sort');\nvar FORCED$5 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$3; // `Array.prototype.sort` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.sort\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: FORCED$5\n}, {\n  sort: function sort(comparefn) {\n    return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction(comparefn));\n  }\n});\n\nvar sort = entryVirtual('Array').sort;\nvar ArrayPrototype$c = Array.prototype;\n\nvar sort_1 = function (it) {\n  var own = it.sort;\n  return it === ArrayPrototype$c || it instanceof Array && own === ArrayPrototype$c.sort ? sort : own;\n};\n\nvar sort$1 = sort_1;\nvar sort$2 = sort$1;\nvar keys$4 = entryVirtual('Array').keys;\nvar keys$5 = keys$4;\nvar ArrayPrototype$d = Array.prototype;\nvar DOMIterables$3 = {\n  DOMTokenList: true,\n  NodeList: true\n};\n\nvar keys_1 = function (it) {\n  var own = it.keys;\n  return it === ArrayPrototype$d || it instanceof Array && own === ArrayPrototype$d.keys // eslint-disable-next-line no-prototype-builtins\n  || DOMIterables$3.hasOwnProperty(classof(it)) ? keys$5 : own;\n};\n\nvar keys$6 = keys_1;\nvar $some = arrayIteration.some;\nvar STRICT_METHOD$4 = arrayMethodIsStrict('some');\nvar USES_TO_LENGTH$8 = arrayMethodUsesToLength('some'); // `Array.prototype.some` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.some\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !STRICT_METHOD$4 || !USES_TO_LENGTH$8\n}, {\n  some: function some(callbackfn\n  /* , thisArg */\n  ) {\n    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar some = entryVirtual('Array').some;\nvar ArrayPrototype$e = Array.prototype;\n\nvar some_1 = function (it) {\n  var own = it.some;\n  return it === ArrayPrototype$e || it instanceof Array && own === ArrayPrototype$e.some ? some : own;\n};\n\nvar some$1 = some_1;\nvar some$2 = some$1;\nvar freezing = !fails(function () {\n  return Object.isExtensible(Object.preventExtensions({}));\n});\nvar internalMetadata = createCommonjsModule(function (module) {\n  var defineProperty = objectDefineProperty.f;\n  var METADATA = uid('meta');\n  var id = 0;\n\n  var isExtensible = Object.isExtensible || function () {\n    return true;\n  };\n\n  var setMetadata = function (it) {\n    defineProperty(it, METADATA, {\n      value: {\n        objectID: 'O' + ++id,\n        // object ID\n        weakData: {} // weak collections IDs\n\n      }\n    });\n  };\n\n  var fastKey = function (it, create) {\n    // return a primitive with prefix\n    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\n    if (!has(it, METADATA)) {\n      // can't set metadata to uncaught frozen object\n      if (!isExtensible(it)) return 'F'; // not necessary to add metadata\n\n      if (!create) return 'E'; // add missing metadata\n\n      setMetadata(it); // return object ID\n    }\n\n    return it[METADATA].objectID;\n  };\n\n  var getWeakData = function (it, create) {\n    if (!has(it, METADATA)) {\n      // can't set metadata to uncaught frozen object\n      if (!isExtensible(it)) return true; // not necessary to add metadata\n\n      if (!create) return false; // add missing metadata\n\n      setMetadata(it); // return the store of weak collections IDs\n    }\n\n    return it[METADATA].weakData;\n  }; // add metadata on freeze-family methods calling\n\n\n  var onFreeze = function (it) {\n    if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);\n    return it;\n  };\n\n  var meta = module.exports = {\n    REQUIRED: false,\n    fastKey: fastKey,\n    getWeakData: getWeakData,\n    onFreeze: onFreeze\n  };\n  hiddenKeys[METADATA] = true;\n});\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar iterate = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = functionBindContext(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    }\n\n    return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators\n\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = toLength(iterable.length); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && result instanceof Result) return result;\n      }\n\n      return new Result(false);\n    }\n\n    iterator = iterFn.call(iterable);\n  }\n\n  next = iterator.next;\n\n  while (!(step = next.call(iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator);\n      throw error;\n    }\n\n    if (typeof result == 'object' && result && result instanceof Result) return result;\n  }\n\n  return new Result(false);\n};\n\nvar anInstance = function (it, Constructor, name) {\n  if (!(it instanceof Constructor)) {\n    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\n  }\n\n  return it;\n};\n\nvar defineProperty$9 = objectDefineProperty.f;\nvar forEach$3 = arrayIteration.forEach;\nvar setInternalState$3 = internalState.set;\nvar internalStateGetterFor = internalState.getterFor;\n\nvar collection = function (CONSTRUCTOR_NAME, wrapper, common) {\n  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;\n  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var NativeConstructor = global$1[CONSTRUCTOR_NAME];\n  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n  var exported = {};\n  var Constructor;\n\n  if (!descriptors || typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n    new NativeConstructor().entries().next();\n  }))) {\n    // create collection constructor\n    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n    internalMetadata.REQUIRED = true;\n  } else {\n    Constructor = wrapper(function (target, iterable) {\n      setInternalState$3(anInstance(target, Constructor, CONSTRUCTOR_NAME), {\n        type: CONSTRUCTOR_NAME,\n        collection: new NativeConstructor()\n      });\n      if (iterable != undefined) iterate(iterable, target[ADDER], {\n        that: target,\n        AS_ENTRIES: IS_MAP\n      });\n    });\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n    forEach$3(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {\n      var IS_ADDER = KEY == 'add' || KEY == 'set';\n\n      if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {\n        createNonEnumerableProperty(Constructor.prototype, KEY, function (a, b) {\n          var collection = getInternalState(this).collection;\n          if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;\n          var result = collection[KEY](a === 0 ? 0 : a, b);\n          return IS_ADDER ? this : result;\n        });\n      }\n    });\n    IS_WEAK || defineProperty$9(Constructor.prototype, 'size', {\n      configurable: true,\n      get: function () {\n        return getInternalState(this).collection.size;\n      }\n    });\n  }\n\n  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);\n  exported[CONSTRUCTOR_NAME] = Constructor;\n\n  _export({\n    global: true,\n    forced: true\n  }, exported);\n\n  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n  return Constructor;\n};\n\nvar redefineAll = function (target, src, options) {\n  for (var key in src) {\n    if (options && options.unsafe && target[key]) target[key] = src[key];else redefine(target, key, src[key], options);\n  }\n\n  return target;\n};\n\nvar SPECIES$3 = wellKnownSymbol('species');\n\nvar setSpecies = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n  var defineProperty = objectDefineProperty.f;\n\n  if (descriptors && Constructor && !Constructor[SPECIES$3]) {\n    defineProperty(Constructor, SPECIES$3, {\n      configurable: true,\n      get: function () {\n        return this;\n      }\n    });\n  }\n};\n\nvar defineProperty$a = objectDefineProperty.f;\nvar fastKey = internalMetadata.fastKey;\nvar setInternalState$4 = internalState.set;\nvar internalStateGetterFor$1 = internalState.getterFor;\nvar collectionStrong = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, CONSTRUCTOR_NAME);\n      setInternalState$4(that, {\n        type: CONSTRUCTOR_NAME,\n        index: objectCreate(null),\n        first: undefined,\n        last: undefined,\n        size: 0\n      });\n      if (!descriptors) that.size = 0;\n      if (iterable != undefined) iterate(iterable, that[ADDER], {\n        that: that,\n        AS_ENTRIES: IS_MAP\n      });\n    });\n    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var entry = getEntry(that, key);\n      var previous, index; // change existing entry\n\n      if (entry) {\n        entry.value = value; // create new entry\n      } else {\n        state.last = entry = {\n          index: index = fastKey(key, true),\n          key: key,\n          value: value,\n          previous: previous = state.last,\n          next: undefined,\n          removed: false\n        };\n        if (!state.first) state.first = entry;\n        if (previous) previous.next = entry;\n        if (descriptors) state.size++;else that.size++; // add to index\n\n        if (index !== 'F') state.index[index] = entry;\n      }\n\n      return that;\n    };\n\n    var getEntry = function (that, key) {\n      var state = getInternalState(that); // fast case\n\n      var index = fastKey(key);\n      var entry;\n      if (index !== 'F') return state.index[index]; // frozen object case\n\n      for (entry = state.first; entry; entry = entry.next) {\n        if (entry.key == key) return entry;\n      }\n    };\n\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        var that = this;\n        var state = getInternalState(that);\n        var data = state.index;\n        var entry = state.first;\n\n        while (entry) {\n          entry.removed = true;\n          if (entry.previous) entry.previous = entry.previous.next = undefined;\n          delete data[entry.index];\n          entry = entry.next;\n        }\n\n        state.first = state.last = undefined;\n        if (descriptors) state.size = 0;else that.size = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = this;\n        var state = getInternalState(that);\n        var entry = getEntry(that, key);\n\n        if (entry) {\n          var next = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev) prev.next = next;\n          if (next) next.previous = prev;\n          if (state.first == entry) state.first = next;\n          if (state.last == entry) state.last = prev;\n          if (descriptors) state.size--;else that.size--;\n        }\n\n        return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn\n      /* , that = undefined */\n      ) {\n        var state = getInternalState(this);\n        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n\n        while (entry = entry ? entry.next : state.first) {\n          boundFunction(entry.value, entry.key, this); // revert to the last existing entry\n\n          while (entry && entry.removed) entry = entry.previous;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(this, key);\n      }\n    });\n    redefineAll(C.prototype, IS_MAP ? {\n      // 23.1.3.6 Map.prototype.get(key)\n      get: function get(key) {\n        var entry = getEntry(this, key);\n        return entry && entry.value;\n      },\n      // 23.1.3.9 Map.prototype.set(key, value)\n      set: function set(key, value) {\n        return define(this, key === 0 ? 0 : key, value);\n      }\n    } : {\n      // 23.2.3.1 Set.prototype.add(value)\n      add: function add(value) {\n        return define(this, value = value === 0 ? 0 : value, value);\n      }\n    });\n    if (descriptors) defineProperty$a(C.prototype, 'size', {\n      get: function () {\n        return getInternalState(this).size;\n      }\n    });\n    return C;\n  },\n  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {\n    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';\n    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);\n    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME); // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n\n    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {\n      setInternalState$4(this, {\n        type: ITERATOR_NAME,\n        target: iterated,\n        state: getInternalCollectionState(iterated),\n        kind: kind,\n        last: undefined\n      });\n    }, function () {\n      var state = getInternalIteratorState(this);\n      var kind = state.kind;\n      var entry = state.last; // revert to the last existing entry\n\n      while (entry && entry.removed) entry = entry.previous; // get next entry\n\n\n      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n        // or finish the iteration\n        state.target = undefined;\n        return {\n          value: undefined,\n          done: true\n        };\n      } // return step by kind\n\n\n      if (kind == 'keys') return {\n        value: entry.key,\n        done: false\n      };\n      if (kind == 'values') return {\n        value: entry.value,\n        done: false\n      };\n      return {\n        value: [entry.key, entry.value],\n        done: false\n      };\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2\n\n    setSpecies(CONSTRUCTOR_NAME);\n  }\n}; // https://tc39.github.io/ecma262/#sec-map-objects\n\nvar es_map = collection('Map', function (init) {\n  return function Map() {\n    return init(this, arguments.length ? arguments[0] : undefined);\n  };\n}, collectionStrong);\nvar map$3 = path.Map;\nvar map$4 = map$3;\nvar map$5 = map$4;\nvar create$3 = create;\nvar create$4 = create$3; // https://tc39.github.io/ecma262/#sec-object.setprototypeof\n\n_export({\n  target: 'Object',\n  stat: true\n}, {\n  setPrototypeOf: objectSetPrototypeOf\n});\n\nvar setPrototypeOf = path.Object.setPrototypeOf;\nvar setPrototypeOf$1 = setPrototypeOf;\nvar setPrototypeOf$2 = setPrototypeOf$1;\nvar setPrototypeOf$3 = createCommonjsModule(function (module) {\n  function _setPrototypeOf(o, p) {\n    module.exports = _setPrototypeOf = setPrototypeOf$2 || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  module.exports = _setPrototypeOf;\n});\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = create$4(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf$3(subClass, superClass);\n}\n\nvar inherits = _inherits;\n\nfunction _assertThisInitialized$1(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar assertThisInitialized = _assertThisInitialized$1;\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof_1(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nvar possibleConstructorReturn = _possibleConstructorReturn;\nvar getPrototypeOf$1 = getPrototypeOf;\nvar getPrototypeOf$2 = getPrototypeOf$1;\nvar getPrototypeOf$3 = createCommonjsModule(function (module) {\n  function _getPrototypeOf(o) {\n    module.exports = _getPrototypeOf = setPrototypeOf$2 ? getPrototypeOf$2 : function _getPrototypeOf(o) {\n      return o.__proto__ || getPrototypeOf$2(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  module.exports = _getPrototypeOf;\n}); // Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\n\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\nvar REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify$3(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify$3(rnds);\n}\n/**\r\n * Determine whether a value can be used as an id.\r\n *\r\n * @param value - Input value of unknown type.\r\n *\r\n * @returns True if the value is valid id, false otherwise.\r\n */\n\n\nfunction isId(value) {\n  return typeof value === \"string\" || typeof value === \"number\";\n}\n/**\r\n * A queue.\r\n *\r\n * @typeParam T - The type of method names to be replaced by queued versions.\r\n */\n\n\nvar Queue = /*#__PURE__*/function () {\n  /**\r\n   * Construct a new Queue.\r\n   *\r\n   * @param options - Queue configuration.\r\n   */\n  function Queue(options) {\n    classCallCheck(this, Queue);\n    this._queue = [];\n    this._timeout = null;\n    this._extended = null; // options\n\n    this.delay = null;\n    this.max = Infinity;\n    this.setOptions(options);\n  }\n  /**\r\n   * Update the configuration of the queue.\r\n   *\r\n   * @param options - Queue configuration.\r\n   */\n\n\n  createClass(Queue, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options && typeof options.delay !== \"undefined\") {\n        this.delay = options.delay;\n      }\n\n      if (options && typeof options.max !== \"undefined\") {\n        this.max = options.max;\n      }\n\n      this._flushIfNeeded();\n    }\n    /**\r\n     * Extend an object with queuing functionality.\r\n     * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.\r\n     *\r\n     * @param object - The object to be extended.\r\n     * @param options - Additional options.\r\n     *\r\n     * @returns The created queue.\r\n     */\n\n  }, {\n    key: \"destroy\",\n\n    /**\r\n     * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.\r\n     */\n    value: function destroy() {\n      this.flush();\n\n      if (this._extended) {\n        var object = this._extended.object;\n        var methods = this._extended.methods;\n\n        for (var i = 0; i < methods.length; i++) {\n          var method = methods[i];\n\n          if (method.original) {\n            // @TODO: better solution?\n            object[method.name] = method.original;\n          } else {\n            // @TODO: better solution?\n            delete object[method.name];\n          }\n        }\n\n        this._extended = null;\n      }\n    }\n    /**\r\n     * Replace a method on an object with a queued version.\r\n     *\r\n     * @param object - Object having the method.\r\n     * @param method - The method name.\r\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(object, method) {\n      /* eslint-disable-next-line @typescript-eslint/no-this-alias -- Function this is necessary in the function bellow, so class this has to be saved into a variable here. */\n      var me = this;\n      var original = object[method];\n\n      if (!original) {\n        throw new Error(\"Method \" + method + \" undefined\");\n      }\n\n      object[method] = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        } // add this call to the queue\n\n\n        me.queue({\n          args: args,\n          fn: original,\n          context: this\n        });\n      };\n    }\n    /**\r\n     * Queue a call.\r\n     *\r\n     * @param entry - The function or entry to be queued.\r\n     */\n\n  }, {\n    key: \"queue\",\n    value: function queue(entry) {\n      if (typeof entry === \"function\") {\n        this._queue.push({\n          fn: entry\n        });\n      } else {\n        this._queue.push(entry);\n      }\n\n      this._flushIfNeeded();\n    }\n    /**\r\n     * Check whether the queue needs to be flushed.\r\n     */\n\n  }, {\n    key: \"_flushIfNeeded\",\n    value: function _flushIfNeeded() {\n      var _this = this; // flush when the maximum is exceeded.\n\n\n      if (this._queue.length > this.max) {\n        this.flush();\n      } // flush after a period of inactivity when a delay is configured\n\n\n      if (this._timeout != null) {\n        clearTimeout(this._timeout);\n        this._timeout = null;\n      }\n\n      if (this.queue.length > 0 && typeof this.delay === \"number\") {\n        this._timeout = setTimeout$2(function () {\n          _this.flush();\n        }, this.delay);\n      }\n    }\n    /**\r\n     * Flush all queued calls\r\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var _context, _context2;\n\n      forEach$2(_context = splice$2(_context2 = this._queue).call(_context2, 0)).call(_context, function (entry) {\n        entry.fn.apply(entry.context || entry.fn, entry.args || []);\n      });\n    }\n  }], [{\n    key: \"extend\",\n    value: function extend(object, options) {\n      var queue = new Queue(options);\n\n      if (object.flush !== undefined) {\n        throw new Error(\"Target object already has a property flush\");\n      }\n\n      object.flush = function () {\n        queue.flush();\n      };\n\n      var methods = [{\n        name: \"flush\",\n        original: undefined\n      }];\n\n      if (options && options.replace) {\n        for (var i = 0; i < options.replace.length; i++) {\n          var name = options.replace[i];\n          methods.push({\n            name: name,\n            // @TODO: better solution?\n            original: object[name]\n          }); // @TODO: better solution?\n\n          queue.replace(object, name);\n        }\n      }\n\n      queue._extended = {\n        object: object,\n        methods: methods\n      };\n      return queue;\n    }\n  }]);\n  return Queue;\n}();\n/**\r\n * [[DataSet]] code that can be reused in [[DataView]] or other similar implementations of [[DataInterface]].\r\n *\r\n * @typeParam Item - Item type that may or may not have an id.\r\n * @typeParam IdProp - Name of the property that contains the id.\r\n */\n\n\nvar DataSetPart = /*#__PURE__*/function () {\n  function DataSetPart() {\n    classCallCheck(this, DataSetPart);\n    this._subscribers = {\n      \"*\": [],\n      add: [],\n      remove: [],\n      update: []\n    };\n    /**\r\n     * @deprecated Use on instead (PS: DataView.subscribe === DataView.on).\r\n     */\n\n    this.subscribe = DataSetPart.prototype.on;\n    /**\r\n     * @deprecated Use off instead (PS: DataView.unsubscribe === DataView.off).\r\n     */\n\n    this.unsubscribe = DataSetPart.prototype.off;\n  }\n  /**\r\n   * Trigger an event\r\n   *\r\n   * @param event - Event name.\r\n   * @param payload - Event payload.\r\n   * @param senderId - Id of the sender.\r\n   */\n\n\n  createClass(DataSetPart, [{\n    key: \"_trigger\",\n    value: function _trigger(event, payload, senderId) {\n      var _context, _context2;\n\n      if (event === \"*\") {\n        throw new Error(\"Cannot trigger event *\");\n      }\n\n      forEach$2(_context = concat$2(_context2 = []).call(_context2, toConsumableArray(this._subscribers[event]), toConsumableArray(this._subscribers[\"*\"]))).call(_context, function (subscriber) {\n        subscriber(event, payload, senderId != null ? senderId : null);\n      });\n    }\n    /**\r\n     * Subscribe to an event, add an event listener.\r\n     *\r\n     * @remarks Non-function callbacks are ignored.\r\n     *\r\n     * @param event - Event name.\r\n     * @param callback - Callback method.\r\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      if (typeof callback === \"function\") {\n        this._subscribers[event].push(callback);\n      } // @TODO: Maybe throw for invalid callbacks?\n\n    }\n    /**\r\n     * Unsubscribe from an event, remove an event listener.\r\n     *\r\n     * @remarks If the same callback was subscribed more than once **all** occurences will be removed.\r\n     *\r\n     * @param event - Event name.\r\n     * @param callback - Callback method.\r\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(event, callback) {\n      var _context3;\n\n      this._subscribers[event] = filter$2(_context3 = this._subscribers[event]).call(_context3, function (subscriber) {\n        return subscriber !== callback;\n      });\n    }\n  }]);\n  return DataSetPart;\n}(); // https://tc39.github.io/ecma262/#sec-set-objects\n\n\nvar es_set = collection('Set', function (init) {\n  return function Set() {\n    return init(this, arguments.length ? arguments[0] : undefined);\n  };\n}, collectionStrong);\nvar set$1 = path.Set;\nvar set$2 = set$1;\nvar set$3 = set$2;\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$2(o, minLen) {\n  var _context10;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen);\n  var n = slice$6(_context10 = Object.prototype.toString.call(o)).call(_context10, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);\n}\n\nfunction _arrayLikeToArray$2(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\r\n * Data stream\r\n *\r\n * @remarks\r\n * [[DataStream]] offers an always up to date stream of items from a [[DataSet]] or [[DataView]].\r\n * That means that the stream is evaluated at the time of iteration, conversion to another data type or when [[cache]] is called, not when the [[DataStream]] was created.\r\n * Multiple invocations of for example [[toItemArray]] may yield different results (if the data source like for example [[DataSet]] gets modified).\r\n *\r\n * @typeParam Item - The item type this stream is going to work with.\r\n */\n\n\nvar DataStream = /*#__PURE__*/function () {\n  /**\r\n   * Create a new data stream.\r\n   *\r\n   * @param pairs - The id, item pairs.\r\n   */\n  function DataStream(pairs) {\n    classCallCheck(this, DataStream);\n    this._pairs = pairs;\n  }\n  /**\r\n   * Return an iterable of key, value pairs for every entry in the stream.\r\n   */\n\n\n  createClass(DataStream, [{\n    key: iterator$4,\n    value: /*#__PURE__*/regenerator.mark(function value() {\n      var _iterator, _step, _step$value, id, item;\n\n      return regenerator.wrap(function value$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator = _createForOfIteratorHelper$1(this._pairs);\n              _context.prev = 1;\n\n              _iterator.s();\n\n            case 3:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 9;\n                break;\n              }\n\n              _step$value = slicedToArray(_step.value, 2), id = _step$value[0], item = _step$value[1];\n              _context.next = 7;\n              return [id, item];\n\n            case 7:\n              _context.next = 3;\n              break;\n\n            case 9:\n              _context.next = 14;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](1);\n\n              _iterator.e(_context.t0);\n\n            case 14:\n              _context.prev = 14;\n\n              _iterator.f();\n\n              return _context.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, value, this, [[1, 11, 14, 17]]);\n    })\n    /**\r\n     * Return an iterable of key, value pairs for every entry in the stream.\r\n     */\n\n  }, {\n    key: \"entries\",\n    value: /*#__PURE__*/regenerator.mark(function entries() {\n      var _iterator2, _step2, _step2$value, id, item;\n\n      return regenerator.wrap(function entries$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iterator2 = _createForOfIteratorHelper$1(this._pairs);\n              _context2.prev = 1;\n\n              _iterator2.s();\n\n            case 3:\n              if ((_step2 = _iterator2.n()).done) {\n                _context2.next = 9;\n                break;\n              }\n\n              _step2$value = slicedToArray(_step2.value, 2), id = _step2$value[0], item = _step2$value[1];\n              _context2.next = 7;\n              return [id, item];\n\n            case 7:\n              _context2.next = 3;\n              break;\n\n            case 9:\n              _context2.next = 14;\n              break;\n\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](1);\n\n              _iterator2.e(_context2.t0);\n\n            case 14:\n              _context2.prev = 14;\n\n              _iterator2.f();\n\n              return _context2.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, entries, this, [[1, 11, 14, 17]]);\n    })\n    /**\r\n     * Return an iterable of keys in the stream.\r\n     */\n\n  }, {\n    key: \"keys\",\n    value: /*#__PURE__*/regenerator.mark(function keys() {\n      var _iterator3, _step3, _step3$value, id;\n\n      return regenerator.wrap(function keys$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _iterator3 = _createForOfIteratorHelper$1(this._pairs);\n              _context3.prev = 1;\n\n              _iterator3.s();\n\n            case 3:\n              if ((_step3 = _iterator3.n()).done) {\n                _context3.next = 9;\n                break;\n              }\n\n              _step3$value = slicedToArray(_step3.value, 1), id = _step3$value[0];\n              _context3.next = 7;\n              return id;\n\n            case 7:\n              _context3.next = 3;\n              break;\n\n            case 9:\n              _context3.next = 14;\n              break;\n\n            case 11:\n              _context3.prev = 11;\n              _context3.t0 = _context3[\"catch\"](1);\n\n              _iterator3.e(_context3.t0);\n\n            case 14:\n              _context3.prev = 14;\n\n              _iterator3.f();\n\n              return _context3.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, keys, this, [[1, 11, 14, 17]]);\n    })\n    /**\r\n     * Return an iterable of values in the stream.\r\n     */\n\n  }, {\n    key: \"values\",\n    value: /*#__PURE__*/regenerator.mark(function values() {\n      var _iterator4, _step4, _step4$value, item;\n\n      return regenerator.wrap(function values$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _iterator4 = _createForOfIteratorHelper$1(this._pairs);\n              _context4.prev = 1;\n\n              _iterator4.s();\n\n            case 3:\n              if ((_step4 = _iterator4.n()).done) {\n                _context4.next = 9;\n                break;\n              }\n\n              _step4$value = slicedToArray(_step4.value, 2), item = _step4$value[1];\n              _context4.next = 7;\n              return item;\n\n            case 7:\n              _context4.next = 3;\n              break;\n\n            case 9:\n              _context4.next = 14;\n              break;\n\n            case 11:\n              _context4.prev = 11;\n              _context4.t0 = _context4[\"catch\"](1);\n\n              _iterator4.e(_context4.t0);\n\n            case 14:\n              _context4.prev = 14;\n\n              _iterator4.f();\n\n              return _context4.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, values, this, [[1, 11, 14, 17]]);\n    })\n    /**\r\n     * Return an array containing all the ids in this stream.\r\n     *\r\n     * @remarks\r\n     * The array may contain duplicities.\r\n     *\r\n     * @returns The array with all ids from this stream.\r\n     */\n\n  }, {\n    key: \"toIdArray\",\n    value: function toIdArray() {\n      var _context5;\n\n      return map$2(_context5 = toConsumableArray(this._pairs)).call(_context5, function (pair) {\n        return pair[0];\n      });\n    }\n    /**\r\n     * Return an array containing all the items in this stream.\r\n     *\r\n     * @remarks\r\n     * The array may contain duplicities.\r\n     *\r\n     * @returns The array with all items from this stream.\r\n     */\n\n  }, {\n    key: \"toItemArray\",\n    value: function toItemArray() {\n      var _context6;\n\n      return map$2(_context6 = toConsumableArray(this._pairs)).call(_context6, function (pair) {\n        return pair[1];\n      });\n    }\n    /**\r\n     * Return an array containing all the entries in this stream.\r\n     *\r\n     * @remarks\r\n     * The array may contain duplicities.\r\n     *\r\n     * @returns The array with all entries from this stream.\r\n     */\n\n  }, {\n    key: \"toEntryArray\",\n    value: function toEntryArray() {\n      return toConsumableArray(this._pairs);\n    }\n    /**\r\n     * Return an object map containing all the items in this stream accessible by ids.\r\n     *\r\n     * @remarks\r\n     * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.\r\n     *\r\n     * @returns The object map of all id → item pairs from this stream.\r\n     */\n\n  }, {\n    key: \"toObjectMap\",\n    value: function toObjectMap() {\n      var map = create$2(null);\n\n      var _iterator5 = _createForOfIteratorHelper$1(this._pairs),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = slicedToArray(_step5.value, 2),\n              id = _step5$value[0],\n              item = _step5$value[1];\n\n          map[id] = item;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return map;\n    }\n    /**\r\n     * Return a map containing all the items in this stream accessible by ids.\r\n     *\r\n     * @returns The map of all id → item pairs from this stream.\r\n     */\n\n  }, {\n    key: \"toMap\",\n    value: function toMap() {\n      return new map$5(this._pairs);\n    }\n    /**\r\n     * Return a set containing all the (unique) ids in this stream.\r\n     *\r\n     * @returns The set of all ids from this stream.\r\n     */\n\n  }, {\n    key: \"toIdSet\",\n    value: function toIdSet() {\n      return new set$3(this.toIdArray());\n    }\n    /**\r\n     * Return a set containing all the (unique) items in this stream.\r\n     *\r\n     * @returns The set of all items from this stream.\r\n     */\n\n  }, {\n    key: \"toItemSet\",\n    value: function toItemSet() {\n      return new set$3(this.toItemArray());\n    }\n    /**\r\n     * Cache the items from this stream.\r\n     *\r\n     * @remarks\r\n     * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.\r\n     * It can also be used to optimize performance as [[DataStream]] would otherwise reevaluate everything upon each iteration.\r\n     *\r\n     * ## Example\r\n     * ```javascript\r\n     * const ds = new DataSet([…])\r\n     *\r\n     * const cachedStream = ds.stream()\r\n     *   .filter(…)\r\n     *   .sort(…)\r\n     *   .map(…)\r\n     *   .cached(…) // Data are fetched, processed and cached here.\r\n     *\r\n     * ds.clear()\r\n     * chachedStream // Still has all the items.\r\n     * ```\r\n     *\r\n     * @returns A new [[DataStream]] with cached items (detached from the original [[DataSet]]).\r\n     */\n\n  }, {\n    key: \"cache\",\n    value: function cache() {\n      return new DataStream(toConsumableArray(this._pairs));\n    }\n    /**\r\n     * Get the distinct values of given property.\r\n     *\r\n     * @param callback - The function that picks and possibly converts the property.\r\n     *\r\n     * @typeParam T - The type of the distinct value.\r\n     *\r\n     * @returns A set of all distinct properties.\r\n     */\n\n  }, {\n    key: \"distinct\",\n    value: function distinct(callback) {\n      var set = new set$3();\n\n      var _iterator6 = _createForOfIteratorHelper$1(this._pairs),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = slicedToArray(_step6.value, 2),\n              id = _step6$value[0],\n              item = _step6$value[1];\n\n          set.add(callback(item, id));\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return set;\n    }\n    /**\r\n     * Filter the items of the stream.\r\n     *\r\n     * @param callback - The function that decides whether an item will be included.\r\n     *\r\n     * @returns A new data stream with the filtered items.\r\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(callback) {\n      var pairs = this._pairs;\n      return new DataStream(defineProperty$7({}, iterator$4, /*#__PURE__*/regenerator.mark(function _callee() {\n        var _iterator7, _step7, _step7$value, id, item;\n\n        return regenerator.wrap(function _callee$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _iterator7 = _createForOfIteratorHelper$1(pairs);\n                _context7.prev = 1;\n\n                _iterator7.s();\n\n              case 3:\n                if ((_step7 = _iterator7.n()).done) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                _step7$value = slicedToArray(_step7.value, 2), id = _step7$value[0], item = _step7$value[1];\n\n                if (!callback(item, id)) {\n                  _context7.next = 8;\n                  break;\n                }\n\n                _context7.next = 8;\n                return [id, item];\n\n              case 8:\n                _context7.next = 3;\n                break;\n\n              case 10:\n                _context7.next = 15;\n                break;\n\n              case 12:\n                _context7.prev = 12;\n                _context7.t0 = _context7[\"catch\"](1);\n\n                _iterator7.e(_context7.t0);\n\n              case 15:\n                _context7.prev = 15;\n\n                _iterator7.f();\n\n                return _context7.finish(15);\n\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee, null, [[1, 12, 15, 18]]);\n      })));\n    }\n    /**\r\n     * Execute a callback for each item of the stream.\r\n     *\r\n     * @param callback - The function that will be invoked for each item.\r\n     */\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      var _iterator8 = _createForOfIteratorHelper$1(this._pairs),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = slicedToArray(_step8.value, 2),\n              id = _step8$value[0],\n              item = _step8$value[1];\n\n          callback(item, id);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n    /**\r\n     * Map the items into a different type.\r\n     *\r\n     * @param callback - The function that does the conversion.\r\n     *\r\n     * @typeParam Mapped - The type of the item after mapping.\r\n     *\r\n     * @returns A new data stream with the mapped items.\r\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(callback) {\n      var pairs = this._pairs;\n      return new DataStream(defineProperty$7({}, iterator$4, /*#__PURE__*/regenerator.mark(function _callee2() {\n        var _iterator9, _step9, _step9$value, id, item;\n\n        return regenerator.wrap(function _callee2$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _iterator9 = _createForOfIteratorHelper$1(pairs);\n                _context8.prev = 1;\n\n                _iterator9.s();\n\n              case 3:\n                if ((_step9 = _iterator9.n()).done) {\n                  _context8.next = 9;\n                  break;\n                }\n\n                _step9$value = slicedToArray(_step9.value, 2), id = _step9$value[0], item = _step9$value[1];\n                _context8.next = 7;\n                return [id, callback(item, id)];\n\n              case 7:\n                _context8.next = 3;\n                break;\n\n              case 9:\n                _context8.next = 14;\n                break;\n\n              case 11:\n                _context8.prev = 11;\n                _context8.t0 = _context8[\"catch\"](1);\n\n                _iterator9.e(_context8.t0);\n\n              case 14:\n                _context8.prev = 14;\n\n                _iterator9.f();\n\n                return _context8.finish(14);\n\n              case 17:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee2, null, [[1, 11, 14, 17]]);\n      })));\n    }\n    /**\r\n     * Get the item with the maximum value of given property.\r\n     *\r\n     * @param callback - The function that picks and possibly converts the property.\r\n     *\r\n     * @returns The item with the maximum if found otherwise null.\r\n     */\n\n  }, {\n    key: \"max\",\n    value: function max(callback) {\n      var iter = getIterator$1(this._pairs);\n      var curr = iter.next();\n\n      if (curr.done) {\n        return null;\n      }\n\n      var maxItem = curr.value[1];\n      var maxValue = callback(curr.value[1], curr.value[0]);\n\n      while (!(curr = iter.next()).done) {\n        var _curr$value = slicedToArray(curr.value, 2),\n            id = _curr$value[0],\n            item = _curr$value[1];\n\n        var _value = callback(item, id);\n\n        if (_value > maxValue) {\n          maxValue = _value;\n          maxItem = item;\n        }\n      }\n\n      return maxItem;\n    }\n    /**\r\n     * Get the item with the minimum value of given property.\r\n     *\r\n     * @param callback - The function that picks and possibly converts the property.\r\n     *\r\n     * @returns The item with the minimum if found otherwise null.\r\n     */\n\n  }, {\n    key: \"min\",\n    value: function min(callback) {\n      var iter = getIterator$1(this._pairs);\n      var curr = iter.next();\n\n      if (curr.done) {\n        return null;\n      }\n\n      var minItem = curr.value[1];\n      var minValue = callback(curr.value[1], curr.value[0]);\n\n      while (!(curr = iter.next()).done) {\n        var _curr$value2 = slicedToArray(curr.value, 2),\n            id = _curr$value2[0],\n            item = _curr$value2[1];\n\n        var _value2 = callback(item, id);\n\n        if (_value2 < minValue) {\n          minValue = _value2;\n          minItem = item;\n        }\n      }\n\n      return minItem;\n    }\n    /**\r\n     * Reduce the items into a single value.\r\n     *\r\n     * @param callback - The function that does the reduction.\r\n     * @param accumulator - The initial value of the accumulator.\r\n     *\r\n     * @typeParam T - The type of the accumulated value.\r\n     *\r\n     * @returns The reduced value.\r\n     */\n\n  }, {\n    key: \"reduce\",\n    value: function reduce(callback, accumulator) {\n      var _iterator10 = _createForOfIteratorHelper$1(this._pairs),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _step10$value = slicedToArray(_step10.value, 2),\n              id = _step10$value[0],\n              item = _step10$value[1];\n\n          accumulator = callback(accumulator, item, id);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      return accumulator;\n    }\n    /**\r\n     * Sort the items.\r\n     *\r\n     * @param callback - Item comparator.\r\n     *\r\n     * @returns A new stream with sorted items.\r\n     */\n\n  }, {\n    key: \"sort\",\n    value: function sort(callback) {\n      var _this = this;\n\n      return new DataStream(defineProperty$7({}, iterator$4, function () {\n        var _context9;\n\n        return getIterator$1(sort$2(_context9 = toConsumableArray(_this._pairs)).call(_context9, function (_ref, _ref2) {\n          var _ref3 = slicedToArray(_ref, 2),\n              idA = _ref3[0],\n              itemA = _ref3[1];\n\n          var _ref4 = slicedToArray(_ref2, 2),\n              idB = _ref4[0],\n              itemB = _ref4[1];\n\n          return callback(itemA, itemB, idA, idB);\n        }));\n      }));\n    }\n  }]);\n  return DataStream;\n}();\n\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = keys$3(object);\n\n  if (getOwnPropertySymbols$2) {\n    var symbols = getOwnPropertySymbols$2(object);\n    if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) {\n      return getOwnPropertyDescriptor$3(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      var _context10;\n\n      forEach$2(_context10 = ownKeys$4(Object(source), true)).call(_context10, function (key) {\n        defineProperty$7(target, key, source[key]);\n      });\n    } else if (getOwnPropertyDescriptors$2) {\n      defineProperties$1(target, getOwnPropertyDescriptors$2(source));\n    } else {\n      var _context11;\n\n      forEach$2(_context11 = ownKeys$4(Object(source))).call(_context11, function (key) {\n        defineProperty$4(target, key, getOwnPropertyDescriptor$3(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$3(o, minLen) {\n  var _context9;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen);\n  var n = slice$6(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);\n}\n\nfunction _arrayLikeToArray$3(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$3(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$3(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * Add an id to given item if it doesn't have one already.\r\n *\r\n * @remarks\r\n * The item will be modified.\r\n *\r\n * @param item - The item that will have an id after a call to this function.\r\n * @param idProp - The key of the id property.\r\n *\r\n * @typeParam Item - Item type that may or may not have an id.\r\n * @typeParam IdProp - Name of the property that contains the id.\r\n *\r\n * @returns true\r\n */\n\n\nfunction ensureFullItem(item, idProp) {\n  if (item[idProp] == null) {\n    // generate an id\n    item[idProp] = v4();\n  }\n\n  return item;\n}\n/**\r\n * # DataSet\r\n *\r\n * Vis.js comes with a flexible DataSet, which can be used to hold and\r\n * manipulate unstructured data and listen for changes in the data. The DataSet\r\n * is key/value based. Data items can be added, updated and removed from the\r\n * DataSet, and one can subscribe to changes in the DataSet. The data in the\r\n * DataSet can be filtered and ordered. Data can be normalized when appending it\r\n * to the DataSet as well.\r\n *\r\n * ## Example\r\n *\r\n * The following example shows how to use a DataSet.\r\n *\r\n * ```javascript\r\n * // create a DataSet\r\n * var options = {};\r\n * var data = new vis.DataSet(options);\r\n *\r\n * // add items\r\n * // note that the data items can contain different properties and data formats\r\n * data.add([\r\n *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},\r\n *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},\r\n *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},\r\n *   {id: 4, text: 'item 4'}\r\n * ]);\r\n *\r\n * // subscribe to any change in the DataSet\r\n * data.on('*', function (event, properties, senderId) {\r\n *   console.log('event', event, properties);\r\n * });\r\n *\r\n * // update an existing item\r\n * data.update({id: 2, group: 1});\r\n *\r\n * // remove an item\r\n * data.remove(4);\r\n *\r\n * // get all ids\r\n * var ids = data.getIds();\r\n * console.log('ids', ids);\r\n *\r\n * // get a specific item\r\n * var item1 = data.get(1);\r\n * console.log('item1', item1);\r\n *\r\n * // retrieve a filtered subset of the data\r\n * var items = data.get({\r\n *   filter: function (item) {\r\n *     return item.group == 1;\r\n *   }\r\n * });\r\n * console.log('filtered items', items);\r\n * ```\r\n *\r\n * @typeParam Item - Item type that may or may not have an id.\r\n * @typeParam IdProp - Name of the property that contains the id.\r\n */\n\n\nvar DataSet = /*#__PURE__*/function (_DataSetPart) {\n  inherits(DataSet, _DataSetPart);\n\n  var _super = _createSuper(DataSet);\n  /**\r\n   * Construct a new DataSet.\r\n   *\r\n   * @param data - Initial data or options.\r\n   * @param options - Options (type error if data is also options).\r\n   */\n\n\n  function DataSet(data, options) {\n    var _this;\n\n    classCallCheck(this, DataSet);\n    _this = _super.call(this);\n    _this._queue = null; // correctly read optional arguments\n\n    if (data && !isArray$5(data)) {\n      options = data;\n      data = [];\n    }\n\n    _this._options = options || {};\n    _this._data = new map$5(); // map with data indexed by id\n\n    _this.length = 0; // number of items in the DataSet\n\n    _this._idProp = _this._options.fieldId || \"id\"; // name of the field containing id\n    // add initial data when provided\n\n    if (data && data.length) {\n      _this.add(data);\n    }\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n  /** @inheritDoc */\n\n\n  createClass(DataSet, [{\n    key: \"setOptions\",\n\n    /**\r\n     * Set new options.\r\n     *\r\n     * @param options - The new options.\r\n     */\n    value: function setOptions(options) {\n      if (options && options.queue !== undefined) {\n        if (options.queue === false) {\n          // delete queue if loaded\n          if (this._queue) {\n            this._queue.destroy();\n\n            this._queue = null;\n          }\n        } else {\n          // create queue and update its options\n          if (!this._queue) {\n            this._queue = Queue.extend(this, {\n              replace: [\"add\", \"update\", \"remove\"]\n            });\n          }\n\n          if (options.queue && _typeof_1(options.queue) === \"object\") {\n            this._queue.setOptions(options.queue);\n          }\n        }\n      }\n    }\n    /**\r\n     * Add a data item or an array with items.\r\n     *\r\n     * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.\r\n     *\r\n     * ## Example\r\n     *\r\n     * ```javascript\r\n     * // create a DataSet\r\n     * const data = new vis.DataSet()\r\n     *\r\n     * // add items\r\n     * const ids = data.add([\r\n     *   { id: 1, text: 'item 1' },\r\n     *   { id: 2, text: 'item 2' },\r\n     *   { text: 'item without an id' }\r\n     * ])\r\n     *\r\n     * console.log(ids) // [1, 2, '<UUIDv4>']\r\n     * ```\r\n     *\r\n     * @param data - Items to be added (ids will be generated if missing).\r\n     * @param senderId - Sender id.\r\n     *\r\n     * @returns addedIds - Array with the ids (generated if not present) of the added items.\r\n     *\r\n     * @throws When an item with the same id as any of the added items already exists.\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(data, senderId) {\n      var _this2 = this;\n\n      var addedIds = [];\n      var id;\n\n      if (isArray$5(data)) {\n        // Array\n        var idsToAdd = map$2(data).call(data, function (d) {\n          return d[_this2._idProp];\n        });\n\n        if (some$2(idsToAdd).call(idsToAdd, function (id) {\n          return _this2._data.has(id);\n        })) {\n          throw new Error(\"A duplicate id was found in the parameter array.\");\n        }\n\n        for (var i = 0, len = data.length; i < len; i++) {\n          id = this._addItem(data[i]);\n          addedIds.push(id);\n        }\n      } else if (data && _typeof_1(data) === \"object\") {\n        // Single item\n        id = this._addItem(data);\n        addedIds.push(id);\n      } else {\n        throw new Error(\"Unknown dataType\");\n      }\n\n      if (addedIds.length) {\n        this._trigger(\"add\", {\n          items: addedIds\n        }, senderId);\n      }\n\n      return addedIds;\n    }\n    /**\r\n     * Update existing items. When an item does not exist, it will be created.\r\n     *\r\n     * @remarks\r\n     * The provided properties will be merged in the existing item. When an item does not exist, it will be created.\r\n     *\r\n     * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.\r\n     *\r\n     * ## Example\r\n     *\r\n     * ```javascript\r\n     * // create a DataSet\r\n     * const data = new vis.DataSet([\r\n     *   { id: 1, text: 'item 1' },\r\n     *   { id: 2, text: 'item 2' },\r\n     *   { id: 3, text: 'item 3' }\r\n     * ])\r\n     *\r\n     * // update items\r\n     * const ids = data.update([\r\n     *   { id: 2, text: 'item 2 (updated)' },\r\n     *   { id: 4, text: 'item 4 (new)' }\r\n     * ])\r\n     *\r\n     * console.log(ids) // [2, 4]\r\n     * ```\r\n     *\r\n     * ## Warning for TypeScript users\r\n     * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.\r\n     *\r\n     * @param data - Items to be updated (if the id is already present) or added (if the id is missing).\r\n     * @param senderId - Sender id.\r\n     *\r\n     * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.\r\n     *\r\n     * @throws When the supplied data is neither an item nor an array of items.\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(data, senderId) {\n      var _this3 = this;\n\n      var addedIds = [];\n      var updatedIds = [];\n      var oldData = [];\n      var updatedData = [];\n      var idProp = this._idProp;\n\n      var addOrUpdate = function addOrUpdate(item) {\n        var origId = item[idProp];\n\n        if (origId != null && _this3._data.has(origId)) {\n          var fullItem = item; // it has an id, therefore it is a fullitem\n\n          var oldItem = assign$2({}, _this3._data.get(origId)); // update item\n\n          var id = _this3._updateItem(fullItem);\n\n          updatedIds.push(id);\n          updatedData.push(fullItem);\n          oldData.push(oldItem);\n        } else {\n          // add new item\n          var _id = _this3._addItem(item);\n\n          addedIds.push(_id);\n        }\n      };\n\n      if (isArray$5(data)) {\n        // Array\n        for (var i = 0, len = data.length; i < len; i++) {\n          if (data[i] && _typeof_1(data[i]) === \"object\") {\n            addOrUpdate(data[i]);\n          } else {\n            console.warn(\"Ignoring input item, which is not an object at index \" + i);\n          }\n        }\n      } else if (data && _typeof_1(data) === \"object\") {\n        // Single item\n        addOrUpdate(data);\n      } else {\n        throw new Error(\"Unknown dataType\");\n      }\n\n      if (addedIds.length) {\n        this._trigger(\"add\", {\n          items: addedIds\n        }, senderId);\n      }\n\n      if (updatedIds.length) {\n        var props = {\n          items: updatedIds,\n          oldData: oldData,\n          data: updatedData\n        }; // TODO: remove deprecated property 'data' some day\n        //Object.defineProperty(props, 'data', {\n        //  'get': (function() {\n        //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');\n        //    return updatedData;\n        //  }).bind(this)\n        //});\n\n        this._trigger(\"update\", props, senderId);\n      }\n\n      return concat$2(addedIds).call(addedIds, updatedIds);\n    }\n    /**\r\n     * Update existing items. When an item does not exist, an error will be thrown.\r\n     *\r\n     * @remarks\r\n     * The provided properties will be deeply merged into the existing item.\r\n     * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.\r\n     *\r\n     * After the items are updated, the DataSet will trigger an event `update`.\r\n     * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.\r\n     *\r\n     * ## Example\r\n     *\r\n     * ```javascript\r\n     * // create a DataSet\r\n     * const data = new vis.DataSet([\r\n     *   { id: 1, text: 'item 1' },\r\n     *   { id: 2, text: 'item 2' },\r\n     *   { id: 3, text: 'item 3' },\r\n     * ])\r\n     *\r\n     * // update items\r\n     * const ids = data.update([\r\n     *   { id: 2, text: 'item 2 (updated)' }, // works\r\n     *   // { id: 4, text: 'item 4 (new)' }, // would throw\r\n     *   // { text: 'item 4 (new)' }, // would also throw\r\n     * ])\r\n     *\r\n     * console.log(ids) // [2]\r\n     * ```\r\n     *\r\n     * @param data - Updates (the id and optionally other props) to the items in this data set.\r\n     * @param senderId - Sender id.\r\n     *\r\n     * @returns updatedIds - The ids of the updated items.\r\n     *\r\n     * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.\r\n     */\n\n  }, {\n    key: \"updateOnly\",\n    value: function updateOnly(data, senderId) {\n      var _context,\n          _this4 = this;\n\n      if (!isArray$5(data)) {\n        data = [data];\n      }\n\n      var updateEventData = map$2(_context = map$2(data).call(data, function (update) {\n        var oldData = _this4._data.get(update[_this4._idProp]);\n\n        if (oldData == null) {\n          throw new Error(\"Updating non-existent items is not allowed.\");\n        }\n\n        return {\n          oldData: oldData,\n          update: update\n        };\n      })).call(_context, function (_ref) {\n        var oldData = _ref.oldData,\n            update = _ref.update;\n        var id = oldData[_this4._idProp];\n        var updatedData = pureDeepObjectAssign(oldData, update);\n\n        _this4._data.set(id, updatedData);\n\n        return {\n          id: id,\n          oldData: oldData,\n          updatedData: updatedData\n        };\n      });\n\n      if (updateEventData.length) {\n        var props = {\n          items: map$2(updateEventData).call(updateEventData, function (value) {\n            return value.id;\n          }),\n          oldData: map$2(updateEventData).call(updateEventData, function (value) {\n            return value.oldData;\n          }),\n          data: map$2(updateEventData).call(updateEventData, function (value) {\n            return value.updatedData;\n          })\n        }; // TODO: remove deprecated property 'data' some day\n        //Object.defineProperty(props, 'data', {\n        //  'get': (function() {\n        //    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');\n        //    return updatedData;\n        //  }).bind(this)\n        //});\n\n        this._trigger(\"update\", props, senderId);\n\n        return props.items;\n      } else {\n        return [];\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"get\",\n    value: function get(first, second) {\n      // @TODO: Woudn't it be better to split this into multiple methods?\n      // parse the arguments\n      var id = undefined;\n      var ids = undefined;\n      var options = undefined;\n\n      if (isId(first)) {\n        // get(id [, options])\n        id = first;\n        options = second;\n      } else if (isArray$5(first)) {\n        // get(ids [, options])\n        ids = first;\n        options = second;\n      } else {\n        // get([, options])\n        options = first;\n      } // determine the return type\n\n\n      var returnType = options && options.returnType === \"Object\" ? \"Object\" : \"Array\"; // @TODO: WTF is this? Or am I missing something?\n      // var returnType\n      // if (options && options.returnType) {\n      //   var allowedValues = ['Array', 'Object']\n      //   returnType =\n      //     allowedValues.indexOf(options.returnType) == -1\n      //       ? 'Array'\n      //       : options.returnType\n      // } else {\n      //   returnType = 'Array'\n      // }\n      // build options\n\n      var filter = options && filter$2(options);\n      var items = [];\n      var item = undefined;\n      var itemIds = undefined;\n      var itemId = undefined; // convert items\n\n      if (id != null) {\n        // return a single item\n        item = this._data.get(id);\n\n        if (item && filter && !filter(item)) {\n          item = undefined;\n        }\n      } else if (ids != null) {\n        // return a subset of items\n        for (var i = 0, len = ids.length; i < len; i++) {\n          item = this._data.get(ids[i]);\n\n          if (item != null && (!filter || filter(item))) {\n            items.push(item);\n          }\n        }\n      } else {\n        var _context2; // return all items\n\n\n        itemIds = toConsumableArray(keys$6(_context2 = this._data).call(_context2));\n\n        for (var _i = 0, _len = itemIds.length; _i < _len; _i++) {\n          itemId = itemIds[_i];\n          item = this._data.get(itemId);\n\n          if (item != null && (!filter || filter(item))) {\n            items.push(item);\n          }\n        }\n      } // order the results\n\n\n      if (options && options.order && id == undefined) {\n        this._sort(items, options.order);\n      } // filter fields of the items\n\n\n      if (options && options.fields) {\n        var fields = options.fields;\n\n        if (id != undefined && item != null) {\n          item = this._filterFields(item, fields);\n        } else {\n          for (var _i2 = 0, _len2 = items.length; _i2 < _len2; _i2++) {\n            items[_i2] = this._filterFields(items[_i2], fields);\n          }\n        }\n      } // return the results\n\n\n      if (returnType == \"Object\") {\n        var result = {};\n\n        for (var _i3 = 0, _len3 = items.length; _i3 < _len3; _i3++) {\n          var resultant = items[_i3]; // @TODO: Shoudn't this be this._fieldId?\n          // result[resultant.id] = resultant\n\n          var _id2 = resultant[this._idProp];\n          result[_id2] = resultant;\n        }\n\n        return result;\n      } else {\n        if (id != null) {\n          var _item; // a single item\n\n\n          return (_item = item) !== null && _item !== void 0 ? _item : null;\n        } else {\n          // just return our array\n          return items;\n        }\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getIds\",\n    value: function getIds(options) {\n      var data = this._data;\n      var filter = options && filter$2(options);\n      var order = options && options.order;\n      var itemIds = toConsumableArray(keys$6(data).call(data));\n      var ids = [];\n\n      if (filter) {\n        // get filtered items\n        if (order) {\n          // create ordered list\n          var items = [];\n\n          for (var i = 0, len = itemIds.length; i < len; i++) {\n            var id = itemIds[i];\n\n            var item = this._data.get(id);\n\n            if (item != null && filter(item)) {\n              items.push(item);\n            }\n          }\n\n          this._sort(items, order);\n\n          for (var _i4 = 0, _len4 = items.length; _i4 < _len4; _i4++) {\n            ids.push(items[_i4][this._idProp]);\n          }\n        } else {\n          // create unordered list\n          for (var _i5 = 0, _len5 = itemIds.length; _i5 < _len5; _i5++) {\n            var _id3 = itemIds[_i5];\n\n            var _item2 = this._data.get(_id3);\n\n            if (_item2 != null && filter(_item2)) {\n              ids.push(_item2[this._idProp]);\n            }\n          }\n        }\n      } else {\n        // get all items\n        if (order) {\n          // create an ordered list\n          var _items = [];\n\n          for (var _i6 = 0, _len6 = itemIds.length; _i6 < _len6; _i6++) {\n            var _id4 = itemIds[_i6];\n\n            _items.push(data.get(_id4));\n          }\n\n          this._sort(_items, order);\n\n          for (var _i7 = 0, _len7 = _items.length; _i7 < _len7; _i7++) {\n            ids.push(_items[_i7][this._idProp]);\n          }\n        } else {\n          // create unordered list\n          for (var _i8 = 0, _len8 = itemIds.length; _i8 < _len8; _i8++) {\n            var _id5 = itemIds[_i8];\n\n            var _item3 = data.get(_id5);\n\n            if (_item3 != null) {\n              ids.push(_item3[this._idProp]);\n            }\n          }\n        }\n      }\n\n      return ids;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getDataSet\",\n    value: function getDataSet() {\n      return this;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, options) {\n      var filter = options && filter$2(options);\n      var data = this._data;\n      var itemIds = toConsumableArray(keys$6(data).call(data));\n\n      if (options && options.order) {\n        // execute forEach on ordered list\n        var items = this.get(options);\n\n        for (var i = 0, len = items.length; i < len; i++) {\n          var item = items[i];\n          var id = item[this._idProp];\n          callback(item, id);\n        }\n      } else {\n        // unordered\n        for (var _i9 = 0, _len9 = itemIds.length; _i9 < _len9; _i9++) {\n          var _id6 = itemIds[_i9];\n\n          var _item4 = this._data.get(_id6);\n\n          if (_item4 != null && (!filter || filter(_item4))) {\n            callback(_item4, _id6);\n          }\n        }\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"map\",\n    value: function map(callback, options) {\n      var filter = options && filter$2(options);\n      var mappedItems = [];\n      var data = this._data;\n      var itemIds = toConsumableArray(keys$6(data).call(data)); // convert and filter items\n\n      for (var i = 0, len = itemIds.length; i < len; i++) {\n        var id = itemIds[i];\n\n        var item = this._data.get(id);\n\n        if (item != null && (!filter || filter(item))) {\n          mappedItems.push(callback(item, id));\n        }\n      } // order items\n\n\n      if (options && options.order) {\n        this._sort(mappedItems, options.order);\n      }\n\n      return mappedItems;\n    }\n    /**\r\n     * Filter the fields of an item.\r\n     *\r\n     * @param item - The item whose fields should be filtered.\r\n     * @param fields - The names of the fields that will be kept.\r\n     *\r\n     * @typeParam K - Field name type.\r\n     *\r\n     * @returns The item without any additional fields.\r\n     */\n\n  }, {\n    key: \"_filterFields\",\n    value: function _filterFields(item, fields) {\n      var _context3;\n\n      if (!item) {\n        // item is null\n        return item;\n      }\n\n      return reduce$2(_context3 = isArray$5(fields) ? // Use the supplied array\n      fields : // Use the keys of the supplied object\n      keys$3(fields)).call(_context3, function (filteredItem, field) {\n        filteredItem[field] = item[field];\n        return filteredItem;\n      }, {});\n    }\n    /**\r\n     * Sort the provided array with items.\r\n     *\r\n     * @param items - Items to be sorted in place.\r\n     * @param order - A field name or custom sort function.\r\n     *\r\n     * @typeParam T - The type of the items in the items array.\r\n     */\n\n  }, {\n    key: \"_sort\",\n    value: function _sort(items, order) {\n      if (typeof order === \"string\") {\n        // order by provided field name\n        var name = order; // field name\n\n        sort$2(items).call(items, function (a, b) {\n          // @TODO: How to treat missing properties?\n          var av = a[name];\n          var bv = b[name];\n          return av > bv ? 1 : av < bv ? -1 : 0;\n        });\n      } else if (typeof order === \"function\") {\n        // order by sort function\n        sort$2(items).call(items, order);\n      } else {\n        // TODO: extend order by an Object {field:string, direction:string}\n        //       where direction can be 'asc' or 'desc'\n        throw new TypeError(\"Order must be a function or a string\");\n      }\n    }\n    /**\r\n     * Remove an item or multiple items by “reference” (only the id is used) or by id.\r\n     *\r\n     * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.\r\n     *\r\n     * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.\r\n     *\r\n     * ## Example\r\n     * ```javascript\r\n     * // create a DataSet\r\n     * const data = new vis.DataSet([\r\n     *   { id: 1, text: 'item 1' },\r\n     *   { id: 2, text: 'item 2' },\r\n     *   { id: 3, text: 'item 3' }\r\n     * ])\r\n     *\r\n     * // remove items\r\n     * const ids = data.remove([2, { id: 3 }, 4])\r\n     *\r\n     * console.log(ids) // [2, 3]\r\n     * ```\r\n     *\r\n     * @param id - One or more items or ids of items to be removed.\r\n     * @param senderId - Sender id.\r\n     *\r\n     * @returns The ids of the removed items.\r\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(id, senderId) {\n      var removedIds = [];\n      var removedItems = []; // force everything to be an array for simplicity\n\n      var ids = isArray$5(id) ? id : [id];\n\n      for (var i = 0, len = ids.length; i < len; i++) {\n        var item = this._remove(ids[i]);\n\n        if (item) {\n          var itemId = item[this._idProp];\n\n          if (itemId != null) {\n            removedIds.push(itemId);\n            removedItems.push(item);\n          }\n        }\n      }\n\n      if (removedIds.length) {\n        this._trigger(\"remove\", {\n          items: removedIds,\n          oldData: removedItems\n        }, senderId);\n      }\n\n      return removedIds;\n    }\n    /**\r\n     * Remove an item by its id or reference.\r\n     *\r\n     * @param id - Id of an item or the item itself.\r\n     *\r\n     * @returns The removed item if removed, null otherwise.\r\n     */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(id) {\n      // @TODO: It origianlly returned the item although the docs say id.\n      // The code expects the item, so probably an error in the docs.\n      var ident; // confirm the id to use based on the args type\n\n      if (isId(id)) {\n        ident = id;\n      } else if (id && _typeof_1(id) === \"object\") {\n        ident = id[this._idProp]; // look for the identifier field using ._idProp\n      } // do the removing if the item is found\n\n\n      if (ident != null && this._data.has(ident)) {\n        var item = this._data.get(ident) || null;\n\n        this._data.delete(ident);\n\n        --this.length;\n        return item;\n      }\n\n      return null;\n    }\n    /**\r\n     * Clear the entire data set.\r\n     *\r\n     * After the items are removed, the [[DataSet]] will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.\r\n     *\r\n     * @param senderId - Sender id.\r\n     *\r\n     * @returns removedIds - The ids of all removed items.\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear(senderId) {\n      var _context4;\n\n      var ids = toConsumableArray(keys$6(_context4 = this._data).call(_context4));\n      var items = [];\n\n      for (var i = 0, len = ids.length; i < len; i++) {\n        items.push(this._data.get(ids[i]));\n      }\n\n      this._data.clear();\n\n      this.length = 0;\n\n      this._trigger(\"remove\", {\n        items: ids,\n        oldData: items\n      }, senderId);\n\n      return ids;\n    }\n    /**\r\n     * Find the item with maximum value of a specified field.\r\n     *\r\n     * @param field - Name of the property that should be searched for max value.\r\n     *\r\n     * @returns Item containing max value, or null if no items.\r\n     */\n\n  }, {\n    key: \"max\",\n    value: function max(field) {\n      var _context5;\n\n      var max = null;\n      var maxField = null;\n\n      var _iterator = _createForOfIteratorHelper$2(values$3(_context5 = this._data).call(_context5)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          var itemField = item[field];\n\n          if (typeof itemField === \"number\" && (maxField == null || itemField > maxField)) {\n            max = item;\n            maxField = itemField;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return max || null;\n    }\n    /**\r\n     * Find the item with minimum value of a specified field.\r\n     *\r\n     * @param field - Name of the property that should be searched for min value.\r\n     *\r\n     * @returns Item containing min value, or null if no items.\r\n     */\n\n  }, {\n    key: \"min\",\n    value: function min(field) {\n      var _context6;\n\n      var min = null;\n      var minField = null;\n\n      var _iterator2 = _createForOfIteratorHelper$2(values$3(_context6 = this._data).call(_context6)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          var itemField = item[field];\n\n          if (typeof itemField === \"number\" && (minField == null || itemField < minField)) {\n            min = item;\n            minField = itemField;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return min || null;\n    }\n    /**\r\n     * Find all distinct values of a specified field\r\n     *\r\n     * @param prop - The property name whose distinct values should be returned.\r\n     *\r\n     * @returns Unordered array containing all distinct values. Items without specified property are ignored.\r\n     */\n\n  }, {\n    key: \"distinct\",\n    value: function distinct(prop) {\n      var data = this._data;\n      var itemIds = toConsumableArray(keys$6(data).call(data));\n      var values = [];\n      var count = 0;\n\n      for (var i = 0, len = itemIds.length; i < len; i++) {\n        var id = itemIds[i];\n        var item = data.get(id);\n        var value = item[prop];\n        var exists = false;\n\n        for (var j = 0; j < count; j++) {\n          if (values[j] == value) {\n            exists = true;\n            break;\n          }\n        }\n\n        if (!exists && value !== undefined) {\n          values[count] = value;\n          count++;\n        }\n      }\n\n      return values;\n    }\n    /**\r\n     * Add a single item. Will fail when an item with the same id already exists.\r\n     *\r\n     * @param item - A new item to be added.\r\n     *\r\n     * @returns Added item's id. An id is generated when it is not present in the item.\r\n     */\n\n  }, {\n    key: \"_addItem\",\n    value: function _addItem(item) {\n      var fullItem = ensureFullItem(item, this._idProp);\n      var id = fullItem[this._idProp]; // check whether this id is already taken\n\n      if (this._data.has(id)) {\n        // item already exists\n        throw new Error(\"Cannot add item: item with id \" + id + \" already exists\");\n      }\n\n      this._data.set(id, fullItem);\n\n      ++this.length;\n      return id;\n    }\n    /**\r\n     * Update a single item: merge with existing item.\r\n     * Will fail when the item has no id, or when there does not exist an item with the same id.\r\n     *\r\n     * @param update - The new item\r\n     *\r\n     * @returns The id of the updated item.\r\n     */\n\n  }, {\n    key: \"_updateItem\",\n    value: function _updateItem(update) {\n      var id = update[this._idProp];\n\n      if (id == null) {\n        throw new Error(\"Cannot update item: item has no id (item: \" + stringify$2(update) + \")\");\n      }\n\n      var item = this._data.get(id);\n\n      if (!item) {\n        // item doesn't exist\n        throw new Error(\"Cannot update item: no item with id \" + id + \" found\");\n      }\n\n      this._data.set(id, _objectSpread(_objectSpread({}, item), update));\n\n      return id;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"stream\",\n    value: function stream(ids) {\n      if (ids) {\n        var data = this._data;\n        return new DataStream(defineProperty$7({}, iterator$4, /*#__PURE__*/regenerator.mark(function _callee() {\n          var _iterator3, _step3, id, item;\n\n          return regenerator.wrap(function _callee$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  _iterator3 = _createForOfIteratorHelper$2(ids);\n                  _context7.prev = 1;\n\n                  _iterator3.s();\n\n                case 3:\n                  if ((_step3 = _iterator3.n()).done) {\n                    _context7.next = 11;\n                    break;\n                  }\n\n                  id = _step3.value;\n                  item = data.get(id);\n\n                  if (!(item != null)) {\n                    _context7.next = 9;\n                    break;\n                  }\n\n                  _context7.next = 9;\n                  return [id, item];\n\n                case 9:\n                  _context7.next = 3;\n                  break;\n\n                case 11:\n                  _context7.next = 16;\n                  break;\n\n                case 13:\n                  _context7.prev = 13;\n                  _context7.t0 = _context7[\"catch\"](1);\n\n                  _iterator3.e(_context7.t0);\n\n                case 16:\n                  _context7.prev = 16;\n\n                  _iterator3.f();\n\n                  return _context7.finish(16);\n\n                case 19:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee, null, [[1, 13, 16, 19]]);\n        })));\n      } else {\n        var _context8;\n\n        return new DataStream(defineProperty$7({}, iterator$4, bind$2(_context8 = entries$2(this._data)).call(_context8, this._data)));\n      }\n    }\n  }, {\n    key: \"idProp\",\n    get: function get() {\n      return this._idProp;\n    }\n  }]);\n  return DataSet;\n}(DataSetPart);\n\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$4(o, minLen) {\n  var _context5;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen);\n  var n = slice$6(_context5 = Object.prototype.toString.call(o)).call(_context5, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);\n}\n\nfunction _arrayLikeToArray$4(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper$1(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$3(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$3(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * DataView\r\n *\r\n * A DataView offers a filtered and/or formatted view on a DataSet. One can subscribe to changes in a DataView, and easily get filtered or formatted data without having to specify filters and field types all the time.\r\n *\r\n * ## Example\r\n * ```javascript\r\n * // create a DataSet\r\n * var data = new vis.DataSet();\r\n * data.add([\r\n *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},\r\n *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},\r\n *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},\r\n *   {id: 4, text: 'item 4'}\r\n * ]);\r\n *\r\n * // create a DataView\r\n * // the view will only contain items having a property group with value 1,\r\n * // and will only output fields id, text, and date.\r\n * var view = new vis.DataView(data, {\r\n *   filter: function (item) {\r\n *     return (item.group == 1);\r\n *   },\r\n *   fields: ['id', 'text', 'date']\r\n * });\r\n *\r\n * // subscribe to any change in the DataView\r\n * view.on('*', function (event, properties, senderId) {\r\n *   console.log('event', event, properties);\r\n * });\r\n *\r\n * // update an item in the data set\r\n * data.update({id: 2, group: 1});\r\n *\r\n * // get all ids in the view\r\n * var ids = view.getIds();\r\n * console.log('ids', ids); // will output [1, 2]\r\n *\r\n * // get all items in the view\r\n * var items = view.get();\r\n * ```\r\n *\r\n * @typeParam Item - Item type that may or may not have an id.\r\n * @typeParam IdProp - Name of the property that contains the id.\r\n */\n\n\nvar DataView = /*#__PURE__*/function (_DataSetPart) {\n  inherits(DataView, _DataSetPart);\n\n  var _super = _createSuper$1(DataView);\n  /**\r\n   * Create a DataView.\r\n   *\r\n   * @param data - The instance containing data (directly or indirectly).\r\n   * @param options - Options to configure this data view.\r\n   */\n\n\n  function DataView(data, options) {\n    var _context;\n\n    var _this;\n\n    classCallCheck(this, DataView);\n    _this = _super.call(this);\n    /** @inheritDoc */\n\n    _this.length = 0;\n    _this._ids = new set$3(); // ids of the items currently in memory (just contains a boolean true)\n\n    _this._options = options || {};\n    _this._listener = bind$2(_context = _this._onEvent).call(_context, assertThisInitialized(_this));\n\n    _this.setData(data);\n\n    return _this;\n  }\n  /** @inheritDoc */\n\n\n  createClass(DataView, [{\n    key: \"setData\",\n    // TODO: implement a function .config() to dynamically update things like configured filter\n    // and trigger changes accordingly\n\n    /**\r\n     * Set a data source for the view.\r\n     *\r\n     * @param data - The instance containing data (directly or indirectly).\r\n     *\r\n     * @remarks\r\n     * Note that when the data view is bound to a data set it won't be garbage\r\n     * collected unless the data set is too. Use `dataView.setData(null)` or\r\n     * `dataView.dispose()` to enable garbage collection before you lose the last\r\n     * reference.\r\n     */\n    value: function setData(data) {\n      if (this._data) {\n        // unsubscribe from current dataset\n        if (this._data.off) {\n          this._data.off(\"*\", this._listener);\n        } // trigger a remove of all items in memory\n\n\n        var ids = this._data.getIds({\n          filter: filter$2(this._options)\n        });\n\n        var items = this._data.get(ids);\n\n        this._ids.clear();\n\n        this.length = 0;\n\n        this._trigger(\"remove\", {\n          items: ids,\n          oldData: items\n        });\n      }\n\n      if (data != null) {\n        this._data = data; // trigger an add of all added items\n\n        var _ids = this._data.getIds({\n          filter: filter$2(this._options)\n        });\n\n        for (var i = 0, len = _ids.length; i < len; i++) {\n          var id = _ids[i];\n\n          this._ids.add(id);\n        }\n\n        this.length = _ids.length;\n\n        this._trigger(\"add\", {\n          items: _ids\n        });\n      } else {\n        this._data = new DataSet();\n      } // subscribe to new dataset\n\n\n      if (this._data.on) {\n        this._data.on(\"*\", this._listener);\n      }\n    }\n    /**\r\n     * Refresh the DataView.\r\n     * Useful when the DataView has a filter function containing a variable parameter.\r\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var ids = this._data.getIds({\n        filter: filter$2(this._options)\n      });\n\n      var oldIds = toConsumableArray(this._ids);\n      var newIds = {};\n      var addedIds = [];\n      var removedIds = [];\n      var removedItems = []; // check for additions\n\n      for (var i = 0, len = ids.length; i < len; i++) {\n        var id = ids[i];\n        newIds[id] = true;\n\n        if (!this._ids.has(id)) {\n          addedIds.push(id);\n\n          this._ids.add(id);\n        }\n      } // check for removals\n\n\n      for (var _i = 0, _len = oldIds.length; _i < _len; _i++) {\n        var _id = oldIds[_i];\n\n        var item = this._data.get(_id);\n\n        if (item == null) {\n          // @TODO: Investigate.\n          // Doesn't happen during tests or examples.\n          // Is it really impossible or could it eventually happen?\n          // How to handle it if it does? The types guarantee non-nullable items.\n          console.error(\"If you see this, report it please.\");\n        } else if (!newIds[_id]) {\n          removedIds.push(_id);\n          removedItems.push(item);\n\n          this._ids.delete(_id);\n        }\n      }\n\n      this.length += addedIds.length - removedIds.length; // trigger events\n\n      if (addedIds.length) {\n        this._trigger(\"add\", {\n          items: addedIds\n        });\n      }\n\n      if (removedIds.length) {\n        this._trigger(\"remove\", {\n          items: removedIds,\n          oldData: removedItems\n        });\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"get\",\n    value: function get(first, second) {\n      if (this._data == null) {\n        return null;\n      } // parse the arguments\n\n\n      var ids = null;\n      var options;\n\n      if (isId(first) || isArray$5(first)) {\n        ids = first;\n        options = second;\n      } else {\n        options = first;\n      } // extend the options with the default options and provided options\n\n\n      var viewOptions = assign$2({}, this._options, options); // create a combined filter method when needed\n\n      var thisFilter = filter$2(this._options);\n      var optionsFilter = options && filter$2(options);\n\n      if (thisFilter && optionsFilter) {\n        viewOptions.filter = function (item) {\n          return thisFilter(item) && optionsFilter(item);\n        };\n      }\n\n      if (ids == null) {\n        return this._data.get(viewOptions);\n      } else {\n        return this._data.get(ids, viewOptions);\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getIds\",\n    value: function getIds(options) {\n      if (this._data.length) {\n        var defaultFilter = filter$2(this._options);\n        var optionsFilter = options != null ? filter$2(options) : null;\n        var filter;\n\n        if (optionsFilter) {\n          if (defaultFilter) {\n            filter = function filter(item) {\n              return defaultFilter(item) && optionsFilter(item);\n            };\n          } else {\n            filter = optionsFilter;\n          }\n        } else {\n          filter = defaultFilter;\n        }\n\n        return this._data.getIds({\n          filter: filter,\n          order: options && options.order\n        });\n      } else {\n        return [];\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, options) {\n      if (this._data) {\n        var _context2;\n\n        var defaultFilter = filter$2(this._options);\n        var optionsFilter = options && filter$2(options);\n        var filter;\n\n        if (optionsFilter) {\n          if (defaultFilter) {\n            filter = function filter(item) {\n              return defaultFilter(item) && optionsFilter(item);\n            };\n          } else {\n            filter = optionsFilter;\n          }\n        } else {\n          filter = defaultFilter;\n        }\n\n        forEach$2(_context2 = this._data).call(_context2, callback, {\n          filter: filter,\n          order: options && options.order\n        });\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"map\",\n    value: function map(callback, options) {\n      if (this._data) {\n        var _context3;\n\n        var defaultFilter = filter$2(this._options);\n        var optionsFilter = options && filter$2(options);\n        var filter;\n\n        if (optionsFilter) {\n          if (defaultFilter) {\n            filter = function filter(item) {\n              return defaultFilter(item) && optionsFilter(item);\n            };\n          } else {\n            filter = optionsFilter;\n          }\n        } else {\n          filter = defaultFilter;\n        }\n\n        return map$2(_context3 = this._data).call(_context3, callback, {\n          filter: filter,\n          order: options && options.order\n        });\n      } else {\n        return [];\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getDataSet\",\n    value: function getDataSet() {\n      return this._data.getDataSet();\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"stream\",\n    value: function stream(ids) {\n      var _context4;\n\n      return this._data.stream(ids || defineProperty$7({}, iterator$4, bind$2(_context4 = keys$6(this._ids)).call(_context4, this._ids)));\n    }\n    /**\r\n     * Render the instance unusable prior to garbage collection.\r\n     *\r\n     * @remarks\r\n     * The intention of this method is to help discover scenarios where the data\r\n     * view is being used when the programmer thinks it has been garbage collected\r\n     * already. It's stricter version of `dataView.setData(null)`.\r\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this$_data;\n\n      if ((_this$_data = this._data) !== null && _this$_data !== void 0 && _this$_data.off) {\n        this._data.off(\"*\", this._listener);\n      }\n\n      var message = \"This data view has already been disposed of.\";\n      var replacement = {\n        get: function get() {\n          throw new Error(message);\n        },\n        set: function set() {\n          throw new Error(message);\n        },\n        configurable: false\n      };\n\n      var _iterator = _createForOfIteratorHelper$3(ownKeys$3(DataView.prototype)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          defineProperty$4(this, key, replacement);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\r\n     * Event listener. Will propagate all events from the connected data set to the subscribers of the DataView, but will filter the items and only trigger when there are changes in the filtered data set.\r\n     *\r\n     * @param event - The name of the event.\r\n     * @param params - Parameters of the event.\r\n     * @param senderId - Id supplied by the sender.\r\n     */\n\n  }, {\n    key: \"_onEvent\",\n    value: function _onEvent(event, params, senderId) {\n      if (!params || !params.items || !this._data) {\n        return;\n      }\n\n      var ids = params.items;\n      var addedIds = [];\n      var updatedIds = [];\n      var removedIds = [];\n      var oldItems = [];\n      var updatedItems = [];\n      var removedItems = [];\n\n      switch (event) {\n        case \"add\":\n          // filter the ids of the added items\n          for (var i = 0, len = ids.length; i < len; i++) {\n            var id = ids[i];\n            var item = this.get(id);\n\n            if (item) {\n              this._ids.add(id);\n\n              addedIds.push(id);\n            }\n          }\n\n          break;\n\n        case \"update\":\n          // determine the event from the views viewpoint: an updated\n          // item can be added, updated, or removed from this view.\n          for (var _i2 = 0, _len2 = ids.length; _i2 < _len2; _i2++) {\n            var _id2 = ids[_i2];\n\n            var _item = this.get(_id2);\n\n            if (_item) {\n              if (this._ids.has(_id2)) {\n                updatedIds.push(_id2);\n                updatedItems.push(params.data[_i2]);\n                oldItems.push(params.oldData[_i2]);\n              } else {\n                this._ids.add(_id2);\n\n                addedIds.push(_id2);\n              }\n            } else {\n              if (this._ids.has(_id2)) {\n                this._ids.delete(_id2);\n\n                removedIds.push(_id2);\n                removedItems.push(params.oldData[_i2]);\n              }\n            }\n          }\n\n          break;\n\n        case \"remove\":\n          // filter the ids of the removed items\n          for (var _i3 = 0, _len3 = ids.length; _i3 < _len3; _i3++) {\n            var _id3 = ids[_i3];\n\n            if (this._ids.has(_id3)) {\n              this._ids.delete(_id3);\n\n              removedIds.push(_id3);\n              removedItems.push(params.oldData[_i3]);\n            }\n          }\n\n          break;\n      }\n\n      this.length += addedIds.length - removedIds.length;\n\n      if (addedIds.length) {\n        this._trigger(\"add\", {\n          items: addedIds\n        }, senderId);\n      }\n\n      if (updatedIds.length) {\n        this._trigger(\"update\", {\n          items: updatedIds,\n          oldData: oldItems,\n          data: updatedItems\n        }, senderId);\n      }\n\n      if (removedIds.length) {\n        this._trigger(\"remove\", {\n          items: removedIds,\n          oldData: removedItems\n        }, senderId);\n      }\n    }\n  }, {\n    key: \"idProp\",\n    get: function get() {\n      return this.getDataSet().idProp;\n    }\n  }]);\n  return DataView;\n}(DataSetPart);\n/**\r\n * Check that given value is compatible with Vis Data Set interface.\r\n *\r\n * @param idProp - The expected property to contain item id.\r\n * @param v - The value to be tested.\r\n *\r\n * @returns True if all expected values and methods match, false otherwise.\r\n */\n\n\nfunction isDataSetLike(idProp, v) {\n  return _typeof_1(v) === \"object\" && v !== null && idProp === v.idProp && typeof v.add === \"function\" && typeof v.clear === \"function\" && typeof v.distinct === \"function\" && typeof forEach$2(v) === \"function\" && typeof v.get === \"function\" && typeof v.getDataSet === \"function\" && typeof v.getIds === \"function\" && typeof v.length === \"number\" && typeof map$2(v) === \"function\" && typeof v.max === \"function\" && typeof v.min === \"function\" && typeof v.off === \"function\" && typeof v.on === \"function\" && typeof v.remove === \"function\" && typeof v.setOptions === \"function\" && typeof v.stream === \"function\" && typeof v.update === \"function\" && typeof v.updateOnly === \"function\";\n}\n/**\r\n * Check that given value is compatible with Vis Data View interface.\r\n *\r\n * @param idProp - The expected property to contain item id.\r\n * @param v - The value to be tested.\r\n *\r\n * @returns True if all expected values and methods match, false otherwise.\r\n */\n\n\nfunction isDataViewLike(idProp, v) {\n  return _typeof_1(v) === \"object\" && v !== null && idProp === v.idProp && typeof forEach$2(v) === \"function\" && typeof v.get === \"function\" && typeof v.getDataSet === \"function\" && typeof v.getIds === \"function\" && typeof v.length === \"number\" && typeof map$2(v) === \"function\" && typeof v.off === \"function\" && typeof v.on === \"function\" && typeof v.stream === \"function\" && isDataSetLike(idProp, v.getDataSet());\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmlzLWRhdGEvcGVlci9lc20vdmlzLWRhdGEuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQURBOzs7QUFLQTtBQUVBO0FBS0E7QUFBQTtBQUxBOztBQ1BBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUxBOztBQ0dBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FDRkE7QUFDQTs7QUFHQTtBQUFBO0FBQUE7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQURBOztBQ0FBOztBQUVBO0FBQ0E7QUFEQTs7QUNDQTs7QUFHQTs7O0FBR0E7QUFIQTtBQUtBO0FBTEE7QUNMQTs7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUNFQTtBQUNBO0FBREE7O0FDSkE7QUFDQTtBQURBO0FDSUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTs7QUNOQTs7QUFFQTtBQUNBO0FBREE7O0FDQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQURBOztBQ0ZBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQURBO0FDR0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQU5BOzs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBO0FBRkE7O0FBUUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FDcEJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBSEE7O0FDR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7O0FBR0E7QUFBQTtBQUNBO0FBREE7O0FBR0E7QUFBQTtBQUNBO0FBREE7O0FBR0E7QUFBQTtBQUNBO0FBREE7QUFWQTs7QUFjQTs7QUFBQTtBQUNBO0FBREE7QUFqQkE7O0FDREE7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFIQTs7QUNHQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7Ozs7QUNMQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBSkE7QUNGQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBSEE7O0FBSUE7QUFDQTs7QUFBQTtBQVBBOztBQVNBO0FBQ0E7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQU1BO0FBRUE7O0FBR0E7QUFBQTtBQUVBO0FBRUE7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUhBOzs7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0RBOzs7QUNqQ0E7QUFDQTtBQURBOztBQ0pBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBREE7O0FDSEE7QUFHQTs7QUFDQTtBQUNBO0FBREE7OztBQ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFyQkE7O0FBd0JBOztBQzNCQTtBQUNBO0FBREE7O0FDREE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBOztBQUFBO0FBTEE7O0FDQUE7QUFDQTtBQUVBOztBQ0hBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUhBOztBQ0xBO0FBQ0E7O0FBRUE7QUFDQTtBQURBOztBQ0RBOzs7QUFHQTtBQUhBO0FDQUE7QUFBQTtBQUFBO0FDS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUFBO0FBSkE7O0FDUEE7QUFHQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQVZBOzs7QUNFQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBOztBQ1JBO0FBQ0E7QUFEQTs7QUNFQTtBQ0ZBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQ0ZBO0FDRkE7QUNNQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTs7O0FBQ0E7QUFBQTs7O0FBQ0E7QUFBQTs7O0FBQ0E7QUFBQTs7QUFKQTtBQU1BO0FBQ0E7O0FBQ0E7QUF0QkE7QUFQQTs7QUFpQ0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBO0FBckJBOztBQ3ZDQTtBQUNBO0FBREE7O0FBSUE7QUFDQTtBQURBOztBQ0xBO0FDQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FDZkE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTs7QUFHQTtBQU5BO0FBSkE7O0FDRkE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQVBBO0FBUkE7O0FDUEE7QUFJQTs7QUFFQTtBQUdBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUhBOztBQ1ZBO0FDREE7O0FBRUE7QUFDQTtBQUNBO0FBRkE7O0FDRkE7QUNGQTtBQ0VBO0FBSUE7O0FBRUE7QUFHQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFIQTs7QUNWQTtBQ0RBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQ0ZBO0FDRkE7O0FDTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFyQkE7QUFEQTs7QUEwQkE7OztBQUdBOzs7QUFHQTtBQU5BOztBQzdCQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBRkE7QUFGQTs7QUNBQTtBQ0RBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFFQTs7QUFDQTtBQUdBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFIQTs7QUNiQTtBQ0RBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQ0ZBO0FDRkE7QUNJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFBQTtBQUxBO0FBU0E7OztBQUNBOztBQUFBO0FBQ0E7QUFDQTs7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFJQTtBQUNBO0FBUkE7OztBQ1pBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7QUNGQTtBQ0RBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQ0ZBO0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUNBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOzs7QUNIQTs7QUFFQTtBQUNBO0FBREE7O0FBSUE7O0FDUEE7QUNGQTs7QUNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQ2lCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7QUFJQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7O0FBU0E7QUFlQTs7Ozs7Ozs7QUFRQTs7OztBQUNBO0FBQ0E7QUFDQTtBQXBCQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFrQkE7QUFFQTs7Ozs7O0FBRUE7O0FBQ0E7QUFDQTtBQUVBOzs7OztBQUVBOztBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7QUFFQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFPQTs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQW5IQTtBQXNIQTs7Ozs7Ozs7O0FBT0E7QUFVQTs7Ozs7O0FBTUE7O0FBQUE7QUFaQTs7Ozs7QUFJQTtBQVFBO0FBRUE7Ozs7Ozs7Ozs7OztBQVNBO0FBRUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFZQTtBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBWUE7QUFFQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7O0FBL0VBOztBQ25OQTtBQ0ZBO0FDRUE7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBSEE7QUFNQTtBQUNBO0FBQUE7QUFkQTtBQURBOztBQW1CQTs7O0FBR0E7OztBQUdBO0FBTkE7QUN4QkE7QUNFQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFWQTs7O0FDSkE7O0FDSUE7QUFDQTtBQURBOzs7QUNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFQQTs7QUNEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOzs7QUNIQTs7QUFFQTtBQUNBO0FBREE7O0FBSUE7O0FDUEE7QUNGQTtBQ0dBO0FBR0E7O0FBQ0E7QUFDQTtBQURBOzs7OztBQ1BBOzs7OztBQ01BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FDREE7QUFDQTtBQUNBO0FBRkE7OztBQ0lBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBYkE7O0FDTkE7QUNEQTtBQ0ZBO0FDR0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUdBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOzs7QUNSQTs7QUFFQTtBQUNBO0FBREE7O0FBSUE7O0FDUEE7QUNGQTtBQ0VBO0FDQ0E7O0FBRUE7QUFDQTtBQURBOztBQ0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQUE7O0FBRUE7QUFDQTtBQURBOzs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBTEE7OztBQVNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFGQTs7QUFHQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBUkE7O0FBV0E7QUFHQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBTEE7O0FBT0E7QUFUQTs7QUNsRUE7QUFFQTtBQUVBOztBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUxBOzs7QUFTQTtBQUNBO0FBREE7Ozs7OztBQ2ZBO0FBQ0E7QUFEQTs7QUNBQTs7OztBQ0NBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTs7QUNIQTtBQUNBO0FBRUE7QUFFQTtBQ0hBOztBQUVBO0FBQUE7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUhBOzs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFOQTs7QUNWQTtBQUNBO0FBREE7QUNMQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTs7QUNQQTs7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUVBO0FDUkE7QUFFQTtBQ0lBO0FBQ0E7O0FBRUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFKQTtBQURBOztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFLQTtBQUNBO0FBREE7O0FBR0E7QUFDQTtBQURBO0FBYkE7QUFpQkE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQUtBO0FBQ0E7QUFEQTs7QUFHQTtBQUNBO0FBREE7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQ3JCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFWQTs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFSQTs7QUFXQTtBQUNBO0FBREE7QUFHQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQUE7QUFDQTs7QUFBQTtBQWJBOztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBUEE7O0FBVUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQVJBOztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFUQTtBQWFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVZBOztBQWFBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQURBOztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7QUFJQTtBQUNBO0FBREE7O0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTs7O0FBYUE7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFBQTtBQWpCQTtBQWtCQTtBQUFBO0FBQUE7QUFsQkE7O0FBcUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7QUFaQTs7QUFlQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTs7O0FBR0E7QUFOQTtBQVVBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUZBO0FBSEE7O0FBVUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBRUE7QUNuVEE7QUNEQTtBQ0ZBO0FDQUE7QUNFQTtBQUNBOztBQUFBOztBQUNBO0FBQ0E7QUFIQTtBQ0dBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBTEE7QUNIQTtBQUNBOztBQU1BOztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQ2hDQTs7QUFNQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBSEE7QUNHQTs7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTEE7QUFUQTtBQ01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUhBOztBQUlBO0FBQUE7QUFBQTtBQVBBOztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFyQ0E7OztBQXlDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQTNDQTs7O0FBK0NBO0FBQ0E7QUFDQTs7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQWxFQTs7QUNmQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBSkE7QUFPQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBcEJBO0FBd0JBO0FBQ0E7O0FBQ0E7QUMvQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL0JBO0FDTUE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFEQTs7QUFlQTs7O0FBR0E7OztBQUdBO0FBTkE7QUNsQkE7QUFJQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQWhCQTtBQ1BBOztBQUVBO0FBQ0E7QUFEQTs7QUNIQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUpBOztBQ0NBO0FDSkE7QUNJQTtBQ0pBOztBQ0VBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FDRUE7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFQQTs7QUNEQTtBQUNBOztBQUdBO0FBQ0E7QUFEQTs7O0FDSUE7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBNUJBOztBQ1RBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQU5BOztBQVFBO0FBQ0E7QUFYQTs7O0FBY0E7QUFBQTtBQUFBO0FBZEE7O0FBZUE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQURBOztBQU9BO0FBVEE7O0FBVUE7O0FBQ0E7QUFkQTs7QUNsQkE7QUFDQTtBQURBO0FBS0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FDTkE7QUNGQTtBQ0ZBOztBQ09BOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBUkE7OztBQ0RBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7O0FDSEE7QUNDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFGQTtBQUhBO0FBREE7QUFZQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7OztBQUdBO0FBTkE7O0FDakJBO0FDSEE7QUNJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBTEE7O0FBUUE7QUFDQTtBQURBOztBQUtBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7O0FDckJBO0FBQUE7QUFBQTs7QUFHQTtBQUNBO0FBREE7O0FDSkE7QUNGQTs7QUNNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7QUNIQTs7QUFFQTtBQUNBO0FBREE7O0FDSEE7QUNGQTs7QUNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBREE7QUFRQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUNoQkE7O0FBQ0E7QUNDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTs7QUFTQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQVRBO0FDZEE7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBOztBQ0xBO0FBSUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQ0pBO0FDREE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQU5BOztBQ1hBO0FDRkE7QUFHQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUNMQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FDRkE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBYkE7QUFEQTs7QUFrQkE7OztBQUdBOzs7QUFHQTtBQU5BO0FDdkJBO0FBR0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUNGQTtBQ0dBO0FBQUE7QUFBQTtBQUdBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQ1BBO0FDREE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUdBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFIQTs7O0FDUEE7QUNDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBSEE7O0FDQUE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTs7QUFHQTtBQUNBOztBQUFBO0FBVEE7OztBQ0lBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFBQTtBQUNBO0FBRUE7QUFKQTs7QUNMQTtBQ01BO0FBQ0E7QUFHQTs7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVBBO0FBUUE7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBbkJBOztBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBcENBOztBQ1RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOztBQ0ZBO0FDREE7QUNGQTtBQ1dBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQTlDQTs7QUNuQkE7QUNEQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTs7QUNGQTtBQ0ZBO0FDSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBTEE7O0FDUkE7QUNEQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTs7QUNGQTtBQ0ZBO0FDQ0E7QUFJQTtBQUNBO0FBR0E7O0FBQ0E7O0FBQUE7QUFDQTtBQURBOztBQ0pBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOztBQ0hBO0FDREE7QUNDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBRkE7O0FDVkE7O0FDS0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOztBQ0ZBO0FDREE7QUNGQTs7QUNFQTtBQUNBO0FBQ0E7O0FBRUE7QUNGQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUZBOztBQ0ZBO0FDSkE7QUNhQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBR0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQW5CQTs7O0FDbkNBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBO0FDREE7O0FDQ0E7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQ0E7QUNpQkE7O0FDbEJBOztBQ0FBOztBQ0FBOztBQ0FBO0FDREE7QUNLQTtBQ1JBOztBQ01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUMvQkE7QUNGQTtBQ1lBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBekJBOztBQ25CQTtBQ0RBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQ0ZBO0FDRkE7O0FDQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUNKQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQ25CQTtBQUNBO0FBQ0E7O0FBRUE7O0FDSUE7QUFDQTtBQUNBOztBQUVBOztBQ1JBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FDREE7QUNFQTtBQUFBO0FBQUE7QUFHQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FDTkE7QUNEQTtBQ0ZBO0FDRUE7QUNGQTtBQ0tBO0FDSEE7QUNGQTs7O0FDSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQ2hCQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOztBQ0ZBO0FDREE7QUNGQTtBQ0VBO0FDRkE7O0FDSUE7QUFDQTtBQUNBOztBQUVBOztBQ0ZBO0FBQ0E7QUFDQTs7QUFFQTs7QUNWQTtBQUNBO0FBQ0E7O0FBRUE7O0FDSUE7QUFDQTtBQUNBOztBQUVBO0FDVEE7QUNEQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTs7QUNGQTtBQ0ZBO0FDRUE7QUNGQTs7QUNDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFJQTs7QUFHQTtBQUNBO0FBQ0E7QUFOQTs7O0FBVUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFoQkE7OztBQW9CQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBOzs7O0FBK0JBO0FBQ0E7QUFDQTs7QUFFQTtBQXRDQTtBQXlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUVBO0FBQUE7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFqQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVLQTs7Ozs7Ozs7OztBQVFBOztBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUNBOzs7QUFFQTs7O0FBR0E7Ozs7OztBQUtBOztBQWpCQTs7OztBQXVCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7Ozs7OztBQXVCQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7QUFHQTtBQUNBO0FBV0E7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FBVUE7Ozs7O0FBQ0E7QUFDQTtBQURBOzs7QUFHQTtBQUlBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQURBOztBQUVBOztBQVdBO0FBQ0E7Ozs7Ozs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7Ozs7QUFBQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlIQTtBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUFBOztBQUNBOztBQUFBO0FBRkE7QUFJQTtBQUNBOztBQUFBO0FBREE7QUFHQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBTEE7OztBQVFBO0FBQ0E7QUFDQTtBQWpCQTs7O0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6QkE7O0FDckJBO0FDREE7QUNGQTtBQ0dBO0FDREE7QUNDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBRkE7O0FDVkE7Ozs7Ozs7OztBQ09BO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTs7QUFDQTs7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFJQTtBQUVBO0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUlBOzs7OztBQU1BOztBQUNBOztBQUNBOzs7O0FBSUE7O0FBQ0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7O0FBQ0E7OztBQUtBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFJQTtBQU5BOztBQVVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFySUE7Ozs7OztBQTRJQTtBQUNBO0FBQUE7QUFBQTtBQURBOztBQUlBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBOztBQUNBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFIQTtBQUtBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUxBOzs7QUFTQTtBQVRBO0FBV0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQWFBOztBQUFBO0FBdERBOzs7O0FBZ0VBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQURBOztBQUdBOzs7O0FBS0E7QUFDQTtBQUVBO0FBS0E7QUFBQTtBQUdBO0FBSEE7QUFSQTs7QUFlQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7Ozs7QUFPQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQU5BO0FBU0E7QUFDQTs7QUFFQTtBQUVBOztBQUNBOzs7QUFHQTs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFYQTtBQWlCQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUF2RUE7QUE5T0E7Ozs7OztBQTZUQTtBQUNBOztBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBR0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTs7QUFxQkE7QUF0RUE7Ozs7QUEyRUE7QUFDQTtBQXpZQTs7OztBQThZQTtBQUVBOzs7Ozs7QUFPQTtBQUNBO0FBREE7O0FBSUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7O0FBSUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTs7Ozs7QUFhQTtBQUNBO0FBZEE7QUFUQTs7QUEyQkE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBWkE7O0FBZUE7QUFDQTtBQTVCQTs7O0FBZ0NBO0FBQUE7QUFBQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNkJBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQXRDQTtBQXlDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFsR0E7QUFxR0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFwSUE7QUF1SUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBOztBQUVBO0FBdkpBO0FBMEpBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsS0E7QUFxS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVZBOzs7O0FBZUE7QUFwTEE7QUF1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFyTUE7Ozs7O0FBNE1BO0FBN3NCQTs7OztBQW90QkE7O0FBR0E7QUFDQTtBQURBOzs7Ozs7Ozs7O0FBWUE7OztBQzF1QkE7QUNFQTtBQ0ZBO0FDR0E7QUNEQTtBQ0NBO0FBRUE7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFGQTs7QUNWQTtBQ09BO0FBQ0E7O0FBR0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFEQTs7QUFJQTtBQUVBO0FBR0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUxBOztBQ3RCQTtBQ0RBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQ0ZBO0FDRkE7QUNHQTtBQ0RBO0FDQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUZBOztBQ1ZBO0FDRUE7QUFJQTtBQUNBO0FBR0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUhBOztBQ1JBO0FDREE7O0FBRUE7QUFDQTtBQUNBO0FBRkE7O0FDRkE7QUNGQTtBQ0VBO0FBQ0E7QUFEQTs7QUNDQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFBQTtBQUNBOztBQUNBOztBQUZBO0FBQUE7QUFEQTs7QUFPQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUVBOztBQUFBO0FBWEE7O0FBY0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUVBOztBQUFBO0FBVEE7OztBQWFBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BOzs7QUNyREE7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUpBOztBQU9BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFBQTtBQTVDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUhBOztBQ1VBO0FBQ0E7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUxBO0FBUUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOztBQUVBO0FBRUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFFQTtBQXJEQTs7QUNoQkE7QUFDQTtBQUNBO0FBRUE7O0FBQUE7QUFKQTs7QUNJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQVRBOztBQ1BBO0FBU0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFWQTtBQWFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFBQTtBQXZCQTs7QUEwQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBVEE7O0FBWUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFmQTs7O0FBb0JBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQUE7QUFuQ0E7OztBQXVDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUEvQ0E7OztBQW1EQTtBQUNBO0FBQ0E7QUFyREE7QUF3REE7O0FBRUE7QUFDQTtBQUNBO0FBSkE7O0FBT0E7QUFDQTtBQUNBO0FBVEE7O0FBWUE7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFwSUE7QUFzSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFEQTtBQVNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQVZBOzs7QUFhQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUF2QkE7O0FBMkJBO0FBQ0E7QUF4S0E7O0FDVkE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQ0FBO0FDSkE7QUNGQTtBQ0VBO0FDRkE7O0FDS0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBOztBQ0ZBO0FDREE7QUNGQTs7QUNFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7O0FBRUE7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBT0E7QUFDQTs7QUFFQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FDVkE7QUNGQTs7QUNJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7O0FBRUE7QUNYQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQ2pCQTs7QUNFQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUNYQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FDMEJBOzs7Ozs7O0FBS0E7QUFlQTs7Ozs7QUFLQTs7QUFkQTtBQU1BO0FBQ0E7O0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7OztBQTVCQTtBQUFBO0FBQUE7QUFrQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUE1Q0E7QUFBQTs7QUE4RkE7OztBQTlGQTtBQWtHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBckhBO0FBQUE7QUFBQTtBQStIQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBRkE7QUFRQTtBQUVBOzs7Ozs7QUFoSkE7QUFBQTtBQUFBO0FBc0pBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7OztBQS9KQTtBQUFBO0FBQUE7QUFBQTs7O0FBb0tBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBRUE7Ozs7QUFwTEE7QUFBQTtBQUFBOzs7QUF3TEE7QUFDQTtBQURBO0FBR0E7QUEzTEE7QUFBQTtBQUFBO0FBeURBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBREE7O0FBSUE7QUFFQTtBQUNBO0FBRkE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBNUZBO0FBQUE7QUFBQTtBQ3JDQTs7Ozs7Ozs7QUFNQTtBQUFBOztBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQXdIQTs7OztBQUdBO0FBQ0E7Ozs7QUFHQTtBQUdBO0FBNUdBOzs7Ozs7Ozs7QUExQkE7QUFBQTtBQUFBOzs7QUFzQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFGQTtBQUtBO0FBc0JBOzs7Ozs7Ozs7QUFyRUE7QUFBQTtBQUFBO0FBaUZBO0FBQ0E7QUFDQTs7QUFFQTtBQXNCQTs7Ozs7Ozs7O0FBM0dBO0FBQUE7QUFBQTs7O0FBdUhBO0FBQ0E7QUFEQTtBQUdBO0FBMUhBO0FBQUE7QUFBQTs7O0FDYkE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQ0FBO0FDSkE7QUNGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0VBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUdBOzs7OztBQUtBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFaQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBaUJBOztBQWpCQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBcUJBOzs7O0FBckJBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUEwQkE7O0FBMUJBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUE4QkE7Ozs7QUE5QkE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQW1DQTs7QUFuQ0E7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXVDQTs7OztBQXZDQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBNENBOztBQTVDQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ0RBOzs7Ozs7Ozs7QUFoREE7QUFBQTtBQUFBOzs7QUF5REE7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBNURBO0FBQUE7QUFBQTs7O0FBcUVBO0FBQUE7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQXhFQTtBQUFBO0FBQUE7QUFpRkE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFwRkE7QUFBQTtBQUFBO0FBNkZBOztBQUNBOzs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBcEdBO0FBQUE7QUFBQTtBQTBHQTtBQUNBO0FBRUE7Ozs7OztBQTdHQTtBQUFBO0FBQUE7QUFtSEE7QUFDQTtBQUVBOzs7Ozs7QUF0SEE7QUFBQTtBQUFBO0FBNEhBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBL0hBO0FBQUE7QUFBQTtBQXVKQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUExSkE7QUFBQTtBQUFBO0FBb0tBOztBQUVBOzs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7Ozs7OztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUE3S0E7QUFBQTtBQUFBO0FBcUxBO0FBQ0E7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUlBOztBQUpBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTQTtBQUVBOzs7Ozs7QUFqTUE7QUFBQTtBQUFBO0FBdU1BOzs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7Ozs7O0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQTVNQTtBQUFBO0FBQUE7QUF3TkE7QUFDQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFHQTs7QUFIQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFFQTs7Ozs7Ozs7QUFsT0E7QUFBQTtBQUFBO0FBME9BO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBOVBBO0FBQUE7QUFBQTtBQXNRQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQTFSQTtBQUFBO0FBQUE7QUF3U0E7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQTlTQTtBQUFBO0FBQUE7OztBQXdUQTtBQUNBOztBQUFBO0FBRUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUZBO0FBREE7QUFRQTtBQWhVQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMwQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJEQTtBQUFBOztBQUFBO0FBNkJBOzs7Ozs7OztBQU1BOzs7O0FBSUE7QUFyQkE7O0FBd0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUNBO0FBaERBOzs7QUFWQTtBQUFBOztBQTREQTs7Ozs7QUE1REE7QUFrRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeEZBO0FBQUE7QUFBQTs7O0FBcUhBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBakpBO0FBQUE7QUFBQTs7O0FBMExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTs7QUFDQTtBQUNBO0FBZEE7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBR0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUZBO0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFyUEE7QUFBQTtBQUFBOzs7O0FBOFJBO0FBQ0E7QUFDQTs7QUFFQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQVRBO0FBV0E7QUFBQTtBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQXJCQTs7QUE0QkE7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUVBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQUxBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBbkJBO0FBcUJBO0FBQ0E7QUFDQTtBQTREQTs7QUFqWkE7QUFBQTtBQUFBO0FBMFpBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBOzs7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVFBOzs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQVRBO0FBV0E7QUFBQTs7O0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUF4Z0JBO0FBQUE7QUFBQTtBQTBnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBMWtCQTtBQUFBO0FBQUE7QUE0a0JBO0FBQ0E7QUFFQTs7QUEva0JBO0FBQUE7QUFBQTtBQW9sQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBN21CQTtBQUFBO0FBQUE7QUFrbkJBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBV0E7Ozs7Ozs7Ozs7O0FBanBCQTtBQUFBO0FBQUE7OztBQStwQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUlBO0FBS0E7QUFDQTtBQVZBO0FBWUE7QUFFQTs7Ozs7Ozs7O0FBbHJCQTtBQUFBO0FBQUE7QUEyckJBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFIQTtBQVVBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTlzQkE7QUFBQTtBQUFBO0FBMHVCQTtBQUNBOztBQUdBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUdBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUF0d0JBO0FBQUE7QUFBQTtBQTh3QkE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQXB5QkE7QUFBQTtBQUFBOzs7QUE4eUJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUE3ekJBO0FBQUE7QUFBQTs7O0FBcTBCQTtBQUNBOztBQUVBOzs7O0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBdDFCQTtBQUFBO0FBQUE7OztBQTgxQkE7QUFDQTs7QUFFQTs7OztBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBRUE7QUFDQTtBQUlBOzs7Ozs7OztBQWozQkE7QUFBQTtBQUFBO0FBeTNCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFsNUJBO0FBQUE7QUFBQTtBQTA1QkE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBMzZCQTtBQUFBO0FBQUE7QUFvN0JBOztBQUNBO0FBQ0E7QUFLQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBRUE7O0FBdjhCQTtBQUFBO0FBQUE7QUF5OEJBO0FBQ0E7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7O0FBSEE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFLQTs7QUFMQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSEE7QUFhQTs7QUFDQTtBQUdBO0FBQ0E7QUEzOUJBO0FBQUE7QUFBQTtBQVlBO0FBQ0E7QUFiQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZDQTtBQUFBOztBQUFBO0FBa0JBOzs7Ozs7OztBQU1BOzs7Ozs7QUFJQTtBQXRCQTs7QUFDQTtBQVFBOztBQWVBO0FBRUE7O0FBRUE7OztBQUNBO0FBM0JBOzs7QUFSQTtBQUFBO0FBcUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FBeENBO0FBb0RBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7OztBQU9BO0FBQUE7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFWQTtBQVlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBeEZBO0FBQUE7QUFBQTtBQTZGQTtBQUNBO0FBREE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBNERBOztBQXRNQTtBQUFBO0FBQUE7QUErTUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7O0FBR0E7O0FBT0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUVBOztBQXBQQTtBQUFBO0FBQUE7QUFzUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQVBBO0FBU0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQWpCQTtBQXNCQTtBQUNBO0FBQ0E7QUFFQTs7QUFoUkE7QUFBQTtBQUFBO0FBcVJBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7O0FBN1NBO0FBQUE7QUFBQTtBQW9UQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBUEE7QUFTQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBakJBO0FBc0JBO0FBQ0E7QUFDQTtBQUVBOztBQTlVQTtBQUFBO0FBQUE7QUFnVkE7QUFDQTtBQUVBOztBQW5WQTtBQUFBO0FBQUE7OztBQXFWQTtBQUtBO0FBRUE7Ozs7Ozs7OztBQTVWQTtBQUFBO0FBQUE7OztBQXFXQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFMQTtBQVFBO0FBUkE7O0FBVUE7Ozs7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBQ0E7QUFFQTs7Ozs7Ozs7QUF6WEE7QUFBQTtBQUFBO0FBcVlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBTEE7QUFTQTs7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFFQTtBQTlEQTs7QUFpRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFHQTs7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQXJlQTtBQUFBO0FBQUE7QUFVQTtBQUNBO0FBWEE7QUFBQTtBQUFBO0FDaEZBOzs7Ozs7Ozs7O0FBUUE7QUFJQTtBQXVCQTtBQ2xDQTs7Ozs7Ozs7OztBQVFBO0FBSUE7QUFlQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2dsb2JhbC5qcz9hMGQ4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2ZhaWxzLmpzPzVkNGQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanM/ZTQ5NyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcz9kMWZhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzP2Y3YWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanM/NTkzNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcz83YzM1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcz84ZjQ3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzPzU1YzYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzPzFmNzgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzP2RjY2IiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaGFzLmpzP2NjZGIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanM/ZDNmMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcz9lYjg4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanM/NzNkNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1mb3JjZWQuanM/MjQyYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9wYXRoLmpzPzhmNDMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYS1mdW5jdGlvbi5qcz9lNjdiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcz9mNTdkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FuLW9iamVjdC5qcz8yZDMzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanM/MjY1OCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanM/OGNkYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9leHBvcnQuanM/OWZkMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1hcnJheS5qcz9jYTBjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLWludGVnZXIuanM/OTU2NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1sZW5ndGguanM/MWE5YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9mbGF0dGVuLWludG8tYXJyYXkuanM/NTg4NCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1vYmplY3QuanM/YWFlOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzP2YzMWQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzP2M5NDIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2hhcmVkLmpzPzNjYmEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdWlkLmpzPzZhOTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbC5qcz9lNTNjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzPzExOWMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanM/MWQ1NyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcz9kMmFkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5mbGF0LW1hcC5qcz81OWRiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwuanM/MTlmYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvZmxhdC1tYXAuanM/Y2ZkNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL2ZsYXQtbWFwLmpzP2MwMmEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvZmxhdC1tYXAuanM/MDRiZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9mbGF0LW1hcC5qcz8zMDg0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcz9jYzM1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcz9jMDVmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzP2Y1ZWMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanM/NDFiZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qcz85YzFmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aC5qcz9hMWMwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5tYXAuanM/ZjhkZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvbWFwLmpzPzFhN2MiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9pbnN0YW5jZS9tYXAuanM/YWZjZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9tYXAuanM/ZDU4ZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9tYXAuanM/NmM4MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyLmpzP2VlYjYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL2ZpbHRlci5qcz9hYWFjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2UvZmlsdGVyLmpzPzhiNzIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvZmlsdGVyLmpzPzIxM2QiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvaW5zdGFuY2UvZmlsdGVyLmpzPzBlNWUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktcmVkdWNlLmpzPzA3YTEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdC5qcz85ZDIwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2VuZ2luZS1pcy1ub2RlLmpzPzBhMGUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5LnJlZHVjZS5qcz9jNTFlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9yZWR1Y2UuanM/MjBhMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL3JlZHVjZS5qcz9jNTAxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3JlZHVjZS5qcz85ZGM2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL3JlZHVjZS5qcz9hZjc3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQuanM/ZjlmYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuZnVuY3Rpb24uYmluZC5qcz83OWUxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvZnVuY3Rpb24vdmlydHVhbC9iaW5kLmpzPzhjMGQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9pbnN0YW5jZS9iaW5kLmpzPzZhZWQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvYmluZC5qcz9hNWJlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL2JpbmQuanM/MmMxYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzPzY1ODAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanM/Mzg4ZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanM/M2YyYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanM/MjZlZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanM/YTQ3OCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzPzViNjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vc3JjL2RhdGEtcGlwZS50cz8yMDgxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanM/NzExOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzPzJiNTgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanM/MzYzZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcz8wMzllIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzPzk3MjQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanM/ZDFmNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzP2NhNGQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanM/OWNhNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanM/YjhhZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzPzM2MmUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanM/Y2I2YyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanM/NGQ1YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanM/ODZhMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcz9jN2U4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanM/ODk4YiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vd24ta2V5cy5qcz9hNDMyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcz9kNDUwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcz9kZDg4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanM/MDI2OCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcz85MDlmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzP2YyMGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanM/YjgxZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanM/ZTAzYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzPzBiYjMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcz9hMTA5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2h0bWwuanM/NDc5NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zaGFyZWQta2V5LmpzPzg4MzMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcz8wNzJmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzP2YyYTMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvcmVkZWZpbmUuanM/Yzk3ZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkLmpzP2MyZWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sLmpzP2I0MjEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzPzU5YjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY2xhc3NvZi5qcz9hZmYzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanM/Yzc4YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcz8wYWQ5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzP2YyNmIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwLmpzPzQ5ZTQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanM/NTkxNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLmpzPzFkNzMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzPzU0NTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktc3ltYm9scy5qcz85YzlkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanM/YTFkMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pdGVyYXRvcnMuanM/OWJmYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanM/Mjg0YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcz8yYjVhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzP2ZjYmQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yLmpzPzBkMzgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUuanM/MTNjOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcz9jMTczIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qcz85MTg5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcz85NmZkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMuanM/MTZjYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcz9mMWIwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUuanM/MmQzOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzP2Y3NTAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcz81ZmQ5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2dldC1pdGVyYXRvci5qcz8zYTViIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvZ2V0LWl0ZXJhdG9yLmpzPzhmOWYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9nZXQtaXRlcmF0b3IuanM/MWFlNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL2dldC1pdGVyYXRvci1tZXRob2QuanM/YjI1NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL2dldC1pdGVyYXRvci1tZXRob2QuanM/OWFiNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcz8zZTc2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzP2ZmYTQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kLmpzP2UxYWUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktZnJvbS5qcz8xMzI5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbi5qcz8zNzMwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzP2E3ZWYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS9mcm9tLmpzP2Y4ZjciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvYXJyYXkvZnJvbS5qcz85M2NjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2FycmF5L2Zyb20uanM/MGRjZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1maWxsLmpzP2YwZWIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5LmZpbGwuanM/N2I3ZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvZmlsbC5qcz8xYzBhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy93ZWIudGltZXJzLmpzP2MwMGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvc2V0LXRpbWVvdXQuanM/OWIxMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9zZXQtdGltZW91dC5qcz9hY2ZhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5qc29uLnN0cmluZ2lmeS5qcz84OWEyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvanNvbi9zdHJpbmdpZnkuanM/ZmM3MSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9qc29uL3N0cmluZ2lmeS5qcz8zYzE4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2pzb24vc3RyaW5naWZ5LmpzPzg4ZjciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5jcmVhdGUuanM/YmZiMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9jcmVhdGUuanM/YzQzMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvY3JlYXRlLmpzPzU5NzQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2NyZWF0ZS5qcz8yOTgyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanM/ODg1MSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy93aGl0ZXNwYWNlcy5qcz9kZWMzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3N0cmluZy10cmltLmpzP2Q4YWYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc3RyaW5nLXRyaW0tZm9yY2VkLmpzPzc4YjIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzPzAxODgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9zdHJpbmcvdmlydHVhbC90cmltLmpzPzJmNWIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mLmpzPzk0NWIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL2luZGV4LW9mLmpzPzk0ZTAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvbnVtYmVyLXBhcnNlLWludC5qcz9jZjZjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5wYXJzZS1pbnQuanM/NGFhNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtdG8tYXJyYXkuanM/NTA0MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMub2JqZWN0LnZhbHVlcy5qcz81MzdkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L3ZhbHVlcy5qcz9lNDg2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcz8zN2VhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanM/ZmU0YyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMuanM/MzI5MSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvaW5jbHVkZXMuanM/YmEzYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1yZWdleHAuanM/Mzc2MCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9ub3QtYS1yZWdleHAuanM/YzJkYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYy5qcz9iMDE4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMuanM/NGVhNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL3N0cmluZy92aXJ0dWFsL2luY2x1ZGVzLmpzPzYyMGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qcz83MjkxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzPzZhZjMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvYXNzaWduLmpzPzcxOGQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2Fzc2lnbi5qcz9jMzQwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9hc3NpZ24uanM/OTQ2NCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlLmpzP2M4NTEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL3NwbGljZS5qcz85ZDUwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2Uvc3BsaWNlLmpzPzYwZjciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2Uvc3BsaWNlLmpzP2QxYjEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvaW5zdGFuY2Uvc3BsaWNlLmpzPzA2ZGQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UuanM/NGMwYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvcmV2ZXJzZS5qcz9iODFkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2UvcmV2ZXJzZS5qcz83NzBjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3JldmVyc2UuanM/ZDIyZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9yZXZlcnNlLmpzPzUyZGMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2guanM/ZTdjNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2guanM/ZjYxOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvZm9yLWVhY2guanM/OTAzYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9hcnJheS92aXJ0dWFsL2Zvci1lYWNoLmpzP2YwNDUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvZm9yLWVhY2guanM/MGI0YiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9mb3ItZWFjaC5qcz9jMzg5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5pcy1hcnJheS5qcz80ZjI3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvaXMtYXJyYXkuanM/OWE2ZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL2FycmF5L2lzLWFycmF5LmpzPzI0MjgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9hcnJheS9pcy1hcnJheS5qcz8xZDc4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanM/MWM0OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1pdGVyYWJsZS5qcz9hMTk1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvaXMtaXRlcmFibGUuanM/MzU4YiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL2lzLWl0ZXJhYmxlLmpzP2I0OTAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcz8wY2M2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanM/NWQxZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLmhhcy1pbnN0YW5jZS5qcz80ZTY3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuaXMtY29uY2F0LXNwcmVhZGFibGUuanM/NGJkOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzP2E5NjIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5tYXRjaC5qcz9kZjYyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wubWF0Y2gtYWxsLmpzP2EwYTMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5yZXBsYWNlLmpzPzNlYjciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5zZWFyY2guanM/MzdlOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLnNwZWNpZXMuanM/Mjk2ZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLnNwbGl0LmpzPzM5YzMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC50by1wcmltaXRpdmUuanM/NDk4NyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLnRvLXN0cmluZy10YWcuanM/OGRlOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLnVuc2NvcGFibGVzLmpzP2M3YzQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmpzb24udG8tc3RyaW5nLXRhZy5qcz81NGY0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvc3ltYm9sL2luZGV4LmpzP2M4MjUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wuYXN5bmMtZGlzcG9zZS5qcz82ZmYyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQuc3ltYm9sLmRpc3Bvc2UuanM/YTgyMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5vYnNlcnZhYmxlLmpzPzAzOGIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wucGF0dGVybi1tYXRjaC5qcz9mYWJmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQuc3ltYm9sLnJlcGxhY2UtYWxsLmpzP2RiOTEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9zeW1ib2wvaW5kZXguanM/MjNkNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL3N5bWJvbC5qcz9iMzczIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanM/ZTY5ZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL2FycmF5L2Zyb20uanM/YjQ5NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL2FycmF5L2Zyb20uanM/NjE0NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanM/NzRiYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvc2xpY2UuanM/YmE4MSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL3NsaWNlLmpzPzZkNGEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9pbnN0YW5jZS9zbGljZS5qcz9iNTM4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvaW5zdGFuY2Uvc2xpY2UuanM/MjZjOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanM/MjkxOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzPzUwYWUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanM/NDMyMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanM/ZjAzNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuZGF0ZS5ub3cuanM/YjhlNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2RhdGUvbm93LmpzPzZjYmIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzPzQyYTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3Qva2V5cy5qcz85MjM1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9rZXlzLmpzP2E5OWYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2tleXMuanM/YWQ1OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9hcnJheS9pcy1hcnJheS5qcz81ZmUyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2FycmF5L2lzLWFycmF5LmpzP2ZiYzciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9zeW1ib2wvaXRlcmF0b3IuanM/OTY5YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL3N5bWJvbC9pdGVyYXRvci5qcz85MDNkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzPzlmNTYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy90eXBlb2YuanM/YTdjZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMucmVmbGVjdC5vd24ta2V5cy5qcz9kZDdjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvcmVmbGVjdC9vd24ta2V5cy5qcz8zZDZhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL3JlZmxlY3Qvb3duLWtleXMuanM/MzIzNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9yZWZsZWN0L293bi1rZXlzLmpzPzBkZTQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2Uvc2xpY2UuanM/MmU0MyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9zbGljZS5qcz9jNzM4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvYXJyYXlXaXRob3V0SG9sZXMuanM/OWM1ZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcz9hZTE2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanM/NDgwYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzP2Q0MDgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL2NvbmNhdC5qcz83ZmE2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2UvY29uY2F0LmpzP2NmZmYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvY29uY2F0LmpzP2U0ODIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvaW5zdGFuY2UvY29uY2F0LmpzPzFkNDEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvc3ltYm9sL2luZGV4LmpzPzMyY2MiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvc3ltYm9sLmpzPzk2ZWYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzPzc0Y2IiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BlZ2pzL2hhbW1lcmpzL2Rpc3QvaGFtbWVyLmVzbS5qcz85MDk2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy92aXMtdXRpbC9lc25leHQvZXNtL3Zpcy11dGlsLmpzPzg1NDMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0LmpzPzJmNjQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9yZWZsZWN0L2NvbnN0cnVjdC5qcz81NmM0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL3JlZmxlY3QvY29uc3RydWN0LmpzP2EyYTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvcmVmbGVjdC9jb25zdHJ1Y3QuanM/YjVlOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvZW50cmllcy5qcz8zNmY3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2FycmF5L3ZpcnR1YWwvZW50cmllcy5qcz9iMTA3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL2VudHJpZXMuanM/MjQ1NCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9lbnRyaWVzLmpzP2UzYzciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz9kZjI2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL3JlZ2VuZXJhdG9yL2luZGV4LmpzPzZhNWUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvc3ltYm9sL2l0ZXJhdG9yLmpzP2E1MzkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvc3ltYm9sL2l0ZXJhdG9yLmpzPzlmMjQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL3ZhbHVlcy5qcz9iODBiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2FycmF5L3ZpcnR1YWwvdmFsdWVzLmpzPzg3YjUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvdmFsdWVzLmpzPzQ2NjUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvaW5zdGFuY2UvdmFsdWVzLmpzPzljZGEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5LnNvcnQuanM/YTdiMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2FycmF5L3ZpcnR1YWwvc29ydC5qcz9iMDk2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2Uvc29ydC5qcz9iNDJlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3NvcnQuanM/Y2MyZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9zb3J0LmpzP2ZmN2IiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL2tleXMuanM/NDNlZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9hcnJheS92aXJ0dWFsL2tleXMuanM/YmM1NCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9rZXlzLmpzPzkxNzQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvaW5zdGFuY2Uva2V5cy5qcz8wNjg1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5zb21lLmpzPzMyNGIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL3NvbWUuanM/YzY4MyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL3NvbWUuanM/MmI5ZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9zb21lLmpzP2ZkZWUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvaW5zdGFuY2Uvc29tZS5qcz9hYmE2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2ZyZWV6aW5nLmpzPzZmMmEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanM/MzdjMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pdGVyYXRlLmpzPzY1ZmUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYW4taW5zdGFuY2UuanM/NDIzNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb2xsZWN0aW9uLmpzP2JlMzQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsLmpzPzk4YTYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2V0LXNwZWNpZXMuanM/MjkzMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZy5qcz85MmJiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5tYXAuanM/M2I5ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL21hcC9pbmRleC5qcz82M2Q5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL21hcC9pbmRleC5qcz9hMzI3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL21hcC5qcz9mZGZlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvb2JqZWN0L2NyZWF0ZS5qcz8xZDY2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcz82ZmRmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcz8yYjU5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanM/NjA3ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzPzdlZGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcz8yMDAxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanM/Y2FlMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL2luaGVyaXRzLmpzPzQzMDAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/OTVlOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanM/MGRjNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzP2I3OTYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcz8wNzg3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanM/MmM4NiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcz80M2RlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanM/ODkwZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzNlNDAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zdHJpbmdpZnkuanM/NmUzMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y0LmpzPzIxNTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vc3JjL2RhdGEtaW50ZXJmYWNlLnRzPzhhMTQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vc3JjL3F1ZXVlLnRzPzA4YmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vc3JjL2RhdGEtc2V0LXBhcnQudHM/MzJiYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc2V0LmpzPzM5ZWIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9zZXQvaW5kZXguanM/NmE4ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9zZXQvaW5kZXguanM/MGQ3NyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9zZXQuanM/NjQ4NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9zcmMvZGF0YS1zdHJlYW0udHM/Mjk1NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9zcmMvZGF0YS1zZXQudHM/MjZhZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9zcmMvZGF0YS12aWV3LnRzPzM5ZTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vc3JjL2RhdGEtc2V0LWNoZWNrLnRzP2E5MmUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vc3JjL2RhdGEtdmlldy1jaGVjay50cz82NmZlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgIW5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxudmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdC5jYWxsKGl0LCAnJykgOiBPYmplY3QoaXQpO1xufSA6IE9iamVjdDtcbiIsIi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIFBSRUZFUlJFRF9TVFJJTkcpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGlucHV0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IHR5cGVvZiBkZXRlY3Rpb24gPT0gJ2Z1bmN0aW9uJyA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgICB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xuXG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/IG5hdGl2ZURlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xuXG52YXIgd3JhcENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKE5hdGl2ZUNvbnN0cnVjdG9yKSB7XG4gIHZhciBXcmFwcGVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE5hdGl2ZUNvbnN0cnVjdG9yKSB7XG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihhKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEsIGIpO1xuICAgICAgfSByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEsIGIsIGMpO1xuICAgIH0gcmV0dXJuIE5hdGl2ZUNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIFdyYXBwZXIucHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICByZXR1cm4gV3JhcHBlcjtcbn07XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgUFJPVE8gPSBvcHRpb25zLnByb3RvO1xuXG4gIHZhciBuYXRpdmVTb3VyY2UgPSBHTE9CQUwgPyBnbG9iYWwgOiBTVEFUSUMgPyBnbG9iYWxbVEFSR0VUXSA6IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuXG4gIHZhciB0YXJnZXQgPSBHTE9CQUwgPyBwYXRoIDogcGF0aFtUQVJHRVRdIHx8IChwYXRoW1RBUkdFVF0gPSB7fSk7XG4gIHZhciB0YXJnZXRQcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuXG4gIHZhciBGT1JDRUQsIFVTRV9OQVRJVkUsIFZJUlRVQUxfUFJPVE9UWVBFO1xuICB2YXIga2V5LCBzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHksIG5hdGl2ZVByb3BlcnR5LCByZXN1bHRQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcblxuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIFVTRV9OQVRJVkUgPSAhRk9SQ0VEICYmIG5hdGl2ZVNvdXJjZSAmJiBoYXMobmF0aXZlU291cmNlLCBrZXkpO1xuXG4gICAgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcblxuICAgIGlmIChVU0VfTkFUSVZFKSBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihuYXRpdmVTb3VyY2UsIGtleSk7XG4gICAgICBuYXRpdmVQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgbmF0aXZlUHJvcGVydHkgPSBuYXRpdmVTb3VyY2Vba2V5XTtcblxuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgaW1wbGVtZW50YXRpb25cbiAgICBzb3VyY2VQcm9wZXJ0eSA9IChVU0VfTkFUSVZFICYmIG5hdGl2ZVByb3BlcnR5KSA/IG5hdGl2ZVByb3BlcnR5IDogc291cmNlW2tleV07XG5cbiAgICBpZiAoVVNFX05BVElWRSAmJiB0eXBlb2YgdGFyZ2V0UHJvcGVydHkgPT09IHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSkgY29udGludWU7XG5cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGlmIChvcHRpb25zLmJpbmQgJiYgVVNFX05BVElWRSkgcmVzdWx0UHJvcGVydHkgPSBiaW5kKHNvdXJjZVByb3BlcnR5LCBnbG9iYWwpO1xuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ3MgaW4gdGhpcyB2ZXJzaW9uXG4gICAgZWxzZSBpZiAob3B0aW9ucy53cmFwICYmIFVTRV9OQVRJVkUpIHJlc3VsdFByb3BlcnR5ID0gd3JhcENvbnN0cnVjdG9yKHNvdXJjZVByb3BlcnR5KTtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICBlbHNlIGlmIChQUk9UTyAmJiB0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gJ2Z1bmN0aW9uJykgcmVzdWx0UHJvcGVydHkgPSBiaW5kKEZ1bmN0aW9uLmNhbGwsIHNvdXJjZVByb3BlcnR5KTtcbiAgICAvLyBkZWZhdWx0IGNhc2VcbiAgICBlbHNlIHJlc3VsdFByb3BlcnR5ID0gc291cmNlUHJvcGVydHk7XG5cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAoc291cmNlUHJvcGVydHkgJiYgc291cmNlUHJvcGVydHkuc2hhbSkgfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkocmVzdWx0UHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGFyZ2V0W2tleV0gPSByZXN1bHRQcm9wZXJ0eTtcblxuICAgIGlmIChQUk9UTykge1xuICAgICAgVklSVFVBTF9QUk9UT1RZUEUgPSBUQVJHRVQgKyAnUHJvdG90eXBlJztcbiAgICAgIGlmICghaGFzKHBhdGgsIFZJUlRVQUxfUFJPVE9UWVBFKSkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkocGF0aCwgVklSVFVBTF9QUk9UT1RZUEUsIHt9KTtcbiAgICAgIH1cbiAgICAgIC8vIGV4cG9ydCB2aXJ0dWFsIHByb3RvdHlwZSBtZXRob2RzXG4gICAgICBwYXRoW1ZJUlRVQUxfUFJPVE9UWVBFXVtrZXldID0gc291cmNlUHJvcGVydHk7XG4gICAgICAvLyBleHBvcnQgcmVhbCBwcm90b3R5cGUgbWV0aG9kc1xuICAgICAgaWYgKG9wdGlvbnMucmVhbCAmJiB0YXJnZXRQcm90b3R5cGUgJiYgIXRhcmdldFByb3RvdHlwZVtrZXldKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh0YXJnZXRQcm90b3R5cGUsIGtleSwgc291cmNlUHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY2xhc3NvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwidmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcblxuLy8gYEZsYXR0ZW5JbnRvQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtRmxhdHRlbkludG9BcnJheVxudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG4gIHZhciB0YXJnZXRJbmRleCA9IHN0YXJ0O1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBiaW5kKG1hcHBlciwgdGhpc0FyZywgMykgOiBmYWxzZTtcbiAgdmFyIGVsZW1lbnQ7XG5cbiAgd2hpbGUgKHNvdXJjZUluZGV4IDwgc291cmNlTGVuKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IGluIHNvdXJjZSkge1xuICAgICAgZWxlbWVudCA9IG1hcEZuID8gbWFwRm4oc291cmNlW3NvdXJjZUluZGV4XSwgc291cmNlSW5kZXgsIG9yaWdpbmFsKSA6IHNvdXJjZVtzb3VyY2VJbmRleF07XG5cbiAgICAgIGlmIChkZXB0aCA+IDAgJiYgaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICB0YXJnZXRJbmRleCA9IGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgZWxlbWVudCwgdG9MZW5ndGgoZWxlbWVudC5sZW5ndGgpLCB0YXJnZXRJbmRleCwgZGVwdGggLSAxKSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gMHgxRkZGRkZGRkZGRkZGRikgdGhyb3cgVHlwZUVycm9yKCdFeGNlZWQgdGhlIGFjY2VwdGFibGUgYXJyYXkgbGVuZ3RoJyk7XG4gICAgICAgIHRhcmdldFt0YXJnZXRJbmRleF0gPSBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRJbmRleCsrO1xuICAgIH1cbiAgICBzb3VyY2VJbmRleCsrO1xuICB9XG4gIHJldHVybiB0YXJnZXRJbmRleDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkludG9BcnJheTtcbiIsInZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbCwga2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG4iLCJ2YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy43LjAnLFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMjAgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsInZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgU3RyaW5nKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArICgrK2lkICsgcG9zdGZpeCkudG9TdHJpbmcoMzYpO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcmV0dXJuICFTdHJpbmcoU3ltYm9sKCkpO1xufSk7XG4iLCJ2YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgJiYgIVN5bWJvbC5zaGFtXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZCcpO1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhcyhXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpKSB7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzKFN5bWJvbCwgbmFtZSkpIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbFtuYW1lXTtcbiAgICBlbHNlIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbCgnU3ltYm9sLicgKyBuYW1lKTtcbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gbmV3IChDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEMpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmxhdHRlbi1pbnRvLWFycmF5Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mbGF0TWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWZsYXRNYXBcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlIH0sIHtcbiAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgQTtcbiAgICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBBLmxlbmd0aCA9IGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCAxLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuIiwidmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUikge1xuICByZXR1cm4gcGF0aFtDT05TVFJVQ1RPUiArICdQcm90b3R5cGUnXTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGVzL2VzLmFycmF5LmZsYXQtbWFwJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGVzL2VzLmFycmF5LnVuc2NvcGFibGVzLmZsYXQtbWFwJyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykuZmxhdE1hcDtcbiIsInZhciBmbGF0TWFwID0gcmVxdWlyZSgnLi4vYXJyYXkvdmlydHVhbC9mbGF0LW1hcCcpO1xuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5mbGF0TWFwO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlIHx8IChpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUuZmxhdE1hcCkgPyBmbGF0TWFwIDogb3duO1xufTtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9pbnN0YW5jZS9mbGF0LW1hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvZmxhdC1tYXBcIik7IiwidmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG52YXIgcHVzaCA9IFtdLnB1c2g7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGU7XG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTsgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbiAgbWFwOiBjcmVhdGVNZXRob2QoMSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QoNCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCg1KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kKDYpXG59O1xuIiwidmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoW25hbWVzcGFjZV0pIHx8IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSlcbiAgICA6IHBhdGhbbmFtZXNwYWNlXSAmJiBwYXRoW25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgdmVyc2lvbiA9IG1hdGNoWzBdICsgbWF0Y2hbMV07XG59IGVsc2UgaWYgKHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9IG1hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbiAmJiArdmVyc2lvbjtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24nKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzdcbiAgcmV0dXJuIFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgIGNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZm9vOiAxIH07XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXlbTUVUSE9EX05BTUVdKEJvb2xlYW4pLmZvbyAhPT0gMTtcbiAgfSk7XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBjYWNoZSA9IHt9O1xuXG52YXIgdGhyb3dlciA9IGZ1bmN0aW9uIChpdCkgeyB0aHJvdyBpdDsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIG9wdGlvbnMpIHtcbiAgaWYgKGhhcyhjYWNoZSwgTUVUSE9EX05BTUUpKSByZXR1cm4gY2FjaGVbTUVUSE9EX05BTUVdO1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgdmFyIEFDQ0VTU09SUyA9IGhhcyhvcHRpb25zLCAnQUNDRVNTT1JTJykgPyBvcHRpb25zLkFDQ0VTU09SUyA6IGZhbHNlO1xuICB2YXIgYXJndW1lbnQwID0gaGFzKG9wdGlvbnMsIDApID8gb3B0aW9uc1swXSA6IHRocm93ZXI7XG4gIHZhciBhcmd1bWVudDEgPSBoYXMob3B0aW9ucywgMSkgPyBvcHRpb25zWzFdIDogdW5kZWZpbmVkO1xuXG4gIHJldHVybiBjYWNoZVtNRVRIT0RfTkFNRV0gPSAhIW1ldGhvZCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIGlmIChBQ0NFU1NPUlMgJiYgIURFU0NSSVBUT1JTKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgTyA9IHsgbGVuZ3RoOiAtMSB9O1xuXG4gICAgaWYgKEFDQ0VTU09SUykgZGVmaW5lUHJvcGVydHkoTywgMSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IHRocm93ZXIgfSk7XG4gICAgZWxzZSBPWzFdID0gMTtcblxuICAgIG1ldGhvZC5jYWxsKE8sIGFyZ3VtZW50MCwgYXJndW1lbnQxKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJG1hcCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5tYXA7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aCcpO1xuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ21hcCcpO1xuLy8gRkY0OS0gaXNzdWVcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdtYXAnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIHx8ICFVU0VTX1RPX0xFTkdUSCB9LCB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZXMvZXMuYXJyYXkubWFwJyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykubWFwO1xuIiwidmFyIG1hcCA9IHJlcXVpcmUoJy4uL2FycmF5L3ZpcnR1YWwvbWFwJyk7XG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0Lm1hcDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCAoaXQgaW5zdGFuY2VvZiBBcnJheSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlLm1hcCkgPyBtYXAgOiBvd247XG59O1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2luc3RhbmNlL21hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvbWFwXCIpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRmaWx0ZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZmlsdGVyO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGgnKTtcblxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdmaWx0ZXInKTtcbi8vIEVkZ2UgMTQtIGlzc3VlXG52YXIgVVNFU19UT19MRU5HVEggPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCgnZmlsdGVyJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB8fCAhVVNFU19UT19MRU5HVEggfSwge1xuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGVzL2VzLmFycmF5LmZpbHRlcicpO1xudmFyIGVudHJ5VmlydHVhbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVybmFscy9lbnRyeS12aXJ0dWFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLmZpbHRlcjtcbiIsInZhciBmaWx0ZXIgPSByZXF1aXJlKCcuLi9hcnJheS92aXJ0dWFsL2ZpbHRlcicpO1xuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5maWx0ZXI7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgKGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5maWx0ZXIpID8gZmlsdGVyIDogb3duO1xufTtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9pbnN0YW5jZS9maWx0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL2ZpbHRlclwiKTsiLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyByZWR1Y2UsIHJlZHVjZVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfUklHSFQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcbiAgICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuICAgIHZhciBpID0gSVNfUklHSFQgPyAtMSA6IDE7XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA8IDIpIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7SVNfUklHSFQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiAgbGVmdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICByaWdodDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwsbm8tdGhyb3ctbGl0ZXJhbFxuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgMTsgfSwgMSk7XG4gIH0pO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzb2YoZ2xvYmFsLnByb2Nlc3MpID09ICdwcm9jZXNzJztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktcmVkdWNlJykubGVmdDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QnKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGgnKTtcbnZhciBDSFJPTUVfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbicpO1xudmFyIElTX05PREUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLWlzLW5vZGUnKTtcblxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdyZWR1Y2UnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdyZWR1Y2UnLCB7IDE6IDAgfSk7XG4vLyBDaHJvbWUgODAtODIgaGFzIGEgY3JpdGljYWwgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ5OTgyXG52YXIgQ0hST01FX0JVRyA9ICFJU19OT0RFICYmIENIUk9NRV9WRVJTSU9OID4gNzkgJiYgQ0hST01FX1ZFUlNJT04gPCA4MztcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNUUklDVF9NRVRIT0QgfHwgIVVTRVNfVE9fTEVOR1RIIHx8IENIUk9NRV9CVUcgfSwge1xuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlJyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykucmVkdWNlO1xuIiwidmFyIHJlZHVjZSA9IHJlcXVpcmUoJy4uL2FycmF5L3ZpcnR1YWwvcmVkdWNlJyk7XG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnJlZHVjZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCAoaXQgaW5zdGFuY2VvZiBBcnJheSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlLnJlZHVjZSkgPyByZWR1Y2UgOiBvd247XG59O1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2luc3RhbmNlL3JlZHVjZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvcmVkdWNlXCIpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChDLCBhcmdzTGVuZ3RoLCBhcmdzKSB7XG4gIGlmICghKGFyZ3NMZW5ndGggaW4gZmFjdG9yaWVzKSkge1xuICAgIGZvciAodmFyIGxpc3QgPSBbXSwgaSA9IDA7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIGxpc3RbaV0gPSAnYVsnICsgaSArICddJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICBmYWN0b3JpZXNbYXJnc0xlbmd0aF0gPSBGdW5jdGlvbignQyxhJywgJ3JldHVybiBuZXcgQygnICsgbGlzdC5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbYXJnc0xlbmd0aF0oQywgYXJncyk7XG59O1xuXG4vLyBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBmbiA9IGFGdW5jdGlvbih0aGlzKTtcbiAgdmFyIHBhcnRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uIGJvdW5kKC8qIGFyZ3MuLi4gKi8pIHtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmRGdW5jdGlvbiA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogZm4uYXBwbHkodGhhdCwgYXJncyk7XG4gIH07XG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZEZ1bmN0aW9uLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kRnVuY3Rpb247XG59O1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kJyk7XG5cbi8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuJCh7IHRhcmdldDogJ0Z1bmN0aW9uJywgcHJvdG86IHRydWUgfSwge1xuICBiaW5kOiBiaW5kXG59KTtcbiIsInJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZXMvZXMuZnVuY3Rpb24uYmluZCcpO1xudmFyIGVudHJ5VmlydHVhbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVybmFscy9lbnRyeS12aXJ0dWFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZW50cnlWaXJ0dWFsKCdGdW5jdGlvbicpLmJpbmQ7XG4iLCJ2YXIgYmluZCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uL3ZpcnR1YWwvYmluZCcpO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5iaW5kO1xuICByZXR1cm4gaXQgPT09IEZ1bmN0aW9uUHJvdG90eXBlIHx8IChpdCBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG93biA9PT0gRnVuY3Rpb25Qcm90b3R5cGUuYmluZCkgPyBiaW5kIDogb3duO1xufTtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9pbnN0YW5jZS9iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9iaW5kXCIpOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHlNb2RpbGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIURFU0NSSVBUT1JTLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBkZWZpbmVQcm9wZXJ0eTogb2JqZWN0RGVmaW5lUHJvcGVydHlNb2RpbGUuZlxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxudmFyIE9iamVjdCA9IHBhdGguT2JqZWN0O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkuc2hhbSkgZGVmaW5lUHJvcGVydHkuc2hhbSA9IHRydWU7XG4iLCJ2YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9mZWF0dXJlcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpOyIsInZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcblxuICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsImltcG9ydCB7IERhdGFJbnRlcmZhY2UsIEV2ZW50Q2FsbGJhY2tzLCBQYXJ0SXRlbSB9IGZyb20gXCIuL2RhdGEtaW50ZXJmYWNlXCI7XG5pbXBvcnQgeyBEYXRhU2V0IH0gZnJvbSBcIi4vZGF0YS1zZXRcIjtcblxuLyoqXG4gKiBUaGlzIGludGVyZmFjZSBpcyB1c2VkIHRvIGNvbnRyb2wgdGhlIHBpcGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVBpcGUge1xuICAvKipcbiAgICogVGFrZSBhbGwgaXRlbXMgZnJvbSB0aGUgc291cmNlIGRhdGEgc2V0IG9yIGRhdGEgdmlldywgdHJhbnNmb3JtIHRoZW0gYXNcbiAgICogY29uZmlndXJlZCBhbmQgdXBkYXRlIHRoZSB0YXJnZXQgZGF0YSBzZXQuXG4gICAqL1xuICBhbGwoKTogdGhpcztcblxuICAvKipcbiAgICogU3RhcnQgb2JzZXJ2aW5nIHRoZSBzb3VyY2UgZGF0YSBzZXQgb3IgZGF0YSB2aWV3LCB0cmFuc2Zvcm1pbmcgdGhlIGl0ZW1zXG4gICAqIGFuZCB1cGRhdGluZyB0aGUgdGFyZ2V0IGRhdGEgc2V0LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgY3VycmVudCBjb250ZW50IG9mIHRoZSBzb3VyY2UgZGF0YSBzZXQgd2lsbCBiZSBpZ25vcmVkLiBJZiB5b3UgZm9yXG4gICAqIGV4YW1wbGUgd2FudCB0byBwcm9jZXNzIGFsbCB0aGUgaXRlbXMgdGhhdCBhcmUgYWxyZWFkeSB0aGVyZSB1c2U6XG4gICAqIGBwaXBlLmFsbCgpLnN0YXJ0KClgLlxuICAgKi9cbiAgc3RhcnQoKTogdGhpcztcblxuICAvKipcbiAgICogU3RvcCBvYnNlcnZpbmcgdGhlIHNvdXJjZSBkYXRhIHNldCBvciBkYXRhIHZpZXcsIHRyYW5zZm9ybWluZyB0aGUgaXRlbXNcbiAgICogYW5kIHVwZGF0aW5nIHRoZSB0YXJnZXQgZGF0YSBzZXQuXG4gICAqL1xuICBzdG9wKCk6IHRoaXM7XG59XG5cbi8qKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHBpcGUuXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFQaXBlRmFjdG9yeSA9IEluc3RhbmNlVHlwZTx0eXBlb2YgRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbj47XG5cbi8qKlxuICogQ3JlYXRlIG5ldyBkYXRhIHBpcGUuXG4gKlxuICogQHBhcmFtIGZyb20gLSBUaGUgc291cmNlIGRhdGEgc2V0IG9yIGRhdGEgdmlldy5cbiAqXG4gKiBAcmVtYXJrc1xuICogRXhhbXBsZSB1c2FnZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGludGVyZmFjZSBBcHBJdGVtIHtcbiAqICAgd2hvYW1pOiBzdHJpbmc7XG4gKiAgIGFwcERhdGE6IHVua25vd247XG4gKiAgIHZpc0RhdGE6IFZpc0l0ZW07XG4gKiB9XG4gKiBpbnRlcmZhY2UgVmlzSXRlbSB7XG4gKiAgIGlkOiBudW1iZXI7XG4gKiAgIGxhYmVsOiBzdHJpbmc7XG4gKiAgIGNvbG9yOiBzdHJpbmc7XG4gKiAgIHg6IG51bWJlcjtcbiAqICAgeTogbnVtYmVyO1xuICogfVxuICpcbiAqIGNvbnN0IGRzMSA9IG5ldyBEYXRhU2V0PEFwcEl0ZW0sIFwid2hvYW1pXCI+KFtdLCB7IGZpZWxkSWQ6IFwid2hvYW1pXCIgfSk7XG4gKiBjb25zdCBkczIgPSBuZXcgRGF0YVNldDxWaXNJdGVtLCBcImlkXCI+KCk7XG4gKlxuICogY29uc3QgcGlwZSA9IGNyZWF0ZU5ld0RhdGFQaXBlRnJvbShkczEpXG4gKiAgIC5maWx0ZXIoKGl0ZW0pOiBib29sZWFuID0+IGl0ZW0uZW5hYmxlZCA9PT0gdHJ1ZSlcbiAqICAgLm1hcDxWaXNJdGVtLCBcImlkXCI+KChpdGVtKTogVmlzSXRlbSA9PiBpdGVtLnZpc0RhdGEpXG4gKiAgIC50byhkczIpO1xuICpcbiAqIHBpcGUuc3RhcnQoKTtcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIEEgZmFjdG9yeSB3aG9zZSBtZXRob2RzIGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgcGlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5ld0RhdGFQaXBlRnJvbTxcbiAgU0kgZXh0ZW5kcyBQYXJ0SXRlbTxTUD4sXG4gIFNQIGV4dGVuZHMgc3RyaW5nID0gXCJpZFwiXG4+KGZyb206IERhdGFJbnRlcmZhY2U8U0ksIFNQPik6IERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb248U0ksIFNQPiB7XG4gIHJldHVybiBuZXcgRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbihmcm9tKTtcbn1cblxudHlwZSBUcmFuc2Zvcm1lcjxUPiA9IChpbnB1dDogVFtdKSA9PiBUW107XG5cbi8qKlxuICogSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIHBpcGUuIFRoaXMgc2hvdWxkIGJlIGFjY2Vzc2libGUgb25seSB0aHJvdWdoXG4gKiBgY3JlYXRlTmV3RGF0YVBpcGVGcm9tYCBmcm9tIHRoZSBvdXRzaWRlLlxuICpcbiAqIEB0eXBlUGFyYW0gU0kgLSBTb3VyY2UgaXRlbSB0eXBlLlxuICogQHR5cGVQYXJhbSBTUCAtIFNvdXJjZSBpdGVtIHR5cGUncyBpZCBwcm9wZXJ0eSBuYW1lLlxuICogQHR5cGVQYXJhbSBUSSAtIFRhcmdldCBpdGVtIHR5cGUuXG4gKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXG4gKi9cbmNsYXNzIFNpbXBsZURhdGFQaXBlPFxuICBTSSBleHRlbmRzIFBhcnRJdGVtPFNQPixcbiAgU1AgZXh0ZW5kcyBzdHJpbmcsXG4gIFRJIGV4dGVuZHMgUGFydEl0ZW08VFA+LFxuICBUUCBleHRlbmRzIHN0cmluZ1xuPiBpbXBsZW1lbnRzIERhdGFQaXBlIHtcbiAgLyoqXG4gICAqIEJvdW5kIGxpc3RlbmVycyBmb3IgdXNlIHdpdGggYERhdGFJbnRlcmZhY2VbJ29uJyB8ICdvZmYnXWAuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9saXN0ZW5lcnM6IEV2ZW50Q2FsbGJhY2tzPFNJLCBTUD4gPSB7XG4gICAgYWRkOiB0aGlzLl9hZGQuYmluZCh0aGlzKSxcbiAgICByZW1vdmU6IHRoaXMuX3JlbW92ZS5iaW5kKHRoaXMpLFxuICAgIHVwZGF0ZTogdGhpcy5fdXBkYXRlLmJpbmQodGhpcyksXG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhIHBpcGUuXG4gICAqXG4gICAqIEBwYXJhbSBfc291cmNlIC0gVGhlIGRhdGEgc2V0IG9yIGRhdGEgdmlldyB0aGF0IHdpbGwgYmUgb2JzZXJ2ZWQuXG4gICAqIEBwYXJhbSBfdHJhbnNmb3JtZXJzIC0gQW4gYXJyYXkgb2YgdHJhbnNmb3JtaW5nIGZ1bmN0aW9ucyB0byBiZSB1c2VkIHRvXG4gICAqIGZpbHRlciBvciB0cmFuc2Zvcm0gdGhlIGl0ZW1zIGluIHRoZSBwaXBlLlxuICAgKiBAcGFyYW0gX3RhcmdldCAtIFRoZSBkYXRhIHNldCBvciBkYXRhIHZpZXcgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGl0ZW1zLlxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgX3NvdXJjZTogRGF0YUludGVyZmFjZTxTSSwgU1A+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgX3RyYW5zZm9ybWVyczogcmVhZG9ubHkgVHJhbnNmb3JtZXI8dW5rbm93bj5bXSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IF90YXJnZXQ6IERhdGFTZXQ8VEksIFRQPlxuICApIHt9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBhbGwoKTogdGhpcyB7XG4gICAgdGhpcy5fdGFyZ2V0LnVwZGF0ZSh0aGlzLl90cmFuc2Zvcm1JdGVtcyh0aGlzLl9zb3VyY2UuZ2V0KCkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgc3RhcnQoKTogdGhpcyB7XG4gICAgdGhpcy5fc291cmNlLm9uKFwiYWRkXCIsIHRoaXMuX2xpc3RlbmVycy5hZGQpO1xuICAgIHRoaXMuX3NvdXJjZS5vbihcInJlbW92ZVwiLCB0aGlzLl9saXN0ZW5lcnMucmVtb3ZlKTtcbiAgICB0aGlzLl9zb3VyY2Uub24oXCJ1cGRhdGVcIiwgdGhpcy5fbGlzdGVuZXJzLnVwZGF0ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgc3RvcCgpOiB0aGlzIHtcbiAgICB0aGlzLl9zb3VyY2Uub2ZmKFwiYWRkXCIsIHRoaXMuX2xpc3RlbmVycy5hZGQpO1xuICAgIHRoaXMuX3NvdXJjZS5vZmYoXCJyZW1vdmVcIiwgdGhpcy5fbGlzdGVuZXJzLnJlbW92ZSk7XG4gICAgdGhpcy5fc291cmNlLm9mZihcInVwZGF0ZVwiLCB0aGlzLl9saXN0ZW5lcnMudXBkYXRlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoZSB0cmFuc2Zvcm1lcnMgdG8gdGhlIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0gaXRlbXMgLSBUaGUgaXRlbXMgdG8gYmUgdHJhbnNmb3JtZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm1lZCBpdGVtcy5cbiAgICovXG4gIHByaXZhdGUgX3RyYW5zZm9ybUl0ZW1zKGl0ZW1zOiB1bmtub3duW10pOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWVycy5yZWR1Y2UoKGl0ZW1zLCB0cmFuc2Zvcm0pOiB1bmtub3duW10gPT4ge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybShpdGVtcyk7XG4gICAgfSwgaXRlbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbiBhZGQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBfbmFtZSAtIElnbm9yZWQuXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHBheWxvYWQgY29udGFpbmluZyB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtcy5cbiAgICovXG4gIHByaXZhdGUgX2FkZChcbiAgICBfbmFtZTogUGFyYW1ldGVyczxFdmVudENhbGxiYWNrczxTSSwgU1A+W1wiYWRkXCJdPlswXSxcbiAgICBwYXlsb2FkOiBQYXJhbWV0ZXJzPEV2ZW50Q2FsbGJhY2tzPFNJLCBTUD5bXCJhZGRcIl0+WzFdXG4gICk6IHZvaWQge1xuICAgIGlmIChwYXlsb2FkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl90YXJnZXQuYWRkKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHRoaXMuX3NvdXJjZS5nZXQocGF5bG9hZC5pdGVtcykpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gdXBkYXRlIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gX25hbWUgLSBJZ25vcmVkLlxuICAgKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkIGNvbnRhaW5pbmcgdGhlIGlkcyBvZiB0aGUgdXBkYXRlZCBpdGVtcy5cbiAgICovXG4gIHByaXZhdGUgX3VwZGF0ZShcbiAgICBfbmFtZTogUGFyYW1ldGVyczxFdmVudENhbGxiYWNrczxTSSwgU1A+W1widXBkYXRlXCJdPlswXSxcbiAgICBwYXlsb2FkOiBQYXJhbWV0ZXJzPEV2ZW50Q2FsbGJhY2tzPFNJLCBTUD5bXCJ1cGRhdGVcIl0+WzFdXG4gICk6IHZvaWQge1xuICAgIGlmIChwYXlsb2FkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl90YXJnZXQudXBkYXRlKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHRoaXMuX3NvdXJjZS5nZXQocGF5bG9hZC5pdGVtcykpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSByZW1vdmUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBfbmFtZSAtIElnbm9yZWQuXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHBheWxvYWQgY29udGFpbmluZyB0aGUgZGF0YSBvZiB0aGUgcmVtb3ZlZCBpdGVtcy5cbiAgICovXG4gIHByaXZhdGUgX3JlbW92ZShcbiAgICBfbmFtZTogUGFyYW1ldGVyczxFdmVudENhbGxiYWNrczxTSSwgU1A+W1wicmVtb3ZlXCJdPlswXSxcbiAgICBwYXlsb2FkOiBQYXJhbWV0ZXJzPEV2ZW50Q2FsbGJhY2tzPFNJLCBTUD5bXCJyZW1vdmVcIl0+WzFdXG4gICk6IHZvaWQge1xuICAgIGlmIChwYXlsb2FkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl90YXJnZXQucmVtb3ZlKHRoaXMuX3RyYW5zZm9ybUl0ZW1zKHBheWxvYWQub2xkRGF0YSkpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIHBpcGUgZmFjdG9yeS4gVGhpcyBzaG91bGQgYmUgYWNjZXNzaWJsZVxuICogb25seSB0aHJvdWdoIGBjcmVhdGVOZXdEYXRhUGlwZUZyb21gIGZyb20gdGhlIG91dHNpZGUuXG4gKlxuICogQHR5cGVQYXJhbSBUSSAtIFRhcmdldCBpdGVtIHR5cGUuXG4gKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXG4gKi9cbmNsYXNzIERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb248XG4gIFNJIGV4dGVuZHMgUGFydEl0ZW08U1A+LFxuICBTUCBleHRlbmRzIHN0cmluZyA9IFwiaWRcIlxuPiB7XG4gIC8qKlxuICAgKiBBcnJheSB0cmFuc2Zvcm1lcnMgdXNlZCB0byB0cmFuc2Zvcm0gaXRlbXMgd2l0aGluIHRoZSBwaXBlLiBUaGlzIGlzIHR5cGVkXG4gICAqIGFzIGFueSBmb3IgdGhlIHNha2Ugb2Ygc2ltcGxpY2l0eS5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgX3RyYW5zZm9ybWVyczogVHJhbnNmb3JtZXI8YW55PltdID0gW107XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhIHBpcGUgZmFjdG9yeS4gVGhpcyBpcyBhbiBpbnRlcm5hbCBjb25zdHJ1Y3RvciB0aGF0XG4gICAqIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgZnJvbSBvdXRzaWRlIG9mIHRoaXMgZmlsZS5cbiAgICpcbiAgICogQHBhcmFtIF9zb3VyY2UgLSBUaGUgc291cmNlIGRhdGEgc2V0IG9yIGRhdGEgdmlldyBmb3IgdGhpcyBwaXBlLlxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgX3NvdXJjZTogRGF0YUludGVyZmFjZTxTSSwgU1A+KSB7fVxuXG4gIC8qKlxuICAgKiBGaWx0ZXIgdGhlIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIGZpbHRlcmluZyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBnaXZlbiBpdGVtXG4gICAqIHNob3VsZCBiZSBwaXBlZCBhbmQgZmFsc2UgaWYgbm90LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGlzIGZhY3RvcnkgZm9yIGZ1cnRoZXIgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBmaWx0ZXIoXG4gICAgY2FsbGJhY2s6IChpdGVtOiBTSSkgPT4gYm9vbGVhblxuICApOiBEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uPFNJLCBTUD4ge1xuICAgIHRoaXMuX3RyYW5zZm9ybWVycy5wdXNoKChpbnB1dCk6IHVua25vd25bXSA9PiBpbnB1dC5maWx0ZXIoY2FsbGJhY2spKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgZWFjaCBzb3VyY2UgaXRlbSB0byBhIG5ldyB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIG1hcHBpbmcgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNvdXJjZSBpdGVtIGFuZCByZXR1cm5zXG4gICAqIGNvcnJlc3BvbmRpbmcgbWFwcGVkIGl0ZW0uXG4gICAqXG4gICAqIEB0eXBlUGFyYW0gVEkgLSBUYXJnZXQgaXRlbSB0eXBlLlxuICAgKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoaXMgZmFjdG9yeSBmb3IgZnVydGhlciBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgcHVibGljIG1hcDxUSSBleHRlbmRzIFBhcnRJdGVtPFRQPiwgVFAgZXh0ZW5kcyBzdHJpbmcgPSBcImlkXCI+KFxuICAgIGNhbGxiYWNrOiAoaXRlbTogU0kpID0+IFRJXG4gICk6IERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb248VEksIFRQPiB7XG4gICAgdGhpcy5fdHJhbnNmb3JtZXJzLnB1c2goKGlucHV0KTogdW5rbm93bltdID0+IGlucHV0Lm1hcChjYWxsYmFjaykpO1xuICAgIHJldHVybiAodGhpcyBhcyB1bmtub3duKSBhcyBEYXRhUGlwZVVuZGVyQ29uc3RydWN0aW9uPFRJLCBUUD47XG4gIH1cblxuICAvKipcbiAgICogTWFwIGVhY2ggc291cmNlIGl0ZW0gdG8gemVybyBvciBtb3JlIGl0ZW1zIG9mIGEgbmV3IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgbWFwcGluZyBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc291cmNlIGl0ZW0gYW5kIHJldHVybnNcbiAgICogYW4gYXJyYXkgb2YgY29ycmVzcG9uZGluZyBtYXBwZWQgaXRlbXMuXG4gICAqXG4gICAqIEB0eXBlUGFyYW0gVEkgLSBUYXJnZXQgaXRlbSB0eXBlLlxuICAgKiBAdHlwZVBhcmFtIFRQIC0gVGFyZ2V0IGl0ZW0gdHlwZSdzIGlkIHByb3BlcnR5IG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoaXMgZmFjdG9yeSBmb3IgZnVydGhlciBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgcHVibGljIGZsYXRNYXA8VEkgZXh0ZW5kcyBQYXJ0SXRlbTxUUD4sIFRQIGV4dGVuZHMgc3RyaW5nID0gXCJpZFwiPihcbiAgICBjYWxsYmFjazogKGl0ZW06IFNJKSA9PiBUSVtdXG4gICk6IERhdGFQaXBlVW5kZXJDb25zdHJ1Y3Rpb248VEksIFRQPiB7XG4gICAgdGhpcy5fdHJhbnNmb3JtZXJzLnB1c2goKGlucHV0KTogdW5rbm93bltdID0+IGlucHV0LmZsYXRNYXAoY2FsbGJhY2spKTtcbiAgICByZXR1cm4gKHRoaXMgYXMgdW5rbm93bikgYXMgRGF0YVBpcGVVbmRlckNvbnN0cnVjdGlvbjxUSSwgVFA+O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3QgdGhpcyBwaXBlIHRvIGdpdmVuIGRhdGEgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIGRhdGEgc2V0IHRoYXQgd2lsbCByZWNlaXZlIHRoZSBpdGVtcyBmcm9tIHRoaXMgcGlwZS5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHBpcGUgY29ubmVjdGVkIGJldHdlZW4gZ2l2ZW4gZGF0YSBzZXRzIGFuZCBwZXJmb3JtaW5nXG4gICAqIGNvbmZpZ3VyZWQgdHJhbnNmb3JtYXRpb24gb24gdGhlIHByb2Nlc3NlZCBpdGVtcy5cbiAgICovXG4gIHB1YmxpYyB0byh0YXJnZXQ6IERhdGFTZXQ8U0ksIFNQPik6IERhdGFQaXBlIHtcbiAgICByZXR1cm4gbmV3IFNpbXBsZURhdGFQaXBlKHRoaXMuX3NvdXJjZSwgdGhpcy5fdHJhbnNmb3JtZXJzLCB0YXJnZXQpO1xuICB9XG59XG4iLCJ2YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuIiwidmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuIiwidmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBQcm9wZXJ0aWVzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIURFU0NSSVBUT1JTLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBkZWZpbmVQcm9wZXJ0aWVzOiBkZWZpbmVQcm9wZXJ0aWVzXG59KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9wYXRoJyk7XG5cbnZhciBPYmplY3QgPSBwYXRoLk9iamVjdDtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoVCwgRCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVCwgRCk7XG59O1xuXG5pZiAoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMuc2hhbSkgZGVmaW5lUHJvcGVydGllcy5zaGFtID0gdHJ1ZTtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydGllc1wiKTsiLCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJ2YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGtleSwgZGVzY3JpcHRvcjtcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9wYXRoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0aC5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnNcIik7IiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcigxKTsgfSk7XG52YXIgRk9SQ0VEID0gIURFU0NSSVBUT1JTIHx8IEZBSUxTX09OX1BSSU1JVElWRVM7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JbmRleGVkT2JqZWN0KGl0KSwga2V5KTtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxudmFyIE9iamVjdCA9IHBhdGguT2JqZWN0O1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbn07XG5cbmlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLnNoYW0pIGdldE93blByb3BlcnR5RGVzY3JpcHRvci5zaGFtID0gdHJ1ZTtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpOyIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG4gICAgYWN0aXZlWERvY3VtZW50ID0gZG9jdW1lbnQuZG9tYWluICYmIG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSBhY3RpdmVYRG9jdW1lbnQgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKTtcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZjtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJ1xuICAgID8gZ2V0V2luZG93TmFtZXMoaXQpXG4gICAgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xufTtcbiIsInZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVudW1lcmFibGUpIHRhcmdldFtrZXldID0gdmFsdWU7XG4gIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldCwga2V5LCB2YWx1ZSk7XG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG5leHBvcnRzLmYgPSB3ZWxsS25vd25TeW1ib2w7XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHZhciBTeW1ib2wgPSBwYXRoLlN5bWJvbCB8fCAocGF0aC5TeW1ib2wgPSB7fSk7XG4gIGlmICghaGFzKFN5bWJvbCwgTkFNRSkpIGRlZmluZVByb3BlcnR5KFN5bWJvbCwgTkFNRSwge1xuICAgIHZhbHVlOiB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoTkFNRSlcbiAgfSk7XG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG4iLCJ2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn07XG4iLCJ2YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRBRywgU1RBVElDLCBTRVRfTUVUSE9EKSB7XG4gIGlmIChpdCkge1xuICAgIHZhciB0YXJnZXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZTtcbiAgICBpZiAoIWhhcyh0YXJnZXQsIFRPX1NUUklOR19UQUcpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIFRPX1NUUklOR19UQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICAgIH1cbiAgICBpZiAoU0VUX01FVEhPRCAmJiAhVE9fU1RSSU5HX1RBR19TVVBQT1JUKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodGFyZ2V0LCAndG9TdHJpbmcnLCB0b1N0cmluZyk7XG4gICAgfVxuICB9XG59O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnRvU3RyaW5nO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKHR5cGVvZiBzdG9yZS5pbnNwZWN0U291cmNlICE9ICdmdW5jdGlvbicpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XG4iLCJ2YXIgTkFUSVZFX1dFQUtfTUFQID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgb2JqZWN0SGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVApIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gc3RvcmUuZ2V0O1xuICB2YXIgd21oYXMgPSBzdG9yZS5oYXM7XG4gIHZhciB3bXNldCA9IHN0b3JlLnNldDtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQuY2FsbChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMuY2FsbChzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCcpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIG5hdGl2ZU9iamVjdENyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQnKTtcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZm9yRWFjaDtcblxudmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG52YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1lNQk9MKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbignSlNPTicsICdzdHJpbmdpZnknKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N0cmluZy10by1zeW1ib2wtcmVnaXN0cnknKTtcbnZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdENyZWF0ZShuYXRpdmVEZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIFApO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcikgZGVsZXRlIE9iamVjdFByb3RvdHlwZVtQXTtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZSwgUCwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7XG4gIH1cbn0gOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHNldEludGVybmFsU3RhdGUoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUykgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGl0KSBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoTywgSElEREVOKSkgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgJGZvckVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMgfHwgJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocHJvcGVydGllcywga2V5KSkgJGRlZmluZVByb3BlcnR5KE8sIGtleSwgcHJvcGVydGllc1trZXldKTtcbiAgfSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gbmF0aXZlT2JqZWN0Q3JlYXRlKE8pIDogJGRlZmluZVByb3BlcnRpZXMobmF0aXZlT2JqZWN0Q3JlYXRlKE8pLCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBQID0gdG9QcmltaXRpdmUoViwgdHJ1ZSk7XG4gIHZhciBlbnVtZXJhYmxlID0gbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0aGlzLCBQKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywgUCkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZW51bWVyYWJsZSB8fCAhaGFzKHRoaXMsIFApIHx8ICFoYXMoQWxsU3ltYm9scywgUCkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW1BdID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG4gIGlmIChkZXNjcmlwdG9yICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIHtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhoaWRkZW5LZXlzLCBrZXkpKSByZXN1bHQucHVzaChrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGU7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXMoT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC1jb25zdHJ1Y3RvclxuaWYgKCFOQVRJVkVfU1lNQk9MKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICFhcmd1bWVudHMubGVuZ3RoIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHRhZyA9IHVpZChkZXNjcmlwdGlvbik7XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSkgc2V0dGVyLmNhbGwoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgVVNFX1NFVFRFUikgc2V0U3ltYm9sRGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogc2V0dGVyIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICB9KTtcblxuICByZWRlZmluZSgkU3ltYm9sLCAnd2l0aG91dFNldHRlcicsIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiB3cmFwKHVpZChkZXNjcmlwdGlvbiksIGRlc2NyaXB0aW9uKTtcbiAgfSk7XG5cbiAgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3ZWxsS25vd25TeW1ib2wobmFtZSksIG5hbWUpO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLVN5bWJvbC1kZXNjcmlwdGlvblxuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFJU19QVVJFKSB7XG4gICAgICByZWRlZmluZShPYmplY3RQcm90b3R5cGUsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuICB9XG59XG5cbiQoeyBnbG9iYWw6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsIHNoYW06ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgU3ltYm9sOiAkU3ltYm9sXG59KTtcblxuJGZvckVhY2gob2JqZWN0S2V5cyhXZWxsS25vd25TeW1ib2xzU3RvcmUpLCBmdW5jdGlvbiAobmFtZSkge1xuICBkZWZpbmVXZWxsS25vd25TeW1ib2wobmFtZSk7XG59KTtcblxuJCh7IHRhcmdldDogU1lNQk9MLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuZm9yXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyhrZXkpO1xuICAgIGlmIChoYXMoU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSwgc3RyaW5nKSkgcmV0dXJuIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXTtcbiAgICB2YXIgc3ltYm9sID0gJFN5bWJvbChzdHJpbmcpO1xuICAgIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXSA9IHN5bWJvbDtcbiAgICBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bWJvbF0gPSBzdHJpbmc7XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfSxcbiAgLy8gYFN5bWJvbC5rZXlGb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgaWYgKGhhcyhTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5LCBzeW0pKSByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gZmFsc2U7IH1cbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogZmFpbHMoZnVuY3Rpb24gKCkgeyBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZigxKTsgfSkgfSwge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeVxuaWYgKCRzdHJpbmdpZnkpIHtcbiAgdmFyIEZPUkNFRF9KU09OX1NUUklOR0lGWSA9ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3ltYm9sID0gJFN5bWJvbCgpO1xuICAgIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gICAgcmV0dXJuICRzdHJpbmdpZnkoW3N5bWJvbF0pICE9ICdbbnVsbF0nXG4gICAgICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgICAgIHx8ICRzdHJpbmdpZnkoeyBhOiBzeW1ib2wgfSkgIT0gJ3t9J1xuICAgICAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgICAgIHx8ICRzdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9ICd7fSc7XG4gIH0pO1xuXG4gICQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfSlNPTl9TVFJJTkdJRlkgfSwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICAgIHZhciBpbmRleCA9IDE7XG4gICAgICB2YXIgJHJlcGxhY2VyO1xuICAgICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpbmRleCkgYXJncy5wdXNoKGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgICAkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgICByZXR1cm4gJHN0cmluZ2lmeS5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmlmICghJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0pIHtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG59XG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZ1xuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgU1lNQk9MKTtcblxuaGlkZGVuS2V5c1tISURERU5dID0gdHJ1ZTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9wYXRoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0aC5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXInKTtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbmlmIChJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5pZiAoIUlTX1BVUkUgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJykuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdChPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3RvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJyk7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3InKTtcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3Rcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuIiwicmVxdWlyZSgnLi9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIERPTUl0ZXJhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20taXRlcmFibGVzJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUgJiYgY2xhc3NvZihDb2xsZWN0aW9uUHJvdG90eXBlKSAhPT0gVE9fU1RSSU5HX1RBRykge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICB9XG4gIEl0ZXJhdG9yc1tDT0xMRUNUSU9OX05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBjb2RlUG9pbnRBdCwgYXQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcbiAgICBzdHJpbmc6IFN0cmluZyhpdGVyYXRlZCksXG4gICAgaW5kZXg6IDBcbiAgfSk7XG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChpdCk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JNZXRob2QgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgfSByZXR1cm4gYW5PYmplY3QoaXRlcmF0b3JNZXRob2QuY2FsbChpdCkpO1xufTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3InKTtcbnZhciBnZXRJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9mZWF0dXJlcy9nZXQtaXRlcmF0b3JcIik7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvcicpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvck1ldGhvZDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9mZWF0dXJlcy9nZXQtaXRlcmF0b3ItbWV0aG9kXCIpOyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgdmFyIHJldHVybk1ldGhvZCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgaWYgKHJldHVybk1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFuT2JqZWN0KHJldHVybk1ldGhvZC5jYWxsKGl0ZXJhdG9yKSkudmFsdWU7XG4gIH1cbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1jbG9zZScpO1xuXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZycpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3IsIG5leHQsIHZhbHVlO1xuICBpZiAobWFwcGluZykgbWFwZm4gPSBiaW5kKG1hcGZuLCBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgLy8gaWYgdGhlIHRhcmdldCBpcyBub3QgaXRlcmFibGUgb3IgaXQncyBhbiBhcnJheSB3aXRoIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIGEgc2ltcGxlIGNhc2VcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhdG9yTWV0aG9kLmNhbGwoTyk7XG4gICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgcmVzdWx0ID0gbmV3IEMoKTtcbiAgICBmb3IgKDshKHN0ZXAgPSBuZXh0LmNhbGwoaXRlcmF0b3IpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgcmVzdWx0ID0gbmV3IEMobGVuZ3RoKTtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZyb20nKTtcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uJyk7XG5cbnZhciBJTkNPUlJFQ1RfSVRFUkFUSU9OID0gIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgQXJyYXkuZnJvbShpdGVyYWJsZSk7XG59KTtcblxuLy8gYEFycmF5LmZyb21gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuJCh7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgZnJvbTogZnJvbVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5mcm9tJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9wYXRoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0aC5BcnJheS5mcm9tO1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2FycmF5L2Zyb20nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL2FycmF5L2Zyb21cIik7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbGxgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xuICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmlsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1maWxsJyk7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSB9LCB7XG4gIGZpbGw6IGZpbGxcbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygnZmlsbCcpO1xuIiwicmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5maWxsJyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykuZmlsbDtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQnKTtcblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG52YXIgTVNJRSA9IC9NU0lFIC5cXC4vLnRlc3QodXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChoYW5kbGVyLCB0aW1lb3V0IC8qICwgLi4uYXJndW1lbnRzICovKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIHZhciBhcmdzID0gYm91bmRBcmdzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBzY2hlZHVsZXIoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGhhbmRsZXIgPT0gJ2Z1bmN0aW9uJyA/IGhhbmRsZXIgOiBGdW5jdGlvbihoYW5kbGVyKSkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSA6IGhhbmRsZXIsIHRpbWVvdXQpO1xuICB9O1xufTtcblxuLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCN0aW1lcnNcbiQoeyBnbG9iYWw6IHRydWUsIGJpbmQ6IHRydWUsIGZvcmNlZDogTVNJRSB9LCB7XG4gIC8vIGBzZXRUaW1lb3V0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCNkb20tc2V0dGltZW91dFxuICBzZXRUaW1lb3V0OiB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgLy8gYHNldEludGVydmFsYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCNkb20tc2V0aW50ZXJ2YWxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLnNldFRpbWVvdXQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL3NldC10aW1lb3V0XCIpOyIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyICRzdHJpbmdpZnkgPSBnZXRCdWlsdEluKCdKU09OJywgJ3N0cmluZ2lmeScpO1xudmFyIHJlID0gL1tcXHVEODAwLVxcdURGRkZdL2c7XG52YXIgbG93ID0gL15bXFx1RDgwMC1cXHVEQkZGXSQvO1xudmFyIGhpID0gL15bXFx1REMwMC1cXHVERkZGXSQvO1xuXG52YXIgZml4ID0gZnVuY3Rpb24gKG1hdGNoLCBvZmZzZXQsIHN0cmluZykge1xuICB2YXIgcHJldiA9IHN0cmluZy5jaGFyQXQob2Zmc2V0IC0gMSk7XG4gIHZhciBuZXh0ID0gc3RyaW5nLmNoYXJBdChvZmZzZXQgKyAxKTtcbiAgaWYgKChsb3cudGVzdChtYXRjaCkgJiYgIWhpLnRlc3QobmV4dCkpIHx8IChoaS50ZXN0KG1hdGNoKSAmJiAhbG93LnRlc3QocHJldikpKSB7XG4gICAgcmV0dXJuICdcXFxcdScgKyBtYXRjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgfSByZXR1cm4gbWF0Y2g7XG59O1xuXG52YXIgRk9SQ0VEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHN0cmluZ2lmeSgnXFx1REYwNlxcdUQ4MzQnKSAhPT0gJ1wiXFxcXHVkZjA2XFxcXHVkODM0XCInXG4gICAgfHwgJHN0cmluZ2lmeSgnXFx1REVBRCcpICE9PSAnXCJcXFxcdWRlYWRcIic7XG59KTtcblxuaWYgKCRzdHJpbmdpZnkpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtd2VsbC1mb3JtZWQtc3RyaW5naWZ5XG4gICQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICAgIHZhciByZXN1bHQgPSAkc3RyaW5naWZ5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAnc3RyaW5nJyA/IHJlc3VsdC5yZXBsYWNlKHJlLCBmaXgpIDogcmVzdWx0O1xuICAgIH1cbiAgfSk7XG59XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLmpzb24uc3RyaW5naWZ5Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9wYXRoJyk7XG5cbmlmICghY29yZS5KU09OKSBjb3JlLkpTT04gPSB7IHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnkgfTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gIHJldHVybiBjb3JlLkpTT04uc3RyaW5naWZ5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2pzb24vc3RyaW5naWZ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9qc29uL3N0cmluZ2lmeVwiKTsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBjcmVhdGU6IGNyZWF0ZVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC5jcmVhdGUnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxudmFyIE9iamVjdCA9IHBhdGguT2JqZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9vYmplY3QvY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvY3JlYXRlXCIpOyIsInZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5OyIsIi8vIGEgc3RyaW5nIG9mIGFsbCB2YWxpZCB1bmljb2RlIHdoaXRlc3BhY2VzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxubW9kdWxlLmV4cG9ydHMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCJ2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgd2hpdGVzcGFjZSA9ICdbJyArIHdoaXRlc3BhY2VzICsgJ10nO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcykge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1MZWZ0LCB0cmltU3RhcnQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbWVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICB0cmltOiBjcmVhdGVNZXRob2QoMylcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgbm9uID0gJ1xcdTIwMEJcXHUwMDg1XFx1MTgwRSc7XG5cbi8vIGNoZWNrIHRoYXQgYSBtZXRob2Qgd29ya3Mgd2l0aCB0aGUgY29ycmVjdCBsaXN0XG4vLyBvZiB3aGl0ZXNwYWNlcyBhbmQgaGFzIGEgY29ycmVjdCBuYW1lXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICByZXR1cm4gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpIHx8IG5vbltNRVRIT0RfTkFNRV0oKSAhPSBub24gfHwgd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctdHJpbScpLnRyaW07XG52YXIgZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctdHJpbS1mb3JjZWQnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltJykgfSwge1xuICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzKTtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGVzL2VzLnN0cmluZy50cmltJyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ1N0cmluZycpLnRyaW07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpLmluZGV4T2Y7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0Jyk7XG52YXIgYXJyYXlNZXRob2RVc2VzVG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoJyk7XG5cbnZhciBuYXRpdmVJbmRleE9mID0gW10uaW5kZXhPZjtcblxudmFyIE5FR0FUSVZFX1pFUk8gPSAhIW5hdGl2ZUluZGV4T2YgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2luZGV4T2YnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdpbmRleE9mJywgeyBBQ0NFU1NPUlM6IHRydWUsIDE6IDAgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogTkVHQVRJVkVfWkVSTyB8fCAhU1RSSUNUX01FVEhPRCB8fCAhVVNFU19UT19MRU5HVEggfSwge1xuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gbmF0aXZlSW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YnKTtcbnZhciBlbnRyeVZpcnR1YWwgPSByZXF1aXJlKCcuLi8uLi8uLi9pbnRlcm5hbHMvZW50cnktdmlydHVhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVudHJ5VmlydHVhbCgnQXJyYXknKS5pbmRleE9mO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciB0cmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykudHJpbTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgJHBhcnNlSW50ID0gZ2xvYmFsLnBhcnNlSW50O1xudmFyIGhleCA9IC9eWystXT8wW1h4XS87XG52YXIgRk9SQ0VEID0gJHBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzB4MTYnKSAhPT0gMjI7XG5cbi8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcbm1vZHVsZS5leHBvcnRzID0gRk9SQ0VEID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCkge1xuICB2YXIgUyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuICByZXR1cm4gJHBhcnNlSW50KFMsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KFMpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHBhcnNlSW50SW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbnVtYmVyLXBhcnNlLWludCcpO1xuXG4vLyBgcGFyc2VJbnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcGFyc2VpbnQtc3RyaW5nLXJhZGl4XG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlSW50ICE9IHBhcnNlSW50SW1wbGVtZW50YXRpb24gfSwge1xuICBwYXJzZUludDogcGFyc2VJbnRJbXBsZW1lbnRhdGlvblxufSk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKS5mO1xuXG4vLyBgT2JqZWN0LnsgZW50cmllcywgdmFsdWVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVE9fRU5UUklFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoaXQpO1xuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBpKSB7XG4gICAgICBrZXkgPSBrZXlzW2krK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoTywga2V5KSkge1xuICAgICAgICByZXN1bHQucHVzaChUT19FTlRSSUVTID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYE9iamVjdC5lbnRyaWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmVudHJpZXNcbiAgZW50cmllczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgT2JqZWN0LnZhbHVlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcbiAgdmFsdWVzOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJHZhbHVlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtdG8tYXJyYXknKS52YWx1ZXM7XG5cbi8vIGBPYmplY3QudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoTykge1xuICAgIHJldHVybiAkdmFsdWVzKE8pO1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LnZhbHVlcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LnZhbHVlcztcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbmF0aXZlR2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyJyk7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVHZXRQcm90b3R5cGVPZigxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTLCBzaGFtOiAhQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSIH0sIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pO1xuXG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9wYXRoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0aC5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmNsdWRlcztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aCcpO1xuXG52YXIgVVNFU19UT19MRU5HVEggPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCgnaW5kZXhPZicsIHsgQUNDRVNTT1JTOiB0cnVlLCAxOiAwIH0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVVTRVNfVE9fTEVOR1RIIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdpbmNsdWRlcycpO1xuIiwicmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlcycpO1xudmFyIGVudHJ5VmlydHVhbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVybmFscy9lbnRyeS12aXJ0dWFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLmluY2x1ZGVzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNyZWdleHBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG4iLCJ2YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcmVnZXhwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ0V4cChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICB2YXIgcmVnZXhwID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICB0cnkge1xuICAgICAgcmVnZXhwW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICAgIH0gY2F0Y2ggKGVycm9yMikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIG5vdEFSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbm90LWEtcmVnZXhwJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYycpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdpbmNsdWRlcycpIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSlcbiAgICAgIC5pbmRleE9mKG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzJyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ1N0cmluZycpLmluY2x1ZGVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcblxudmFyIG5hdGl2ZUFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbm1vZHVsZS5leHBvcnRzID0gIW5hdGl2ZUFzc2lnbiB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXG4gIGlmIChERVNDUklQVE9SUyAmJiBuYXRpdmVBc3NpZ24oeyBiOiAxIH0sIG5hdGl2ZUFzc2lnbihkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiBuYXRpdmVBc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKG5hdGl2ZUFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gb2JqZWN0S2V5cyhTKS5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfSByZXR1cm4gVDtcbn0gOiBuYXRpdmVBc3NpZ247XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xuICBhc3NpZ246IGFzc2lnblxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24nKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC5hc3NpZ247XG4iLCJ2YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvb2JqZWN0L2Fzc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2Fzc2lnblwiKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtdXNlcy10by1sZW5ndGgnKTtcblxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdzcGxpY2UnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdzcGxpY2UnLCB7IEFDQ0VTU09SUzogdHJ1ZSwgMDogMCwgMTogMiB9KTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGO1xudmFyIE1BWElNVU1fQUxMT1dFRF9MRU5HVEhfRVhDRUVERUQgPSAnTWF4aW11bSBhbGxvd2VkIGxlbmd0aCBleGNlZWRlZCc7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zcGxpY2Vcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB8fCAhVVNFU19UT19MRU5HVEggfSwge1xuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQgLyogLCAuLi5pdGVtcyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgYWN0dWFsU3RhcnQgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGluc2VydENvdW50LCBhY3R1YWxEZWxldGVDb3VudCwgQSwgaywgZnJvbSwgdG87XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMCkge1xuICAgICAgaW5zZXJ0Q291bnQgPSBhY3R1YWxEZWxldGVDb3VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGluc2VydENvdW50ID0gMDtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbGVuIC0gYWN0dWFsU3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc2VydENvdW50ID0gYXJndW1lbnRzTGVuZ3RoIC0gMjtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbWluKG1heCh0b0ludGVnZXIoZGVsZXRlQ291bnQpLCAwKSwgbGVuIC0gYWN0dWFsU3RhcnQpO1xuICAgIH1cbiAgICBpZiAobGVuICsgaW5zZXJ0Q291bnQgLSBhY3R1YWxEZWxldGVDb3VudCA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfTEVOR1RIX0VYQ0VFREVEKTtcbiAgICB9XG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCBhY3R1YWxEZWxldGVDb3VudCk7XG4gICAgZm9yIChrID0gMDsgayA8IGFjdHVhbERlbGV0ZUNvdW50OyBrKyspIHtcbiAgICAgIGZyb20gPSBhY3R1YWxTdGFydCArIGs7XG4gICAgICBpZiAoZnJvbSBpbiBPKSBjcmVhdGVQcm9wZXJ0eShBLCBrLCBPW2Zyb21dKTtcbiAgICB9XG4gICAgQS5sZW5ndGggPSBhY3R1YWxEZWxldGVDb3VudDtcbiAgICBpZiAoaW5zZXJ0Q291bnQgPCBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgZm9yIChrID0gYWN0dWFsU3RhcnQ7IGsgPCBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgIHRvID0gayArIGluc2VydENvdW50O1xuICAgICAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgfVxuICAgICAgZm9yIChrID0gbGVuOyBrID4gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpbnNlcnRDb3VudDsgay0tKSBkZWxldGUgT1trIC0gMV07XG4gICAgfSBlbHNlIGlmIChpbnNlcnRDb3VudCA+IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICBmb3IgKGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDsgayA+IGFjdHVhbFN0YXJ0OyBrLS0pIHtcbiAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDE7XG4gICAgICAgIHRvID0gayArIGluc2VydENvdW50IC0gMTtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrID0gMDsgayA8IGluc2VydENvdW50OyBrKyspIHtcbiAgICAgIE9bayArIGFjdHVhbFN0YXJ0XSA9IGFyZ3VtZW50c1trICsgMl07XG4gICAgfVxuICAgIE8ubGVuZ3RoID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpbnNlcnRDb3VudDtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGVzL2VzLmFycmF5LnNwbGljZScpO1xudmFyIGVudHJ5VmlydHVhbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVybmFscy9lbnRyeS12aXJ0dWFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLnNwbGljZTtcbiIsInZhciBzcGxpY2UgPSByZXF1aXJlKCcuLi9hcnJheS92aXJ0dWFsL3NwbGljZScpO1xuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5zcGxpY2U7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgKGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5zcGxpY2UpID8gc3BsaWNlIDogb3duO1xufTtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9pbnN0YW5jZS9zcGxpY2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3NwbGljZVwiKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG5cbnZhciBuYXRpdmVSZXZlcnNlID0gW10ucmV2ZXJzZTtcbnZhciB0ZXN0ID0gWzEsIDJdO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJldmVyc2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJldmVyc2Vcbi8vIGZpeCBmb3IgU2FmYXJpIDEyLjAgYnVnXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg4Nzk0XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBTdHJpbmcodGVzdCkgPT09IFN0cmluZyh0ZXN0LnJldmVyc2UoKSkgfSwge1xuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIGlmIChpc0FycmF5KHRoaXMpKSB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHJldHVybiBuYXRpdmVSZXZlcnNlLmNhbGwodGhpcyk7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5yZXZlcnNlJyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykucmV2ZXJzZTtcbiIsInZhciByZXZlcnNlID0gcmVxdWlyZSgnLi4vYXJyYXkvdmlydHVhbC9yZXZlcnNlJyk7XG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnJldmVyc2U7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgKGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5yZXZlcnNlKSA/IHJldmVyc2UgOiBvd247XG59O1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2luc3RhbmNlL3JldmVyc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3JldmVyc2VcIik7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZvckVhY2g7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0Jyk7XG52YXIgYXJyYXlNZXRob2RVc2VzVG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoJyk7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnZm9yRWFjaCcpO1xudmFyIFVTRVNfVE9fTEVOR1RIID0gYXJyYXlNZXRob2RVc2VzVG9MZW5ndGgoJ2ZvckVhY2gnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5tb2R1bGUuZXhwb3J0cyA9ICghU1RSSUNUX01FVEhPRCB8fCAhVVNFU19UT19MRU5HVEgpID8gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSA6IFtdLmZvckVhY2g7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogW10uZm9yRWFjaCAhPSBmb3JFYWNoIH0sIHtcbiAgZm9yRWFjaDogZm9yRWFjaFxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoJyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykuZm9yRWFjaDtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9lcy9hcnJheS92aXJ0dWFsL2Zvci1lYWNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yJyk7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2FycmF5L3ZpcnR1YWwvZm9yLWVhY2gnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBOb2RlTGlzdDogdHJ1ZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmZvckVhY2g7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgKGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5mb3JFYWNoKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICB8fCBET01JdGVyYWJsZXMuaGFzT3duUHJvcGVydHkoY2xhc3NvZihpdCkpID8gZm9yRWFjaCA6IG93bjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL2Zvci1lYWNoXCIpOyIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcblxuLy8gYEFycmF5LmlzQXJyYXlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkuaXNhcnJheVxuJCh7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIGlzQXJyYXk6IGlzQXJyYXlcbn0pO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5pcy1hcnJheScpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguQXJyYXkuaXNBcnJheTtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9hcnJheS9pcy1hcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9mZWF0dXJlcy9hcnJheS9pcy1hcnJheVwiKTsiLCJ2YXIgX0FycmF5JGlzQXJyYXkgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL2FycmF5L2lzLWFycmF5XCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChfQXJyYXkkaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICB8fCBJdGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2xhc3NvZihPKSk7XG59O1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvcicpO1xudmFyIGlzSXRlcmFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtaXRlcmFibGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhYmxlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL2ZlYXR1cmVzL2lzLWl0ZXJhYmxlXCIpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBWOF9WRVJTSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uJyk7XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHdlbGxLbm93blN5bWJvbCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7XG52YXIgTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCc7XG5cbi8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUID0gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgYXJyYXlbSVNfQ09OQ0FUX1NQUkVBREFCTEVdID0gZmFsc2U7XG4gIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XG59KTtcblxudmFyIFNQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2NvbmNhdCcpO1xuXG52YXIgaXNDb25jYXRTcHJlYWRhYmxlID0gZnVuY3Rpb24gKE8pIHtcbiAgaWYgKCFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3ByZWFkYWJsZSA9IE9bSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICByZXR1cm4gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheShPKTtcbn07XG5cbnZhciBGT1JDRUQgPSAhSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCB8fCAhU1BFQ0lFU19TVVBQT1JUO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuY29uY2F0XG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAaXNDb25jYXRTcHJlYWRhYmxlIGFuZCBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KGFyZykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuICAgIGZvciAoaSA9IC0xLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07XG4gICAgICBpZiAoaXNDb25jYXRTcHJlYWRhYmxlKEUpKSB7XG4gICAgICAgIGxlbiA9IHRvTGVuZ3RoKEUubGVuZ3RoKTtcbiAgICAgICAgaWYgKG4gKyBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrLCBuKyspIGlmIChrIGluIEUpIGNyZWF0ZVByb3BlcnR5KEEsIG4sIEVba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG4gPj0gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KEEsIG4rKywgRSk7XG4gICAgICB9XG4gICAgfVxuICAgIEEubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuYXN5bmNpdGVyYXRvclxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdhc3luY0l0ZXJhdG9yJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLmhhc0luc3RhbmNlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLmhhc2luc3RhbmNlXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2hhc0luc3RhbmNlJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5pc2NvbmNhdHNwcmVhZGFibGVcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLml0ZXJhdG9yYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLml0ZXJhdG9yXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLm1hdGNoYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLm1hdGNoXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLm1hdGNoQWxsYCB3ZWxsLWtub3duIHN5bWJvbFxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdtYXRjaEFsbCcpO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC5yZXBsYWNlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnJlcGxhY2VcbmRlZmluZVdlbGxLbm93blN5bWJvbCgncmVwbGFjZScpO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC5zZWFyY2hgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuc2VhcmNoXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3NlYXJjaCcpO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC5zcGVjaWVzYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnNwZWNpZXNcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC5zcGxpdGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5zcGxpdFxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdzcGxpdCcpO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC50b1ByaW1pdGl2ZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC50b3ByaW1pdGl2ZVxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC50b1N0cmluZ1RhZ2Agd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC50b3N0cmluZ3RhZ1xuZGVmaW5lV2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC51bnNjb3BhYmxlc2Agd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC51bnNjb3BhYmxlc1xuZGVmaW5lV2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xuXG4vLyBKU09OW0BAdG9TdHJpbmdUYWddIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1qc29uLUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5jb25jYXQnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wuaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnN5bWJvbC5pcy1jb25jYXQtc3ByZWFkYWJsZScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLm1hdGNoJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnN5bWJvbC5tYXRjaC1hbGwnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLnNlYXJjaCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wuc3BlY2llcycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wuc3BsaXQnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wudG8tc3RyaW5nLXRhZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wudW5zY29wYWJsZXMnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuanNvbi50by1zdHJpbmctdGFnJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLm1hdGgudG8tc3RyaW5nLXRhZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5yZWZsZWN0LnRvLXN0cmluZy10YWcnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLlN5bWJvbDtcbiIsInZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG5cbi8vIGBTeW1ib2wuYXN5bmNEaXNwb3NlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdXNpbmctc3RhdGVtZW50XG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2FzeW5jRGlzcG9zZScpO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC5kaXNwb3NlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdXNpbmctc3RhdGVtZW50XG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2Rpc3Bvc2UnKTtcbiIsInZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG5cbi8vIGBTeW1ib2wub2JzZXJ2YWJsZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC5wYXR0ZXJuTWF0Y2hgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wYXR0ZXJuLW1hdGNoaW5nXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3BhdHRlcm5NYXRjaCcpO1xuIiwiLy8gVE9ETzogcmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCgncmVwbGFjZUFsbCcpO1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL3N5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lc25leHQuc3ltYm9sLmFzeW5jLWRpc3Bvc2UnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5kaXNwb3NlJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzbmV4dC5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lc25leHQuc3ltYm9sLnBhdHRlcm4tbWF0Y2gnKTtcbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzbmV4dC5zeW1ib2wucmVwbGFjZS1hbGwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvZmVhdHVyZXMvc3ltYm9sXCIpOyIsInZhciBfZ2V0SXRlcmF0b3IgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9pc0l0ZXJhYmxlID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9pcy1pdGVyYWJsZVwiKTtcblxudmFyIF9TeW1ib2wgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL3N5bWJvbFwiKTtcblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIF9TeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9pc0l0ZXJhYmxlKE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBfZ2V0SXRlcmF0b3IoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJ2YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvYXJyYXkvZnJvbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9mZWF0dXJlcy9hcnJheS9mcm9tXCIpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG52YXIgYXJyYXlNZXRob2RVc2VzVG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLXVzZXMtdG8tbGVuZ3RoJyk7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc2xpY2UnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdzbGljZScsIHsgQUNDRVNTT1JTOiB0cnVlLCAwOiAwLCAxOiAyIH0pO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyIG5hdGl2ZVNsaWNlID0gW10uc2xpY2U7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNsaWNlXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB8fCAhVVNFU19UT19MRU5HVEggfSwge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgICAvLyBpbmxpbmUgYEFycmF5U3BlY2llc0NyZWF0ZWAgZm9yIHVzYWdlIG5hdGl2ZSBgQXJyYXkjc2xpY2VgIHdoZXJlIGl0J3MgcG9zc2libGVcbiAgICB2YXIgQ29uc3RydWN0b3IsIHJlc3VsdCwgbjtcbiAgICBpZiAoaXNBcnJheShPKSkge1xuICAgICAgQ29uc3RydWN0b3IgPSBPLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgQ29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAoQ29uc3RydWN0b3IgPT09IEFycmF5IHx8IGlzQXJyYXkoQ29uc3RydWN0b3IucHJvdG90eXBlKSkpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KENvbnN0cnVjdG9yKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yW1NQRUNJRVNdO1xuICAgICAgICBpZiAoQ29uc3RydWN0b3IgPT09IG51bGwpIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVTbGljZS5jYWxsKE8sIGssIGZpbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCA9IG5ldyAoQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQ29uc3RydWN0b3IpKG1heChmaW4gLSBrLCAwKSk7XG4gICAgZm9yIChuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGlmIChrIGluIE8pIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGVzL2VzLmFycmF5LnNsaWNlJyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5Jykuc2xpY2U7XG4iLCJ2YXIgc2xpY2UgPSByZXF1aXJlKCcuLi9hcnJheS92aXJ0dWFsL3NsaWNlJyk7XG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNsaWNlO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlIHx8IChpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUuc2xpY2UpID8gc2xpY2UgOiBvd247XG59O1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2luc3RhbmNlL3NsaWNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL2ZlYXR1cmVzL2luc3RhbmNlL3NsaWNlXCIpOyIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTsiLCJ2YXIgX0FycmF5JGZyb20gPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL2FycmF5L2Zyb21cIik7XG5cbnZhciBfc2xpY2VJbnN0YW5jZVByb3BlcnR5ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9pbnN0YW5jZS9zbGljZVwiKTtcblxudmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIHZhciBfY29udGV4dDtcblxuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuXG4gIHZhciBuID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dCwgOCwgLTEpO1xuXG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBfQXJyYXkkZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xuXG4vLyBgRGF0ZS5ub3dgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF0ZS5ub3dcbiQoeyB0YXJnZXQ6ICdEYXRlJywgc3RhdDogdHJ1ZSB9LCB7XG4gIG5vdzogZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLmRhdGUubm93Jyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9wYXRoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0aC5EYXRlLm5vdztcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlS2V5cygxKTsgfSk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyB9LCB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdChpdCkpO1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LmtleXMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC5rZXlzO1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL29iamVjdC9rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3Qva2V5c1wiKTsiLCJ2YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvYXJyYXkvaXMtYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL2FycmF5L2lzLWFycmF5XCIpOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yJyk7XG52YXIgV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKCdpdGVyYXRvcicpO1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL3N5bWJvbC9pdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9mZWF0dXJlcy9zeW1ib2wvaXRlcmF0b3JcIik7IiwidmFyIF9TeW1ib2wkaXRlcmF0b3IgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9TeW1ib2wgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL3N5bWJvbFwiKTtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgX1N5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfU3ltYm9sJGl0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIF9TeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9TeW1ib2wgJiYgb2JqICE9PSBfU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xuXG4vLyBgUmVmbGVjdC5vd25LZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3Qub3dua2V5c1xuJCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgb3duS2V5czogb3duS2V5c1xufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnJlZmxlY3Qub3duLWtleXMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLlJlZmxlY3Qub3duS2V5cztcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9yZWZsZWN0L293bi1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9yZWZsZWN0L293bi1rZXlzXCIpOyIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9pbnN0YW5jZS9zbGljZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2Uvc2xpY2VcIik7IiwidmFyIF9BcnJheSRpc0FycmF5ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9hcnJheS9pcy1hcnJheVwiKTtcblxudmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChfQXJyYXkkaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlczsiLCJ2YXIgX0FycmF5JGZyb20gPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL2FycmF5L2Zyb21cIik7XG5cbnZhciBfaXNJdGVyYWJsZSA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfU3ltYm9sID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy9zeW1ib2xcIik7XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIF9TeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgX2lzSXRlcmFibGUoT2JqZWN0KGl0ZXIpKSkgcmV0dXJuIF9BcnJheSRmcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZFwiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyIsInJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0Jyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykuY29uY2F0O1xuIiwidmFyIGNvbmNhdCA9IHJlcXVpcmUoJy4uL2FycmF5L3ZpcnR1YWwvY29uY2F0Jyk7XG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmNvbmNhdDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCAoaXQgaW5zdGFuY2VvZiBBcnJheSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlLmNvbmNhdCkgPyBjb25jYXQgOiBvd247XG59O1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2luc3RhbmNlL2NvbmNhdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvY29uY2F0XCIpOyIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9zeW1ib2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL3N5bWJvbFwiKTsiLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSBldmVudCBzcGVjaWZpYyBhcnJheXMgZm9yIGV2ZW50IHR5cGVzIHRoYXQgbm9cclxuICAvLyBvbmUgaXMgc3Vic2NyaWJlZCBmb3IgdG8gYXZvaWQgbWVtb3J5IGxlYWsuXHJcbiAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcclxuICB9XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjE3LXJjIC0gMjAxOS0xMi0xNlxuICogaHR0cDovL25hdmVyLmdpdGh1Yi5pby9lZ2pzXG4gKlxuICogRm9ya2VkIEJ5IE5hdmVyIGVnanNcbiAqIENvcHlyaWdodCAoYykgaGFtbWVyanNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICovXG52YXIgYXNzaWduO1xuXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufSBlbHNlIHtcbiAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxudmFyIGFzc2lnbiQxID0gYXNzaWduO1xuXG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8ge1xuICBzdHlsZToge31cbn0gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcbnZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgYWJzID0gTWF0aC5hYnM7XG52YXIgbm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4O1xuICB2YXIgcHJvcDtcbiAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICBwcm9wID0gcHJlZml4ID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jLCBuby1uZXN0ZWQtdGVybmFyeSAqL1xudmFyIHdpbjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgLy8gd2luZG93IGlzIHVuZGVmaW5lZCBpbiBub2RlLmpzXG4gIHdpbiA9IHt9O1xufSBlbHNlIHtcbiAgd2luID0gd2luZG93O1xufVxuXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICBpZiAoIU5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgdmFyIGNzc1N1cHBvcnRzID0gd2luLkNTUyAmJiB3aW4uQ1NTLnN1cHBvcnRzO1xuICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgcmV0dXJuIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbi5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHRvdWNoTWFwO1xufVxuXG52YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcblxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbnZhciBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xudmFyIFNVUFBPUlRfVE9VQ0ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW47XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbiwgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG52YXIgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG52YXIgQ09NUFVURV9JTlRFUlZBTCA9IDI1O1xudmFyIElOUFVUX1NUQVJUID0gMTtcbnZhciBJTlBVVF9NT1ZFID0gMjtcbnZhciBJTlBVVF9FTkQgPSA0O1xudmFyIElOUFVUX0NBTkNFTCA9IDg7XG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcbnZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xudmFyIERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTDtcbnZhciBQUk9QU19YWSA9IFsneCcsICd5J107XG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgdmFyIGk7XG5cbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gVFlQRV9GVU5DVElPTikge1xuICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgLy8gbm9uZVxuICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICB9XG5cbiAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7IC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG5cbiAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgfSAvLyBwYW4teCBPUiBwYW4teVxuXG5cbiAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICB9IC8vIG1hbmlwdWxhdGlvblxuXG5cbiAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gIH1cblxuICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgVG91Y2hBY3Rpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5zZXQodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFRvdWNoQWN0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICBpZiAodmFsdWUgPT09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgIH1cblxuICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICovXG5cblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgKi9cblxuXG4gIF9wcm90by5jb21wdXRlID0gZnVuY3Rpb24gY29tcHV0ZSgpIHtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cblxuICBfcHJvdG8ucHJldmVudERlZmF1bHRzID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHRzKGlucHV0KSB7XG4gICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjsgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG5cbiAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAvLyBkbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcbiAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhhc05vbmUgfHwgaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8fCBoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgKi9cblxuXG4gIF9wcm90by5wcmV2ZW50U3JjID0gZnVuY3Rpb24gcHJldmVudFNyYyhzcmNFdmVudCkge1xuICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICByZXR1cm4gVG91Y2hBY3Rpb247XG59KCk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5cbmZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7IC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG5cbiAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXG4gICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICovXG5cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgdmFyIHBvaW50ZXJzID0gW107XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgIH07XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICBwcm9wcyA9IFBST1BTX1hZO1xuICB9XG5cbiAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV07XG4gIHZhciB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5cbmZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHByb3BzID0gUFJPUFNfWFk7XG4gIH1cblxuICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXTtcbiAgdmFyIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gIH1cblxuICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICB9XG5cbiAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7IC8vIGxldCB7IG9mZnNldERlbHRhOm9mZnNldCA9IHt9LCBwcmV2RGVsdGEgPSB7fSwgcHJldklucHV0ID0ge30gfSA9IHNlc3Npb247XG4gIC8vIGpzY3MgdGhyb3dpbmcgZXJyb3Igb24gZGVmYWx1dCBkZXN0cnVjdHVyZWQgdmFsdWVzIGFuZCB3aXRob3V0IGRlZmF1bHRzIHRlc3RzIGZhaWxcblxuICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICB9O1xuICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55XG4gICAgfTtcbiAgfVxuXG4gIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5cbmZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAqL1xuXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cblxuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQ7XG4gIHZhciBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcDtcbiAgdmFyIHZlbG9jaXR5O1xuICB2YXIgdmVsb2NpdHlYO1xuICB2YXIgdmVsb2NpdHlZO1xuICB2YXIgZGlyZWN0aW9uO1xuXG4gIGlmIChpbnB1dC5ldmVudFR5cGUgIT09IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcbiAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgdmVsb2NpdHkgPSBhYnModi54KSA+IGFicyh2LnkpID8gdi54IDogdi55O1xuICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG4gICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xuICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICB9XG5cbiAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbn1cblxuLyoqXG4qIEBwcml2YXRlXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cblxuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDsgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuXG4gIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICB9IC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcblxuXG4gIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQsXG4gICAgICBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICB2YXIgb2Zmc2V0Q2VudGVyID0gZmlyc3RNdWx0aXBsZSA/IGZpcnN0TXVsdGlwbGUuY2VudGVyIDogZmlyc3RJbnB1dC5jZW50ZXI7XG4gIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG4gIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpO1xuICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICB2YXIgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSBhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG4gIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogaW5wdXQucG9pbnRlcnMubGVuZ3RoID4gc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycztcbiAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTsgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcblxuICB2YXIgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgdmFyIHNyY0V2ZW50VGFyZ2V0O1xuXG4gIGlmIChzcmNFdmVudC5jb21wb3NlZFBhdGgpIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9IGVsc2UgaWYgKHNyY0V2ZW50LnBhdGgpIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LnBhdGhbMF07XG4gIH0gZWxzZSB7XG4gICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC50YXJnZXQ7XG4gIH1cblxuICBpZiAoaGFzUGFyZW50KHNyY0V2ZW50VGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgdGFyZ2V0ID0gc3JjRXZlbnRUYXJnZXQ7XG4gIH1cblxuICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cblxuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICB2YXIgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgdmFyIGlzRmlyc3QgPSBldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgdmFyIGlzRmluYWwgPSBldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiBwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMDtcbiAgaW5wdXQuaXNGaXJzdCA9ICEhaXNGaXJzdDtcbiAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICBpZiAoaXNGaXJzdCkge1xuICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICB9IC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuXG5cbiAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlOyAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcblxuICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTsgLy8gZW1pdCBzZWNyZXQgZXZlbnRcblxuICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcbiAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXG4gKi9cbmZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIElucHV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5wdXQobWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0OyAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAqIEB2aXJ0dWFsXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7fTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgKi9cblxuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICB9O1xuXG4gIHJldHVybiBJbnB1dDtcbn0oKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgaWYgKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kIHx8ICFmaW5kQnlLZXkgJiYgc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgIC8vIGRvIG5vdCB1c2UgPT09IGhlcmUsIHRlc3QgZmFpbHNcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbn1cblxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07IC8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG5cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG5cbn07XG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJzsgLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5cbmlmICh3aW4uTVNQb2ludGVyRXZlbnQgJiYgIXdpbi5Qb2ludGVyRXZlbnQpIHtcbiAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxuXG52YXIgUG9pbnRlckV2ZW50SW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShQb2ludGVyRXZlbnRJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgcHJvdG8gPSBQb2ludGVyRXZlbnRJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgcHJvdG8uZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG4gICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0b3JlID0gX3RoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG4gICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuICAgIHZhciBpc1RvdWNoID0gcG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0g7IC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG5cbiAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpOyAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICB9IC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuXG5cbiAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG5cblxuICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQb2ludGVyRXZlbnRJbnB1dDtcbn0oSW5wdXQpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuXG5mdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG5cbiAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICB9XG5cbiAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgaSsrO1xuICB9XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxudmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcbnZhciBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcbi8qKlxuICogQHByaXZhdGVcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIFRvdWNoSW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShUb3VjaElucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgVG91Y2hJbnB1dC5wcm90b3R5cGUuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50YXJnZXRJZHMgPSB7fTsgLy8gdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVG91Y2hJbnB1dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVG91Y2hJbnB1dDtcbn0oSW5wdXQpO1xuXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzOyAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuXG4gIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgfVxuXG4gIHZhciBpO1xuICB2YXIgdGFyZ2V0VG91Y2hlcztcbiAgdmFyIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG4gIHZhciBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdO1xuICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7IC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcblxuICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gIH0pOyAvLyBjb2xsZWN0IHRvdWNoZXNcblxuICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH0gLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuXG5cbiAgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICB9IC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG5cblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gWy8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksIGNoYW5nZWRUYXJnZXRUb3VjaGVzXTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG52YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbnZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcbi8qKlxuICogQHByaXZhdGVcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBNb3VzZUlucHV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSW5wdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTW91c2VJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwcm90byA9IE1vdXNlSW5wdXQucHJvdG90eXBlO1xuICAgIHByb3RvLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG4gICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IE1vdXNlSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07IC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgIH0gLy8gbW91c2UgbXVzdCBiZSBkb3duXG5cblxuICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBNb3VzZUlucHV0O1xufShJbnB1dCk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG52YXIgREVEVVBfRElTVEFOQ0UgPSAyNTtcblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuICB2YXIgX2V2ZW50RGF0YSRjaGFuZ2VkUG9pID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVycyxcbiAgICAgIHRvdWNoID0gX2V2ZW50RGF0YSRjaGFuZ2VkUG9pWzBdO1xuXG4gIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnByaW1hcnlUb3VjaCkge1xuICAgIHZhciBsYXN0VG91Y2ggPSB7XG4gICAgICB4OiB0b3VjaC5jbGllbnRYLFxuICAgICAgeTogdG91Y2guY2xpZW50WVxuICAgIH07XG4gICAgdmFyIGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgdGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG5cbiAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24gcmVtb3ZlTGFzdFRvdWNoKCkge1xuICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuXG4gICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG4gIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQoZXZlbnREYXRhKSB7XG4gIHZhciB4ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFg7XG4gIHZhciB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpO1xuICAgIHZhciBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuXG4gICAgaWYgKGR4IDw9IERFRFVQX0RJU1RBTkNFICYmIGR5IDw9IERFRFVQX0RJU1RBTkNFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBUb3VjaE1vdXNlSW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgVG91Y2hNb3VzZUlucHV0ID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0lucHV0KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoVG91Y2hNb3VzZUlucHV0LCBfSW5wdXQpO1xuXG4gICAgZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KF9tYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9JbnB1dC5jYWxsKHRoaXMsIF9tYW5hZ2VyLCBjYWxsYmFjaykgfHwgdGhpcztcblxuICAgICAgX3RoaXMuaGFuZGxlciA9IGZ1bmN0aW9uIChtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0g7XG4gICAgICAgIHZhciBpc01vdXNlID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX01PVVNFO1xuXG4gICAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG5cblxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgaW5wdXREYXRhKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KF90aGlzLm1hbmFnZXIsIF90aGlzLmhhbmRsZXIpO1xuICAgICAgX3RoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dChfdGhpcy5tYW5hZ2VyLCBfdGhpcy5oYW5kbGVyKTtcbiAgICAgIF90aGlzLnByaW1hcnlUb3VjaCA9IG51bGw7XG4gICAgICBfdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IFRvdWNoTW91c2VJbnB1dC5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvdWNoTW91c2VJbnB1dDtcbiAgfShJbnB1dCk7XG5cbiAgcmV0dXJuIFRvdWNoTW91c2VJbnB1dDtcbn0oKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgdmFyIFR5cGU7IC8vIGxldCBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICBpZiAoaW5wdXRDbGFzcykge1xuICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgfSBlbHNlIHtcbiAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUeXBlKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaW52b2tlQXJyYXlBcmcoYXJnLCBmbiwgY29udGV4dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG52YXIgX3VuaXF1ZUlkID0gMTtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG5cbiAgaWYgKG1hbmFnZXIpIHtcbiAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgfVxuXG4gIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxuICogQHBhcmFtIHtjb25zdGFudH0gc3RhdGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgcmV0dXJuICdjYW5jZWwnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9DSEFOR0VEKSB7XG4gICAgcmV0dXJuICdtb3ZlJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cbiAqIFRoZSBkZWZpbml0aW9uIG9mIGEgaW5wdXQgc2Vzc2lvbiBpcyBmcm9tIHRoZSBmaXJzdCBpbnB1dCB1bnRpbCB0aGUgbGFzdCBpbnB1dCwgd2l0aCBhbGwgaXQncyBtb3ZlbWVudCBpbiBpdC4gKlxuICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gKlxuICogT24gZWFjaCByZWNvZ25pemluZyBjeWNsZSAoc2VlIE1hbmFnZXIucmVjb2duaXplKSB0aGUgLnJlY29nbml6ZSgpIG1ldGhvZCBpcyBleGVjdXRlZFxuICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAqXG4gKiBJZiB0aGUgcmVjb2duaXplciBoYXMgdGhlIHN0YXRlIEZBSUxFRCwgQ0FOQ0VMTEVEIG9yIFJFQ09HTklaRUQgKGVxdWFscyBFTkRFRCksIGl0IGlzIHJlc2V0IHRvXG4gKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICpcbiAqICAgICAgICAgICAgICAgUG9zc2libGVcbiAqICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICogICBGYWlsZWQgICAgICBDYW5jZWxsZWQgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICBSZWNvZ25pemVkICAgICAgIEJlZ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVjb2duaXplclxuICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbnZhciBSZWNvZ25pemVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHtcbiAgICAgIGVuYWJsZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuICAgIHRoaXMubWFuYWdlciA9IG51bGw7IC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gICAgYXNzaWduJDEodGhpcy5vcHRpb25zLCBvcHRpb25zKTsgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcblxuICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8ucmVjb2duaXplV2l0aCA9IGZ1bmN0aW9uIHJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcblxuICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8uZHJvcFJlY29nbml6ZVdpdGggPSBmdW5jdGlvbiBkcm9wUmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlcXVpcmVGYWlsdXJlID0gZnVuY3Rpb24gcmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuXG4gICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmRyb3BSZXF1aXJlRmFpbHVyZSA9IGZ1bmN0aW9uIGRyb3BSZXF1aXJlRmFpbHVyZShvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG5cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBfcHJvdG8uaGFzUmVxdWlyZUZhaWx1cmVzID0gZnVuY3Rpb24gaGFzUmVxdWlyZUZhaWx1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgX3Byb3RvLmNhblJlY29nbml6ZVdpdGggPSBmdW5jdGlvbiBjYW5SZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgIH0gLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG5cblxuICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgfVxuXG4gICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7XG4gICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICB9IC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG5cblxuICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cblxuXG4gIF9wcm90by50cnlFbWl0ID0gZnVuY3Rpb24gdHJ5RW1pdChpbnB1dCkge1xuICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgfSAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG5cblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYW4gd2UgZW1pdD9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgX3Byb3RvLmNhbkVtaXQgPSBmdW5jdGlvbiBjYW5FbWl0KCkge1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlY29nbml6ZSA9IGZ1bmN0aW9uIHJlY29nbml6ZShpbnB1dERhdGEpIHtcbiAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgdmFyIGlucHV0RGF0YUNsb25lID0gYXNzaWduJDEoe30sIGlucHV0RGF0YSk7IC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuXG4gICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG5cblxuICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7IC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxuICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcblxuICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgKiBAdmlydHVhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAqIEByZXR1cm5zIHtjb25zdGFudH0gU1RBVEVcbiAgICovXG5cbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuXG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0RGF0YSkge307XG4gIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgKiBAdmlydHVhbFxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7fTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXG4gICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICogQHZpcnR1YWxcbiAgICovXG5cblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHt9O1xuXG4gIHJldHVybiBSZWNvZ25pemVyO1xufSgpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBBIHRhcCBpcyByZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gKiBhIHNpbmdsZSB0YXAuXG4gKlxuICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuXG52YXIgVGFwUmVjb2duaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoVGFwUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFRhcFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICB0YXBzOiAxLFxuICAgICAgaW50ZXJ2YWw6IDMwMCxcbiAgICAgIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICB0aW1lOiAyNTAsXG4gICAgICAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgdGhyZXNob2xkOiA5LFxuICAgICAgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgIHBvc1RocmVzaG9sZDogMTBcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpczsgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuXG4gICAgX3RoaXMucFRpbWUgPSBmYWxzZTtcbiAgICBfdGhpcy5wQ2VudGVyID0gZmFsc2U7XG4gICAgX3RoaXMuX3RpbWVyID0gbnVsbDtcbiAgICBfdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIF90aGlzLmNvdW50ID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGFwUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgfTtcblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG4gICAgdGhpcy5yZXNldCgpO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgfSAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcblxuXG4gICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsIDogdHJ1ZTtcbiAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcbiAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgIGlmICghdmFsaWRNdWx0aVRhcCB8fCAhdmFsaWRJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDsgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cblxuICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcblxuICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuXG4gICAgICAgICAgICBfdGhpczIudHJ5RW1pdCgpO1xuICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH07XG5cbiAgX3Byb3RvLmZhaWxUaW1lb3V0ID0gZnVuY3Rpb24gZmFpbFRpbWVvdXQoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUYXBSZWNvZ25pemVyO1xufShSZWNvZ25pemVyKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cblxudmFyIEF0dHJSZWNvZ25pemVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShBdHRyUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9SZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgKi9cblxuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcbiAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICB2YXIgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpOyAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG5cbiAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfTtcblxuICByZXR1cm4gQXR0clJlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Y29uc3RhbnR9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgcmV0dXJuICdkb3duJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9VUCkge1xuICAgIHJldHVybiAndXAnO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgcmV0dXJuICdyaWdodCc7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuXG52YXIgUGFuUmVjb2duaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBhblJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUGFuUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gICAgX3RoaXMucFggPSBudWxsO1xuICAgIF90aGlzLnBZID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGFuUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgdmFyIGFjdGlvbnMgPSBbXTtcblxuICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbnM7XG4gIH07XG5cbiAgX3Byb3RvLmRpcmVjdGlvblRlc3QgPSBmdW5jdGlvbiBkaXJlY3Rpb25UZXN0KGlucHV0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQuZGlyZWN0aW9uO1xuICAgIHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZOyAvLyBsb2NrIHRvIGF4aXM/XG5cbiAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IHggPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgIGhhc01vdmVkID0geCAhPT0gdGhpcy5wWDtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlyZWN0aW9uID0geSA9PT0gMCA/IERJUkVDVElPTl9OT05FIDogeSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgaGFzTW92ZWQgPSB5ICE9PSB0aGlzLnBZO1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICB9O1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoIC8vIHJlcGxhY2Ugd2l0aCBhIHN1cGVyIGNhbGxcbiAgICB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcbiAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgfVxuXG4gICAgX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBQYW5SZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFN3aXBlXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5cbnZhciBTd2lwZVJlY29nbml6ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShTd2lwZVJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gU3dpcGVSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTd2lwZVJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgIH1cblxuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIGRpcmVjdGlvbiAmIGlucHV0Lm9mZnNldERpcmVjdGlvbiAmJiBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiYgaW5wdXQubWF4UG9pbnRlcnMgPT09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJiBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0Lm9mZnNldERpcmVjdGlvbik7XG5cbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gU3dpcGVSZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxudmFyIFBpbmNoUmVjb2duaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBpbmNoUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMlxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBpbmNoUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgIH1cblxuICAgIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gUGluY2hSZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuXG52YXIgUm90YXRlUmVjb2duaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJvdGF0ZVJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMlxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJvdGF0ZVJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICB9O1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgfTtcblxuICByZXR1cm4gUm90YXRlUmVjb2duaXplcjtcbn0oQXR0clJlY29nbml6ZXIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuXG52YXIgUHJlc3NSZWNvZ25pemVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShQcmVzc1JlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRpbWU6IDI1MSxcbiAgICAgIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICB0aHJlc2hvbGQ6IDlcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgICBfdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIF90aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFByZXNzUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gIH07XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcbiAgICB0aGlzLl9pbnB1dCA9IGlucHV0OyAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcblxuICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCBpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcblxuICAgICAgICBfdGhpczIudHJ5RW1pdCgpO1xuICAgICAgfSwgb3B0aW9ucy50aW1lKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlucHV0ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgXCJ1cFwiLCBpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQcmVzc1JlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRvbUV2ZW50czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgKi9cbiAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBpbnB1dENsYXNzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAqIEBuYW1lc3BhY2VcbiAgICovXG4gIGNzc1Byb3BzOiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB0b3VjaFNlbGVjdDogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAqL1xuICAgIHRvdWNoQ2FsbG91dDogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgY29udGVudFpvb21pbmc6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB1c2VyRHJhZzogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICovXG4gICAgdGFwSGlnaGxpZ2h0Q29sb3I6IFwicmdiYSgwLDAsMCwwKVwiXG4gIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXG4gKiBUaGlzIGlzIHNlcGFyYXRlZCB3aXRoIG90aGVyIGRlZmF1bHRzIGJlY2F1c2Ugb2YgdHJlZS1zaGFraW5nLlxuICogQHR5cGUge0FycmF5fVxuICovXG5cbnZhciBwcmVzZXQgPSBbW1JvdGF0ZVJlY29nbml6ZXIsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtQaW5jaFJlY29nbml6ZXIsIHtcbiAgZW5hYmxlOiBmYWxzZVxufSwgWydyb3RhdGUnXV0sIFtTd2lwZVJlY29nbml6ZXIsIHtcbiAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTFxufV0sIFtQYW5SZWNvZ25pemVyLCB7XG4gIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUxcbn0sIFsnc3dpcGUnXV0sIFtUYXBSZWNvZ25pemVyXSwgW1RhcFJlY29nbml6ZXIsIHtcbiAgZXZlbnQ6ICdkb3VibGV0YXAnLFxuICB0YXBzOiAyXG59LCBbJ3RhcCddXSwgW1ByZXNzUmVjb2duaXplcl1dO1xuXG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcbiAqL1xuXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG5cbiAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHByb3A7XG4gIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG5cbiAgICBpZiAoYWRkKSB7XG4gICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgXCJcIjtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghYWRkKSB7XG4gICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiB0cmlnZ2VyIGRvbSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5cblxuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG59XG4vKipcbiogQHByaXZhdGVcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIE1hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduJDEoe30sIGRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuICAgIHRoaXMub2xkQ3NzUHJvcHMgPSB7fTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcbiAgICBlYWNoKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciByZWNvZ25pemVyID0gX3RoaXMuYWRkKG5ldyBpdGVtWzBdKGl0ZW1bMV0pKTtcblxuICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICBhc3NpZ24kMSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG5cbiAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICovXG5cblxuICBfcHJvdG8uc3RvcCA9IGZ1bmN0aW9uIHN0b3AoZm9yY2UpIHtcbiAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgKi9cblxuXG4gIF9wcm90by5yZWNvZ25pemUgPSBmdW5jdGlvbiByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG5cbiAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuXG5cbiAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuICAgIHZhciByZWNvZ25pemVyO1xuICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7IC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG5cbiAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjsgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cblxuICAgIGlmICghY3VyUmVjb2duaXplciB8fCBjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTsgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cblxuICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHtcbiAgICAgICAgLy8gM1xuICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgfSAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG5cblxuICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgIHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgIGN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgKi9cblxuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQocmVjb2duaXplcikge1xuICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfVxuXG4gICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09PSByZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICovXG5cblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgXCJhZGRcIiwgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gcmVtb3ZlIGV4aXN0aW5nXG5cblxuICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG5cbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcbiAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgIHJldHVybiByZWNvZ25pemVyO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShyZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsIFwicmVtb3ZlXCIsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0UmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpOyAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuXG4gICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCB0YXJnZXRSZWNvZ25pemVyKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYmluZCBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCB8fCBoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGUgdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5vZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuXG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgIH0gLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG5cblxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG5cbiAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhLnR5cGUgPSBldmVudDtcblxuICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICovXG5cblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gTWFuYWdlcjtcbn0oKTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIFNpbmdsZVRvdWNoSW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShTaW5nbGVUb3VjaElucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHByb3RvID0gU2luZ2xlVG91Y2hJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNpbmdsZVRvdWNoSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTsgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpOyAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFNpbmdsZVRvdWNoSW5wdXQ7XG59KElucHV0KTtcblxuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXRob2QsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9IFwiREVQUkVDQVRFRCBNRVRIT0Q6IFwiICsgbmFtZSArIFwiXFxuXCIgKyBtZXNzYWdlICsgXCIgQVQgXFxuXCI7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJykucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG4gICAgdmFyIGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG5cbiAgICBpZiAobG9nKSB7XG4gICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cblxudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoZGVzdCwgc3JjLCBtZXJnZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgaWYgKCFtZXJnZSB8fCBtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG5cbnZhciBtZXJnZSA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoZGVzdCwgc3JjKSB7XG4gIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbn0sICdtZXJnZScsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuXG5mdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlO1xuICB2YXIgY2hpbGRQO1xuICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICBpZiAocHJvcGVydGllcykge1xuICAgIGFzc2lnbiQxKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgSGFtbWVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgdmFyIEhhbW1lciA9XG4gIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEBjb25zdCB7c3RyaW5nfVxuICAgICovXG4gIGZ1bmN0aW9uIEhhbW1lcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCBfZXh0ZW5kcyh7XG4gICAgICByZWNvZ25pemVyczogcHJlc2V0LmNvbmNhdCgpXG4gICAgfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIEhhbW1lci5WRVJTSU9OID0gXCIyLjAuMTctcmNcIjtcbiAgSGFtbWVyLkRJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fQUxMO1xuICBIYW1tZXIuRElSRUNUSU9OX0RPV04gPSBESVJFQ1RJT05fRE9XTjtcbiAgSGFtbWVyLkRJUkVDVElPTl9MRUZUID0gRElSRUNUSU9OX0xFRlQ7XG4gIEhhbW1lci5ESVJFQ1RJT05fUklHSFQgPSBESVJFQ1RJT05fUklHSFQ7XG4gIEhhbW1lci5ESVJFQ1RJT05fVVAgPSBESVJFQ1RJT05fVVA7XG4gIEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMO1xuICBIYW1tZXIuRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1ZFUlRJQ0FMO1xuICBIYW1tZXIuRElSRUNUSU9OX05PTkUgPSBESVJFQ1RJT05fTk9ORTtcbiAgSGFtbWVyLkRJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG4gIEhhbW1lci5JTlBVVF9TVEFSVCA9IElOUFVUX1NUQVJUO1xuICBIYW1tZXIuSU5QVVRfTU9WRSA9IElOUFVUX01PVkU7XG4gIEhhbW1lci5JTlBVVF9FTkQgPSBJTlBVVF9FTkQ7XG4gIEhhbW1lci5JTlBVVF9DQU5DRUwgPSBJTlBVVF9DQU5DRUw7XG4gIEhhbW1lci5TVEFURV9QT1NTSUJMRSA9IFNUQVRFX1BPU1NJQkxFO1xuICBIYW1tZXIuU1RBVEVfQkVHQU4gPSBTVEFURV9CRUdBTjtcbiAgSGFtbWVyLlNUQVRFX0NIQU5HRUQgPSBTVEFURV9DSEFOR0VEO1xuICBIYW1tZXIuU1RBVEVfRU5ERUQgPSBTVEFURV9FTkRFRDtcbiAgSGFtbWVyLlNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9SRUNPR05JWkVEO1xuICBIYW1tZXIuU1RBVEVfQ0FOQ0VMTEVEID0gU1RBVEVfQ0FOQ0VMTEVEO1xuICBIYW1tZXIuU1RBVEVfRkFJTEVEID0gU1RBVEVfRkFJTEVEO1xuICBIYW1tZXIuTWFuYWdlciA9IE1hbmFnZXI7XG4gIEhhbW1lci5JbnB1dCA9IElucHV0O1xuICBIYW1tZXIuVG91Y2hBY3Rpb24gPSBUb3VjaEFjdGlvbjtcbiAgSGFtbWVyLlRvdWNoSW5wdXQgPSBUb3VjaElucHV0O1xuICBIYW1tZXIuTW91c2VJbnB1dCA9IE1vdXNlSW5wdXQ7XG4gIEhhbW1lci5Qb2ludGVyRXZlbnRJbnB1dCA9IFBvaW50ZXJFdmVudElucHV0O1xuICBIYW1tZXIuVG91Y2hNb3VzZUlucHV0ID0gVG91Y2hNb3VzZUlucHV0O1xuICBIYW1tZXIuU2luZ2xlVG91Y2hJbnB1dCA9IFNpbmdsZVRvdWNoSW5wdXQ7XG4gIEhhbW1lci5SZWNvZ25pemVyID0gUmVjb2duaXplcjtcbiAgSGFtbWVyLkF0dHJSZWNvZ25pemVyID0gQXR0clJlY29nbml6ZXI7XG4gIEhhbW1lci5UYXAgPSBUYXBSZWNvZ25pemVyO1xuICBIYW1tZXIuUGFuID0gUGFuUmVjb2duaXplcjtcbiAgSGFtbWVyLlN3aXBlID0gU3dpcGVSZWNvZ25pemVyO1xuICBIYW1tZXIuUGluY2ggPSBQaW5jaFJlY29nbml6ZXI7XG4gIEhhbW1lci5Sb3RhdGUgPSBSb3RhdGVSZWNvZ25pemVyO1xuICBIYW1tZXIuUHJlc3MgPSBQcmVzc1JlY29nbml6ZXI7XG4gIEhhbW1lci5vbiA9IGFkZEV2ZW50TGlzdGVuZXJzO1xuICBIYW1tZXIub2ZmID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnM7XG4gIEhhbW1lci5lYWNoID0gZWFjaDtcbiAgSGFtbWVyLm1lcmdlID0gbWVyZ2U7XG4gIEhhbW1lci5leHRlbmQgPSBleHRlbmQ7XG4gIEhhbW1lci5iaW5kRm4gPSBiaW5kRm47XG4gIEhhbW1lci5hc3NpZ24gPSBhc3NpZ24kMTtcbiAgSGFtbWVyLmluaGVyaXQgPSBpbmhlcml0O1xuICBIYW1tZXIuYmluZEZuID0gYmluZEZuO1xuICBIYW1tZXIucHJlZml4ZWQgPSBwcmVmaXhlZDtcbiAgSGFtbWVyLnRvQXJyYXkgPSB0b0FycmF5O1xuICBIYW1tZXIuaW5BcnJheSA9IGluQXJyYXk7XG4gIEhhbW1lci51bmlxdWVBcnJheSA9IHVuaXF1ZUFycmF5O1xuICBIYW1tZXIuc3BsaXRTdHIgPSBzcGxpdFN0cjtcbiAgSGFtbWVyLmJvb2xPckZuID0gYm9vbE9yRm47XG4gIEhhbW1lci5oYXNQYXJlbnQgPSBoYXNQYXJlbnQ7XG4gIEhhbW1lci5hZGRFdmVudExpc3RlbmVycyA9IGFkZEV2ZW50TGlzdGVuZXJzO1xuICBIYW1tZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSByZW1vdmVFdmVudExpc3RlbmVycztcbiAgSGFtbWVyLmRlZmF1bHRzID0gYXNzaWduJDEoe30sIGRlZmF1bHRzLCB7XG4gICAgcHJlc2V0OiBwcmVzZXRcbiAgfSk7XG4gIHJldHVybiBIYW1tZXI7XG59KCk7XG5cbi8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxuXG52YXIgZGVmYXVsdHMkMSA9IEhhbW1lci5kZWZhdWx0cztcblxuZXhwb3J0IGRlZmF1bHQgSGFtbWVyO1xuZXhwb3J0IHsgSU5QVVRfU1RBUlQsIElOUFVUX01PVkUsIElOUFVUX0VORCwgSU5QVVRfQ0FOQ0VMLCBTVEFURV9QT1NTSUJMRSwgU1RBVEVfQkVHQU4sIFNUQVRFX0NIQU5HRUQsIFNUQVRFX0VOREVELCBTVEFURV9SRUNPR05JWkVELCBTVEFURV9DQU5DRUxMRUQsIFNUQVRFX0ZBSUxFRCwgRElSRUNUSU9OX05PTkUsIERJUkVDVElPTl9MRUZULCBESVJFQ1RJT05fUklHSFQsIERJUkVDVElPTl9VUCwgRElSRUNUSU9OX0RPV04sIERJUkVDVElPTl9IT1JJWk9OVEFMLCBESVJFQ1RJT05fVkVSVElDQUwsIERJUkVDVElPTl9BTEwsIE1hbmFnZXIsIElucHV0LCBUb3VjaEFjdGlvbiwgVG91Y2hJbnB1dCwgTW91c2VJbnB1dCwgUG9pbnRlckV2ZW50SW5wdXQsIFRvdWNoTW91c2VJbnB1dCwgU2luZ2xlVG91Y2hJbnB1dCwgUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIFRhcFJlY29nbml6ZXIgYXMgVGFwLCBQYW5SZWNvZ25pemVyIGFzIFBhbiwgU3dpcGVSZWNvZ25pemVyIGFzIFN3aXBlLCBQaW5jaFJlY29nbml6ZXIgYXMgUGluY2gsIFJvdGF0ZVJlY29nbml6ZXIgYXMgUm90YXRlLCBQcmVzc1JlY29nbml6ZXIgYXMgUHJlc3MsIGFkZEV2ZW50TGlzdGVuZXJzIGFzIG9uLCByZW1vdmVFdmVudExpc3RlbmVycyBhcyBvZmYsIGVhY2gsIG1lcmdlLCBleHRlbmQsIGFzc2lnbiQxIGFzIGFzc2lnbiwgaW5oZXJpdCwgYmluZEZuLCBwcmVmaXhlZCwgdG9BcnJheSwgaW5BcnJheSwgdW5pcXVlQXJyYXksIHNwbGl0U3RyLCBib29sT3JGbiwgaGFzUGFyZW50LCBhZGRFdmVudExpc3RlbmVycywgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsIGRlZmF1bHRzJDEgYXMgZGVmYXVsdHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhbW1lci5lc20uanMubWFwXG4iLCIvKipcbiAqIHZpcy11dGlsXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdmlzanMvdmlzLXV0aWxcbiAqXG4gKiB1dGlsaXRpZSBjb2xsZWN0aW9uIGZvciB2aXNqc1xuICpcbiAqIEB2ZXJzaW9uIDUuMC4xXG4gKiBAZGF0ZSAgICAyMDIxLTAxLTA4VDE2OjMyOjAzLjk3MVpcbiAqXG4gKiBAY29weXJpZ2h0IChjKSAyMDExLTIwMTcgQWxtZW5kZSBCLlYsIGh0dHA6Ly9hbG1lbmRlLmNvbVxuICogQGNvcHlyaWdodCAoYykgMjAxNy0yMDE5IHZpc2pzIGNvbnRyaWJ1dG9ycywgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2pzXG4gKlxuICogQGxpY2Vuc2VcbiAqIHZpcy5qcyBpcyBkdWFsIGxpY2Vuc2VkIHVuZGVyIGJvdGhcbiAqXG4gKiAgIDEuIFRoZSBBcGFjaGUgMi4wIExpY2Vuc2VcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogICBhbmRcbiAqXG4gKiAgIDIuIFRoZSBNSVQgTGljZW5zZVxuICogICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogdmlzLmpzIG1heSBiZSBkaXN0cmlidXRlZCB1bmRlciBlaXRoZXIgbGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRW1pdHRlciBmcm9tICdjb21wb25lbnQtZW1pdHRlcic7XG5pbXBvcnQgUmVhbEhhbW1lciBmcm9tICdAZWdqcy9oYW1tZXJqcyc7XG5cbi8qKlxyXG4gKiBVc2UgdGhpcyBzeW1ib2wgdG8gZGVsZXRlIHByb3BlcmllcyBpbiBkZWVwT2JqZWN0QXNzaWduLlxyXG4gKi9cclxuY29uc3QgREVMRVRFID0gU3ltYm9sKFwiREVMRVRFXCIpO1xyXG4vKipcclxuICogUHVyZSB2ZXJzaW9uIG9mIGRlZXBPYmplY3RBc3NpZ24sIGl0IGRvZXNuJ3QgbW9kaWZ5IGFueSBvZiBpdCdzIGFyZ3VtZW50cy5cclxuICpcclxuICogQHBhcmFtIGJhc2UgLSBUaGUgYmFzZSBvYmplY3QgdGhhdCBmdWxsZmlscyB0aGUgd2hvbGUgaW50ZXJmYWNlIFQuXHJcbiAqIEBwYXJhbSB1cGRhdGVzIC0gVXBkYXRlcyB0aGF0IG1heSBjaGFuZ2Ugb3IgZGVsZXRlIHByb3BzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGJyYW5kIG5ldyBpbnN0YW5jZSB3aXRoIGFsbCB0aGUgc3VwcGxpZWQgb2JqZWN0cyBkZWVwbHkgbWVyZ2VkLlxyXG4gKi9cclxuZnVuY3Rpb24gcHVyZURlZXBPYmplY3RBc3NpZ24oYmFzZSwgLi4udXBkYXRlcykge1xyXG4gICAgcmV0dXJuIGRlZXBPYmplY3RBc3NpZ24oe30sIGJhc2UsIC4uLnVwZGF0ZXMpO1xyXG59XHJcbi8qKlxyXG4gKiBEZWVwIHZlcnNpb24gb2Ygb2JqZWN0IGFzc2lnbiB3aXRoIGFkZGl0aW9uYWwgZGVsZXRpbmcgYnkgdGhlIERFTEVURSBzeW1ib2wuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZXMgLSBPYmplY3RzIHRvIGJlIGRlZXBseSBtZXJnZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBvYmplY3QgZnJvbSB2YWx1ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwT2JqZWN0QXNzaWduKC4uLnZhbHVlcykge1xyXG4gICAgY29uc3QgbWVyZ2VkID0gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5KC4uLnZhbHVlcyk7XHJcbiAgICBzdHJpcERlbGV0ZShtZXJnZWQpO1xyXG4gICAgcmV0dXJuIG1lcmdlZDtcclxufVxyXG4vKipcclxuICogRGVlcCB2ZXJzaW9uIG9mIG9iamVjdCBhc3NpZ24gd2l0aCBhZGRpdGlvbmFsIGRlbGV0aW5nIGJ5IHRoZSBERUxFVEUgc3ltYm9sLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGlzIGRvZXNuJ3Qgc3RyaXAgdGhlIERFTEVURSBzeW1ib2xzIHNvIHRoZXkgbWF5IGVuZCB1cCBpbiB0aGUgZmluYWwgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWVzIC0gT2JqZWN0cyB0byBiZSBkZWVwbHkgbWVyZ2VkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgZmlyc3Qgb2JqZWN0IGZyb20gdmFsdWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5KC4uLnZhbHVlcykge1xyXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlc1swXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZXBPYmplY3RBc3NpZ25Ob25lbnRyeShkZWVwT2JqZWN0QXNzaWduKHZhbHVlc1swXSwgdmFsdWVzWzFdKSwgLi4udmFsdWVzLnNsaWNlKDIpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGEgPSB2YWx1ZXNbMF07XHJcbiAgICBjb25zdCBiID0gdmFsdWVzWzFdO1xyXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIFJlZmxlY3Qub3duS2V5cyhiKSkge1xyXG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGIsIHByb3ApKSA7XHJcbiAgICAgICAgZWxzZSBpZiAoYltwcm9wXSA9PT0gREVMRVRFKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhW3Byb3BdICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgIGJbcHJvcF0gIT09IG51bGwgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGFbcHJvcF0gPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGJbcHJvcF0gPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoYVtwcm9wXSkgJiZcclxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoYltwcm9wXSkpIHtcclxuICAgICAgICAgICAgYVtwcm9wXSA9IGRlZXBPYmplY3RBc3NpZ25Ob25lbnRyeShhW3Byb3BdLCBiW3Byb3BdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFbcHJvcF0gPSBjbG9uZShiW3Byb3BdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufVxyXG4vKipcclxuICogRGVlcCBjbG9uZSBnaXZlbiBvYmplY3Qgb3IgYXJyYXkuIEluIGNhc2Ugb2YgcHJpbWl0aXZlIHNpbXBseSByZXR1cm4uXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gQW55dGhpbmcuXHJcbiAqXHJcbiAqIEByZXR1cm5zIERlZXAgY2xvbmVkIG9iamVjdC9hcnJheSBvciB1bmNoYW5nZWQgYS5cclxuICovXHJcbmZ1bmN0aW9uIGNsb25lKGEpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XHJcbiAgICAgICAgcmV0dXJuIGEubWFwKCh2YWx1ZSkgPT4gY2xvbmUodmFsdWUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZGVlcE9iamVjdEFzc2lnbk5vbmVudHJ5KHt9LCBhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTdHJpcCBERUxFVEUgZnJvbSBnaXZlbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gT2JqZWN0IHdoaWNoIG1heSBjb250YWluIERFTEVURSBidXQgd29uJ3QgYWZ0ZXIgdGhpcyBpcyBleGVjdXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHN0cmlwRGVsZXRlKGEpIHtcclxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhhKSkge1xyXG4gICAgICAgIGlmIChhW3Byb3BdID09PSBERUxFVEUpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhW3Byb3BdID09PSBcIm9iamVjdFwiICYmIGFbcHJvcF0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RyaXBEZWxldGUoYVtwcm9wXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBTZWVkYWJsZSwgZmFzdCBhbmQgcmVhc29uYWJseSBnb29kIChub3QgY3J5cHRvIGJ1dCBtb3JlIHRoYW4gb2theSBmb3Igb3VyXHJcbiAqIG5lZWRzKSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQWRhcHRlZCBmcm9tIHtAbGluayBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMTA0MjkxMDA3MzYvaHR0cDovL2JhYWdvZS5jb206ODAvZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0fS5cclxuICogT3JpZ2luYWwgYWxnb3JpdGhtIGNyZWF0ZWQgYnkgSm9oYW5uZXMgQmFhZ8O4ZSBcXDxiYWFnb2VcXEBiYWFnb2UuY29tXFw+IGluIDIwMTAuXHJcbiAqL1xyXG4vKipcclxuICogQ3JlYXRlIGEgc2VlZGVkIHBzZXVkbyByYW5kb20gZ2VuZXJhdG9yIGJhc2VkIG9uIEFsZWEgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cclxuICpcclxuICogQHBhcmFtIHNlZWQgLSBBbGwgc3VwcGxpZWQgYXJndW1lbnRzIHdpbGwgYmUgdXNlZCBhcyBhIHNlZWQuIEluIGNhc2Ugbm90aGluZ1xyXG4gKiBpcyBzdXBwbGllZCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZCB0byBzZWVkIHRoZSBnZW5lcmF0b3IuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgcmVhZHkgdG8gdXNlIHNlZWRlZCBnZW5lcmF0b3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBBbGVhKC4uLnNlZWQpIHtcclxuICAgIHJldHVybiBBbGVhSW1wbGVtZW50YXRpb24oc2VlZC5sZW5ndGggPyBzZWVkIDogW0RhdGUubm93KCldKTtcclxufVxyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgW1tBbGVhXV0gd2l0aG91dCB1c2VyIGlucHV0IHZhbGlkYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWVkIC0gVGhlIGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gc2VlZCB0aGUgZ2VuZXJhdG9yLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIHJlYWR5IHRvIHVzZSBzZWVkZWQgZ2VuZXJhdG9yLlxyXG4gKi9cclxuZnVuY3Rpb24gQWxlYUltcGxlbWVudGF0aW9uKHNlZWQpIHtcclxuICAgIGxldCBbczAsIHMxLCBzMl0gPSBtYXNoU2VlZChzZWVkKTtcclxuICAgIGxldCBjID0gMTtcclxuICAgIGNvbnN0IHJhbmRvbSA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB0ID0gMjA5MTYzOSAqIHMwICsgYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXHJcbiAgICAgICAgczAgPSBzMTtcclxuICAgICAgICBzMSA9IHMyO1xyXG4gICAgICAgIHJldHVybiAoczIgPSB0IC0gKGMgPSB0IHwgMCkpO1xyXG4gICAgfTtcclxuICAgIHJhbmRvbS51aW50MzIgPSAoKSA9PiByYW5kb20oKSAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXHJcbiAgICByYW5kb20uZnJhY3Q1MyA9ICgpID0+IHJhbmRvbSgpICsgKChyYW5kb20oKSAqIDB4MjAwMDAwKSB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjsgLy8gMl4tNTNcclxuICAgIHJhbmRvbS5hbGdvcml0aG0gPSBcIkFsZWFcIjtcclxuICAgIHJhbmRvbS5zZWVkID0gc2VlZDtcclxuICAgIHJhbmRvbS52ZXJzaW9uID0gXCIwLjlcIjtcclxuICAgIHJldHVybiByYW5kb207XHJcbn1cclxuLyoqXHJcbiAqIFR1cm4gYXJiaXRyYXJ5IGRhdGEgaW50byB2YWx1ZXMgW1tBbGVhSW1wbGVtZW50YXRpb25dXSBjYW4gdXNlIHRvIGdlbmVyYXRlXHJcbiAqIHJhbmRvbSBudW1iZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2VlZCAtIEFyYml0cmFyeSBkYXRhIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBzZWVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaHJlZSBudW1iZXJzIHRvIHVzZSBhcyBpbml0aWFsIHZhbHVlcyBmb3IgW1tBbGVhSW1wbGVtZW50YXRpb25dXS5cclxuICovXHJcbmZ1bmN0aW9uIG1hc2hTZWVkKC4uLnNlZWQpIHtcclxuICAgIGNvbnN0IG1hc2ggPSBNYXNoKCk7XHJcbiAgICBsZXQgczAgPSBtYXNoKFwiIFwiKTtcclxuICAgIGxldCBzMSA9IG1hc2goXCIgXCIpO1xyXG4gICAgbGV0IHMyID0gbWFzaChcIiBcIik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzMCAtPSBtYXNoKHNlZWRbaV0pO1xyXG4gICAgICAgIGlmIChzMCA8IDApIHtcclxuICAgICAgICAgICAgczAgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgczEgLT0gbWFzaChzZWVkW2ldKTtcclxuICAgICAgICBpZiAoczEgPCAwKSB7XHJcbiAgICAgICAgICAgIHMxICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMyIC09IG1hc2goc2VlZFtpXSk7XHJcbiAgICAgICAgaWYgKHMyIDwgMCkge1xyXG4gICAgICAgICAgICBzMiArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbczAsIHMxLCBzMl07XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXNoIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIG5vbnB1cmUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhcmJpdHJhcnkgW1tNYXNoYWJsZV1dIGRhdGEgYW5kIHR1cm5zXHJcbiAqIHRoZW0gaW50byBudW1iZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gTWFzaCgpIHtcclxuICAgIGxldCBuID0gMHhlZmM4MjQ5ZDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHN0cmluZyA9IGRhdGEudG9TdHJpbmcoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICBsZXQgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xyXG4gICAgICAgICAgICBuID0gaCA+Pj4gMDtcclxuICAgICAgICAgICAgaCAtPSBuO1xyXG4gICAgICAgICAgICBoICo9IG47XHJcbiAgICAgICAgICAgIG4gPSBoID4+PiAwO1xyXG4gICAgICAgICAgICBoIC09IG47XHJcbiAgICAgICAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxyXG4gICAgfTtcclxufVxuXG4vKipcbiAqIFNldHVwIGEgbW9jayBoYW1tZXIuanMgb2JqZWN0LCBmb3IgdW5pdCB0ZXN0aW5nLlxuICpcbiAqIEluc3BpcmF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL3B1bGwvNjU4XG4gKlxuICogQHJldHVybnMge3tvbjogbm9vcCwgb2ZmOiBub29wLCBkZXN0cm95OiBub29wLCBlbWl0OiBub29wLCBnZXQ6IGdldH19XG4gKi9cbmZ1bmN0aW9uIGhhbW1lck1vY2soKSB7XG4gIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuICByZXR1cm4ge1xuICAgIG9uOiBub29wLFxuICAgIG9mZjogbm9vcCxcbiAgICBkZXN0cm95OiBub29wLFxuICAgIGVtaXQ6IG5vb3AsXG5cbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXQ6IG5vb3AsXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59XG5cbmNvbnN0IEhhbW1lciA9XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IHdpbmRvdy5IYW1tZXIgfHwgUmVhbEhhbW1lclxuICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBoYW1tZXIuanMgaXMgb25seSBhdmFpbGFibGUgaW4gYSBicm93c2VyLCBub3QgaW4gbm9kZS5qcy4gUmVwbGFjaW5nIGl0IHdpdGggYSBtb2NrIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIGhhbW1lck1vY2soKTtcbiAgICAgIH07XG5cbi8qKlxuICogVHVybiBhbiBlbGVtZW50IGludG8gYW4gY2xpY2tUb1VzZSBlbGVtZW50LlxuICogV2hlbiBub3QgYWN0aXZlLCB0aGUgZWxlbWVudCBoYXMgYSB0cmFuc3BhcmVudCBvdmVybGF5LiBXaGVuIHRoZSBvdmVybGF5IGlzXG4gKiBjbGlja2VkLCB0aGUgbW9kZSBpcyBjaGFuZ2VkIHRvIGFjdGl2ZS5cbiAqIFdoZW4gYWN0aXZlLCB0aGUgZWxlbWVudCBpcyBkaXNwbGF5ZWQgd2l0aCBhIGJsdWUgYm9yZGVyIGFyb3VuZCBpdCwgYW5kXG4gKiB0aGUgaW50ZXJhY3RpdmUgY29udGVudHMgb2YgdGhlIGVsZW1lbnQgY2FuIGJlIHVzZWQuIFdoZW4gY2xpY2tlZCBvdXRzaWRlXG4gKiB0aGUgZWxlbWVudCwgdGhlIGVsZW1lbnRzIG1vZGUgaXMgY2hhbmdlZCB0byBpbmFjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICogQGNsYXNzIEFjdGl2YXRvclxuICovXG5mdW5jdGlvbiBBY3RpdmF0b3IoY29udGFpbmVyKSB7XG4gIHRoaXMuX2NsZWFudXBRdWV1ZSA9IFtdO1xuXG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5fZG9tID0ge1xuICAgIGNvbnRhaW5lcixcbiAgICBvdmVybGF5OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICB9O1xuXG4gIHRoaXMuX2RvbS5vdmVybGF5LmNsYXNzTGlzdC5hZGQoXCJ2aXMtb3ZlcmxheVwiKTtcblxuICB0aGlzLl9kb20uY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RvbS5vdmVybGF5KTtcbiAgdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goKCkgPT4ge1xuICAgIHRoaXMuX2RvbS5vdmVybGF5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZG9tLm92ZXJsYXkpO1xuICB9KTtcblxuICBjb25zdCBoYW1tZXIgPSBIYW1tZXIodGhpcy5fZG9tLm92ZXJsYXkpO1xuICBoYW1tZXIub24oXCJ0YXBcIiwgdGhpcy5fb25UYXBPdmVybGF5LmJpbmQodGhpcykpO1xuICB0aGlzLl9jbGVhbnVwUXVldWUucHVzaCgoKSA9PiB7XG4gICAgaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAvLyBGSVhNRTogY2xlYW5pbmcgdXAgaGFtbWVyIGluc3RhbmNlcyBkb2Vzbid0IHdvcmsgKFRpbWVsaW5lIG5vdCByZW1vdmVkXG4gICAgLy8gZnJvbSBtZW1vcnkpXG4gIH0pO1xuXG4gIC8vIGJsb2NrIGFsbCB0b3VjaCBldmVudHMgKGV4Y2VwdCB0YXApXG4gIGNvbnN0IGV2ZW50cyA9IFtcbiAgICBcInRhcFwiLFxuICAgIFwiZG91YmxldGFwXCIsXG4gICAgXCJwcmVzc1wiLFxuICAgIFwicGluY2hcIixcbiAgICBcInBhblwiLFxuICAgIFwicGFuc3RhcnRcIixcbiAgICBcInBhbm1vdmVcIixcbiAgICBcInBhbmVuZFwiLFxuICBdO1xuICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICBoYW1tZXIub24oZXZlbnQsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGF0dGFjaCBhIGNsaWNrIGV2ZW50IHRvIHRoZSB3aW5kb3csIGluIG9yZGVyIHRvIGRlYWN0aXZhdGUgd2hlbiBjbGlja2luZyBvdXRzaWRlIHRoZSB0aW1lbGluZVxuICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgIHRoaXMuX29uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghX2hhc1BhcmVudChldmVudC50YXJnZXQsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNsaWNrKTtcbiAgICB0aGlzLl9jbGVhbnVwUXVldWUucHVzaCgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNsaWNrKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHByZXBhcmUgZXNjYXBlIGtleSBsaXN0ZW5lciBmb3IgZGVhY3RpdmF0aW5nIHdoZW4gYWN0aXZlXG4gIHRoaXMuX2VzY0xpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKFxuICAgICAgXCJrZXlcIiBpbiBldmVudFxuICAgICAgICA/IGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIlxuICAgICAgICA6IGV2ZW50LmtleUNvZGUgPT09IDI3IC8qIHRoZSBrZXlDb2RlIGlzIGZvciBJRTExICovXG4gICAgKSB7XG4gICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHR1cm4gaW50byBhbiBldmVudCBlbWl0dGVyXG5FbWl0dGVyKEFjdGl2YXRvci5wcm90b3R5cGUpO1xuXG4vLyBUaGUgY3VycmVudGx5IGFjdGl2ZSBhY3RpdmF0b3JcbkFjdGl2YXRvci5jdXJyZW50ID0gbnVsbDtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBhY3RpdmF0b3IuIENsZWFucyB1cCBhbGwgY3JlYXRlZCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVhY3RpdmF0ZSgpO1xuXG4gIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5fY2xlYW51cFF1ZXVlLnNwbGljZSgwKS5yZXZlcnNlKCkpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59O1xuXG4vKipcbiAqIEFjdGl2YXRlIHRoZSBlbGVtZW50XG4gKiBPdmVybGF5IGlzIGhpZGRlbiwgZWxlbWVudCBpcyBkZWNvcmF0ZWQgd2l0aCBhIGJsdWUgc2hhZG93IGJvcmRlclxuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyB3ZSBhbGxvdyBvbmx5IG9uZSBhY3RpdmUgYWN0aXZhdG9yIGF0IGEgdGltZVxuICBpZiAoQWN0aXZhdG9yLmN1cnJlbnQpIHtcbiAgICBBY3RpdmF0b3IuY3VycmVudC5kZWFjdGl2YXRlKCk7XG4gIH1cbiAgQWN0aXZhdG9yLmN1cnJlbnQgPSB0aGlzO1xuXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5fZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICB0aGlzLl9kb20uY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ2aXMtYWN0aXZlXCIpO1xuXG4gIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgdGhpcy5lbWl0KFwiYWN0aXZhdGVcIik7XG5cbiAgLy8gdWdseSBoYWNrOiBiaW5kIEVTQyBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnRzLCBhcyB0aGUgTmV0d29yayByZWJpbmRzIGFsbFxuICAvLyBrZXlib2FyZCBldmVudHMgb24gYSAnY2hhbmdlJyBldmVudFxuICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2VzY0xpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogRGVhY3RpdmF0ZSB0aGUgZWxlbWVudFxuICogT3ZlcmxheSBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBlbGVtZW50XG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgdGhpcy5fZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgdGhpcy5fZG9tLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwidmlzLWFjdGl2ZVwiKTtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9lc2NMaXN0ZW5lcik7XG5cbiAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB0aGlzLmVtaXQoXCJkZWFjdGl2YXRlXCIpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYSB0YXAgZXZlbnQ6IGFjdGl2YXRlIHRoZSBjb250YWluZXJcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuX29uVGFwT3ZlcmxheSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gIHRoaXMuYWN0aXZhdGUoKTtcbiAgZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB0aGUgZWxlbWVudCBoYXMgdGhlIHJlcXVlc3RlZCBwYXJlbnQgZWxlbWVudCBzb21ld2hlcmUgaW5cbiAqIGl0cyBjaGFpbiBvZiBwYXJlbnQgbm9kZXMuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHBhcmVudCBpcyBmb3VuZCBzb21ld2hlcmUgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2hhc1BhcmVudChlbGVtZW50LCBwYXJlbnQpIHtcbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHV0aWxpdHkgZnVuY3Rpb25zXHJcbi8vIHBhcnNlIEFTUC5OZXQgRGF0ZSBwYXR0ZXJuLFxyXG4vLyBmb3IgZXhhbXBsZSAnL0RhdGUoMTE5ODkwODcxNzA1NikvJyBvciAnL0RhdGUoMTE5ODkwODcxNzA1Ni0wNzAwKS8nXHJcbi8vIGNvZGUgZnJvbSBodHRwOi8vbW9tZW50anMuY29tL1xyXG5jb25zdCBBU1BEYXRlUmVnZXggPSAvXlxcLz9EYXRlXFwoKC0/XFxkKykvaTtcclxuLy8gQ29sb3IgUkVzXHJcbmNvbnN0IGZ1bGxIZXhSRSA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7XHJcbmNvbnN0IHNob3J0SGV4UkUgPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xyXG5jb25zdCByZ2JSRSA9IC9ecmdiXFwoICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICpcXCkkL2k7XHJcbmNvbnN0IHJnYmFSRSA9IC9ecmdiYVxcKCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKFswMV18MD9cXC5cXGQrKSAqXFwpJC9pO1xyXG4vKipcclxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIG51bWJlci5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gSW5wdXQgdmFsdWUgb2YgdW5rbm93biB0eXBlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBldmVyeXRoaW5nIGluIHRoZSBET00gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gRE9Nb2JqZWN0IC0gTm9kZSB3aG9zZSBjaGlsZCBub2RlcyB3aWxsIGJlIHJlY3Vyc2l2ZWx5IGRlbGV0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWN1cnNpdmVET01EZWxldGUoRE9Nb2JqZWN0KSB7XHJcbiAgICBpZiAoRE9Nb2JqZWN0KSB7XHJcbiAgICAgICAgd2hpbGUgKERPTW9iamVjdC5oYXNDaGlsZE5vZGVzKCkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBET01vYmplY3QuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVET01EZWxldGUoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgRE9Nb2JqZWN0LnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gSW5wdXQgdmFsdWUgb2YgdW5rbm93biB0eXBlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XHJcbn1cclxuLyoqXHJcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBvYmplY3QgKG5vdCBwcmltaXRpdmUgb3IgbnVsbCkuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIElucHV0IHZhbHVlIG9mIHVua25vd24gdHlwZS5cclxuICpcclxuICogQHJldHVybnMgVHJ1ZSBpZiBub3QgbnVsbCBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgRGF0ZSwgb3IgYSBTdHJpbmcgY29udGFpbmluZyBhIERhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIElucHV0IHZhbHVlIG9mIHVua25vd24gdHlwZS5cclxuICpcclxuICogQHJldHVybnMgVHJ1ZSBpZiBEYXRlIGluc3RhbmNlIG9yIHN0cmluZyBkYXRlIHJlcHJlc2VudGF0aW9uLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIC8vIHRlc3Qgd2hldGhlciB0aGlzIHN0cmluZyBjb250YWlucyBhIGRhdGVcclxuICAgICAgICBjb25zdCBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKHZhbHVlKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFpc05hTihEYXRlLnBhcnNlKHZhbHVlKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBDb3B5IHByb3BlcnR5IGZyb20gYiB0byBhIGlmIHByb3BlcnR5IHByZXNlbnQgaW4gYS5cclxuICogSWYgcHJvcGVydHkgaW4gYiBleHBsaWNpdGx5IHNldCB0byBudWxsLCBkZWxldGUgaXQgaWYgYGFsbG93RGVsZXRpb25gIHNldC5cclxuICpcclxuICogSW50ZXJuYWwgaGVscGVyIHJvdXRpbmUsIHNob3VsZCBub3QgYmUgZXhwb3J0ZWQuIE5vdCBhZGRlZCB0byBgZXhwb3J0c2AgZm9yIHRoYXQgcmVhc29uLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIFRhcmdldCBvYmplY3QuXHJcbiAqIEBwYXJhbSBiIC0gU291cmNlIG9iamVjdC5cclxuICogQHBhcmFtIHByb3AgLSBOYW1lIG9mIHByb3BlcnR5IHRvIGNvcHkgZnJvbSBiIHRvIGEuXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnR5IGluIGEgaWYgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiLlxyXG4gKi9cclxuZnVuY3Rpb24gY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pIHtcclxuICAgIGxldCBkb0RlbGV0aW9uID0gZmFsc2U7XHJcbiAgICBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGRvRGVsZXRpb24gPSBiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGlmIChkb0RlbGV0aW9uKSB7XHJcbiAgICAgICAgZGVsZXRlIGFbcHJvcF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhW3Byb3BdID0gYltwcm9wXTsgLy8gUmVtZW1iZXIsIHRoaXMgaXMgYSByZWZlcmVuY2UgY29weSFcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRmlsbCBhbiBvYmplY3Qgd2l0aCBhIHBvc3NpYmx5IHBhcnRpYWxseSBkZWZpbmVkIG90aGVyIG9iamVjdC5cclxuICpcclxuICogT25seSBjb3BpZXMgdmFsdWVzIGZvciB0aGUgcHJvcGVydGllcyBhbHJlYWR5IHByZXNlbnQgaW4gYS5cclxuICogVGhhdCBtZWFucyBhbiBvYmplY3QgaXMgbm90IGNyZWF0ZWQgb24gYSBwcm9wZXJ0eSBpZiBvbmx5IHRoZSBiIG9iamVjdCBoYXMgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gVGhlIG9iamVjdCB0aGF0IHdpbGwgaGF2ZSBpdCdzIHByb3BlcnRpZXMgdXBkYXRlZC5cclxuICogQHBhcmFtIGIgLSBUaGUgb2JqZWN0IHdpdGggcHJvcGVydHkgdXBkYXRlcy5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCBkZWxldGUgcHJvcGVydGllcyBpbiBhIHRoYXQgYXJlIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgaW4gYi5cclxuICovXHJcbmZ1bmN0aW9uIGZpbGxJZkRlZmluZWQoYSwgYiwgYWxsb3dEZWxldGlvbiA9IGZhbHNlKSB7XHJcbiAgICAvLyBOT1RFOiBpdGVyYXRpb24gb2YgcHJvcGVydGllcyBvZiBhXHJcbiAgICAvLyBOT1RFOiBwcm90b3R5cGUgcHJvcGVydGllcyBpdGVyYXRlZCBvdmVyIGFzIHdlbGxcclxuICAgIGZvciAoY29uc3QgcHJvcCBpbiBhKSB7XHJcbiAgICAgICAgaWYgKGJbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoYltwcm9wXSA9PT0gbnVsbCB8fCB0eXBlb2YgYltwcm9wXSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogdHlwZW9mIG51bGwgPT09ICdvYmplY3QnXHJcbiAgICAgICAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhUHJvcCA9IGFbcHJvcF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiUHJvcCA9IGJbcHJvcF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoYVByb3ApICYmIGlzT2JqZWN0KGJQcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxJZkRlZmluZWQoYVByb3AsIGJQcm9wLCBhbGxvd0RlbGV0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIG9mIGFsbCBvZiB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIGFcclxuICogdGFyZ2V0IG9iamVjdC4gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IHRvIGNvcHkgdG8uXHJcbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNvcHkgcHJvcGVydGllcy5cclxuICpcclxuICogQHJldHVybnMgVGhlIHRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xyXG4vKipcclxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGNvcGllZCB0byBhLlxyXG4gKiBAcGFyYW0gYSAtIFRoZSB0YXJnZXQuXHJcbiAqIEBwYXJhbSBvdGhlcnMgLSBUaGUgc291cmNlcy5cclxuICpcclxuICogQHJldHVybnMgQXJndW1lbnQgYS5cclxuICovXHJcbmZ1bmN0aW9uIHNlbGVjdGl2ZUV4dGVuZChwcm9wcywgYSwgLi4ub3RoZXJzKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgd2l0aCBwcm9wZXJ0eSBuYW1lcyBleHBlY3RlZCBhcyBmaXJzdCBhcmd1bWVudFwiKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qgb3RoZXIgb2Ygb3RoZXJzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbcF07XHJcbiAgICAgICAgICAgIGlmIChvdGhlciAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufVxyXG4vKipcclxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cclxuICogT25seSBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCB2YWx1ZXMgYXJlIGNvcGllZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogUHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIHJvdXRpbmUgaW1wbGllZCB0aGF0IG11bHRpcGxlIHNvdXJjZSBvYmplY3RzIGNvdWxkXHJcbiAqIGJlIHVzZWQ7IGhvd2V2ZXIsIHRoZSBpbXBsZW1lbnRhdGlvbiB3YXMgKip3cm9uZyoqLiBTaW5jZSBtdWx0aXBsZSAoXFw+MSlcclxuICogc291cmNlcyB3ZXJlbid0IHVzZWQgYW55d2hlcmUgaW4gdGhlIGB2aXMuanNgIGNvZGUsIHRoaXMgaGFzIGJlZW4gcmVtb3ZlZFxyXG4gKlxyXG4gKiBAcGFyYW0gcHJvcHMgLSBOYW1lcyBvZiBmaXJzdC1sZXZlbCBwcm9wZXJ0aWVzIHRvIGNvcHkgb3Zlci5cclxuICogQHBhcmFtIGEgLSBUYXJnZXQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gYiAtIFNvdXJjZSBvYmplY3QuXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnR5IGluIGEgaWYgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBcmd1bWVudCBhLlxyXG4gKi9cclxuZnVuY3Rpb24gc2VsZWN0aXZlRGVlcEV4dGVuZChwcm9wcywgYSwgYiwgYWxsb3dEZWxldGlvbiA9IGZhbHNlKSB7XHJcbiAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kXCIpO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xyXG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1twXTtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHByb3ApKSB7XHJcbiAgICAgICAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFbcHJvcF0gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIGZhbHNlLCBhbGxvd0RlbGV0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJbcHJvcF0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufVxyXG4vKipcclxuICogRXh0ZW5kIG9iamVjdCBgYWAgd2l0aCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBgYmAsIGlnbm9yaW5nIHByb3BlcnRpZXMgd2hpY2hcclxuICogYXJlIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHRvIGJlIGV4Y2x1ZGVkLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgcHJvcGVydGllcyBvZiBgYmAgYXJlIGNvbnNpZGVyZWQgZm9yIGNvcHlpbmcuIFByb3BlcnRpZXMgd2hpY2ggYXJlXHJcbiAqIHRoZW1zZWx2ZXMgb2JqZWN0cyBhcmUgYXJlIGFsc28gZXh0ZW5kZWQuIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWRcclxuICogdmFsdWVzIGFyZSBjb3BpZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBwcm9wc1RvRXhjbHVkZSAtIE5hbWVzIG9mIHByb3BlcnRpZXMgd2hpY2ggc2hvdWxkICpub3QqIGJlIGNvcGllZC5cclxuICogQHBhcmFtIGEgLSBPYmplY3QgdG8gZXh0ZW5kLlxyXG4gKiBAcGFyYW0gYiAtIE9iamVjdCB0byB0YWtlIHByb3BlcnRpZXMgZnJvbSBmb3IgZXh0ZW5zaW9uLlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIGRlbGV0ZSBwcm9wZXJ0aWVzIGluIGEgdGhhdCBhcmUgZXhwbGljaXRseVxyXG4gKiBzZXQgdG8gbnVsbCBpbiBiLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBcmd1bWVudCBhLlxyXG4gKi9cclxuZnVuY3Rpb24gc2VsZWN0aXZlTm90RGVlcEV4dGVuZChwcm9wc1RvRXhjbHVkZSwgYSwgYiwgYWxsb3dEZWxldGlvbiA9IGZhbHNlKSB7XHJcbiAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgQXJyYXlzIHRvIGRlZXBFeHRlbmRcclxuICAgIC8vIE5PVEU6IGFycmF5IHByb3BlcnRpZXMgaGF2ZSBhbiBlbHNlLWJlbG93OyBhcHBhcmVudGx5LCB0aGVyZSBpcyBhIHByb2JsZW0gaGVyZS5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kXCIpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBwcm9wIGluIGIpIHtcclxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwcm9wKSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IC8vIEhhbmRsZSBsb2NhbCBwcm9wZXJ0aWVzIG9ubHlcclxuICAgICAgICBpZiAocHJvcHNUb0V4Y2x1ZGUuaW5jbHVkZXMocHJvcCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfSAvLyBJbiBleGNsdXNpb24gbGlzdCwgc2tpcFxyXG4gICAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBhW3Byb3BdID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJbcHJvcF0pKSB7XHJcbiAgICAgICAgICAgIGFbcHJvcF0gPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiW3Byb3BdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhW3Byb3BdLnB1c2goYltwcm9wXVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufVxyXG4vKipcclxuICogRGVlcCBleHRlbmQgYW4gb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cclxuICpcclxuICogQHBhcmFtIGEgLSBUYXJnZXQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gYiAtIFNvdXJjZSBvYmplY3QuXHJcbiAqIEBwYXJhbSBwcm90b0V4dGVuZCAtIElmIHRydWUsIHRoZSBwcm90b3R5cGUgdmFsdWVzIHdpbGwgYWxzbyBiZSBleHRlbmRlZC5cclxuICogKFRoYXQgaXMgdGhlIG9wdGlvbnMgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBvdGhlcnMgd2lsbCBhbHNvIGdldCB0aGVcclxuICogaW5oZXJpdGVkIG9wdGlvbnMpLlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIHRoZSB2YWx1ZXMgb2YgZmllbGRzIHRoYXQgYXJlIG51bGwgd2lsbCBiZSBkZWxldGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBcmd1bWVudCBhLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEV4dGVuZChhLCBiLCBwcm90b0V4dGVuZCA9IGZhbHNlLCBhbGxvd0RlbGV0aW9uID0gZmFsc2UpIHtcclxuICAgIGZvciAoY29uc3QgcHJvcCBpbiBiKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwcm9wKSB8fCBwcm90b0V4dGVuZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJbcHJvcF0gPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgICAgICAgICAgIGJbcHJvcF0gIT09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihiW3Byb3BdKSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFbcHJvcF0gPSBkZWVwRXh0ZW5kKHt9LCBiW3Byb3BdLCBwcm90b0V4dGVuZCk7IC8vIE5PVEU6IGFsbG93RGVsZXRpb24gbm90IHByb3BhZ2F0ZWQhXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYVtwcm9wXSA9PT0gXCJvYmplY3RcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFbcHJvcF0gIT09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYVtwcm9wXSkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIHByb3RvRXh0ZW5kKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJbcHJvcF0pKSB7XHJcbiAgICAgICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXS5zbGljZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuLyoqXHJcbiAqIFRlc3Qgd2hldGhlciBhbGwgZWxlbWVudHMgaW4gdHdvIGFycmF5cyBhcmUgZXF1YWwuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gRmlyc3QgYXJyYXkuXHJcbiAqIEBwYXJhbSBiIC0gU2Vjb25kIGFycmF5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIGJvdGggYXJyYXlzIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFuZCBzYW1lIGVsZW1lbnRzICgxID0gJzEnKS5cclxuICovXHJcbmZ1bmN0aW9uIGVxdWFsQXJyYXkoYSwgYikge1xyXG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0aGUgdHlwZSBvZiBhbiBvYmplY3QsIGZvciBleGFtcGxlIGV4cG9ydHMuZ2V0VHlwZShbXSkgcmV0dXJucyAnQXJyYXknLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0IC0gSW5wdXQgdmFsdWUgb2YgdW5rbm93biB0eXBlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBEZXRlY3RlZCB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHlwZShvYmplY3QpIHtcclxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2Ygb2JqZWN0O1xyXG4gICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiQm9vbGVhblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIk51bWJlclwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlN0cmluZ1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIkFycmF5XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIkRhdGVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiT2JqZWN0XCI7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIHJldHVybiBcIk51bWJlclwiO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiQm9vbGVhblwiO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gXCJTdHJpbmdcIjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlO1xyXG59XHJcbi8qKlxyXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cclxuICpcclxuICogQHBhcmFtIGFyciAtIEZpcnN0IHBhcnQuXHJcbiAqIEBwYXJhbSBuZXdWYWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBhYWRkZWQgaW50byB0aGUgYXJyYXkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgbmV3IGFycmF5IHdpdGggYWxsIGl0ZW1zIGZyb20gYXJyIGFuZCBuZXdWYWx1ZSAod2hpY2ggaXMgbGFzdCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3B5QW5kRXh0ZW5kQXJyYXkoYXJyLCBuZXdWYWx1ZSkge1xyXG4gICAgcmV0dXJuIFsuLi5hcnIsIG5ld1ZhbHVlXTtcclxufVxyXG4vKipcclxuICogVXNlZCB0byBleHRlbmQgYW4gYXJyYXkgYW5kIGNvcHkgaXQuIFRoaXMgaXMgdXNlZCB0byBwcm9wYWdhdGUgcGF0aHMgcmVjdXJzaXZlbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnIgLSBUaGUgYXJyYXkgdG8gYmUgY29waWVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBTaGFsbG93IGNvcHkgb2YgYXJyLlxyXG4gKi9cclxuZnVuY3Rpb24gY29weUFycmF5KGFycikge1xyXG4gICAgcmV0dXJuIGFyci5zbGljZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZSB0aGUgYWJzb2x1dGUgbGVmdCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbSAtIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgbGVmdCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQgaW4gdGhlIGJyb3dzZXIgcGFnZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldEFic29sdXRlTGVmdChlbGVtKSB7XHJcbiAgICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZSB0aGUgYWJzb2x1dGUgcmlnaHQgdmFsdWUgb2YgYSBET00gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIGVsZW0gLSBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdi5cclxuICpcclxuICogQHJldHVybnMgVGhlIGFic29sdXRlIHJpZ2h0IHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudCBpbiB0aGUgYnJvd3NlciBwYWdlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVSaWdodChlbGVtKSB7XHJcbiAgICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodDtcclxufVxyXG4vKipcclxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIHRvcCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbSAtIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgdG9wIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudCBpbiB0aGUgYnJvd3NlciBwYWdlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVUb3AoZWxlbSkge1xyXG4gICAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgYSBjbGFzc05hbWUgdG8gdGhlIGdpdmVuIGVsZW1lbnRzIHN0eWxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbSAtIFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBjbGFzc2VzIHdpbGwgYmUgYWRkZWQuXHJcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gU3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgY2xhc3Nlcy5cclxuICovXHJcbmZ1bmN0aW9uIGFkZENsYXNzTmFtZShlbGVtLCBjbGFzc05hbWVzKSB7XHJcbiAgICBsZXQgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KFwiIFwiKTtcclxuICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBjbGFzc05hbWVzLnNwbGl0KFwiIFwiKTtcclxuICAgIGNsYXNzZXMgPSBjbGFzc2VzLmNvbmNhdChuZXdDbGFzc2VzLmZpbHRlcihmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICFjbGFzc2VzLmluY2x1ZGVzKGNsYXNzTmFtZSk7XHJcbiAgICB9KSk7XHJcbiAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbihcIiBcIik7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBhIGNsYXNzTmFtZSBmcm9tIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZS5cclxuICpcclxuICogQHBhcmFtIGVsZW0gLSBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRoZSBjbGFzc2VzIHdpbGwgYmUgcmVtb3ZlZC5cclxuICogQHBhcmFtIGNsYXNzTmFtZXMgLSBTcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzc2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lKGVsZW0sIGNsYXNzTmFtZXMpIHtcclxuICAgIGxldCBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoXCIgXCIpO1xyXG4gICAgY29uc3Qgb2xkQ2xhc3NlcyA9IGNsYXNzTmFtZXMuc3BsaXQoXCIgXCIpO1xyXG4gICAgY2xhc3NlcyA9IGNsYXNzZXMuZmlsdGVyKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICByZXR1cm4gIW9sZENsYXNzZXMuaW5jbHVkZXMoY2xhc3NOYW1lKTtcclxuICAgIH0pO1xyXG4gICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpO1xyXG59XHJcbi8qKlxyXG4gKiBGb3IgZWFjaCBtZXRob2QgZm9yIGJvdGggYXJyYXlzIGFuZCBvYmplY3RzLlxyXG4gKiBJbiBjYXNlIG9mIGFuIGFycmF5LCB0aGUgYnVpbHQtaW4gQXJyYXkuZm9yRWFjaCgpIGlzIGFwcGxpZWQgKCoqTm8sIGl0J3Mgbm90ISoqKS5cclxuICogSW4gY2FzZSBvZiBhbiBPYmplY3QsIHRoZSBtZXRob2QgbG9vcHMgb3ZlciBhbGwgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0IC0gQW4gT2JqZWN0IG9yIEFycmF5IHRvIGJlIGl0ZXJhdGVkIG92ZXIuXHJcbiAqIEBwYXJhbSBjYWxsYmFjayAtIEFycmF5LmZvckVhY2gtbGlrZSBjYWxsYmFjay5cclxuICovXHJcbmZ1bmN0aW9uIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjaykge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xyXG4gICAgICAgIC8vIGFycmF5XHJcbiAgICAgICAgY29uc3QgbGVuID0gb2JqZWN0Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG9iamVjdFtpXSwgaSwgb2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBvYmplY3RcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYW4gYXJyYXk6IGFsbCBvYmplY3RzIHByb3BlcnRpZXMgYXJlIHB1dCBpbnRvIHRoZSBhcnJheS4gVGhlIHJlc3VsdGluZyBhcnJheSBpcyB1bm9yZGVyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBvIC0gT2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHVub3JkZXJlZCB2YWx1ZXMuXHJcbiAqL1xyXG5jb25zdCB0b0FycmF5ID0gT2JqZWN0LnZhbHVlcztcclxuLyoqXHJcbiAqIFVwZGF0ZSBhIHByb3BlcnR5IGluIGFuIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3Qgd2hvc2UgcHJvcGVydHkgd2lsbCBiZSB1cGRhdGVkLlxyXG4gKiBAcGFyYW0ga2V5IC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgdXBkYXRlZC5cclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG5ldyB2YWx1ZSB0byBiZSBhc3NpZ25lZC5cclxuICpcclxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgd2FzIHVwZGF0ZWQgKHRydWUpIG9yIGFscmVhZHkgc3RyaWN0bHkgdGhlIHNhbWUgaW4gdGhlIG9yaWdpbmFsIG9iamVjdCAoZmFsc2UpLlxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydHkob2JqZWN0LCBrZXksIHZhbHVlKSB7XHJcbiAgICBpZiAob2JqZWN0W2tleV0gIT09IHZhbHVlKSB7XHJcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhyb3R0bGUgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIGJlIG9ubHkgZXhlY3V0ZWQgb25jZSBwZXIgYW5pbWF0aW9uIGZyYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0gZm4gLSBUaGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiB0aHJvdHRsZShmbikge1xyXG4gICAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBpZiAoIXNjaGVkdWxlZCkge1xyXG4gICAgICAgICAgICBzY2hlZHVsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmbigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgYW5kIGV2ZW50IGxpc3RlbmVyLiBXb3JrcyBmb3IgYWxsIGJyb3dzZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGJpbmQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvLlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gU2FtZSBhcyBFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYWN0aW9uLCDigJQsIOKAlCkuXHJcbiAqIEBwYXJhbSBsaXN0ZW5lciAtIFNhbWUgYXMgRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKOKAlCwgbGlzdGVuZXIsIOKAlCkuXHJcbiAqIEBwYXJhbSB1c2VDYXB0dXJlIC0gU2FtZSBhcyBFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIo4oCULCDigJQsIHVzZUNhcHR1cmUpLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcbiAgICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB1c2VDYXB0dXJlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhY3Rpb24gPT09IFwibW91c2V3aGVlbFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJGaXJlZm94XCIpKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgLy8gRm9yIEZpcmVmb3hcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gQFRPRE86IElFIHR5cGVzPyBEb2VzIGFueW9uZSBjYXJlP1xyXG4gICAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgYWN0aW9uLCBsaXN0ZW5lcik7IC8vIElFIGJyb3dzZXJzXHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gYmluZCB0aGUgZXZlbnQgbGlzdGVuZXIgdG8uXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBTYW1lIGFzIEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhY3Rpb24sIOKAlCwg4oCUKS5cclxuICogQHBhcmFtIGxpc3RlbmVyIC0gU2FtZSBhcyBFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIo4oCULCBsaXN0ZW5lciwg4oCUKS5cclxuICogQHBhcmFtIHVzZUNhcHR1cmUgLSBTYW1lIGFzIEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcijigJQsIOKAlCwgdXNlQ2FwdHVyZSkuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuICAgIGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAvLyBub24tSUUgYnJvd3NlcnNcclxuICAgICAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHVzZUNhcHR1cmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gXCJtb3VzZXdoZWVsXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIkZpcmVmb3hcIikpIHtcclxuICAgICAgICAgICAgYWN0aW9uID0gXCJET01Nb3VzZVNjcm9sbFwiOyAvLyBGb3IgRmlyZWZveFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBAVE9ETzogSUUgdHlwZXM/IERvZXMgYW55b25lIGNhcmU/XHJcbiAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyBhY3Rpb24sIGxpc3RlbmVyKTsgLy8gSUUgYnJvd3NlcnNcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FuY2VscyB0aGUgZXZlbnQncyBkZWZhdWx0IGFjdGlvbiBpZiBpdCBpcyBjYW5jZWxhYmxlLCB3aXRob3V0IHN0b3BwaW5nIGZ1cnRoZXIgcHJvcGFnYXRpb24gb2YgdGhlIGV2ZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgd2hvc2UgZGVmYXVsdCBhY3Rpb24gc2hvdWxkIGJlIHByZXZlbnRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XHJcbiAgICBpZiAoIWV2ZW50KSB7XHJcbiAgICAgICAgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoIWV2ZW50KSA7XHJcbiAgICBlbHNlIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIG5vbi1JRSBicm93c2Vyc1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gQFRPRE86IElFIHR5cGVzPyBEb2VzIGFueW9uZSBjYXJlP1xyXG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7IC8vIElFIGJyb3dzZXJzXHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdldCBIVE1MIGVsZW1lbnQgd2hpY2ggaXMgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudC5cclxuICpcclxuICogQHJldHVybnMgVGhlIGVsZW1lbnQgb3IgbnVsbCBpZiBub3Qgb2J0YWluYWJsZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldFRhcmdldChldmVudCA9IHdpbmRvdy5ldmVudCkge1xyXG4gICAgLy8gY29kZSBmcm9tIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxyXG4gICAgLy8gQFRPRE86IEV2ZW50VGFyZ2V0IGNhbiBiZSBhbG1vc3QgYW55dGhpbmcsIGlzIGl0IG9rYXkgdG8gcmV0dXJuIG9ubHkgRWxlbWVudHM/XHJcbiAgICBsZXQgdGFyZ2V0ID0gbnVsbDtcclxuICAgIGlmICghZXZlbnQpIDtcclxuICAgIGVsc2UgaWYgKGV2ZW50LnRhcmdldCkge1xyXG4gICAgICAgIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV2ZW50LnNyY0VsZW1lbnQpIHtcclxuICAgICAgICB0YXJnZXQgPSBldmVudC5zcmNFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQubm9kZVR5cGUgIT0gbnVsbCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMykge1xyXG4gICAgICAgIC8vIGRlZmVhdCBTYWZhcmkgYnVnXHJcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgZ2l2ZW4gZWxlbWVudCBjb250YWlucyBnaXZlbiBwYXJlbnQgc29tZXdoZXJlIGluIHRoZSBET00gdHJlZS5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBiZSB0ZXN0ZWQuXHJcbiAqIEBwYXJhbSBwYXJlbnQgLSBUaGUgYW5jZXN0b3IgKG5vdCBuZWNlc3NhcmlseSBwYXJlbnQpIG9mIHRoZSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHBhcmVudCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgZWxlbWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzUGFyZW50KGVsZW1lbnQsIHBhcmVudCkge1xyXG4gICAgbGV0IGVsZW0gPSBlbGVtZW50O1xyXG4gICAgd2hpbGUgKGVsZW0pIHtcclxuICAgICAgICBpZiAoZWxlbSA9PT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuY29uc3Qgb3B0aW9uID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIGJvb2xlYW4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYmUgY29udmVydGVkIGludG9ib29sZWFuLCBhIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgYXMgYCgoKSA9PiB1bmtub3duKWAuXHJcbiAgICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gSWYgdGhlIHZhbHVlIG9yIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uID09IG51bGwgdGhlbiB0aGlzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQ29ycmVzcG9uZGluZyBib29sZWFuIHZhbHVlLCBpZiBub25lIHRoZW4gdGhlIGRlZmF1bHQgdmFsdWUsIGlmIG5vbmUgdGhlbiBudWxsLlxyXG4gICAgICovXHJcbiAgICBhc0Jvb2xlYW4odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IGEgdmFsdWUgaW50byBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBjb252ZXJ0ZWQgaW50b251bWJlciwgYSBmdW5jdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIGFzIGAoKCkgPT4gdW5rbm93bilgLlxyXG4gICAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIElmIHRoZSB2YWx1ZSBvciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiA9PSBudWxsIHRoZW4gdGhpcyB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIENvcnJlc3BvbmRpbmcgKipib3hlZCoqIG51bWJlciB2YWx1ZSwgaWYgbm9uZSB0aGVuIHRoZSBkZWZhdWx0IHZhbHVlLCBpZiBub25lIHRoZW4gbnVsbC5cclxuICAgICAqL1xyXG4gICAgYXNOdW1iZXIodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNvbnZlcnRlZCBpbnRvc3RyaW5nLCBhIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgYXMgYCgoKSA9PiB1bmtub3duKWAuXHJcbiAgICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gSWYgdGhlIHZhbHVlIG9yIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uID09IG51bGwgdGhlbiB0aGlzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQ29ycmVzcG9uZGluZyAqKmJveGVkKiogc3RyaW5nIHZhbHVlLCBpZiBub25lIHRoZW4gdGhlIGRlZmF1bHQgdmFsdWUsIGlmIG5vbmUgdGhlbiBudWxsLlxyXG4gICAgICovXHJcbiAgICBhc1N0cmluZyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBhIHZhbHVlIGludG8gYSBzaXplLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNvbnZlcnRlZCBpbnRvc2l6ZSwgYSBmdW5jdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIGFzIGAoKCkgPT4gdW5rbm93bilgLlxyXG4gICAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIElmIHRoZSB2YWx1ZSBvciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiA9PSBudWxsIHRoZW4gdGhpcyB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIENvcnJlc3BvbmRpbmcgc3RyaW5nIHZhbHVlIChudW1iZXIgKyAncHgnKSwgaWYgbm9uZSB0aGVuIHRoZSBkZWZhdWx0IHZhbHVlLCBpZiBub25lIHRoZW4gbnVsbC5cclxuICAgICAqL1xyXG4gICAgYXNTaXplKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgXCJweFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgRE9NIEVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYmUgY29udmVydGVkIGludG8gRE9NIEVsZW1lbnQsIGEgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZCBhcyBgKCgpID0+IHVua25vd24pYC5cclxuICAgICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBJZiB0aGUgdmFsdWUgb3IgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gPT0gbnVsbCB0aGVuIHRoaXMgd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgRE9NIEVsZW1lbnQsIGlmIG5vbmUgdGhlbiB0aGUgZGVmYXVsdCB2YWx1ZSwgaWYgbm9uZSB0aGVuIG51bGwuXHJcbiAgICAgKi9cclxuICAgIGFzRWxlbWVudCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlIHx8IG51bGw7XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogQ29udmVydCBoZXggY29sb3Igc3RyaW5nIGludG8gUkdCIGNvbG9yIG9iamVjdC5cclxuICpcclxuICogQHJlbWFya3NcclxuICoge0BsaW5rIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdifVxyXG4gKlxyXG4gKiBAcGFyYW0gaGV4IC0gSGV4IGNvbG9yIHN0cmluZyAoMyBvciA2IGRpZ2l0cywgd2l0aCBvciB3aXRob3V0ICMpLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBSR0IgY29sb3Igb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gaGV4VG9SR0IoaGV4KSB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgc3dpdGNoIChoZXgubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgcmVzdWx0ID0gc2hvcnRIZXhSRS5leGVjKGhleCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSArIHJlc3VsdFsxXSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSArIHJlc3VsdFsyXSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSArIHJlc3VsdFszXSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bGxIZXhSRS5leGVjKGhleCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHN0cmluZyBjb2xvciBpbiBoZXggb3IgUkdCIGZvcm1hdCBhbmQgYWRkcyB0aGUgb3BhY2l0eSwgUkdCQSBpcyBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciAtIFRoZSBjb2xvciBzdHJpbmcgKGhleCwgUkdCLCBSR0JBKS5cclxuICogQHBhcmFtIG9wYWNpdHkgLSBUaGUgbmV3IG9wYWNpdHkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFJHQkEgc3RyaW5nLCBmb3IgZXhhbXBsZSAncmdiYSgyNTUsIDAsIDEyNywgMC4zKScuXHJcbiAqL1xyXG5mdW5jdGlvbiBvdmVycmlkZU9wYWNpdHkoY29sb3IsIG9wYWNpdHkpIHtcclxuICAgIGlmIChjb2xvci5pbmNsdWRlcyhcInJnYmFcIikpIHtcclxuICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2xvci5pbmNsdWRlcyhcInJnYlwiKSkge1xyXG4gICAgICAgIGNvbnN0IHJnYiA9IGNvbG9yXHJcbiAgICAgICAgICAgIC5zdWJzdHIoY29sb3IuaW5kZXhPZihcIihcIikgKyAxKVxyXG4gICAgICAgICAgICAucmVwbGFjZShcIilcIiwgXCJcIilcclxuICAgICAgICAgICAgLnNwbGl0KFwiLFwiKTtcclxuICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiWzBdICsgXCIsXCIgKyByZ2JbMV0gKyBcIixcIiArIHJnYlsyXSArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcmdiID0gaGV4VG9SR0IoY29sb3IpO1xyXG4gICAgICAgIGlmIChyZ2IgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiLnIgKyBcIixcIiArIHJnYi5nICsgXCIsXCIgKyByZ2IuYiArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29udmVydCBSR0IgXFw8MCwgMjU1XFw+IGludG8gaGV4IGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHJlZCAtIFJlZCBjaGFubmVsLlxyXG4gKiBAcGFyYW0gZ3JlZW4gLSBHcmVlbiBjaGFubmVsLlxyXG4gKiBAcGFyYW0gYmx1ZSAtIEJsdWUgY2hhbm5lbC5cclxuICpcclxuICogQHJldHVybnMgSGV4IGNvbG9yIHN0cmluZyAoZm9yIGV4YW1wbGU6ICcjMGFjZGMwJykuXHJcbiAqL1xyXG5mdW5jdGlvbiBSR0JUb0hleChyZWQsIGdyZWVuLCBibHVlKSB7XHJcbiAgICByZXR1cm4gKFwiI1wiICsgKCgxIDw8IDI0KSArIChyZWQgPDwgMTYpICsgKGdyZWVuIDw8IDgpICsgYmx1ZSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcclxufVxyXG4vKipcclxuICogUGFyc2UgYSBjb2xvciBwcm9wZXJ0eSBpbnRvIGFuIG9iamVjdCB3aXRoIGJvcmRlciwgYmFja2dyb3VuZCwgYW5kIGhpZ2hsaWdodCBjb2xvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dENvbG9yIC0gU2hvcnRoYW5kIGNvbG9yIHN0cmluZyBvciBpbnB1dCBjb2xvciBvYmplY3QuXHJcbiAqIEBwYXJhbSBkZWZhdWx0Q29sb3IgLSBGdWxsIGNvbG9yIG9iamVjdCB0byBmaWxsIGluIG1pc3NpbmcgdmFsdWVzIGluIGlucHV0Q29sb3IuXHJcbiAqXHJcbiAqIEByZXR1cm5zIENvbG9yIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXRDb2xvciwgZGVmYXVsdENvbG9yKSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoaW5wdXRDb2xvcikpIHtcclxuICAgICAgICBsZXQgY29sb3JTdHIgPSBpbnB1dENvbG9yO1xyXG4gICAgICAgIGlmIChpc1ZhbGlkUkdCKGNvbG9yU3RyKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZ2IgPSBjb2xvclN0clxyXG4gICAgICAgICAgICAgICAgLnN1YnN0cig0KVxyXG4gICAgICAgICAgICAgICAgLnN1YnN0cigwLCBjb2xvclN0ci5sZW5ndGggLSA1KVxyXG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiLFwiKVxyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb2xvclN0ciA9IFJHQlRvSGV4KHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNWYWxpZEhleChjb2xvclN0cikgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgaHN2ID0gaGV4VG9IU1YoY29sb3JTdHIpO1xyXG4gICAgICAgICAgICBjb25zdCBsaWdodGVyQ29sb3JIU1YgPSB7XHJcbiAgICAgICAgICAgICAgICBoOiBoc3YuaCxcclxuICAgICAgICAgICAgICAgIHM6IGhzdi5zICogMC44LFxyXG4gICAgICAgICAgICAgICAgdjogTWF0aC5taW4oMSwgaHN2LnYgKiAxLjAyKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZGFya2VyQ29sb3JIU1YgPSB7XHJcbiAgICAgICAgICAgICAgICBoOiBoc3YuaCxcclxuICAgICAgICAgICAgICAgIHM6IE1hdGgubWluKDEsIGhzdi5zICogMS4yNSksXHJcbiAgICAgICAgICAgICAgICB2OiBoc3YudiAqIDAuOCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZGFya2VyQ29sb3JIZXggPSBIU1ZUb0hleChkYXJrZXJDb2xvckhTVi5oLCBkYXJrZXJDb2xvckhTVi5zLCBkYXJrZXJDb2xvckhTVi52KTtcclxuICAgICAgICAgICAgY29uc3QgbGlnaHRlckNvbG9ySGV4ID0gSFNWVG9IZXgobGlnaHRlckNvbG9ySFNWLmgsIGxpZ2h0ZXJDb2xvckhTVi5zLCBsaWdodGVyQ29sb3JIU1Yudik7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXgsXHJcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVyQ29sb3JIZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBob3Zlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogY29sb3JTdHIsXHJcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6IGNvbG9yU3RyLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGhvdmVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogY29sb3JTdHIsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBjb2xvclN0cixcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGRlZmF1bHRDb2xvcikge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuYmFja2dyb3VuZCB8fCBkZWZhdWx0Q29sb3IuYmFja2dyb3VuZCxcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ib3JkZXIgfHwgZGVmYXVsdENvbG9yLmJvcmRlcixcclxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodDogaXNTdHJpbmcoaW5wdXRDb2xvci5oaWdobGlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5oaWdobGlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaGlnaGxpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogKGlucHV0Q29sb3IuaGlnaGxpZ2h0ICYmIGlucHV0Q29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogKGlucHV0Q29sb3IuaGlnaGxpZ2h0ICYmIGlucHV0Q29sb3IuaGlnaGxpZ2h0LmJvcmRlcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb2xvci5oaWdobGlnaHQuYm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBob3ZlcjogaXNTdHJpbmcoaW5wdXRDb2xvci5ob3ZlcilcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhvdmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhvdmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAoaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJvcmRlcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb2xvci5ob3Zlci5ib3JkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IChpbnB1dENvbG9yLmhvdmVyICYmIGlucHV0Q29sb3IuaG92ZXIuYmFja2dyb3VuZCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb2xvci5ob3Zlci5iYWNrZ3JvdW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0ge1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ib3JkZXIgfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0OiBpc1N0cmluZyhpbnB1dENvbG9yLmhpZ2hsaWdodClcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhpZ2hsaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5oaWdobGlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAoaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAoaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYm9yZGVyKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBob3ZlcjogaXNTdHJpbmcoaW5wdXRDb2xvci5ob3ZlcilcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhvdmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhvdmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAoaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJvcmRlcikgfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAoaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJhY2tncm91bmQpIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IFJHQiBcXDwwLCAyNTVcXD4gaW50byBIU1Ygb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiB7QGxpbmsgaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9yZ2IyaHN2Lmh0bX1cclxuICpcclxuICogQHBhcmFtIHJlZCAtIFJlZCBjaGFubmVsLlxyXG4gKiBAcGFyYW0gZ3JlZW4gLSBHcmVlbiBjaGFubmVsLlxyXG4gKiBAcGFyYW0gYmx1ZSAtIEJsdWUgY2hhbm5lbC5cclxuICpcclxuICogQHJldHVybnMgSFNWIGNvbG9yIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIFJHQlRvSFNWKHJlZCwgZ3JlZW4sIGJsdWUpIHtcclxuICAgIHJlZCA9IHJlZCAvIDI1NTtcclxuICAgIGdyZWVuID0gZ3JlZW4gLyAyNTU7XHJcbiAgICBibHVlID0gYmx1ZSAvIDI1NTtcclxuICAgIGNvbnN0IG1pblJHQiA9IE1hdGgubWluKHJlZCwgTWF0aC5taW4oZ3JlZW4sIGJsdWUpKTtcclxuICAgIGNvbnN0IG1heFJHQiA9IE1hdGgubWF4KHJlZCwgTWF0aC5tYXgoZ3JlZW4sIGJsdWUpKTtcclxuICAgIC8vIEJsYWNrLWdyYXktd2hpdGVcclxuICAgIGlmIChtaW5SR0IgPT09IG1heFJHQikge1xyXG4gICAgICAgIHJldHVybiB7IGg6IDAsIHM6IDAsIHY6IG1pblJHQiB9O1xyXG4gICAgfVxyXG4gICAgLy8gQ29sb3JzIG90aGVyIHRoYW4gYmxhY2stZ3JheS13aGl0ZTpcclxuICAgIGNvbnN0IGQgPSByZWQgPT09IG1pblJHQiA/IGdyZWVuIC0gYmx1ZSA6IGJsdWUgPT09IG1pblJHQiA/IHJlZCAtIGdyZWVuIDogYmx1ZSAtIHJlZDtcclxuICAgIGNvbnN0IGggPSByZWQgPT09IG1pblJHQiA/IDMgOiBibHVlID09PSBtaW5SR0IgPyAxIDogNTtcclxuICAgIGNvbnN0IGh1ZSA9ICg2MCAqIChoIC0gZCAvIChtYXhSR0IgLSBtaW5SR0IpKSkgLyAzNjA7XHJcbiAgICBjb25zdCBzYXR1cmF0aW9uID0gKG1heFJHQiAtIG1pblJHQikgLyBtYXhSR0I7XHJcbiAgICBjb25zdCB2YWx1ZSA9IG1heFJHQjtcclxuICAgIHJldHVybiB7IGg6IGh1ZSwgczogc2F0dXJhdGlvbiwgdjogdmFsdWUgfTtcclxufVxyXG5jb25zdCBjc3NVdGlsID0ge1xyXG4gICAgLy8gc3BsaXQgYSBzdHJpbmcgd2l0aCBjc3Mgc3R5bGVzIGludG8gYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlc1xyXG4gICAgc3BsaXQoY3NzVGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IHt9O1xyXG4gICAgICAgIGNzc1RleHQuc3BsaXQoXCI7XCIpLmZvckVhY2goKHN0eWxlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdHlsZS50cmltKCkgIT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBzdHlsZS5zcGxpdChcIjpcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYXJ0c1swXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnRzWzFdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc3R5bGVzO1xyXG4gICAgfSxcclxuICAgIC8vIGJ1aWxkIGEgY3NzIHRleHQgc3RyaW5nIGZyb20gYW4gb2JqZWN0IHdpdGgga2V5L3ZhbHVlc1xyXG4gICAgam9pbihzdHlsZXMpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVzKVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleSArIFwiOiBcIiArIHN0eWxlc1trZXldO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5qb2luKFwiOyBcIik7XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogQXBwZW5kIGEgc3RyaW5nIHdpdGggY3NzIHN0eWxlcyB0byBhbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRoYXQgd2lsbCByZWNlaXZlIG5ldyBzdHlsZXMuXHJcbiAqIEBwYXJhbSBjc3NUZXh0IC0gVGhlIHN0eWxlcyB0byBiZSBhcHBlbmRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGFkZENzc1RleHQoZWxlbWVudCwgY3NzVGV4dCkge1xyXG4gICAgY29uc3QgY3VycmVudFN0eWxlcyA9IGNzc1V0aWwuc3BsaXQoZWxlbWVudC5zdHlsZS5jc3NUZXh0KTtcclxuICAgIGNvbnN0IG5ld1N0eWxlcyA9IGNzc1V0aWwuc3BsaXQoY3NzVGV4dCk7XHJcbiAgICBjb25zdCBzdHlsZXMgPSB7XHJcbiAgICAgICAgLi4uY3VycmVudFN0eWxlcyxcclxuICAgICAgICAuLi5uZXdTdHlsZXMsXHJcbiAgICB9O1xyXG4gICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gY3NzVXRpbC5qb2luKHN0eWxlcyk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBhIHN0cmluZyB3aXRoIGNzcyBzdHlsZXMgZnJvbSBhbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZyb20gd2hpY2ggc3R5bGVzIHNob3VsZCBiZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gY3NzVGV4dCAtIFRoZSBzdHlsZXMgdG8gYmUgcmVtb3ZlZC5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZUNzc1RleHQoZWxlbWVudCwgY3NzVGV4dCkge1xyXG4gICAgY29uc3Qgc3R5bGVzID0gY3NzVXRpbC5zcGxpdChlbGVtZW50LnN0eWxlLmNzc1RleHQpO1xyXG4gICAgY29uc3QgcmVtb3ZlU3R5bGVzID0gY3NzVXRpbC5zcGxpdChjc3NUZXh0KTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJlbW92ZVN0eWxlcykge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVtb3ZlU3R5bGVzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBjc3NVdGlsLmpvaW4oc3R5bGVzKTtcclxufVxyXG4vKipcclxuICogQ29udmVydCBIU1YgXFw8MCwgMVxcPiBpbnRvIFJHQiBjb2xvciBvYmplY3QuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIHtAbGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tamlqYWNrc29uLzUzMTEyNTZ9XHJcbiAqXHJcbiAqIEBwYXJhbSBoIC0gSHVlLlxyXG4gKiBAcGFyYW0gcyAtIFNhdHVyYXRpb24uXHJcbiAqIEBwYXJhbSB2IC0gVmFsdWUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFJHQiBjb2xvciBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBIU1ZUb1JHQihoLCBzLCB2KSB7XHJcbiAgICBsZXQgcjtcclxuICAgIGxldCBnO1xyXG4gICAgbGV0IGI7XHJcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihoICogNik7XHJcbiAgICBjb25zdCBmID0gaCAqIDYgLSBpO1xyXG4gICAgY29uc3QgcCA9IHYgKiAoMSAtIHMpO1xyXG4gICAgY29uc3QgcSA9IHYgKiAoMSAtIGYgKiBzKTtcclxuICAgIGNvbnN0IHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XHJcbiAgICBzd2l0Y2ggKGkgJSA2KSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAociA9IHYpLCAoZyA9IHQpLCAoYiA9IHApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIChyID0gcSksIChnID0gdiksIChiID0gcCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgKHIgPSBwKSwgKGcgPSB2KSwgKGIgPSB0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAociA9IHApLCAoZyA9IHEpLCAoYiA9IHYpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIChyID0gdCksIChnID0gcCksIChiID0gdik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgKHIgPSB2KSwgKGcgPSBwKSwgKGIgPSBxKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHI6IE1hdGguZmxvb3IociAqIDI1NSksXHJcbiAgICAgICAgZzogTWF0aC5mbG9vcihnICogMjU1KSxcclxuICAgICAgICBiOiBNYXRoLmZsb29yKGIgKiAyNTUpLFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ29udmVydCBIU1YgXFw8MCwgMVxcPiBpbnRvIGhleCBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBoIC0gSHVlLlxyXG4gKiBAcGFyYW0gcyAtIFNhdHVyYXRpb24uXHJcbiAqIEBwYXJhbSB2IC0gVmFsdWUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEhleCBjb2xvciBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBIU1ZUb0hleChoLCBzLCB2KSB7XHJcbiAgICBjb25zdCByZ2IgPSBIU1ZUb1JHQihoLCBzLCB2KTtcclxuICAgIHJldHVybiBSR0JUb0hleChyZ2IuciwgcmdiLmcsIHJnYi5iKTtcclxufVxyXG4vKipcclxuICogQ29udmVydCBoZXggY29sb3Igc3RyaW5nIGludG8gSFNWIFxcPDAsIDFcXD4uXHJcbiAqXHJcbiAqIEBwYXJhbSBoZXggLSBIZXggY29sb3Igc3RyaW5nLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBIU1YgY29sb3Igb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gaGV4VG9IU1YoaGV4KSB7XHJcbiAgICBjb25zdCByZ2IgPSBoZXhUb1JHQihoZXgpO1xyXG4gICAgaWYgKCFyZ2IpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnJHtoZXh9JyBpcyBub3QgYSB2YWxpZCBjb2xvci5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBSR0JUb0hTVihyZ2IuciwgcmdiLmcsIHJnYi5iKTtcclxufVxyXG4vKipcclxuICogVmFsaWRhdGUgaGV4IGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIGhleCAtIFVua25vd24gc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gYSBjb2xvci5cclxuICpcclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1ZhbGlkSGV4KGhleCkge1xyXG4gICAgY29uc3QgaXNPayA9IC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaS50ZXN0KGhleCk7XHJcbiAgICByZXR1cm4gaXNPaztcclxufVxyXG4vKipcclxuICogVmFsaWRhdGUgUkdCIGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHJnYiAtIFVua25vd24gc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gYSBjb2xvci5cclxuICpcclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1ZhbGlkUkdCKHJnYikge1xyXG4gICAgcmV0dXJuIHJnYlJFLnRlc3QocmdiKTtcclxufVxyXG4vKipcclxuICogVmFsaWRhdGUgUkdCQSBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSByZ2JhIC0gVW5rbm93biBzdHJpbmcgdGhhdCBtYXkgY29udGFpbiBhIGNvbG9yLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRSR0JBKHJnYmEpIHtcclxuICAgIHJldHVybiByZ2JhUkUudGVzdChyZ2JhKTtcclxufVxyXG4vKipcclxuICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdC5cclxuICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaWVsZHMgLSBOYW1lcyBvZiBwcm9wZXJ0aWVzIHRvIGJlIGJyaWRnZWQuXHJcbiAqIEBwYXJhbSByZWZlcmVuY2VPYmplY3QgLSBUaGUgb3JpZ2luYWwgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIG5ldyBvYmplY3QgaW5oZXJpdGluZyBmcm9tIHRoZSByZWZlcmVuY2VPYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZWxlY3RpdmVCcmlkZ2VPYmplY3QoZmllbGRzLCByZWZlcmVuY2VPYmplY3QpIHtcclxuICAgIGlmIChyZWZlcmVuY2VPYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIHJlZmVyZW5jZU9iamVjdCA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIC8vICEhISB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcclxuICAgICAgICBjb25zdCBvYmplY3RUbyA9IE9iamVjdC5jcmVhdGUocmVmZXJlbmNlT2JqZWN0KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZmVyZW5jZU9iamVjdCwgZmllbGRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VPYmplY3RbZmllbGRzW2ldXSA9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0VG9bZmllbGRzW2ldXSA9IGJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbZmllbGRzW2ldXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdFRvO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgcmVjdXJzaXZlbHkgcmVkaXJlY3RzIHRoZSBwcm90b3R5cGUgb2YgSlNPTiBvYmplY3RzIHRvIHRoZSByZWZlcmVuY2VPYmplY3QuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgZGVmYXVsdCBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmZXJlbmNlT2JqZWN0IC0gVGhlIG9yaWdpbmFsIG9iamVjdC5cclxuICpcclxuICogQHJldHVybnMgVGhlIEVsZW1lbnQgaWYgdGhlIHJlZmVyZW5jZU9iamVjdCBpcyBhbiBFbGVtZW50LCBvciBhIG5ldyBvYmplY3QgaW5oZXJpdGluZyBmcm9tIHRoZSByZWZlcmVuY2VPYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBicmlkZ2VPYmplY3QocmVmZXJlbmNlT2JqZWN0KSB7XHJcbiAgICBpZiAocmVmZXJlbmNlT2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiByZWZlcmVuY2VPYmplY3QgIT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChyZWZlcmVuY2VPYmplY3QgaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcbiAgICAgICAgLy8gQXZvaWQgYnJpZGdpbmcgRE9NIG9iamVjdHNcclxuICAgICAgICByZXR1cm4gcmVmZXJlbmNlT2JqZWN0O1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2JqZWN0VG8gPSBPYmplY3QuY3JlYXRlKHJlZmVyZW5jZU9iamVjdCk7XHJcbiAgICBmb3IgKGNvbnN0IGkgaW4gcmVmZXJlbmNlT2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWZlcmVuY2VPYmplY3QsIGkpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0W2ldID09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdFRvW2ldID0gYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqZWN0VG87XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHByb3ZpZGVzIGEgc3RhYmxlIHNvcnQgaW1wbGVtZW50YXRpb24sIHZlcnkgZmFzdCBmb3IgcHJlc29ydGVkIGRhdGEuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gVGhlIGFycmF5IHRvIGJlIHNvcnRlZCAoaW4tcGxhY2UpLlxyXG4gKiBAcGFyYW0gY29tcGFyZSAtIEFuIG9yZGVyIGNvbXBhcmF0b3IuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBhcmd1bWVudCBhLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5zZXJ0U29ydChhLCBjb21wYXJlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrID0gYVtpXTtcclxuICAgICAgICBsZXQgajtcclxuICAgICAgICBmb3IgKGogPSBpOyBqID4gMCAmJiBjb21wYXJlKGssIGFbaiAtIDFdKSA8IDA7IGotLSkge1xyXG4gICAgICAgICAgICBhW2pdID0gYVtqIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFbal0gPSBrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIG9wdGlvbnMgb2Ygc3Vib2JqZWN0cyBpbiB0aGUgb3B0aW9ucyBvYmplY3QuXHJcbiAqXHJcbiAqIEEgcmVxdWlyZW1lbnQgb2YgdGhlc2Ugc3Vib2JqZWN0cyBpcyB0aGF0IHRoZXkgaGF2ZSBhbiAnZW5hYmxlZCcgZWxlbWVudFxyXG4gKiB3aGljaCBpcyBvcHRpb25hbCBmb3IgdGhlIHVzZXIgYnV0IG1hbmRhdG9yeSBmb3IgdGhlIHByb2dyYW0uXHJcbiAqXHJcbiAqIFRoZSBhZGRlZCB2YWx1ZSBoZXJlIG9mIHRoZSBtZXJnZSBpcyB0aGF0IG9wdGlvbiAnZW5hYmxlZCcgaXMgc2V0IGFzIHJlcXVpcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWVyZ2VUYXJnZXQgLSBFaXRoZXIgdGhpcy5vcHRpb25zIG9yIHRoZSBvcHRpb25zIHVzZWQgZm9yIHRoZSBncm91cHMuXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cclxuICogQHBhcmFtIG9wdGlvbiAtIE9wdGlvbiBrZXkgaW4gdGhlIG9wdGlvbnMgYXJndW1lbnQuXHJcbiAqIEBwYXJhbSBnbG9iYWxPcHRpb25zIC0gR2xvYmFsIG9wdGlvbnMsIHBhc3NlZCBpbiB0byBkZXRlcm1pbmUgdmFsdWUgb2Ygb3B0aW9uICdlbmFibGVkJy5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhtZXJnZVRhcmdldCwgb3B0aW9ucywgb3B0aW9uLCBnbG9iYWxPcHRpb25zID0ge30pIHtcclxuICAgIC8vIExvY2FsIGhlbHBlcnNcclxuICAgIGNvbnN0IGlzUHJlc2VudCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIjtcclxuICAgIH07XHJcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ0OTEyODcvMTIyMzUzMVxyXG4gICAgY29uc3QgaXNFbXB0eSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHggaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCB4KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8vIEd1YXJkc1xyXG4gICAgaWYgKCFpc09iamVjdChtZXJnZVRhcmdldCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbWVyZ2VUYXJnZXQgbXVzdCBiZSBhbiBvYmplY3RcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzUHJlc2VudChvcHRpb24pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG9wdGlvbiBtdXN0IGhhdmUgYSB2YWx1ZVwiKTtcclxuICAgIH1cclxuICAgIGlmICghaXNPYmplY3QoZ2xvYmFsT3B0aW9ucykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgZ2xvYmFsT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcclxuICAgIH1cclxuICAgIC8vXHJcbiAgICAvLyBBY3R1YWwgbWVyZ2Ugcm91dGluZSwgc2VwYXJhdGVkIGZyb20gbWFpbiBsb2dpY1xyXG4gICAgLy8gT25seSBhIHNpbmdsZSBsZXZlbCBvZiBvcHRpb25zIGlzIG1lcmdlZC4gRGVlcGVyIGxldmVscyBhcmUgcmVmJ2QuIFRoaXMgbWF5IGFjdHVhbGx5IGJlIGFuIGlzc3VlLlxyXG4gICAgLy9cclxuICAgIGNvbnN0IGRvTWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pIHtcclxuICAgICAgICBpZiAoIWlzT2JqZWN0KHRhcmdldFtvcHRpb25dKSkge1xyXG4gICAgICAgICAgICB0YXJnZXRbb3B0aW9uXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzcmMgPSBvcHRpb25zW29wdGlvbl07XHJcbiAgICAgICAgY29uc3QgZHN0ID0gdGFyZ2V0W29wdGlvbl07XHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHNyYykge1xyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgcHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIGRzdFtwcm9wXSA9IHNyY1twcm9wXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBMb2NhbCBpbml0aWFsaXphdGlvblxyXG4gICAgY29uc3Qgc3JjT3B0aW9uID0gb3B0aW9uc1tvcHRpb25dO1xyXG4gICAgY29uc3QgZ2xvYmFsUGFzc2VkID0gaXNPYmplY3QoZ2xvYmFsT3B0aW9ucykgJiYgIWlzRW1wdHkoZ2xvYmFsT3B0aW9ucyk7XHJcbiAgICBjb25zdCBnbG9iYWxPcHRpb24gPSBnbG9iYWxQYXNzZWQgPyBnbG9iYWxPcHRpb25zW29wdGlvbl0gOiB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBnbG9iYWxFbmFibGVkID0gZ2xvYmFsT3B0aW9uID8gZ2xvYmFsT3B0aW9uLmVuYWJsZWQgOiB1bmRlZmluZWQ7XHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gTWFpbiByb3V0aW5lXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgaWYgKHNyY09wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvXHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHNyY09wdGlvbiA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICBpZiAoIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XHJcbiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gc3JjT3B0aW9uO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChzcmNPcHRpb24gPT09IG51bGwgJiYgIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XHJcbiAgICAgICAgLy8gSWYgcG9zc2libGUsIGV4cGxpY2l0IGNvcHkgZnJvbSBnbG9iYWxzXHJcbiAgICAgICAgaWYgKGlzUHJlc2VudChnbG9iYWxPcHRpb24pKSB7XHJcbiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl0gPSBPYmplY3QuY3JlYXRlKGdsb2JhbE9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG9cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzT2JqZWN0KHNyY09wdGlvbikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvL1xyXG4gICAgLy8gRW5zdXJlIHRoYXQgJ2VuYWJsZWQnIGlzIHByb3Blcmx5IHNldC4gSXQgaXMgcmVxdWlyZWQgaW50ZXJuYWxseVxyXG4gICAgLy8gTm90ZSB0aGF0IHRoZSB2YWx1ZSBmcm9tIG9wdGlvbnMgd2lsbCBhbHdheXMgb3ZlcndyaXRlIHRoZSBleGlzdGluZyB2YWx1ZVxyXG4gICAgLy9cclxuICAgIGxldCBlbmFibGVkID0gdHJ1ZTsgLy8gZGVmYXVsdCB2YWx1ZVxyXG4gICAgaWYgKHNyY09wdGlvbi5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBlbmFibGVkID0gc3JjT3B0aW9uLmVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUYWtlIGZyb20gZ2xvYmFscywgaWYgcHJlc2VudFxyXG4gICAgICAgIGlmIChnbG9iYWxFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZW5hYmxlZCA9IGdsb2JhbE9wdGlvbi5lbmFibGVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRvTWVyZ2UobWVyZ2VUYXJnZXQsIG9wdGlvbnMsIG9wdGlvbik7XHJcbiAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSBlbmFibGVkO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgYSBiaW5hcnkgc2VhcmNoIGZvciBhIHZpc2libGUgaXRlbSBpbiBhIHNvcnRlZCBsaXN0LiBJZiB3ZSBmaW5kIGEgdmlzaWJsZSBpdGVtLCB0aGUgY29kZSB0aGF0IHVzZXNcclxuICogdGhpcyBmdW5jdGlvbiB3aWxsIHRoZW4gaXRlcmF0ZSBpbiBib3RoIGRpcmVjdGlvbnMgb3ZlciB0aGlzIHNvcnRlZCBsaXN0IHRvIGZpbmQgYWxsIHZpc2libGUgaXRlbXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBvcmRlcmVkSXRlbXMgLSBJdGVtcyBvcmRlcmVkIGJ5IHN0YXJ0LlxyXG4gKiBAcGFyYW0gY29tcGFyYXRvciAtIC0xIGlzIGxvd2VyLCAwIGlzIGVxdWFsLCAxIGlzIGhpZ2hlci5cclxuICogQHBhcmFtIGZpZWxkIC0gUHJvcGVydHkgbmFtZSBvbiBhbiBpdGVtIChUaGF0IGlzIGl0ZW1bZmllbGRdKS5cclxuICogQHBhcmFtIGZpZWxkMiAtIFNlY29uZCBwcm9wZXJ0eSBuYW1lIG9uIGFuIGl0ZW0gKFRoYXQgaXMgaXRlbVtmaWVsZF1bZmllbGQyXSkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEluZGV4IG9mIHRoZSBmb3VuZCBpdGVtIG9yIC0xIGlmIG5vdGhpbmcgd2FzIGZvdW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoQ3VzdG9tKG9yZGVyZWRJdGVtcywgY29tcGFyYXRvciwgZmllbGQsIGZpZWxkMikge1xyXG4gICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwMDAwO1xyXG4gICAgbGV0IGl0ZXJhdGlvbiA9IDA7XHJcbiAgICBsZXQgbG93ID0gMDtcclxuICAgIGxldCBoaWdoID0gb3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDE7XHJcbiAgICB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IG9yZGVyZWRJdGVtc1ttaWRkbGVdO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQyID09PSB1bmRlZmluZWQgPyBpdGVtW2ZpZWxkXSA6IGl0ZW1bZmllbGRdW2ZpZWxkMl07XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoUmVzdWx0ID0gY29tcGFyYXRvcih2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHNlYXJjaFJlc3VsdCA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIGppaGFhLCBmb3VuZCBhIHZpc2libGUgaXRlbSFcclxuICAgICAgICAgICAgcmV0dXJuIG1pZGRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VhcmNoUmVzdWx0ID09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGl0IGlzIHRvbyBzbWFsbCAtLT4gaW5jcmVhc2UgbG93XHJcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpdCBpcyB0b28gYmlnIC0tPiBkZWNyZWFzZSBoaWdoXHJcbiAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpdGVyYXRpb24rKztcclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBkb2VzIGEgYmluYXJ5IHNlYXJjaCBmb3IgYSBzcGVjaWZpYyB2YWx1ZSBpbiBhIHNvcnRlZCBhcnJheS5cclxuICogSWYgaXQgZG9lcyBub3QgZXhpc3QgYnV0IGlzIGluIGJldHdlZW4gb2YgdHdvIHZhbHVlcywgd2UgcmV0dXJuIGVpdGhlciB0aGVcclxuICogb25lIGJlZm9yZSBvciB0aGUgb25lIGFmdGVyLCBkZXBlbmRpbmcgb24gdXNlciBpbnB1dCBJZiBpdCBpcyBmb3VuZCwgd2VcclxuICogcmV0dXJuIHRoZSBpbmRleCwgZWxzZSAtMS5cclxuICpcclxuICogQHBhcmFtIG9yZGVyZWRJdGVtcyAtIFNvcnRlZCBhcnJheS5cclxuICogQHBhcmFtIHRhcmdldCAtIFRoZSBzZWFyY2hlZCB2YWx1ZS5cclxuICogQHBhcmFtIGZpZWxkIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgaW4gaXRlbXMgdG8gYmUgc2VhcmNoZWQuXHJcbiAqIEBwYXJhbSBzaWRlUHJlZmVyZW5jZSAtIElmIHRoZSB0YXJnZXQgaXMgYmV0d2VlbiB0d28gdmFsdWVzLCBzaG91bGQgdGhlIGluZGV4IG9mIHRoZSBiZWZvcmUgb3IgdGhlIGFmdGVyIGJlIHJldHVybmVkP1xyXG4gKiBAcGFyYW0gY29tcGFyYXRvciAtIEFuIG9wdGlvbmFsIGNvbXBhcmF0b3IsIHJldHVybmluZyAtMSwgMCwgMSBmb3IgXFw8LCA9PT0sIFxcPi5cclxuICpcclxuICogQHJldHVybnMgVGhlIGluZGV4IG9mIGZvdW5kIHZhbHVlIG9yIC0xIGlmIG5vdGhpbmcgd2FzIGZvdW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoVmFsdWUob3JkZXJlZEl0ZW1zLCB0YXJnZXQsIGZpZWxkLCBzaWRlUHJlZmVyZW5jZSwgY29tcGFyYXRvcikge1xyXG4gICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwMDAwO1xyXG4gICAgbGV0IGl0ZXJhdGlvbiA9IDA7XHJcbiAgICBsZXQgbG93ID0gMDtcclxuICAgIGxldCBoaWdoID0gb3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgcHJldlZhbHVlO1xyXG4gICAgbGV0IHZhbHVlO1xyXG4gICAgbGV0IG5leHRWYWx1ZTtcclxuICAgIGxldCBtaWRkbGU7XHJcbiAgICBjb21wYXJhdG9yID1cclxuICAgICAgICBjb21wYXJhdG9yICE9IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGNvbXBhcmF0b3JcclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT0gYiA/IDAgOiBhIDwgYiA/IC0xIDogMTtcclxuICAgICAgICAgICAgfTtcclxuICAgIHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XHJcbiAgICAgICAgLy8gZ2V0IGEgbmV3IGd1ZXNzXHJcbiAgICAgICAgbWlkZGxlID0gTWF0aC5mbG9vcigwLjUgKiAoaGlnaCArIGxvdykpO1xyXG4gICAgICAgIHByZXZWYWx1ZSA9IG9yZGVyZWRJdGVtc1tNYXRoLm1heCgwLCBtaWRkbGUgLSAxKV1bZmllbGRdO1xyXG4gICAgICAgIHZhbHVlID0gb3JkZXJlZEl0ZW1zW21pZGRsZV1bZmllbGRdO1xyXG4gICAgICAgIG5leHRWYWx1ZSA9XHJcbiAgICAgICAgICAgIG9yZGVyZWRJdGVtc1tNYXRoLm1pbihvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMSwgbWlkZGxlICsgMSldW2ZpZWxkXTtcclxuICAgICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgdGFyZ2V0KSA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIHdlIGZvdW5kIHRoZSB0YXJnZXRcclxuICAgICAgICAgICAgcmV0dXJuIG1pZGRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29tcGFyYXRvcihwcmV2VmFsdWUsIHRhcmdldCkgPCAwICYmXHJcbiAgICAgICAgICAgIGNvbXBhcmF0b3IodmFsdWUsIHRhcmdldCkgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIHRhcmdldCBpcyBpbiBiZXR3ZWVuIG9mIHRoZSBwcmV2aW91cyBhbmQgdGhlIGN1cnJlbnRcclxuICAgICAgICAgICAgcmV0dXJuIHNpZGVQcmVmZXJlbmNlID09IFwiYmVmb3JlXCIgPyBNYXRoLm1heCgwLCBtaWRkbGUgLSAxKSA6IG1pZGRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29tcGFyYXRvcih2YWx1ZSwgdGFyZ2V0KSA8IDAgJiZcclxuICAgICAgICAgICAgY29tcGFyYXRvcihuZXh0VmFsdWUsIHRhcmdldCkgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIHRhcmdldCBpcyBpbiBiZXR3ZWVuIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgbmV4dFxyXG4gICAgICAgICAgICByZXR1cm4gc2lkZVByZWZlcmVuY2UgPT0gXCJiZWZvcmVcIlxyXG4gICAgICAgICAgICAgICAgPyBtaWRkbGVcclxuICAgICAgICAgICAgICAgIDogTWF0aC5taW4ob3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDEsIG1pZGRsZSArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZGlkbnQgZmluZCB0aGUgdGFyZ2V0LCB3ZSBuZWVkIHRvIGNoYW5nZSBvdXIgYm91bmRhcmllcy5cclxuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIHRhcmdldCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyB0b28gc21hbGwgLS0+IGluY3JlYXNlIGxvd1xyXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkZGxlICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcclxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGl0ZXJhdGlvbisrO1xyXG4gICAgfVxyXG4gICAgLy8gZGlkbnQgZmluZCBhbnl0aGluZy4gUmV0dXJuIC0xLlxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qXHJcbiAqIEVhc2luZyBGdW5jdGlvbnMuXHJcbiAqIE9ubHkgY29uc2lkZXJpbmcgdGhlIHQgdmFsdWUgZm9yIHRoZSByYW5nZSBbMCwgMV0gPT4gWzAsIDFdLlxyXG4gKlxyXG4gKiBJbnNwaXJhdGlvbjogZnJvbSBodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cclxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcclxuICovXHJcbmNvbnN0IGVhc2luZ0Z1bmN0aW9ucyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgbm8gZWFzaW5nIGFuZCBubyBhY2NlbGVyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgICAqL1xyXG4gICAgbGluZWFyKHQpIHtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEFjY2VsZXJhdGUgZnJvbSB6ZXJvIHZlbG9jaXR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICAgKi9cclxuICAgIGVhc2VJblF1YWQodCkge1xyXG4gICAgICAgIHJldHVybiB0ICogdDtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIERlY2VsZXJhdGUgdG8gemVybyB2ZWxvY2l0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAgICovXHJcbiAgICBlYXNlT3V0UXVhZCh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQWNjZWxlcmF0ZSB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgICAqL1xyXG4gICAgZWFzZUluT3V0UXVhZCh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHQgPCAwLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdDtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEFjY2VsZXJhdGUgZnJvbSB6ZXJvIHZlbG9jaXR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICAgKi9cclxuICAgIGVhc2VJbkN1YmljKHQpIHtcclxuICAgICAgICByZXR1cm4gdCAqIHQgKiB0O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogRGVjZWxlcmF0ZSB0byB6ZXJvIHZlbG9jaXR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICAgKi9cclxuICAgIGVhc2VPdXRDdWJpYyh0KSB7XHJcbiAgICAgICAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEFjY2VsZXJhdGUgdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICAgKi9cclxuICAgIGVhc2VJbk91dEN1YmljKHQpIHtcclxuICAgICAgICByZXR1cm4gdCA8IDAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2NlbGVyYXRlIGZyb20gemVybyB2ZWxvY2l0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAgICovXHJcbiAgICBlYXNlSW5RdWFydCh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHQ7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgICAqL1xyXG4gICAgZWFzZU91dFF1YXJ0KHQpIHtcclxuICAgICAgICByZXR1cm4gMSAtIC0tdCAqIHQgKiB0ICogdDtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEFjY2VsZXJhdGUgdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICAgKi9cclxuICAgIGVhc2VJbk91dFF1YXJ0KHQpIHtcclxuICAgICAgICByZXR1cm4gdCA8IDAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAtLXQgKiB0ICogdCAqIHQ7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2NlbGVyYXRlIGZyb20gemVybyB2ZWxvY2l0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAgICovXHJcbiAgICBlYXNlSW5RdWludCh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogRGVjZWxlcmF0ZSB0byB6ZXJvIHZlbG9jaXR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICAgKi9cclxuICAgIGVhc2VPdXRRdWludCh0KSB7XHJcbiAgICAgICAgcmV0dXJuIDEgKyAtLXQgKiB0ICogdCAqIHQgKiB0O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQWNjZWxlcmF0ZSB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgICAqL1xyXG4gICAgZWFzZUluT3V0UXVpbnQodCkge1xyXG4gICAgICAgIHJldHVybiB0IDwgMC41ID8gMTYgKiB0ICogdCAqIHQgKiB0ICogdCA6IDEgKyAxNiAqIC0tdCAqIHQgKiB0ICogdCAqIHQ7XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogRXhwZXJpbWVudGFseSBjb21wdXRlIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyIGZvciB0aGlzIGJyb3dzZXIuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSB3aWR0aCBpbiBwaXhlbHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTY3JvbGxCYXJXaWR0aCgpIHtcclxuICAgIGNvbnN0IGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XHJcbiAgICBpbm5lci5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG4gICAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gXCIyMDBweFwiO1xyXG4gICAgY29uc3Qgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgb3V0ZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgICBvdXRlci5zdHlsZS50b3AgPSBcIjBweFwiO1xyXG4gICAgb3V0ZXIuc3R5bGUubGVmdCA9IFwiMHB4XCI7XHJcbiAgICBvdXRlci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcclxuICAgIG91dGVyLnN0eWxlLndpZHRoID0gXCIyMDBweFwiO1xyXG4gICAgb3V0ZXIuc3R5bGUuaGVpZ2h0ID0gXCIxNTBweFwiO1xyXG4gICAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgb3V0ZXIuYXBwZW5kQ2hpbGQoaW5uZXIpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlcik7XHJcbiAgICBjb25zdCB3MSA9IGlubmVyLm9mZnNldFdpZHRoO1xyXG4gICAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSBcInNjcm9sbFwiO1xyXG4gICAgbGV0IHcyID0gaW5uZXIub2Zmc2V0V2lkdGg7XHJcbiAgICBpZiAodzEgPT0gdzIpIHtcclxuICAgICAgICB3MiA9IG91dGVyLmNsaWVudFdpZHRoO1xyXG4gICAgfVxyXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XHJcbiAgICByZXR1cm4gdzEgLSB3MjtcclxufVxyXG4vLyBAVE9ETzogVGhpcyBkb2Vzbid0IHdvcmsgcHJvcGVybHkuXHJcbi8vIEl0IHdvcmtzIG9ubHkgZm9yIHNpbmdsZSBwcm9wZXJ0eSBvYmplY3RzLFxyXG4vLyBvdGhlcndpc2UgaXQgY29tYmluZXMgYWxsIG9mIHRoZSB0eXBlcyBpbiBhIHVuaW9uLlxyXG4vLyBleHBvcnQgZnVuY3Rpb24gdG9wTW9zdDxLMSBleHRlbmRzIHN0cmluZywgVjE+IChcclxuLy8gICBwaWxlOiBSZWNvcmQ8SzEsIHVuZGVmaW5lZCB8IFYxPltdLFxyXG4vLyAgIGFjY2Vzc29yczogSzEgfCBbSzFdXHJcbi8vICk6IHVuZGVmaW5lZCB8IFYxXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiB0b3BNb3N0PEsxIGV4dGVuZHMgc3RyaW5nLCBLMiBleHRlbmRzIHN0cmluZywgVjEsIFYyPiAoXHJcbi8vICAgcGlsZTogUmVjb3JkPEsxLCB1bmRlZmluZWQgfCBWMSB8IFJlY29yZDxLMiwgdW5kZWZpbmVkIHwgVjI+PltdLFxyXG4vLyAgIGFjY2Vzc29yczogW0sxLCBLMl1cclxuLy8gKTogdW5kZWZpbmVkIHwgVjEgfCBWMlxyXG4vLyBleHBvcnQgZnVuY3Rpb24gdG9wTW9zdDxLMSBleHRlbmRzIHN0cmluZywgSzIgZXh0ZW5kcyBzdHJpbmcsIEszIGV4dGVuZHMgc3RyaW5nLCBWMSwgVjIsIFYzPiAoXHJcbi8vICAgcGlsZTogUmVjb3JkPEsxLCB1bmRlZmluZWQgfCBWMSB8IFJlY29yZDxLMiwgdW5kZWZpbmVkIHwgVjIgfCBSZWNvcmQ8SzMsIHVuZGVmaW5lZCB8IFYzPj4+W10sXHJcbi8vICAgYWNjZXNzb3JzOiBbSzEsIEsyLCBLM11cclxuLy8gKTogdW5kZWZpbmVkIHwgVjEgfCBWMiB8IFYzXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHRvcCBtb3N0IHByb3BlcnR5IHZhbHVlIGZyb20gYSBwaWxlIG9mIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBwaWxlIC0gQXJyYXkgb2Ygb2JqZWN0cywgbm8gcmVxdWlyZWQgZm9ybWF0LlxyXG4gKiBAcGFyYW0gYWNjZXNzb3JzIC0gQXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAqIEZvciBleGFtcGxlIGBvYmplY3RbJ2ZvbyddWydiYXInXWAg4oaSIGBbJ2ZvbycsICdiYXInXWAuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB3aXRoIGdpdmVuIGFjY2Vzc29ycyBwYXRoIGZyb20gdGhlIGZpcnN0IHBpbGUgaXRlbSB3aGVyZSBpdCdzIG5vdCB1bmRlZmluZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b3BNb3N0KHBpbGUsIGFjY2Vzc29ycykge1xyXG4gICAgbGV0IGNhbmRpZGF0ZTtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShhY2Nlc3NvcnMpKSB7XHJcbiAgICAgICAgYWNjZXNzb3JzID0gW2FjY2Vzc29yc107XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBwaWxlKSB7XHJcbiAgICAgICAgaWYgKG1lbWJlcikge1xyXG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBtZW1iZXJbYWNjZXNzb3JzWzBdXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhY2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVbYWNjZXNzb3JzW2ldXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FuZGlkYXRlO1xyXG59XG5cbmNvbnN0IGh0bWxDb2xvcnMgPSB7XG4gIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgbmF2eTogXCIjMDAwMDgwXCIsXG4gIGRhcmtibHVlOiBcIiMwMDAwOEJcIixcbiAgbWVkaXVtYmx1ZTogXCIjMDAwMENEXCIsXG4gIGJsdWU6IFwiIzAwMDBGRlwiLFxuICBkYXJrZ3JlZW46IFwiIzAwNjQwMFwiLFxuICBncmVlbjogXCIjMDA4MDAwXCIsXG4gIHRlYWw6IFwiIzAwODA4MFwiLFxuICBkYXJrY3lhbjogXCIjMDA4QjhCXCIsXG4gIGRlZXBza3libHVlOiBcIiMwMEJGRkZcIixcbiAgZGFya3R1cnF1b2lzZTogXCIjMDBDRUQxXCIsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBcIiMwMEZBOUFcIixcbiAgbGltZTogXCIjMDBGRjAwXCIsXG4gIHNwcmluZ2dyZWVuOiBcIiMwMEZGN0ZcIixcbiAgYXF1YTogXCIjMDBGRkZGXCIsXG4gIGN5YW46IFwiIzAwRkZGRlwiLFxuICBtaWRuaWdodGJsdWU6IFwiIzE5MTk3MFwiLFxuICBkb2RnZXJibHVlOiBcIiMxRTkwRkZcIixcbiAgbGlnaHRzZWFncmVlbjogXCIjMjBCMkFBXCIsXG4gIGZvcmVzdGdyZWVuOiBcIiMyMjhCMjJcIixcbiAgc2VhZ3JlZW46IFwiIzJFOEI1N1wiLFxuICBkYXJrc2xhdGVncmF5OiBcIiMyRjRGNEZcIixcbiAgbGltZWdyZWVuOiBcIiMzMkNEMzJcIixcbiAgbWVkaXVtc2VhZ3JlZW46IFwiIzNDQjM3MVwiLFxuICB0dXJxdW9pc2U6IFwiIzQwRTBEMFwiLFxuICByb3lhbGJsdWU6IFwiIzQxNjlFMVwiLFxuICBzdGVlbGJsdWU6IFwiIzQ2ODJCNFwiLFxuICBkYXJrc2xhdGVibHVlOiBcIiM0ODNEOEJcIixcbiAgbWVkaXVtdHVycXVvaXNlOiBcIiM0OEQxQ0NcIixcbiAgaW5kaWdvOiBcIiM0QjAwODJcIixcbiAgZGFya29saXZlZ3JlZW46IFwiIzU1NkIyRlwiLFxuICBjYWRldGJsdWU6IFwiIzVGOUVBMFwiLFxuICBjb3JuZmxvd2VyYmx1ZTogXCIjNjQ5NUVEXCIsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFwiIzY2Q0RBQVwiLFxuICBkaW1ncmF5OiBcIiM2OTY5NjlcIixcbiAgc2xhdGVibHVlOiBcIiM2QTVBQ0RcIixcbiAgb2xpdmVkcmFiOiBcIiM2QjhFMjNcIixcbiAgc2xhdGVncmF5OiBcIiM3MDgwOTBcIixcbiAgbGlnaHRzbGF0ZWdyYXk6IFwiIzc3ODg5OVwiLFxuICBtZWRpdW1zbGF0ZWJsdWU6IFwiIzdCNjhFRVwiLFxuICBsYXduZ3JlZW46IFwiIzdDRkMwMFwiLFxuICBjaGFydHJldXNlOiBcIiM3RkZGMDBcIixcbiAgYXF1YW1hcmluZTogXCIjN0ZGRkQ0XCIsXG4gIG1hcm9vbjogXCIjODAwMDAwXCIsXG4gIHB1cnBsZTogXCIjODAwMDgwXCIsXG4gIG9saXZlOiBcIiM4MDgwMDBcIixcbiAgZ3JheTogXCIjODA4MDgwXCIsXG4gIHNreWJsdWU6IFwiIzg3Q0VFQlwiLFxuICBsaWdodHNreWJsdWU6IFwiIzg3Q0VGQVwiLFxuICBibHVldmlvbGV0OiBcIiM4QTJCRTJcIixcbiAgZGFya3JlZDogXCIjOEIwMDAwXCIsXG4gIGRhcmttYWdlbnRhOiBcIiM4QjAwOEJcIixcbiAgc2FkZGxlYnJvd246IFwiIzhCNDUxM1wiLFxuICBkYXJrc2VhZ3JlZW46IFwiIzhGQkM4RlwiLFxuICBsaWdodGdyZWVuOiBcIiM5MEVFOTBcIixcbiAgbWVkaXVtcHVycGxlOiBcIiM5MzcwRDhcIixcbiAgZGFya3Zpb2xldDogXCIjOTQwMEQzXCIsXG4gIHBhbGVncmVlbjogXCIjOThGQjk4XCIsXG4gIGRhcmtvcmNoaWQ6IFwiIzk5MzJDQ1wiLFxuICB5ZWxsb3dncmVlbjogXCIjOUFDRDMyXCIsXG4gIHNpZW5uYTogXCIjQTA1MjJEXCIsXG4gIGJyb3duOiBcIiNBNTJBMkFcIixcbiAgZGFya2dyYXk6IFwiI0E5QTlBOVwiLFxuICBsaWdodGJsdWU6IFwiI0FERDhFNlwiLFxuICBncmVlbnllbGxvdzogXCIjQURGRjJGXCIsXG4gIHBhbGV0dXJxdW9pc2U6IFwiI0FGRUVFRVwiLFxuICBsaWdodHN0ZWVsYmx1ZTogXCIjQjBDNERFXCIsXG4gIHBvd2RlcmJsdWU6IFwiI0IwRTBFNlwiLFxuICBmaXJlYnJpY2s6IFwiI0IyMjIyMlwiLFxuICBkYXJrZ29sZGVucm9kOiBcIiNCODg2MEJcIixcbiAgbWVkaXVtb3JjaGlkOiBcIiNCQTU1RDNcIixcbiAgcm9zeWJyb3duOiBcIiNCQzhGOEZcIixcbiAgZGFya2toYWtpOiBcIiNCREI3NkJcIixcbiAgc2lsdmVyOiBcIiNDMEMwQzBcIixcbiAgbWVkaXVtdmlvbGV0cmVkOiBcIiNDNzE1ODVcIixcbiAgaW5kaWFucmVkOiBcIiNDRDVDNUNcIixcbiAgcGVydTogXCIjQ0Q4NTNGXCIsXG4gIGNob2NvbGF0ZTogXCIjRDI2OTFFXCIsXG4gIHRhbjogXCIjRDJCNDhDXCIsXG4gIGxpZ2h0Z3JleTogXCIjRDNEM0QzXCIsXG4gIHBhbGV2aW9sZXRyZWQ6IFwiI0Q4NzA5M1wiLFxuICB0aGlzdGxlOiBcIiNEOEJGRDhcIixcbiAgb3JjaGlkOiBcIiNEQTcwRDZcIixcbiAgZ29sZGVucm9kOiBcIiNEQUE1MjBcIixcbiAgY3JpbXNvbjogXCIjREMxNDNDXCIsXG4gIGdhaW5zYm9ybzogXCIjRENEQ0RDXCIsXG4gIHBsdW06IFwiI0REQTBERFwiLFxuICBidXJseXdvb2Q6IFwiI0RFQjg4N1wiLFxuICBsaWdodGN5YW46IFwiI0UwRkZGRlwiLFxuICBsYXZlbmRlcjogXCIjRTZFNkZBXCIsXG4gIGRhcmtzYWxtb246IFwiI0U5OTY3QVwiLFxuICB2aW9sZXQ6IFwiI0VFODJFRVwiLFxuICBwYWxlZ29sZGVucm9kOiBcIiNFRUU4QUFcIixcbiAgbGlnaHRjb3JhbDogXCIjRjA4MDgwXCIsXG4gIGtoYWtpOiBcIiNGMEU2OENcIixcbiAgYWxpY2VibHVlOiBcIiNGMEY4RkZcIixcbiAgaG9uZXlkZXc6IFwiI0YwRkZGMFwiLFxuICBhenVyZTogXCIjRjBGRkZGXCIsXG4gIHNhbmR5YnJvd246IFwiI0Y0QTQ2MFwiLFxuICB3aGVhdDogXCIjRjVERUIzXCIsXG4gIGJlaWdlOiBcIiNGNUY1RENcIixcbiAgd2hpdGVzbW9rZTogXCIjRjVGNUY1XCIsXG4gIG1pbnRjcmVhbTogXCIjRjVGRkZBXCIsXG4gIGdob3N0d2hpdGU6IFwiI0Y4RjhGRlwiLFxuICBzYWxtb246IFwiI0ZBODA3MlwiLFxuICBhbnRpcXVld2hpdGU6IFwiI0ZBRUJEN1wiLFxuICBsaW5lbjogXCIjRkFGMEU2XCIsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcIiNGQUZBRDJcIixcbiAgb2xkbGFjZTogXCIjRkRGNUU2XCIsXG4gIHJlZDogXCIjRkYwMDAwXCIsXG4gIGZ1Y2hzaWE6IFwiI0ZGMDBGRlwiLFxuICBtYWdlbnRhOiBcIiNGRjAwRkZcIixcbiAgZGVlcHBpbms6IFwiI0ZGMTQ5M1wiLFxuICBvcmFuZ2VyZWQ6IFwiI0ZGNDUwMFwiLFxuICB0b21hdG86IFwiI0ZGNjM0N1wiLFxuICBob3RwaW5rOiBcIiNGRjY5QjRcIixcbiAgY29yYWw6IFwiI0ZGN0Y1MFwiLFxuICBkYXJrb3JhbmdlOiBcIiNGRjhDMDBcIixcbiAgbGlnaHRzYWxtb246IFwiI0ZGQTA3QVwiLFxuICBvcmFuZ2U6IFwiI0ZGQTUwMFwiLFxuICBsaWdodHBpbms6IFwiI0ZGQjZDMVwiLFxuICBwaW5rOiBcIiNGRkMwQ0JcIixcbiAgZ29sZDogXCIjRkZENzAwXCIsXG4gIHBlYWNocHVmZjogXCIjRkZEQUI5XCIsXG4gIG5hdmFqb3doaXRlOiBcIiNGRkRFQURcIixcbiAgbW9jY2FzaW46IFwiI0ZGRTRCNVwiLFxuICBiaXNxdWU6IFwiI0ZGRTRDNFwiLFxuICBtaXN0eXJvc2U6IFwiI0ZGRTRFMVwiLFxuICBibGFuY2hlZGFsbW9uZDogXCIjRkZFQkNEXCIsXG4gIHBhcGF5YXdoaXA6IFwiI0ZGRUZENVwiLFxuICBsYXZlbmRlcmJsdXNoOiBcIiNGRkYwRjVcIixcbiAgc2Vhc2hlbGw6IFwiI0ZGRjVFRVwiLFxuICBjb3Juc2lsazogXCIjRkZGOERDXCIsXG4gIGxlbW9uY2hpZmZvbjogXCIjRkZGQUNEXCIsXG4gIGZsb3JhbHdoaXRlOiBcIiNGRkZBRjBcIixcbiAgc25vdzogXCIjRkZGQUZBXCIsXG4gIHllbGxvdzogXCIjRkZGRjAwXCIsXG4gIGxpZ2h0eWVsbG93OiBcIiNGRkZGRTBcIixcbiAgaXZvcnk6IFwiI0ZGRkZGMFwiLFxuICB3aGl0ZTogXCIjRkZGRkZGXCIsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz0xXVxuICovXG5jbGFzcyBDb2xvclBpY2tlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BpeGVsUmF0aW89MV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBpeGVsUmF0aW8gPSAxKSB7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICB0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMgPSB7IHg6IDI4OSAvIDIsIHk6IDI4OSAvIDIgfTtcbiAgICB0aGlzLnIgPSAyODkgKiAwLjQ5O1xuICAgIHRoaXMuY29sb3IgPSB7IHI6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDEuMCB9O1xuICAgIHRoaXMuaHVlQ2lyY2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5pdGlhbENvbG9yID0geyByOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAxLjAgfTtcbiAgICB0aGlzLnByZXZpb3VzQ29sb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG5cbiAgICAvLyBib3VuZCBieVxuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSAoKSA9PiB7fTtcbiAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSAoKSA9PiB7fTtcblxuICAgIC8vIGNyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogdGhpcyBpbnNlcnRzIHRoZSBjb2xvclBpY2tlciBpbnRvIGEgZGl2IGZyb20gdGhlIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICAgKi9cbiAgaW5zZXJ0VG8oY29udGFpbmVyKSB7XG4gICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuaGFtbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgICB0aGlzLl9iaW5kSGFtbWVyKCk7XG5cbiAgICB0aGlzLl9zZXRTaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIG9uIGFwcGx5IGFuZCBzYXZlLiBCaW5kIGl0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2V0VXBkYXRlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgdXBkYXRlIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgb24gYXBwbHkgYW5kIHNhdmUuIEJpbmQgaXQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzZXRDbG9zZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgY2xvc2luZyBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaXNDb2xvclN0cmluZyhjb2xvcikge1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBodG1sQ29sb3JzW2NvbG9yXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb2xvciBvZiB0aGUgY29sb3JQaWNrZXJcbiAgICogU3VwcG9ydGVkIGZvcm1hdHM6XG4gICAqICdyZWQnICAgICAgICAgICAgICAgICAgIC0tPiBIVE1MIGNvbG9yIHN0cmluZ1xuICAgKiAnI2ZmZmZmZicgICAgICAgICAgICAgICAtLT4gaGV4IHN0cmluZ1xuICAgKiAncmdiKDI1NSwyNTUsMjU1KScgICAgICAtLT4gcmdiIHN0cmluZ1xuICAgKiAncmdiYSgyNTUsMjU1LDI1NSwxLjApJyAtLT4gcmdiYSBzdHJpbmdcbiAgICoge3I6MjU1LGc6MjU1LGI6MjU1fSAgICAgLS0+IHJnYiBvYmplY3RcbiAgICoge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfSAtLT4gcmdiYSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBvYmplY3R9IGNvbG9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldEluaXRpYWw9dHJ1ZV1cbiAgICovXG4gIHNldENvbG9yKGNvbG9yLCBzZXRJbml0aWFsID0gdHJ1ZSkge1xuICAgIGlmIChjb2xvciA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmdiYTtcblxuICAgIC8vIGlmIGEgaHRtbCBjb2xvciBzaG9ydGhhbmQgaXMgdXNlZCwgY29udmVydCB0byBoZXhcbiAgICBjb25zdCBodG1sQ29sb3IgPSB0aGlzLl9pc0NvbG9yU3RyaW5nKGNvbG9yKTtcbiAgICBpZiAoaHRtbENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbG9yID0gaHRtbENvbG9yO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvcm1hdFxuICAgIGlmIChpc1N0cmluZyhjb2xvcikgPT09IHRydWUpIHtcbiAgICAgIGlmIChpc1ZhbGlkUkdCKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCByZ2JhQXJyYXkgPSBjb2xvclxuICAgICAgICAgIC5zdWJzdHIoNClcbiAgICAgICAgICAuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDUpXG4gICAgICAgICAgLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgcmdiYSA9IHsgcjogcmdiYUFycmF5WzBdLCBnOiByZ2JhQXJyYXlbMV0sIGI6IHJnYmFBcnJheVsyXSwgYTogMS4wIH07XG4gICAgICB9IGVsc2UgaWYgKGlzVmFsaWRSR0JBKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCByZ2JhQXJyYXkgPSBjb2xvclxuICAgICAgICAgIC5zdWJzdHIoNSlcbiAgICAgICAgICAuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDYpXG4gICAgICAgICAgLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgcmdiYSA9IHtcbiAgICAgICAgICByOiByZ2JhQXJyYXlbMF0sXG4gICAgICAgICAgZzogcmdiYUFycmF5WzFdLFxuICAgICAgICAgIGI6IHJnYmFBcnJheVsyXSxcbiAgICAgICAgICBhOiByZ2JhQXJyYXlbM10sXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzVmFsaWRIZXgoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJnYk9iaiA9IGhleFRvUkdCKGNvbG9yKTtcbiAgICAgICAgcmdiYSA9IHsgcjogcmdiT2JqLnIsIGc6IHJnYk9iai5nLCBiOiByZ2JPYmouYiwgYTogMS4wIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY29sb3IuciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgY29sb3IuZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgY29sb3IuYiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGFscGhhID0gY29sb3IuYSAhPT0gdW5kZWZpbmVkID8gY29sb3IuYSA6IFwiMS4wXCI7XG4gICAgICAgICAgcmdiYSA9IHsgcjogY29sb3IuciwgZzogY29sb3IuZywgYjogY29sb3IuYiwgYTogYWxwaGEgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCBjb2xvclxuICAgIGlmIChyZ2JhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJVbmtub3duIGNvbG9yIHBhc3NlZCB0byB0aGUgY29sb3JQaWNrZXIuIFN1cHBvcnRlZCBhcmUgc3RyaW5nczogcmdiLCBoZXgsIHJnYmEuIE9iamVjdDogcmdiICh7cjpyLGc6ZyxiOmIsW2E6YV19KS4gU3VwcGxpZWQ6IFwiICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShjb2xvcilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldENvbG9yKHJnYmEsIHNldEluaXRpYWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB0aGlzIHNob3dzIHRoZSBjb2xvciBwaWNrZXIuXG4gICAqIFRoZSBodWUgY2lyY2xlIGlzIGNvbnN0cnVjdGVkIG9uY2UgYW5kIHN0b3JlZC5cbiAgICovXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNsb3NlQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGxpZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgdGhpcy5fZ2VuZXJhdGVIdWVDaXJjbGUoKTtcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQUklWQVRFIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIHBpY2tlci4gSXMgY2FsbGVkIGJ5IHRoZSBjYW5jZWwgYnV0dG9uLlxuICAgKiBPcHRpb25hbCBib29sZWFuIHRvIHN0b3JlIHRoZSBwcmV2aW91cyBjb2xvciBmb3IgZWFzeSBhY2Nlc3MgbGF0ZXIgb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0b3JlUHJldmlvdXM9dHJ1ZV1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oaWRlKHN0b3JlUHJldmlvdXMgPSB0cnVlKSB7XG4gICAgLy8gc3RvcmUgdGhlIHByZXZpb3VzIGNvbG9yIGZvciBuZXh0IHRpbWU7XG4gICAgaWYgKHN0b3JlUHJldmlvdXMgPT09IHRydWUpIHtcbiAgICAgIHRoaXMucHJldmlvdXNDb2xvciA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29sb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFwcGxpZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5pbml0aWFsQ29sb3IpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhbWUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gICAgLy8gY2FsbCB0aGUgY2xvc2luZyBjYWxsYmFjaywgcmVzdG9yaW5nIHRoZSBvbmNsaWNrIG1ldGhvZC5cbiAgICAvLyB0aGlzIGlzIGluIGEgc2V0VGltZW91dCBiZWNhdXNlIGl0IHdpbGwgdHJpZ2dlciB0aGUgc2hvdyBhZ2FpbiBiZWZvcmUgdGhlIGNsaWNrIGlzIGRvbmUuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBib3VuZCB0byB0aGUgc2F2ZSBidXR0b24uIFNhdmVzIGFuZCBoaWRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXZlKCkge1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG4gICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgdGhpcy5faGlkZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5kIHRvIGFwcGx5IGJ1dHRvbi4gU2F2ZXMgYnV0IGRvZXMgbm90IGNsb3NlLiBJcyB1bmRvbmUgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHkoKSB7XG4gICAgdGhpcy5hcHBsaWVkID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpO1xuICAgIHRoaXMuX3VwZGF0ZVBpY2tlcih0aGlzLmNvbG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBsb2FkIHRoZSBjb2xvciBmcm9tIHRoZSBwcmV2aW91cyBzZXNzaW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2xvYWRMYXN0KCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRDb2xvcih0aGlzLnByZXZpb3VzQ29sb3IsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxlcnQoXCJUaGVyZSBpcyBubyBsYXN0IGNvbG9yIHRvIGxvYWQuLi5cIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNldCB0aGUgY29sb3IsIHBsYWNlIHRoZSBwaWNrZXJcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHJnYmFcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2V0SW5pdGlhbD10cnVlXVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldENvbG9yKHJnYmEsIHNldEluaXRpYWwgPSB0cnVlKSB7XG4gICAgLy8gc3RvcmUgdGhlIGluaXRpYWwgY29sb3JcbiAgICBpZiAoc2V0SW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3IgPSBPYmplY3QuYXNzaWduKHt9LCByZ2JhKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbG9yID0gcmdiYTtcbiAgICBjb25zdCBoc3YgPSBSR0JUb0hTVihyZ2JhLnIsIHJnYmEuZywgcmdiYS5iKTtcblxuICAgIGNvbnN0IGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJO1xuICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMuciAqIGhzdi5zO1xuICAgIGNvbnN0IHggPVxuICAgICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgIGNvbnN0IHkgPVxuICAgICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuXG4gICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPVxuICAgICAgeCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArIFwicHhcIjtcbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID1cbiAgICAgIHkgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgdGhpcy5fdXBkYXRlUGlja2VyKHJnYmEpO1xuICB9XG5cbiAgLyoqXG4gICAqIGJvdW5kIHRvIG9wYWNpdHkgY29udHJvbFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5jb2xvci5hID0gdmFsdWUgLyAxMDA7XG4gICAgdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIGJvdW5kIHRvIGJyaWdodG5lc3MgY29udHJvbFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRCcmlnaHRuZXNzKHZhbHVlKSB7XG4gICAgY29uc3QgaHN2ID0gUkdCVG9IU1YodGhpcy5jb2xvci5yLCB0aGlzLmNvbG9yLmcsIHRoaXMuY29sb3IuYik7XG4gICAgaHN2LnYgPSB2YWx1ZSAvIDEwMDtcbiAgICBjb25zdCByZ2JhID0gSFNWVG9SR0IoaHN2LmgsIGhzdi5zLCBoc3Yudik7XG4gICAgcmdiYVtcImFcIl0gPSB0aGlzLmNvbG9yLmE7XG4gICAgdGhpcy5jb2xvciA9IHJnYmE7XG4gICAgdGhpcy5fdXBkYXRlUGlja2VyKCk7XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlIHRoZSBjb2xvciBwaWNrZXIuIEEgYmxhY2sgY2lyY2xlIG92ZXJsYXlzIHRoZSBodWUgY2lyY2xlIHRvIG1pbWljIHRoZSBicmlnaHRuZXNzIGRlY3JlYXNpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZ2JhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlUGlja2VyKHJnYmEgPSB0aGlzLmNvbG9yKSB7XG4gICAgY29uc3QgaHN2ID0gUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKHRoaXMucGl4ZWxSYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5waXhlbFJhdGlvID1cbiAgICAgICAgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC9cbiAgICAgICAgKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAxKTtcbiAgICB9XG4gICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAvLyBjbGVhciB0aGUgY2FudmFzXG4gICAgY29uc3QgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICBjdHgucHV0SW1hZ2VEYXRhKHRoaXMuaHVlQ2lyY2xlLCAwLCAwKTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsMCwwLFwiICsgKDEgLSBoc3YudikgKyBcIilcIjtcbiAgICBjdHguY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCwgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55LCB0aGlzLnIpO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS52YWx1ZSA9IDEwMCAqIGhzdi52O1xuICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gMTAwICogcmdiYS5hO1xuXG4gICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID1cbiAgICAgIFwicmdiYShcIiArXG4gICAgICB0aGlzLmluaXRpYWxDb2xvci5yICtcbiAgICAgIFwiLFwiICtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yLmcgK1xuICAgICAgXCIsXCIgK1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3IuYiArXG4gICAgICBcIixcIiArXG4gICAgICB0aGlzLmluaXRpYWxDb2xvci5hICtcbiAgICAgIFwiKVwiO1xuICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID1cbiAgICAgIFwicmdiYShcIiArXG4gICAgICB0aGlzLmNvbG9yLnIgK1xuICAgICAgXCIsXCIgK1xuICAgICAgdGhpcy5jb2xvci5nICtcbiAgICAgIFwiLFwiICtcbiAgICAgIHRoaXMuY29sb3IuYiArXG4gICAgICBcIixcIiArXG4gICAgICB0aGlzLmNvbG9yLmEgK1xuICAgICAgXCIpXCI7XG4gIH1cblxuICAvKipcbiAgICogdXNlZCBieSBjcmVhdGUgdG8gc2V0IHRoZSBzaXplIG9mIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U2l6ZSgpIHtcbiAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcblxuICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMud2lkdGggPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5oZWlnaHQgPSAyODkgKiB0aGlzLnBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlIGFsbCBkb20gZWxlbWVudHNcbiAgICogVE9ETzogY2xlYW51cCwgbG90cyBvZiBzaW1pbGFyIGRvbSBlbGVtZW50c1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZSgpIHtcbiAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9IFwidmlzLWNvbG9yLXBpY2tlclwiO1xuXG4gICAgdGhpcy5jb2xvclBpY2tlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xhc3NOYW1lID0gXCJ2aXMtc2VsZWN0b3JcIjtcbiAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvcik7XG5cbiAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuXG4gICAgaWYgKCF0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQpIHtcbiAgICAgIGNvbnN0IG5vQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICAgIG5vQ2FudmFzLnN0eWxlLmNvbG9yID0gXCJyZWRcIjtcbiAgICAgIG5vQ2FudmFzLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgIG5vQ2FudmFzLnN0eWxlLnBhZGRpbmcgPSBcIjEwcHhcIjtcbiAgICAgIG5vQ2FudmFzLmlubmVyVGV4dCA9IFwiRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzXCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICB0aGlzLnBpeGVsUmF0aW8gPVxuICAgICAgICAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgL1xuICAgICAgICAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgIDEpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhc1xuICAgICAgICAuZ2V0Q29udGV4dChcIjJkXCIpXG4gICAgICAgIC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgIH1cblxuICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29sb3JcIjtcblxuICAgIHRoaXMub3BhY2l0eURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5vcGFjaXR5RGl2LmNsYXNzTmFtZSA9IFwidmlzLW9wYWNpdHlcIjtcblxuICAgIHRoaXMuYnJpZ2h0bmVzc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5icmlnaHRuZXNzRGl2LmNsYXNzTmFtZSA9IFwidmlzLWJyaWdodG5lc3NcIjtcblxuICAgIHRoaXMuYXJyb3dEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuYXJyb3dEaXYuY2xhc3NOYW1lID0gXCJ2aXMtYXJyb3dcIjtcblxuICAgIHRoaXMub3BhY2l0eVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS50eXBlID0gXCJyYW5nZVwiOyAvLyBOb3Qgc3VwcG9ydGVkIG9uIElFOVxuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWluID0gXCIwXCI7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5tYXggPSBcIjEwMFwiO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gVE9ETzogQWRkIHNvbWUgZXJyb3IgaGFuZGxpbmcuXG4gICAgfVxuICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gXCIxMDBcIjtcbiAgICB0aGlzLm9wYWNpdHlSYW5nZS5jbGFzc05hbWUgPSBcInZpcy1yYW5nZVwiO1xuXG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnR5cGUgPSBcInJhbmdlXCI7IC8vIE5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5taW4gPSBcIjBcIjtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1heCA9IFwiMTAwXCI7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBUT0RPOiBBZGQgc29tZSBlcnJvciBoYW5kbGluZy5cbiAgICB9XG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSBcIjEwMFwiO1xuICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLmNsYXNzTmFtZSA9IFwidmlzLXJhbmdlXCI7XG5cbiAgICB0aGlzLm9wYWNpdHlEaXYuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5UmFuZ2UpO1xuICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5hcHBlbmRDaGlsZCh0aGlzLmJyaWdodG5lc3NSYW5nZSk7XG5cbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgfTtcblxuICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtYnJpZ2h0bmVzc1wiO1xuICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmlubmVyVGV4dCA9IFwiYnJpZ2h0bmVzczpcIjtcblxuICAgIHRoaXMub3BhY2l0eUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm9wYWNpdHlMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtb3BhY2l0eVwiO1xuICAgIHRoaXMub3BhY2l0eUxhYmVsLmlubmVyVGV4dCA9IFwib3BhY2l0eTpcIjtcblxuICAgIHRoaXMubmV3Q29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMubmV3Q29sb3JEaXYuY2xhc3NOYW1lID0gXCJ2aXMtbmV3LWNvbG9yXCI7XG4gICAgdGhpcy5uZXdDb2xvckRpdi5pbm5lclRleHQgPSBcIm5ld1wiO1xuXG4gICAgdGhpcy5pbml0aWFsQ29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LmNsYXNzTmFtZSA9IFwidmlzLWluaXRpYWwtY29sb3JcIjtcbiAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5pbm5lclRleHQgPSBcImluaXRpYWxcIjtcblxuICAgIHRoaXMuY2FuY2VsQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWNhbmNlbFwiO1xuICAgIHRoaXMuY2FuY2VsQnV0dG9uLmlubmVyVGV4dCA9IFwiY2FuY2VsXCI7XG4gICAgdGhpcy5jYW5jZWxCdXR0b24ub25jbGljayA9IHRoaXMuX2hpZGUuYmluZCh0aGlzLCBmYWxzZSk7XG5cbiAgICB0aGlzLmFwcGx5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmFwcGx5QnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtYXBwbHlcIjtcbiAgICB0aGlzLmFwcGx5QnV0dG9uLmlubmVyVGV4dCA9IFwiYXBwbHlcIjtcbiAgICB0aGlzLmFwcGx5QnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9hcHBseS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5zYXZlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLnNhdmVCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1zYXZlXCI7XG4gICAgdGhpcy5zYXZlQnV0dG9uLmlubmVyVGV4dCA9IFwic2F2ZVwiO1xuICAgIHRoaXMuc2F2ZUJ1dHRvbi5vbmNsaWNrID0gdGhpcy5fc2F2ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5sb2FkQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmxvYWRCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1sb2FkXCI7XG4gICAgdGhpcy5sb2FkQnV0dG9uLmlubmVyVGV4dCA9IFwibG9hZCBsYXN0XCI7XG4gICAgdGhpcy5sb2FkQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9sb2FkTGFzdC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyRGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXJyb3dEaXYpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzTGFiZWwpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzRGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eUxhYmVsKTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eURpdik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5ld0NvbG9yRGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuaW5pdGlhbENvbG9yRGl2KTtcblxuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jYW5jZWxCdXR0b24pO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcHBseUJ1dHRvbik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnNhdmVCdXR0b24pO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5sb2FkQnV0dG9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBiaW5kIGhhbW1lciB0byB0aGUgY29sb3IgcGlja2VyXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYmluZEhhbW1lcigpIHtcbiAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICB0aGlzLnBpbmNoID0ge307XG4gICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuICAgIHRoaXMuaGFtbWVyLmdldChcInBpbmNoXCIpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcblxuICAgIHRoaXMuaGFtbWVyLm9uKFwiaGFtbWVyLmlucHV0XCIsIChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmlzRmlyc3QpIHtcbiAgICAgICAgdGhpcy5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmhhbW1lci5vbihcInRhcFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgfSk7XG4gICAgdGhpcy5oYW1tZXIub24oXCJwYW5zdGFydFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgfSk7XG4gICAgdGhpcy5oYW1tZXIub24oXCJwYW5tb3ZlXCIsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbW1lci5vbihcInBhbmVuZFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogZ2VuZXJhdGUgdGhlIGh1ZSBjaXJjbGUuIFRoaXMgaXMgcmVsYXRpdmVseSBoZWF2eSAoMjAwbXMpIGFuZCBpcyBkb25lIG9ubHkgb25jZSBvbiB0aGUgZmlyc3QgdGltZSBpdCBpcyBzaG93bi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZW5lcmF0ZUh1ZUNpcmNsZSgpIHtcbiAgICBpZiAodGhpcy5nZW5lcmF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID1cbiAgICAgICAgICAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgL1xuICAgICAgICAgIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgIGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgIDEpO1xuICAgICAgfVxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgIGNvbnN0IHcgPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgaCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcblxuICAgICAgLy8gZHJhdyBodWUgY2lyY2xlXG4gICAgICBsZXQgeCwgeSwgaHVlLCBzYXQ7XG4gICAgICB0aGlzLmNlbnRlckNvb3JkaW5hdGVzID0geyB4OiB3ICogMC41LCB5OiBoICogMC41IH07XG4gICAgICB0aGlzLnIgPSAwLjQ5ICogdztcbiAgICAgIGNvbnN0IGFuZ2xlQ29udmVydCA9ICgyICogTWF0aC5QSSkgLyAzNjA7XG4gICAgICBjb25zdCBoZmFjID0gMSAvIDM2MDtcbiAgICAgIGNvbnN0IHNmYWMgPSAxIC8gdGhpcy5yO1xuICAgICAgbGV0IHJnYjtcbiAgICAgIGZvciAoaHVlID0gMDsgaHVlIDwgMzYwOyBodWUrKykge1xuICAgICAgICBmb3IgKHNhdCA9IDA7IHNhdCA8IHRoaXMucjsgc2F0KyspIHtcbiAgICAgICAgICB4ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy54ICsgc2F0ICogTWF0aC5zaW4oYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICB5ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy55ICsgc2F0ICogTWF0aC5jb3MoYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICByZ2IgPSBIU1ZUb1JHQihodWUgKiBoZmFjLCBzYXQgKiBzZmFjLCAxKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2IoXCIgKyByZ2IuciArIFwiLFwiICsgcmdiLmcgKyBcIixcIiArIHJnYi5iICsgXCIpXCI7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHggLSAwLjUsIHkgLSAwLjUsIDIsIDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsMSlcIjtcbiAgICAgIGN0eC5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LCB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksIHRoaXMucik7XG4gICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgIHRoaXMuaHVlQ2lyY2xlID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKTtcbiAgICB9XG4gICAgdGhpcy5nZW5lcmF0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIG1vdmUgdGhlIHNlbGVjdG9yLiBUaGlzIGlzIGNhbGxlZCBieSBoYW1tZXIgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3ZlU2VsZWN0b3IoZXZlbnQpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5jb2xvclBpY2tlckRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBsZWZ0ID0gZXZlbnQuY2VudGVyLnggLSByZWN0LmxlZnQ7XG4gICAgY29uc3QgdG9wID0gZXZlbnQuY2VudGVyLnkgLSByZWN0LnRvcDtcblxuICAgIGNvbnN0IGNlbnRlclkgPSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudEhlaWdodDtcbiAgICBjb25zdCBjZW50ZXJYID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRXaWR0aDtcblxuICAgIGNvbnN0IHggPSBsZWZ0IC0gY2VudGVyWDtcbiAgICBjb25zdCB5ID0gdG9wIC0gY2VudGVyWTtcblxuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMih4LCB5KTtcbiAgICBjb25zdCByYWRpdXMgPSAwLjk4ICogTWF0aC5taW4oTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpLCBjZW50ZXJYKTtcblxuICAgIGNvbnN0IG5ld1RvcCA9IE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyArIGNlbnRlclk7XG4gICAgY29uc3QgbmV3TGVmdCA9IE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyArIGNlbnRlclg7XG5cbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID1cbiAgICAgIG5ld1RvcCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPVxuICAgICAgbmV3TGVmdCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArIFwicHhcIjtcblxuICAgIC8vIHNldCBjb2xvclxuICAgIGxldCBoID0gYW5nbGUgLyAoMiAqIE1hdGguUEkpO1xuICAgIGggPSBoIDwgMCA/IGggKyAxIDogaDtcbiAgICBjb25zdCBzID0gcmFkaXVzIC8gdGhpcy5yO1xuICAgIGNvbnN0IGhzdiA9IFJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgIGhzdi5oID0gaDtcbiAgICBoc3YucyA9IHM7XG4gICAgY29uc3QgcmdiYSA9IEhTVlRvUkdCKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICAgIHJnYmFbXCJhXCJdID0gdGhpcy5jb2xvci5hO1xuICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuXG4gICAgLy8gdXBkYXRlIHByZXZpZXdzXG4gICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID1cbiAgICAgIFwicmdiYShcIiArXG4gICAgICB0aGlzLmluaXRpYWxDb2xvci5yICtcbiAgICAgIFwiLFwiICtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yLmcgK1xuICAgICAgXCIsXCIgK1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3IuYiArXG4gICAgICBcIixcIiArXG4gICAgICB0aGlzLmluaXRpYWxDb2xvci5hICtcbiAgICAgIFwiKVwiO1xuICAgIHRoaXMubmV3Q29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID1cbiAgICAgIFwicmdiYShcIiArXG4gICAgICB0aGlzLmNvbG9yLnIgK1xuICAgICAgXCIsXCIgK1xuICAgICAgdGhpcy5jb2xvci5nICtcbiAgICAgIFwiLFwiICtcbiAgICAgIHRoaXMuY29sb3IuYiArXG4gICAgICBcIixcIiArXG4gICAgICB0aGlzLmNvbG9yLmEgK1xuICAgICAgXCIpXCI7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwIGdpdmVuIHRleHQgKGxhc3QgYXJndW1lbnQpIGluIEhUTUwgZWxlbWVudHMgKGFsbCBwcmVjZWRpbmcgYXJndW1lbnRzKS5cbiAqXG4gKiBAcGFyYW0gey4uLmFueX0gcmVzdCAtIExpc3Qgb2YgdGFnIG5hbWVzIGZvbGxvd2VkIGJ5IGlubmVyIHRleHQuXG4gKlxuICogQHJldHVybnMgQW4gZWxlbWVudCBvciBhIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gd3JhcEluVGFnKC4uLnJlc3QpIHtcbiAgaWYgKHJlc3QubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cy5cIik7XG4gIH0gZWxzZSBpZiAocmVzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocmVzdFswXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocmVzdFswXSk7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZCh3cmFwSW5UYWcoLi4ucmVzdC5zbGljZSgxKSkpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbi8qKlxuICogVGhlIHdheSB0aGlzIHdvcmtzIGlzIGZvciBhbGwgcHJvcGVydGllcyBvZiB0aGlzLnBvc3NpYmxlIG9wdGlvbnMsIHlvdSBjYW4gc3VwcGx5IHRoZSBwcm9wZXJ0eSBuYW1lIGluIGFueSBmb3JtIHRvIGxpc3QgdGhlIG9wdGlvbnMuXG4gKiBCb29sZWFuIG9wdGlvbnMgYXJlIHJlY29nbmlzZWQgYXMgQm9vbGVhblxuICogTnVtYmVyIG9wdGlvbnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtkZWZhdWx0IHZhbHVlLCBtaW4gdmFsdWUsIG1heCB2YWx1ZSwgc3RlcHNpemVdXG4gKiBDb2xvcnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFsnY29sb3InLCAnI2ZmZmZmZiddXG4gKiBTdHJpbmdzIHdpdGggc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCAuLl1cbiAqXG4gKiBUaGUgb3B0aW9ucyBhcmUgbWF0Y2hlZCB3aXRoIHRoZWlyIGNvdW50ZXJwYXJ0cyBpbiBlYWNoIG9mIHRoZSBtb2R1bGVzIGFuZCB0aGUgdmFsdWVzIHVzZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24gYXJlXG4gKi9cbmNsYXNzIENvbmZpZ3VyYXRvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50TW9kdWxlICAgICAgICB8IHRoZSBsb2NhdGlvbiB3aGVyZSBwYXJlbnRNb2R1bGUuc2V0T3B0aW9ucygpIGNhbiBiZSBjYWxsZWRcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRDb250YWluZXIgICAgfCB0aGUgZGVmYXVsdCBjb250YWluZXIgb2YgdGhlIG1vZHVsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlndXJlT3B0aW9ucyAgICB8IHRoZSBmdWxseSBjb25maWd1cmVkIGFuZCBwcmVkZWZpbmVkIG9wdGlvbnMgc2V0IGZvdW5kIGluIGFsbE9wdGlvbnMuanNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gICAgICAgICAgfCBjYW52YXMgcGl4ZWwgcmF0aW9cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGlkZU9wdGlvbiAgICAgICAgfCBjdXN0b20gbG9naWMgdG8gZHluYW1pY2FsbHkgaGlkZSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXJlbnRNb2R1bGUsXG4gICAgZGVmYXVsdENvbnRhaW5lcixcbiAgICBjb25maWd1cmVPcHRpb25zLFxuICAgIHBpeGVsUmF0aW8gPSAxLFxuICAgIGhpZGVPcHRpb24gPSAoKSA9PiBmYWxzZVxuICApIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudE1vZHVsZTtcbiAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG4gICAgdGhpcy5jb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyO1xuICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuaGlkZU9wdGlvbiA9IGhpZGVPcHRpb247XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5wb3B1cENvdW50ZXIgPSAwO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGZpbHRlcjogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjogdW5kZWZpbmVkLFxuICAgICAgc2hvd0J1dHRvbjogdHJ1ZSxcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuY29uZmlndXJlT3B0aW9ucyA9IGNvbmZpZ3VyZU9wdGlvbnM7XG4gICAgdGhpcy5tb2R1bGVPcHRpb25zID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICB0aGlzLnBvcHVwTGltaXQgPSA1O1xuICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG4gICAgdGhpcy5jb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlcihwaXhlbFJhdGlvKTtcbiAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogcmVmcmVzaCBhbGwgb3B0aW9ucy5cbiAgICogQmVjYXVzZSBhbGwgbW9kdWxlcyBwYXJzZSB0aGVpciBvcHRpb25zIGJ5IHRoZW1zZWx2ZXMsIHdlIGp1c3QgdXNlIHRoZWlyIG9wdGlvbnMuIFdlIGNvcHkgdGhlbSBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmVzZXQgdGhlIHBvcHVwIGhpc3RvcnkgYmVjYXVzZSB0aGUgaW5kaWNlcyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gICAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcblxuICAgICAgbGV0IGVuYWJsZWQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmpvaW4oKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zIGNhbm5vdCBiZSBudWxsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNob3dCdXR0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93QnV0dG9uID0gb3B0aW9ucy5zaG93QnV0dG9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSB0cnVlO1xuICAgICAgICBlbmFibGVkID0gb3B0aW9ucztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIHRoaXMuX2NsZWFuKCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1vZHVsZU9wdGlvbnNcbiAgICovXG4gIHNldE1vZHVsZU9wdGlvbnMobW9kdWxlT3B0aW9ucykge1xuICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IG1vZHVsZU9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgICB9XG4gICAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFsbCBET00gZWxlbWVudHNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGUoKSB7XG4gICAgdGhpcy5fY2xlYW4oKTtcbiAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG5cbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBsZXQgc2hvdyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIGluIHRoaXMuY29uZmlndXJlT3B0aW9ucykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbmZpZ3VyZU9wdGlvbnMsIG9wdGlvbikpIHtcbiAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgICAgIHNob3cgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHNob3cgPSBmaWx0ZXIob3B0aW9uLCBbXSk7XG4gICAgICAgICAgc2hvdyA9XG4gICAgICAgICAgICBzaG93IHx8XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW29wdGlvbl0sIFtvcHRpb25dLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIgPT09IHRydWUgfHwgZmlsdGVyLmluZGV4T2Yob3B0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAvLyBsaW5lYnJlYWsgYmV0d2VlbiBjYXRlZ29yaWVzXG4gICAgICAgICAgaWYgKGNvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShbXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGEgaGVhZGVyIGZvciB0aGUgY2F0ZWdvcnlcbiAgICAgICAgICB0aGlzLl9tYWtlSGVhZGVyKG9wdGlvbik7XG5cbiAgICAgICAgICAvLyBnZXQgdGhlIHN1YiBvcHRpb25zXG4gICAgICAgICAgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tvcHRpb25dLCBbb3B0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9tYWtlQnV0dG9uKCk7XG4gICAgdGhpcy5fcHVzaCgpO1xuICAgIC8vfiB0aGlzLmNvbG9yUGlja2VyLmluc2VydFRvKHRoaXMuY29udGFpbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkcmF3IGFsbCBET00gZWxlbWVudHMgb24gdGhlIHNjcmVlblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3B1c2goKSB7XG4gICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLndyYXBwZXIuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbi13cmFwcGVyXCI7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zaG93UG9wdXBJZk5lZWRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlbGV0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xlYW4oKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud3JhcHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG5cbiAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgYWN0dWFsT3B0aW9ucyBpZiBpdCBleGlzdHNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFZhbHVlKHBhdGgpIHtcbiAgICBsZXQgYmFzZSA9IHRoaXMubW9kdWxlT3B0aW9ucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChiYXNlW3BhdGhbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmFzZSA9IGJhc2VbcGF0aFtpXV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICAvKipcbiAgICogYWxsIG9wdGlvbiBlbGVtZW50cyBhcmUgd3JhcHBlZCBpbiBhbiBpdGVtXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50Pn0gZG9tRWxlbWVudHNcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlSXRlbShwYXRoLCAuLi5kb21FbGVtZW50cykge1xuICAgIGlmICh0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaXRlbS5jbGFzc05hbWUgPVxuICAgICAgICBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaXRlbSB2aXMtY29uZmlnLXNcIiArIHBhdGgubGVuZ3RoO1xuICAgICAgZG9tRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICBpdGVtLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLnB1c2goaXRlbSk7XG4gICAgICByZXR1cm4gdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIGhlYWRlciBmb3IgbWFqb3Igc3ViamVjdHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlSGVhZGVyKG5hbWUpIHtcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaGVhZGVyXCI7XG4gICAgZGl2LmlubmVyVGV4dCA9IG5hbWU7XG4gICAgdGhpcy5fbWFrZUl0ZW0oW10sIGRpdik7XG4gIH1cblxuICAvKipcbiAgICogbWFrZSBhIGxhYmVsLCBpZiBpdCBpcyBhbiBvYmplY3QgbGFiZWwsIGl0IGdldHMgZGlmZmVyZW50IHN0eWxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZWN0TGFiZWxcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VMYWJlbChuYW1lLCBwYXRoLCBvYmplY3RMYWJlbCA9IGZhbHNlKSB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuY2xhc3NOYW1lID1cbiAgICAgIFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1sYWJlbCB2aXMtY29uZmlnLXNcIiArIHBhdGgubGVuZ3RoO1xuICAgIGlmIChvYmplY3RMYWJlbCA9PT0gdHJ1ZSkge1xuICAgICAgd2hpbGUgKGRpdi5maXJzdENoaWxkKSB7XG4gICAgICAgIGRpdi5yZW1vdmVDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQod3JhcEluVGFnKFwiaVwiLCBcImJcIiwgbmFtZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXYuaW5uZXJUZXh0ID0gbmFtZSArIFwiOlwiO1xuICAgIH1cbiAgICByZXR1cm4gZGl2O1xuICB9XG5cbiAgLyoqXG4gICAqIG1ha2UgYSBkcm9wZG93biBsaXN0IGZvciBtdWx0aXBsZSBwb3NzaWJsZSBzdHJpbmcgb3B0b2luc1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgY29uc3Qgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICBzZWxlY3QuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXNlbGVjdFwiO1xuICAgIGxldCBzZWxlY3RlZFZhbHVlID0gMDtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGFyci5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZSA9IGFyci5pbmRleE9mKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgIG9wdGlvbi52YWx1ZSA9IGFycltpXTtcbiAgICAgIGlmIChpID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IFwic2VsZWN0ZWRcIjtcbiAgICAgIH1cbiAgICAgIG9wdGlvbi5pbm5lclRleHQgPSBhcnJbaV07XG4gICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgc2VsZWN0Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcbiAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgc2VsZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYWtlIGEgcmFuZ2Ugb2JqZWN0IGZvciBudW1lcmljIG9wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlUmFuZ2UoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGFyclswXTtcbiAgICBjb25zdCBtaW4gPSBhcnJbMV07XG4gICAgY29uc3QgbWF4ID0gYXJyWzJdO1xuICAgIGNvbnN0IHN0ZXAgPSBhcnJbM107XG4gICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgcmFuZ2UuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlXCI7XG4gICAgdHJ5IHtcbiAgICAgIHJhbmdlLnR5cGUgPSBcInJhbmdlXCI7IC8vIG5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICByYW5nZS5taW4gPSBtaW47XG4gICAgICByYW5nZS5tYXggPSBtYXg7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBUT0RPOiBBZGQgc29tZSBlcnJvciBoYW5kbGluZy5cbiAgICB9XG4gICAgcmFuZ2Uuc3RlcCA9IHN0ZXA7XG5cbiAgICAvLyBzZXQgdXAgdGhlIHBvcHVwIHNldHRpbmdzIGluIGNhc2UgdGhleSBhcmUgbmVlZGVkLlxuICAgIGxldCBwb3B1cFN0cmluZyA9IFwiXCI7XG4gICAgbGV0IHBvcHVwVmFsdWUgPSAwO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IDEuMjtcbiAgICAgIGlmICh2YWx1ZSA8IDAgJiYgdmFsdWUgKiBmYWN0b3IgPCBtaW4pIHtcbiAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgcG9wdXBTdHJpbmcgPSBcInJhbmdlIGluY3JlYXNlZFwiO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAvIGZhY3RvciA8IG1pbikge1xuICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgLyBmYWN0b3IpO1xuICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICBwb3B1cFN0cmluZyA9IFwicmFuZ2UgaW5jcmVhc2VkXCI7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgKiBmYWN0b3IgPiBtYXggJiYgbWF4ICE9PSAxKSB7XG4gICAgICAgIHJhbmdlLm1heCA9IE1hdGguY2VpbCh2YWx1ZSAqIGZhY3Rvcik7XG4gICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5tYXg7XG4gICAgICAgIHBvcHVwU3RyaW5nID0gXCJyYW5nZSBpbmNyZWFzZWRcIjtcbiAgICAgIH1cbiAgICAgIHJhbmdlLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1yYW5nZWlucHV0XCI7XG4gICAgaW5wdXQudmFsdWUgPSByYW5nZS52YWx1ZTtcblxuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICByYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIG1lLl91cGRhdGUoTnVtYmVyKHRoaXMudmFsdWUpLCBwYXRoKTtcbiAgICB9O1xuICAgIHJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnB1dC52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgfTtcblxuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgY29uc3QgaXRlbUluZGV4ID0gdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHJhbmdlLCBpbnB1dCk7XG5cbiAgICAvLyBpZiBhIHBvcHVwIGlzIG5lZWRlZCBBTkQgaXQgaGFzIG5vdCBiZWVuIHNob3duIGZvciB0aGlzIHZhbHVlLCBzaG93IGl0LlxuICAgIGlmIChwb3B1cFN0cmluZyAhPT0gXCJcIiAmJiB0aGlzLnBvcHVwSGlzdG9yeVtpdGVtSW5kZXhdICE9PSBwb3B1cFZhbHVlKSB7XG4gICAgICB0aGlzLnBvcHVwSGlzdG9yeVtpdGVtSW5kZXhdID0gcG9wdXBWYWx1ZTtcbiAgICAgIHRoaXMuX3NldHVwUG9wdXAocG9wdXBTdHJpbmcsIGl0ZW1JbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIG1ha2UgYSBidXR0b24gb2JqZWN0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZUJ1dHRvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dCdXR0b24gPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IGdlbmVyYXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b25cIjtcbiAgICAgIGdlbmVyYXRlQnV0dG9uLmlubmVyVGV4dCA9IFwiZ2VuZXJhdGUgb3B0aW9uc1wiO1xuICAgICAgZ2VuZXJhdGVCdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fcHJpbnRPcHRpb25zKCk7XG4gICAgICB9O1xuICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW92ZXIgPSAoKSA9PiB7XG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24gaG92ZXJcIjtcbiAgICAgIH07XG4gICAgICBnZW5lcmF0ZUJ1dHRvbi5vbm1vdXNlb3V0ID0gKCkgPT4ge1xuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uXCI7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5vcHRpb25zQ29udGFpbmVyLmNsYXNzTmFtZSA9XG4gICAgICAgIFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1vcHRpb24tY29udGFpbmVyXCI7XG5cbiAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaCh0aGlzLm9wdGlvbnNDb250YWluZXIpO1xuICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKGdlbmVyYXRlQnV0dG9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcHJlcGFyZSB0aGUgcG9wdXBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cFBvcHVwKHN0cmluZywgaW5kZXgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmluaXRpYWxpemVkID09PSB0cnVlICYmXG4gICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUgJiZcbiAgICAgIHRoaXMucG9wdXBDb3VudGVyIDwgdGhpcy5wb3B1cExpbWl0XG4gICAgKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmlkID0gXCJ2aXMtY29uZmlndXJhdGlvbi1wb3B1cFwiO1xuICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgIGRpdi5pbm5lclRleHQgPSBzdHJpbmc7XG4gICAgICBkaXYub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnBvcHVwQ291bnRlciArPSAxO1xuICAgICAgdGhpcy5wb3B1cERpdiA9IHsgaHRtbDogZGl2LCBpbmRleDogaW5kZXggfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIHRoZSBwb3B1cCBmcm9tIHRoZSBkb21cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW1vdmVQb3B1cCgpIHtcbiAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBEaXYuaHRtbCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5kZWxldGVUaW1lb3V0KTtcbiAgICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aGUgcG9wdXAgaWYgaXQgaXMgbmVlZGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3dQb3B1cElmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY29ycmVzcG9uZGluZ0VsZW1lbnQgPSB0aGlzLmRvbUVsZW1lbnRzW3RoaXMucG9wdXBEaXYuaW5kZXhdO1xuICAgICAgY29uc3QgcmVjdCA9IGNvcnJlc3BvbmRpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUudG9wID0gcmVjdC50b3AgLSAzMCArIFwicHhcIjsgLy8gMzAgaXMgdGhlIGhlaWdodDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKTtcbiAgICAgIHRoaXMucG9wdXBEaXYuaGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgfSwgMTUwMCk7XG4gICAgICB0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgIH0sIDE4MDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBtYWtlIGEgY2hlY2tib3ggZm9yIGJvb2xlYW4gb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZUNoZWNrYm94KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jaGVja2JveFwiO1xuICAgIGNoZWNrYm94LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goeyBwYXRoOiBwYXRoLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5fdXBkYXRlKHRoaXMuY2hlY2tlZCwgcGF0aCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYWtlIGEgdGV4dCBpbnB1dCBmaWVsZCBmb3Igc3RyaW5nIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VUZXh0SW5wdXQoZGVmYXVsdFZhbHVlLCB2YWx1ZSwgcGF0aCkge1xuICAgIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGNoZWNrYm94LnR5cGUgPSBcInRleHRcIjtcbiAgICBjaGVja2JveC5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctdGV4dFwiO1xuICAgIGNoZWNrYm94LnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7IHBhdGg6IHBhdGgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5fdXBkYXRlKHRoaXMudmFsdWUsIHBhdGgpO1xuICAgIH07XG5cbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBjaGVja2JveCk7XG4gIH1cblxuICAvKipcbiAgICogbWFrZSBhIGNvbG9yIGZpZWxkIHdpdGggYSBjb2xvciBwaWNrZXIgZm9yIGNvbG9yIGZpZWxkc1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBhcnJbMV07XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29sb3IgOiB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSAhPT0gXCJub25lXCIpIHtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9ja1wiO1xuICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2sgbm9uZVwiO1xuICAgIH1cblxuICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuICAgIGRpdi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpO1xuICAgIH07XG5cbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBkaXYpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVzZWQgYnkgdGhlIGNvbG9yIGJ1dHRvbnMgdG8gY2FsbCB0aGUgY29sb3IgcGlja2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGl2XG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKSB7XG4gICAgLy8gY2xlYXIgdGhlIGNhbGxiYWNrIGZyb20gdGhpcyBkaXZcbiAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyhkaXYpO1xuICAgIHRoaXMuY29sb3JQaWNrZXIuc2hvdygpO1xuXG4gICAgdGhpcy5jb2xvclBpY2tlci5zZXRDb2xvcih2YWx1ZSk7XG4gICAgdGhpcy5jb2xvclBpY2tlci5zZXRVcGRhdGVDYWxsYmFjaygoY29sb3IpID0+IHtcbiAgICAgIGNvbnN0IGNvbG9yU3RyaW5nID1cbiAgICAgICAgXCJyZ2JhKFwiICsgY29sb3IuciArIFwiLFwiICsgY29sb3IuZyArIFwiLFwiICsgY29sb3IuYiArIFwiLFwiICsgY29sb3IuYSArIFwiKVwiO1xuICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yU3RyaW5nO1xuICAgICAgdGhpcy5fdXBkYXRlKGNvbG9yU3RyaW5nLCBwYXRoKTtcbiAgICB9KTtcblxuICAgIC8vIG9uIGNsb3NlIG9mIHRoZSBjb2xvcnBpY2tlciwgcmVzdG9yZSB0aGUgY2FsbGJhY2suXG4gICAgdGhpcy5jb2xvclBpY2tlci5zZXRDbG9zZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGRpdi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHBhcnNlIGFuIG9iamVjdCBhbmQgZHJhdyB0aGUgY29ycmVjdCBpdGVtc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwYXRoPVtdXSAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoZWNrT25seT1mYWxzZV1cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlT2JqZWN0KG9iaiwgcGF0aCA9IFtdLCBjaGVja09ubHkgPSBmYWxzZSkge1xuICAgIGxldCBzaG93ID0gZmFsc2U7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICBsZXQgdmlzaWJsZUluU2V0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBzdWJPYmogaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgc3ViT2JqKSkge1xuICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaXRlbSA9IG9ialtzdWJPYmpdO1xuICAgICAgICBjb25zdCBuZXdQYXRoID0gY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIHN1Yk9iaik7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBzaG93ID0gZmlsdGVyKHN1Yk9iaiwgcGF0aCk7XG5cbiAgICAgICAgICAvLyBpZiBuZWVkZWQgd2UgbXVzdCBnbyBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuICAgICAgICAgIGlmIChzaG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShpdGVtKSAmJlxuICAgICAgICAgICAgICB0eXBlb2YgaXRlbSAhPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICB0eXBlb2YgaXRlbSAhPT0gXCJib29sZWFuXCIgJiZcbiAgICAgICAgICAgICAgaXRlbSBpbnN0YW5jZW9mIE9iamVjdFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICBzaG93ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBjaGVja09ubHkgPT09IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHZpc2libGVJblNldCA9IHRydWU7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShuZXdQYXRoKTtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVBcnJheShpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5fbWFrZVRleHRJbnB1dChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBza2lwIHRoZSBvcHRpb25zIHRoYXQgYXJlIG5vdCBlbmFibGVkXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGlkZU9wdGlvbihwYXRoLCBzdWJPYmosIHRoaXMubW9kdWxlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgLy8gaW5pdGlhbGx5IGNvbGxhcHNlIG9wdGlvbnMgd2l0aCBhbiBkaXNhYmxlZCBlbmFibGVkIG9wdGlvbi5cbiAgICAgICAgICAgICAgaWYgKGl0ZW0uZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5hYmxlZFBhdGggPSBjb3B5QW5kRXh0ZW5kQXJyYXkobmV3UGF0aCwgXCJlbmFibGVkXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuYWJsZWRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlKGVuYWJsZWRQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZFZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChzdWJPYmosIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0obmV3UGF0aCwgbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUNoZWNrYm94KGl0ZW0sIGVuYWJsZWRWYWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0obmV3UGF0aCwgbGFiZWwpO1xuICAgICAgICAgICAgICAgIHZpc2libGVJblNldCA9XG4gICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCkgfHwgdmlzaWJsZUluU2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJkb250IGtub3cgaG93IHRvIGhhbmRsZVwiLCBpdGVtLCBzdWJPYmosIG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZUluU2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIGhhbmRsZSB0aGUgYXJyYXkgdHlwZSBvZiBvcHRpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVBcnJheShhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwic3RyaW5nXCIgJiYgYXJyWzBdID09PSBcImNvbG9yXCIpIHtcbiAgICAgIHRoaXMuX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgaWYgKGFyclsxXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyclswXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5fbWFrZURyb3Bkb3duKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyclswXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5fbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHsgcGF0aDogcGF0aCwgdmFsdWU6IE51bWJlcih2YWx1ZSkgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGNhbGxlZCB0byB1cGRhdGUgdGhlIG5ldHdvcmsgd2l0aCB0aGUgbmV3IHNldHRpbmdzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlKHZhbHVlLCBwYXRoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgpO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5wYXJlbnQuYm9keSAmJlxuICAgICAgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyICYmXG4gICAgICB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIuZW1pdFxuICAgICkge1xuICAgICAgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQoXCJjb25maWdDaGFuZ2VcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyZW50LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBib29sZWFufSB2YWx1ZVxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAqIEBwYXJhbSB7e319IG9wdGlvbnNPYmpcbiAgICogQHJldHVybnMge3t9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgsIG9wdGlvbnNPYmogPSB7fSkge1xuICAgIGxldCBwb2ludGVyID0gb3B0aW9uc09iajtcblxuICAgIC8vIHdoZW4gZHJvcGRvd24gYm94ZXMgY2FuIGJlIHN0cmluZyBvciBib29sZWFuLCB3ZSB0eXBlY2FzdCBpdCBpbnRvIGNvcnJlY3QgdHlwZXNcbiAgICB2YWx1ZSA9IHZhbHVlID09PSBcInRydWVcIiA/IHRydWUgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IHZhbHVlID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHZhbHVlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGF0aFtpXSAhPT0gXCJnbG9iYWxcIikge1xuICAgICAgICBpZiAocG9pbnRlcltwYXRoW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9pbnRlcltwYXRoW2ldXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpICE9PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBwb2ludGVyID0gcG9pbnRlcltwYXRoW2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnNPYmo7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcmludE9wdGlvbnMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuXG4gICAgd2hpbGUgKHRoaXMub3B0aW9uc0NvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5vcHRpb25zQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQoXG4gICAgICB3cmFwSW5UYWcoXCJwcmVcIiwgXCJjb25zdCBvcHRpb25zID0gXCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zLCBudWxsLCAyKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHt7fX0gb3B0aW9uc1xuICAgKi9cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5nZWRPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jb25zdHJ1Y3RPcHRpb25zKFxuICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnZhbHVlLFxuICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnBhdGgsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG59XG5cbi8qKlxuICogUG9wdXAgaXMgYSBjbGFzcyB0byBjcmVhdGUgYSBwb3B1cCB3aW5kb3cgd2l0aCBzb21lIHRleHRcbiAqL1xuY2xhc3MgUG9wdXAge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgICAgICAgVGhlIGNvbnRhaW5lciBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgb3ZlcmZsb3dNZXRob2QgIEhvdyB0aGUgcG9wdXAgc2hvdWxkIGFjdCB0byBvdmVyZmxvd2luZyAoJ2ZsaXAnIG9yICdjYXAnKVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCBvdmVyZmxvd01ldGhvZCkge1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMub3ZlcmZsb3dNZXRob2QgPSBvdmVyZmxvd01ldGhvZCB8fCBcImNhcFwiO1xuXG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMucGFkZGluZyA9IDU7XG4gICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgZnJhbWVcbiAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9IFwidmlzLXRvb2x0aXBcIjtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIHBvcHVwIHdpbmRvd1xuICAgKiBAcGFyYW0ge251bWJlcn0geSAgIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBwb3B1cCB3aW5kb3dcbiAgICovXG4gIHNldFBvc2l0aW9uKHgsIHkpIHtcbiAgICB0aGlzLnggPSBwYXJzZUludCh4KTtcbiAgICB0aGlzLnkgPSBwYXJzZUludCh5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbnRlbnQgZm9yIHRoZSBwb3B1cCB3aW5kb3cuIFRoaXMgY2FuIGJlIEhUTUwgY29kZSBvciB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEVsZW1lbnR9IGNvbnRlbnRcbiAgICovXG4gIHNldFRleHQoY29udGVudCkge1xuICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgd2hpbGUgKHRoaXMuZnJhbWUuZmlyc3RDaGlsZCkge1xuICAgICAgICB0aGlzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuZnJhbWUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdHJpbmcgY29udGFpbmluZyBsaXRlcmFsIHRleHQsIGVsZW1lbnQgaGFzIHRvIGJlIHVzZWQgZm9yIEhUTUwgZHVlIHRvXG4gICAgICAvLyBYU1Mgcmlza3MgYXNzb2NpYXRlZCB3aXRoIGlubmVySFRNTCAoaS5lLiBwcmV2ZW50IFhTUyBieSBhY2NpZGVudCkuXG4gICAgICB0aGlzLmZyYW1lLmlubmVyVGV4dCA9IGNvbnRlbnQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIHBvcHVwIHdpbmRvd1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb1Nob3ddICAgIFNob3cgb3IgaGlkZSB0aGUgd2luZG93XG4gICAqL1xuICBzaG93KGRvU2hvdykge1xuICAgIGlmIChkb1Nob3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZG9TaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZG9TaG93ID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmZyYW1lLmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5mcmFtZS5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuZnJhbWUucGFyZW50Tm9kZS5jbGllbnRIZWlnaHQ7XG4gICAgICBjb25zdCBtYXhXaWR0aCA9IHRoaXMuZnJhbWUucGFyZW50Tm9kZS5jbGllbnRXaWR0aDtcblxuICAgICAgbGV0IGxlZnQgPSAwLFxuICAgICAgICB0b3AgPSAwO1xuXG4gICAgICBpZiAodGhpcy5vdmVyZmxvd01ldGhvZCA9PSBcImZsaXBcIikge1xuICAgICAgICBsZXQgaXNMZWZ0ID0gZmFsc2UsXG4gICAgICAgICAgaXNUb3AgPSB0cnVlOyAvLyBXaGVyZSBhcm91bmQgdGhlIHBvc2l0aW9uIGl0J3MgbG9jYXRlZFxuXG4gICAgICAgIGlmICh0aGlzLnkgLSBoZWlnaHQgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICBpc1RvcCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMueCArIHdpZHRoID4gbWF4V2lkdGggLSB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICBpc0xlZnQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgIGxlZnQgPSB0aGlzLnggLSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWZ0ID0gdGhpcy54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVG9wKSB7XG4gICAgICAgICAgdG9wID0gdGhpcy55IC0gaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcCA9IHRoaXMueTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9wID0gdGhpcy55IC0gaGVpZ2h0O1xuICAgICAgICBpZiAodG9wICsgaGVpZ2h0ICsgdGhpcy5wYWRkaW5nID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgdG9wID0gbWF4SGVpZ2h0IC0gaGVpZ2h0IC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3AgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICB0b3AgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBsZWZ0ID0gdGhpcy54O1xuICAgICAgICBpZiAobGVmdCArIHdpZHRoICsgdGhpcy5wYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICBsZWZ0ID0gbWF4V2lkdGggLSB3aWR0aCAtIHRoaXMucGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCA8IHRoaXMucGFkZGluZykge1xuICAgICAgICAgIGxlZnQgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgcG9wdXAgd2luZG93XG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICB0aGlzLmZyYW1lLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgIHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBwb3B1cCB3aW5kb3dcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZnJhbWUpOyAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIERPTVxuICB9XG59XG5cbmxldCBlcnJvckZvdW5kID0gZmFsc2U7XG5sZXQgYWxsT3B0aW9ucztcblxuY29uc3QgVkFMSURBVE9SX1BSSU5UX1NUWUxFID0gXCJiYWNrZ3JvdW5kOiAjRkZlZWVlOyBjb2xvcjogI2RkMDAwMFwiO1xuXG4vKipcbiAqICBVc2VkIHRvIHZhbGlkYXRlIG9wdGlvbnMuXG4gKi9cbmNsYXNzIFZhbGlkYXRvciB7XG4gIC8qKlxuICAgKiBNYWluIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlT3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gc3ViT2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGUob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgc3ViT2JqZWN0KSB7XG4gICAgZXJyb3JGb3VuZCA9IGZhbHNlO1xuICAgIGFsbE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zO1xuICAgIGxldCB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgaWYgKHN1Yk9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnNbc3ViT2JqZWN0XTtcbiAgICB9XG4gICAgVmFsaWRhdG9yLnBhcnNlKG9wdGlvbnMsIHVzZWRPcHRpb25zLCBbXSk7XG4gICAgcmV0dXJuIGVycm9yRm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCB0cmF2ZXJzZSBhbiBvYmplY3QgcmVjdXJzaXZlbHkgYW5kIGNoZWNrIGV2ZXJ5IHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgKiBAc3RhdGljXG4gICAqL1xuICBzdGF0aWMgcGFyc2Uob3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgb3B0aW9uKSkge1xuICAgICAgICBWYWxpZGF0b3IuY2hlY2sob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgZXZlcnkgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGNhbGwgdGhlIHBhcnNlIGZ1bmN0aW9uIG9uIHRoYXQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgKiBAc3RhdGljXG4gICAqL1xuICBzdGF0aWMgY2hlY2sob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgaWYgKFxuICAgICAgcmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBWYWxpZGF0b3IuZ2V0U3VnZ2VzdGlvbihvcHRpb24sIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByZWZlcmVuY2VPcHRpb24gPSBvcHRpb247XG4gICAgbGV0IGlzX29iamVjdCA9IHRydWU7XG5cbiAgICBpZiAoXG4gICAgICByZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgcmVmZXJlbmNlT3B0aW9ucy5fX2FueV9fICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIC8vIE5PVEU6IFRoaXMgb25seSB0cmlnZ2VycyBpZiB0aGUgX19hbnlfXyBpcyBpbiB0aGUgdG9wIGxldmVsIG9mIHRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgIC8vICAgICAgIFRIQVQnUyBBIFJFQUxMWSBCQUQgUExBQ0UgVE8gQUxMT1cgSVQhISEhXG4gICAgICAvLyBUT0RPOiBFeGFtaW5lIGlmIG5lZWRlZCwgcmVtb3ZlIGlmIHBvc3NpYmxlXG5cbiAgICAgIC8vIF9fYW55X18gaXMgYSB3aWxkY2FyZC4gQW55IHZhbHVlIGlzIGFjY2VwdGVkIGFuZCB3aWxsIGJlIGZ1cnRoZXIgYW5hbHlzZWQgYnkgcmVmZXJlbmNlLlxuICAgICAgcmVmZXJlbmNlT3B0aW9uID0gXCJfX2FueV9fXCI7XG5cbiAgICAgIC8vIGlmIHRoZSBhbnktc3ViZ3JvdXAgaXMgbm90IGEgcHJlZGVmaW5lZCBvYmplY3QgaW4gdGhlIGNvbmZpZ3VyYXRvcixcbiAgICAgIC8vIHdlIGRvIG5vdCBsb29rIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG4gICAgICBpc19vYmplY3QgPSBWYWxpZGF0b3IuZ2V0VHlwZShvcHRpb25zW29wdGlvbl0pID09PSBcIm9iamVjdFwiO1xuICAgIH1cblxuICAgIGxldCByZWZPcHRpb25PYmogPSByZWZlcmVuY2VPcHRpb25zW3JlZmVyZW5jZU9wdGlvbl07XG4gICAgaWYgKGlzX29iamVjdCAmJiByZWZPcHRpb25PYmouX190eXBlX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVmT3B0aW9uT2JqID0gcmVmT3B0aW9uT2JqLl9fdHlwZV9fO1xuICAgIH1cblxuICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhcbiAgICAgIG9wdGlvbixcbiAgICAgIG9wdGlvbnMsXG4gICAgICByZWZlcmVuY2VPcHRpb25zLFxuICAgICAgcmVmZXJlbmNlT3B0aW9uLFxuICAgICAgcmVmT3B0aW9uT2JqLFxuICAgICAgcGF0aFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBvcHRpb24gICAgICAgICAgIHwgdGhlIG9wdGlvbiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgICAgICAgICAgfCBUaGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtvYmplY3R9ICByZWZlcmVuY2VPcHRpb25zIHwgVGhlIHJlZmVyZW5jZSBvcHRpb25zIGNvbnRhaW5pbmcgYWxsIG9wdGlvbnMgYW5kIHRoZWlyIGFsbG93ZWQgZm9ybWF0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gIHJlZmVyZW5jZU9wdGlvbiAgfCBVc3VhbGx5IHRoaXMgaXMgdGhlIHNhbWUgYXMgb3B0aW9uLCBleGNlcHQgd2hlbiBoYW5kbGluZyBhbiBfX2FueV9fIHRhZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICByZWZPcHRpb25PYmogICAgIHwgVGhpcyBpcyB0aGUgdHlwZSBvYmplY3QgZnJvbSB0aGUgcmVmZXJlbmNlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheX0gICBwYXRoICAgICAgICAgICAgIHwgd2hlcmUgaW4gdGhlIG9iamVjdCBpcyB0aGUgb3B0aW9uXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBjaGVja0ZpZWxkcyhcbiAgICBvcHRpb24sXG4gICAgb3B0aW9ucyxcbiAgICByZWZlcmVuY2VPcHRpb25zLFxuICAgIHJlZmVyZW5jZU9wdGlvbixcbiAgICByZWZPcHRpb25PYmosXG4gICAgcGF0aFxuICApIHtcbiAgICBjb25zdCBsb2cgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCIlY1wiICsgbWVzc2FnZSArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiksXG4gICAgICAgIFZBTElEQVRPUl9QUklOVF9TVFlMRVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb3B0aW9uVHlwZSA9IFZhbGlkYXRvci5nZXRUeXBlKG9wdGlvbnNbb3B0aW9uXSk7XG4gICAgY29uc3QgcmVmT3B0aW9uVHlwZSA9IHJlZk9wdGlvbk9ialtvcHRpb25UeXBlXTtcblxuICAgIGlmIChyZWZPcHRpb25UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIHdlIGNoZWNrIGlmIGl0IGlzIHN1cHBvc2VkIHRvIGJlIG9uZSBvZiBhIGZldyBzZWxlY3QgdmFsdWVzXG4gICAgICBpZiAoXG4gICAgICAgIFZhbGlkYXRvci5nZXRUeXBlKHJlZk9wdGlvblR5cGUpID09PSBcImFycmF5XCIgJiZcbiAgICAgICAgcmVmT3B0aW9uVHlwZS5pbmRleE9mKG9wdGlvbnNbb3B0aW9uXSkgPT09IC0xXG4gICAgICApIHtcbiAgICAgICAgbG9nKFxuICAgICAgICAgICdJbnZhbGlkIG9wdGlvbiBkZXRlY3RlZCBpbiBcIicgK1xuICAgICAgICAgICAgb3B0aW9uICtcbiAgICAgICAgICAgICdcIi4nICtcbiAgICAgICAgICAgIFwiIEFsbG93ZWQgdmFsdWVzIGFyZTpcIiArXG4gICAgICAgICAgICBWYWxpZGF0b3IucHJpbnQocmVmT3B0aW9uVHlwZSkgK1xuICAgICAgICAgICAgJyBub3QgXCInICtcbiAgICAgICAgICAgIG9wdGlvbnNbb3B0aW9uXSArXG4gICAgICAgICAgICAnXCIuICdcbiAgICAgICAgKTtcbiAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvblR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmVmZXJlbmNlT3B0aW9uICE9PSBcIl9fYW55X19cIikge1xuICAgICAgICBwYXRoID0gY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgIFZhbGlkYXRvci5wYXJzZShcbiAgICAgICAgICBvcHRpb25zW29wdGlvbl0sXG4gICAgICAgICAgcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dLFxuICAgICAgICAgIHBhdGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZk9wdGlvbk9ialtcImFueVwiXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0eXBlIG9mIHRoZSBmaWVsZCBpcyBpbmNvcnJlY3QgYW5kIHRoZSBmaWVsZCBjYW5ub3QgYmUgYW55XG4gICAgICBsb2coXG4gICAgICAgICdJbnZhbGlkIHR5cGUgcmVjZWl2ZWQgZm9yIFwiJyArXG4gICAgICAgICAgb3B0aW9uICtcbiAgICAgICAgICAnXCIuIEV4cGVjdGVkOiAnICtcbiAgICAgICAgICBWYWxpZGF0b3IucHJpbnQoT2JqZWN0LmtleXMocmVmT3B0aW9uT2JqKSkgK1xuICAgICAgICAgIFwiLiBSZWNlaXZlZCBbXCIgK1xuICAgICAgICAgIG9wdGlvblR5cGUgK1xuICAgICAgICAgICddIFwiJyArXG4gICAgICAgICAgb3B0aW9uc1tvcHRpb25dICtcbiAgICAgICAgICAnXCInXG4gICAgICApO1xuICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0IHwgYm9vbGVhbiB8IG51bWJlciB8IHN0cmluZyB8IEFycmF5LjxudW1iZXI+IHwgRGF0ZSB8IE5vZGUgfCBNb21lbnQgfCB1bmRlZmluZWQgfCBudWxsfSBvYmplY3RcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGdldFR5cGUob2JqZWN0KSB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBvYmplY3Q7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Qubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gXCJkb21cIjtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuX2lzQU1vbWVudE9iamVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gXCJtb21lbnRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGdldFN1Z2dlc3Rpb24ob3B0aW9uLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgY29uc3QgbG9jYWxTZWFyY2ggPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnMsIHBhdGgsIGZhbHNlKTtcbiAgICBjb25zdCBnbG9iYWxTZWFyY2ggPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhvcHRpb24sIGFsbE9wdGlvbnMsIFtdLCB0cnVlKTtcblxuICAgIGNvbnN0IGxvY2FsU2VhcmNoVGhyZXNob2xkID0gODtcbiAgICBjb25zdCBnbG9iYWxTZWFyY2hUaHJlc2hvbGQgPSA0O1xuXG4gICAgbGV0IG1zZztcbiAgICBpZiAobG9jYWxTZWFyY2guaW5kZXhNYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtc2cgPVxuICAgICAgICBcIiBpbiBcIiArXG4gICAgICAgIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgXCJcIikgK1xuICAgICAgICAnUGVyaGFwcyBpdCB3YXMgaW5jb21wbGV0ZT8gRGlkIHlvdSBtZWFuOiBcIicgK1xuICAgICAgICBsb2NhbFNlYXJjaC5pbmRleE1hdGNoICtcbiAgICAgICAgJ1wiP1xcblxcbic7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGdsb2JhbFNlYXJjaC5kaXN0YW5jZSA8PSBnbG9iYWxTZWFyY2hUaHJlc2hvbGQgJiZcbiAgICAgIGxvY2FsU2VhcmNoLmRpc3RhbmNlID4gZ2xvYmFsU2VhcmNoLmRpc3RhbmNlXG4gICAgKSB7XG4gICAgICBtc2cgPVxuICAgICAgICBcIiBpbiBcIiArXG4gICAgICAgIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgXCJcIikgK1xuICAgICAgICBcIlBlcmhhcHMgaXQgd2FzIG1pc3BsYWNlZD8gTWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGF0OiBcIiArXG4gICAgICAgIFZhbGlkYXRvci5wcmludExvY2F0aW9uKFxuICAgICAgICAgIGdsb2JhbFNlYXJjaC5wYXRoLFxuICAgICAgICAgIGdsb2JhbFNlYXJjaC5jbG9zZXN0TWF0Y2gsXG4gICAgICAgICAgXCJcIlxuICAgICAgICApO1xuICAgIH0gZWxzZSBpZiAobG9jYWxTZWFyY2guZGlzdGFuY2UgPD0gbG9jYWxTZWFyY2hUaHJlc2hvbGQpIHtcbiAgICAgIG1zZyA9XG4gICAgICAgICcuIERpZCB5b3UgbWVhbiBcIicgK1xuICAgICAgICBsb2NhbFNlYXJjaC5jbG9zZXN0TWF0Y2ggK1xuICAgICAgICAnXCI/JyArXG4gICAgICAgIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyA9XG4gICAgICAgIFwiLiBEaWQgeW91IG1lYW4gb25lIG9mIHRoZXNlOiBcIiArXG4gICAgICAgIFZhbGlkYXRvci5wcmludChPYmplY3Qua2V5cyhvcHRpb25zKSkgK1xuICAgICAgICBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pO1xuICAgIH1cblxuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAnJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiJyArIG1zZyxcbiAgICAgIFZBTElEQVRPUl9QUklOVF9TVFlMRVxuICAgICk7XG4gICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogdHJhdmVyc2UgdGhlIG9wdGlvbnMgaW4gc2VhcmNoIGZvciBhIG1hdGNoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdXG4gICAqIEByZXR1cm5zIHt7Y2xvc2VzdE1hdGNoOiBzdHJpbmcsIHBhdGg6IEFycmF5LCBkaXN0YW5jZTogbnVtYmVyfX1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zLCBwYXRoLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAgIGxldCBtaW4gPSAxZTk7XG4gICAgbGV0IGNsb3Nlc3RNYXRjaCA9IFwiXCI7XG4gICAgbGV0IGNsb3Nlc3RNYXRjaFBhdGggPSBbXTtcbiAgICBjb25zdCBsb3dlckNhc2VPcHRpb24gPSBvcHRpb24udG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgaW5kZXhNYXRjaCA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IG9wIGluIG9wdGlvbnMpIHtcbiAgICAgIGxldCBkaXN0YW5jZTtcbiAgICAgIGlmIChvcHRpb25zW29wXS5fX3R5cGVfXyAhPT0gdW5kZWZpbmVkICYmIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhcbiAgICAgICAgICBvcHRpb24sXG4gICAgICAgICAgb3B0aW9uc1tvcF0sXG4gICAgICAgICAgY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wKVxuICAgICAgICApO1xuICAgICAgICBpZiAobWluID4gcmVzdWx0LmRpc3RhbmNlKSB7XG4gICAgICAgICAgY2xvc2VzdE1hdGNoID0gcmVzdWx0LmNsb3Nlc3RNYXRjaDtcbiAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gcmVzdWx0LnBhdGg7XG4gICAgICAgICAgbWluID0gcmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICAgIGluZGV4TWF0Y2ggPSByZXN1bHQuaW5kZXhNYXRjaDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsb3dlckNhc2VPcHRpb24pICE9PSAtMSkge1xuICAgICAgICAgIGluZGV4TWF0Y2ggPSBvcDtcbiAgICAgICAgfVxuICAgICAgICBkaXN0YW5jZSA9IFZhbGlkYXRvci5sZXZlbnNodGVpbkRpc3RhbmNlKG9wdGlvbiwgb3ApO1xuICAgICAgICBpZiAobWluID4gZGlzdGFuY2UpIHtcbiAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSBvcDtcbiAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gY29weUFycmF5KHBhdGgpO1xuICAgICAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjbG9zZXN0TWF0Y2g6IGNsb3Nlc3RNYXRjaCxcbiAgICAgIHBhdGg6IGNsb3Nlc3RNYXRjaFBhdGgsXG4gICAgICBkaXN0YW5jZTogbWluLFxuICAgICAgaW5kZXhNYXRjaDogaW5kZXhNYXRjaCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBwcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiwgcHJlZml4ID0gXCJQcm9ibGVtIHZhbHVlIGZvdW5kIGF0OiBcXG5cIikge1xuICAgIGxldCBzdHIgPSBcIlxcblxcblwiICsgcHJlZml4ICsgXCJvcHRpb25zID0ge1xcblwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpICsgMTsgaisrKSB7XG4gICAgICAgIHN0ciArPSBcIiAgXCI7XG4gICAgICB9XG4gICAgICBzdHIgKz0gcGF0aFtpXSArIFwiOiB7XFxuXCI7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGF0aC5sZW5ndGggKyAxOyBqKyspIHtcbiAgICAgIHN0ciArPSBcIiAgXCI7XG4gICAgfVxuICAgIHN0ciArPSBvcHRpb24gKyBcIlxcblwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggKyAxOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGF0aC5sZW5ndGggLSBpOyBqKyspIHtcbiAgICAgICAgc3RyICs9IFwiICBcIjtcbiAgICAgIH1cbiAgICAgIHN0ciArPSBcIn1cXG5cIjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ciArIFwiXFxuXFxuXCI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIHByaW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob3B0aW9ucylcbiAgICAgIC5yZXBsYWNlKC8oXCIpfChcXFspfChcXF0pfCgsXCJfX3R5cGVfX1wiKS9nLCBcIlwiKVxuICAgICAgLnJlcGxhY2UoLygsKS9nLCBcIiwgXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqICBDb21wdXRlIHRoZSBlZGl0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzXG4gICAqIGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX0ltcGxlbWVudGF0aW9uL1N0cmluZ3MvTGV2ZW5zaHRlaW5fZGlzdGFuY2UjSmF2YVNjcmlwdFxuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTEgQW5kcmVpIE1hY2tlbnppZVxuICAgKlxuICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgKlxuICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICpcbiAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fX1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGxldmVuc2h0ZWluRGlzdGFuY2UoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGIubGVuZ3RoO1xuICAgIGlmIChiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGEubGVuZ3RoO1xuXG4gICAgY29uc3QgbWF0cml4ID0gW107XG5cbiAgICAvLyBpbmNyZW1lbnQgYWxvbmcgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIHJvd1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgbWF0cml4W2ldID0gW2ldO1xuICAgIH1cblxuICAgIC8vIGluY3JlbWVudCBlYWNoIGNvbHVtbiBpbiB0aGUgZmlyc3Qgcm93XG4gICAgbGV0IGo7XG4gICAgZm9yIChqID0gMDsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICBtYXRyaXhbMF1bal0gPSBqO1xuICAgIH1cblxuICAgIC8vIEZpbGwgaW4gdGhlIHJlc3Qgb2YgdGhlIG1hdHJpeFxuICAgIGZvciAoaSA9IDE7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChiLmNoYXJBdChpIC0gMSkgPT0gYS5jaGFyQXQoaiAtIDEpKSB7XG4gICAgICAgICAgbWF0cml4W2ldW2pdID0gbWF0cml4W2kgLSAxXVtqIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4oXG4gICAgICAgICAgICBtYXRyaXhbaSAtIDFdW2ogLSAxXSArIDEsIC8vIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICAgIG1hdHJpeFtpXVtqIC0gMV0gKyAxLCAvLyBpbnNlcnRpb25cbiAgICAgICAgICAgICAgbWF0cml4W2kgLSAxXVtqXSArIDFcbiAgICAgICAgICAgIClcbiAgICAgICAgICApOyAvLyBkZWxldGlvblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdHJpeFtiLmxlbmd0aF1bYS5sZW5ndGhdO1xuICB9XG59XG5cbmNvbnN0IEFjdGl2YXRvciQxID0gQWN0aXZhdG9yO1xyXG5jb25zdCBDb2xvclBpY2tlciQxID0gQ29sb3JQaWNrZXI7XHJcbmNvbnN0IENvbmZpZ3VyYXRvciQxID0gQ29uZmlndXJhdG9yO1xyXG5jb25zdCBIYW1tZXIkMSA9IEhhbW1lcjtcclxuY29uc3QgUG9wdXAkMSA9IFBvcHVwO1xyXG5jb25zdCBWQUxJREFUT1JfUFJJTlRfU1RZTEUkMSA9IFZBTElEQVRPUl9QUklOVF9TVFlMRTtcclxuY29uc3QgVmFsaWRhdG9yJDEgPSBWYWxpZGF0b3I7XG5cbmV4cG9ydCB7IEFjdGl2YXRvciQxIGFzIEFjdGl2YXRvciwgQWxlYSwgQ29sb3JQaWNrZXIkMSBhcyBDb2xvclBpY2tlciwgQ29uZmlndXJhdG9yJDEgYXMgQ29uZmlndXJhdG9yLCBERUxFVEUsIEhTVlRvSGV4LCBIU1ZUb1JHQiwgSGFtbWVyJDEgYXMgSGFtbWVyLCBQb3B1cCQxIGFzIFBvcHVwLCBSR0JUb0hTViwgUkdCVG9IZXgsIFZBTElEQVRPUl9QUklOVF9TVFlMRSQxIGFzIFZBTElEQVRPUl9QUklOVF9TVFlMRSwgVmFsaWRhdG9yJDEgYXMgVmFsaWRhdG9yLCBhZGRDbGFzc05hbWUsIGFkZENzc1RleHQsIGFkZEV2ZW50TGlzdGVuZXIsIGJpbmFyeVNlYXJjaEN1c3RvbSwgYmluYXJ5U2VhcmNoVmFsdWUsIGJyaWRnZU9iamVjdCwgY29weUFuZEV4dGVuZEFycmF5LCBjb3B5QXJyYXksIGRlZXBFeHRlbmQsIGRlZXBPYmplY3RBc3NpZ24sIGVhc2luZ0Z1bmN0aW9ucywgZXF1YWxBcnJheSwgZXh0ZW5kLCBmaWxsSWZEZWZpbmVkLCBmb3JFYWNoLCBnZXRBYnNvbHV0ZUxlZnQsIGdldEFic29sdXRlUmlnaHQsIGdldEFic29sdXRlVG9wLCBnZXRTY3JvbGxCYXJXaWR0aCwgZ2V0VGFyZ2V0LCBnZXRUeXBlLCBoYXNQYXJlbnQsIGhleFRvSFNWLCBoZXhUb1JHQiwgaW5zZXJ0U29ydCwgaXNEYXRlLCBpc051bWJlciwgaXNPYmplY3QsIGlzU3RyaW5nLCBpc1ZhbGlkSGV4LCBpc1ZhbGlkUkdCLCBpc1ZhbGlkUkdCQSwgbWVyZ2VPcHRpb25zLCBvcHRpb24sIG92ZXJyaWRlT3BhY2l0eSwgcGFyc2VDb2xvciwgcHJldmVudERlZmF1bHQsIHB1cmVEZWVwT2JqZWN0QXNzaWduLCByZWN1cnNpdmVET01EZWxldGUsIHJlbW92ZUNsYXNzTmFtZSwgcmVtb3ZlQ3NzVGV4dCwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgc2VsZWN0aXZlQnJpZGdlT2JqZWN0LCBzZWxlY3RpdmVEZWVwRXh0ZW5kLCBzZWxlY3RpdmVFeHRlbmQsIHNlbGVjdGl2ZU5vdERlZXBFeHRlbmQsIHRocm90dGxlLCB0b0FycmF5LCB0b3BNb3N0LCB1cGRhdGVQcm9wZXJ0eSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlzLXV0aWwuanMubWFwXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgbmF0aXZlQ29uc3RydWN0ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcblxuLy8gYFJlZmxlY3QuY29uc3RydWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuY29uc3RydWN0XG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgbmF0aXZlQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcbnZhciBGT1JDRUQgPSBORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRztcblxuJCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogRk9SQ0VEIH0sIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIG5hdGl2ZUNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0Jyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9wYXRoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0aC5SZWZsZWN0LmNvbnN0cnVjdDtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9yZWZsZWN0L2NvbnN0cnVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvcmVmbGVjdC9jb25zdHJ1Y3RcIik7IiwicmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIGVudHJ5VmlydHVhbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVybmFscy9lbnRyeS12aXJ0dWFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLmVudHJpZXM7XG4iLCJ2YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXMvYXJyYXkvdmlydHVhbC9lbnRyaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yJyk7XG52YXIgZW50cmllcyA9IHJlcXVpcmUoJy4uL2FycmF5L3ZpcnR1YWwvZW50cmllcycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIE5vZGVMaXN0OiB0cnVlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZW50cmllcztcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCAoaXQgaW5zdGFuY2VvZiBBcnJheSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlLmVudHJpZXMpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHx8IERPTUl0ZXJhYmxlcy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKGl0KSkgPyBlbnRyaWVzIDogb3duO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2UvZW50cmllc1wiKTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCJ2YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvc3ltYm9sL2l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9zeW1ib2wvaXRlcmF0b3JcIik7IiwicmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIGVudHJ5VmlydHVhbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVybmFscy9lbnRyeS12aXJ0dWFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLnZhbHVlcztcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9lcy9hcnJheS92aXJ0dWFsL3ZhbHVlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvcicpO1xudmFyIHZhbHVlcyA9IHJlcXVpcmUoJy4uL2FycmF5L3ZpcnR1YWwvdmFsdWVzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgTm9kZUxpc3Q6IHRydWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC52YWx1ZXM7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgKGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS52YWx1ZXMpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHx8IERPTUl0ZXJhYmxlcy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKGl0KSkgPyB2YWx1ZXMgOiBvd247XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS92YWx1ZXNcIik7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdCcpO1xuXG52YXIgdGVzdCA9IFtdO1xudmFyIG5hdGl2ZVNvcnQgPSB0ZXN0LnNvcnQ7XG5cbi8vIElFOC1cbnZhciBGQUlMU19PTl9VTkRFRklORUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSk7XG4vLyBWOCBidWdcbnZhciBGQUlMU19PTl9OVUxMID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQobnVsbCk7XG59KTtcbi8vIE9sZCBXZWJLaXRcbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnc29ydCcpO1xuXG52YXIgRk9SQ0VEID0gRkFJTFNfT05fVU5ERUZJTkVEIHx8ICFGQUlMU19PTl9OVUxMIHx8ICFTVFJJQ1RfTUVUSE9EO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvcnRcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/IG5hdGl2ZVNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcbiAgICAgIDogbmF0aXZlU29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5zb3J0Jyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5Jykuc29ydDtcbiIsInZhciBzb3J0ID0gcmVxdWlyZSgnLi4vYXJyYXkvdmlydHVhbC9zb3J0Jyk7XG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNvcnQ7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgKGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5zb3J0KSA/IHNvcnQgOiBvd247XG59O1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2luc3RhbmNlL3NvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3NvcnRcIik7IiwicmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIGVudHJ5VmlydHVhbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVybmFscy9lbnRyeS12aXJ0dWFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLmtleXM7XG4iLCJ2YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZXMvYXJyYXkvdmlydHVhbC9rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yJyk7XG52YXIga2V5cyA9IHJlcXVpcmUoJy4uL2FycmF5L3ZpcnR1YWwva2V5cycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIE5vZGVMaXN0OiB0cnVlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQua2V5cztcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCAoaXQgaW5zdGFuY2VvZiBBcnJheSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlLmtleXMpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHx8IERPTUl0ZXJhYmxlcy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKGl0KSkgPyBrZXlzIDogb3duO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvaW5zdGFuY2Uva2V5c1wiKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkc29tZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5zb21lO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdCcpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC11c2VzLXRvLWxlbmd0aCcpO1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ3NvbWUnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdzb21lJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNUUklDVF9NRVRIT0QgfHwgIVVTRVNfVE9fTEVOR1RIIH0sIHtcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5zb21lJyk7XG52YXIgZW50cnlWaXJ0dWFsID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2VudHJ5LXZpcnR1YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5Jykuc29tZTtcbiIsInZhciBzb21lID0gcmVxdWlyZSgnLi4vYXJyYXkvdmlydHVhbC9zb21lJyk7XG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNvbWU7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgKGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5zb21lKSA/IHNvbWUgOiBvd247XG59O1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2luc3RhbmNlL3NvbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3NvbWVcIik7IiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbiIsInZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciBGUkVFWklORyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mcmVlemluZycpO1xuXG52YXIgTUVUQURBVEEgPSB1aWQoJ21ldGEnKTtcbnZhciBpZCA9IDA7XG5cbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgZGVmaW5lUHJvcGVydHkoaXQsIE1FVEFEQVRBLCB7IHZhbHVlOiB7XG4gICAgb2JqZWN0SUQ6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHdlYWtEYXRhOiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcblxudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YWRhdGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFEQVRBXS5vYmplY3RJRDtcbn07XG5cbnZhciBnZXRXZWFrRGF0YSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YWRhdGEoaXQpO1xuICAvLyByZXR1cm4gdGhlIHN0b3JlIG9mIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFEQVRBXS53ZWFrRGF0YTtcbn07XG5cbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWklORyAmJiBtZXRhLlJFUVVJUkVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQURBVEEpKSBzZXRNZXRhZGF0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJFUVVJUkVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2Vha0RhdGE6IGdldFdlYWtEYXRhLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cbmhpZGRlbktleXNbTUVUQURBVEFdID0gdHJ1ZTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1jbG9zZScpO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcbiAgdmFyIEFTX0VOVFJJRVMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuQVNfRU5UUklFUyk7XG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XG4gIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gIHZhciBmbiA9IGJpbmQodW5ib3VuZEZ1bmN0aW9uLCB0aGF0LCAxICsgQVNfRU5UUklFUyArIElOVEVSUlVQVEVEKTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIGNvbmRpdGlvbik7XG4gIH07XG5cbiAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChBU19FTlRSSUVTKSB7XG4gICAgICBhbk9iamVjdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTtcbiAgfVxuXG4gIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICB3aGlsZSAoIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0ICcgKyAobmFtZSA/IG5hbWUgKyAnICcgOiAnJykgKyAnaW52b2NhdGlvbicpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4vZXhwb3J0Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZvckVhY2g7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FLCB3cmFwcGVyLCBjb21tb24pIHtcbiAgdmFyIElTX01BUCA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignTWFwJykgIT09IC0xO1xuICB2YXIgSVNfV0VBSyA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignV2VhaycpICE9PSAtMTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsW0NPTlNUUlVDVE9SX05BTUVdO1xuICB2YXIgTmF0aXZlUHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IgJiYgTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICB2YXIgZXhwb3J0ZWQgPSB7fTtcbiAgdmFyIENvbnN0cnVjdG9yO1xuXG4gIGlmICghREVTQ1JJUFRPUlMgfHwgdHlwZW9mIE5hdGl2ZUNvbnN0cnVjdG9yICE9ICdmdW5jdGlvbidcbiAgICB8fCAhKElTX1dFQUsgfHwgTmF0aXZlUHJvdG90eXBlLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHsgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTsgfSkpXG4gICkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5SRVFVSVJFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKGFuSW5zdGFuY2UodGFyZ2V0LCBDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSksIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgY29sbGVjdGlvbjogbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKClcbiAgICAgIH0pO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZShpdGVyYWJsZSwgdGFyZ2V0W0FEREVSXSwgeyB0aGF0OiB0YXJnZXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcbiAgICB9KTtcblxuICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcblxuICAgIGZvckVhY2goWydhZGQnLCAnY2xlYXInLCAnZGVsZXRlJywgJ2ZvckVhY2gnLCAnZ2V0JywgJ2hhcycsICdzZXQnLCAna2V5cycsICd2YWx1ZXMnLCAnZW50cmllcyddLCBmdW5jdGlvbiAoS0VZKSB7XG4gICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT0gJ2FkZCcgfHwgS0VZID09ICdzZXQnO1xuICAgICAgaWYgKEtFWSBpbiBOYXRpdmVQcm90b3R5cGUgJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29uc3RydWN0b3IucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmNvbGxlY3Rpb247XG4gICAgICAgICAgaWYgKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSkgcmV0dXJuIEtFWSA9PSAnZ2V0JyA/IHVuZGVmaW5lZCA6IGZhbHNlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb2xsZWN0aW9uW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIElTX1dFQUsgfHwgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5jb2xsZWN0aW9uLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgZmFsc2UsIHRydWUpO1xuXG4gIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gQ29uc3RydWN0b3I7XG4gICQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCBleHBvcnRlZCk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5zYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4oQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTXSkge1xuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lLWFsbCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvcicpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEnKS5mYXN0S2V5O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgIGluZGV4OiBjcmVhdGUobnVsbCksXG4gICAgICAgIGZpcnN0OiB1bmRlZmluZWQsXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZTogMFxuICAgICAgfSk7XG4gICAgICBpZiAoIURFU0NSSVBUT1JTKSB0aGF0LnNpemUgPSAwO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHsgdGhhdDogdGhhdCwgQVNfRU5UUklFUzogSVNfTUFQIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgIHZhciBwcmV2aW91cywgaW5kZXg7XG4gICAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdCA9IGVudHJ5ID0ge1xuICAgICAgICAgIGluZGV4OiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSxcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzID0gc3RhdGUubGFzdCxcbiAgICAgICAgICBuZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgcmVtb3ZlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdGF0ZS5maXJzdCkgc3RhdGUuZmlyc3QgPSBlbnRyeTtcbiAgICAgICAgaWYgKHByZXZpb3VzKSBwcmV2aW91cy5uZXh0ID0gZW50cnk7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSsrO1xuICAgICAgICBlbHNlIHRoYXQuc2l6ZSsrO1xuICAgICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHN0YXRlLmluZGV4W2luZGV4XSA9IGVudHJ5O1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIC8vIGZhc3QgY2FzZVxuICAgICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICAgICAgdmFyIGVudHJ5O1xuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiBzdGF0ZS5pbmRleFtpbmRleF07XG4gICAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgICAgIGZvciAoZW50cnkgPSBzdGF0ZS5maXJzdDsgZW50cnk7IGVudHJ5ID0gZW50cnkubmV4dCkge1xuICAgICAgICBpZiAoZW50cnkua2V5ID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZGF0YSA9IHN0YXRlLmluZGV4O1xuICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcbiAgICAgICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnByZXZpb3VzKSBlbnRyeS5wcmV2aW91cyA9IGVudHJ5LnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5maXJzdCA9IHN0YXRlLmxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSA9IDA7XG4gICAgICAgIGVsc2UgdGhhdC5zaXplID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmluZGV4W2VudHJ5LmluZGV4XTtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wcmV2aW91cyA9IHByZXY7XG4gICAgICAgICAgaWYgKHN0YXRlLmZpcnN0ID09IGVudHJ5KSBzdGF0ZS5maXJzdCA9IG5leHQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmxhc3QgPT0gZW50cnkpIHN0YXRlLmxhc3QgPSBwcmV2O1xuICAgICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZS0tO1xuICAgICAgICAgIGVsc2UgdGhhdC5zaXplLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5maXJzdCkge1xuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIElTX01BUCA/IHtcbiAgICAgIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudmFsdWU7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSA6IHtcbiAgICAgIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eShDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKSB7XG4gICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XG4gICAgdmFyIGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB2YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihJVEVSQVRPUl9OQU1FKTtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgZGVmaW5lSXRlcmF0b3IoQywgQ09OU1RSVUNUT1JfTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogSVRFUkFUT1JfTkFNRSxcbiAgICAgICAgdGFyZ2V0OiBpdGVyYXRlZCxcbiAgICAgICAgc3RhdGU6IGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlKGl0ZXJhdGVkKSxcbiAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgbGFzdDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gICAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5sYXN0O1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXN0YXRlLnRhcmdldCB8fCAhKHN0YXRlLmxhc3QgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLnN0YXRlLmZpcnN0KSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGVudHJ5LmtleSwgZG9uZTogZmFsc2UgfTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogZW50cnkudmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICByZXR1cm4geyB2YWx1ZTogW2VudHJ5LmtleSwgZW50cnkudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24nKTtcbnZhciBjb2xsZWN0aW9uU3Ryb25nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIGBNYXBgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXAtb2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSBjb2xsZWN0aW9uKCdNYXAnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIGNvbGxlY3Rpb25TdHJvbmcpO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5tYXAnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvcicpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguTWFwO1xuIiwidmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL21hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvbWFwXCIpOyIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9vYmplY3QvY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL2ZlYXR1cmVzL29iamVjdC9jcmVhdGVcIik7IiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2ZcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgc2V0UHJvdG90eXBlT2Y6IHNldFByb3RvdHlwZU9mXG59KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9mZWF0dXJlcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTsiLCJ2YXIgX09iamVjdCRzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIik7XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gX09iamVjdCRzZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgX09iamVjdCRjcmVhdGUgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL29iamVjdC9jcmVhdGVcIik7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IF9PYmplY3QkY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJ2YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvZmVhdHVyZXMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIik7IiwidmFyIF9PYmplY3QkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIik7XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gX09iamVjdCRzZXRQcm90b3R5cGVPZiA/IF9PYmplY3QkZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBfT2JqZWN0JGdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbnZhciBnZXRSYW5kb21WYWx1ZXM7XG52YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyIsImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyIsImltcG9ydCB7IEFzc2lnbmFibGUgfSBmcm9tIFwidmlzLXV0aWwvZXNuZXh0XCI7XG5pbXBvcnQgeyBEYXRhU2V0IH0gZnJvbSBcIi4vZGF0YS1zZXRcIjtcbmltcG9ydCB7IERhdGFTdHJlYW0gfSBmcm9tIFwiLi9kYXRhLXN0cmVhbVwiO1xuXG50eXBlIFZhbHVlT2Y8VD4gPSBUW2tleW9mIFRdO1xuXG4vKiogVmFsaWQgaWQgdHlwZS4gKi9cbmV4cG9ydCB0eXBlIElkID0gbnVtYmVyIHwgc3RyaW5nO1xuLyoqIE51bGxhYmxlIGlkIHR5cGUuICovXG5leHBvcnQgdHlwZSBPcHRJZCA9IHVuZGVmaW5lZCB8IG51bGwgfCBJZDtcbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZSBvZiB1bmtub3duIHR5cGUuXG4gKlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdmFsaWQgaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSWQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBJZCB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuXG4vKipcbiAqIE1ha2UgYW4gb2JqZWN0IGRlZXBseSBwYXJ0aWFsLlxuICovXG5leHBvcnQgdHlwZSBEZWVwUGFydGlhbDxUPiA9IFQgZXh0ZW5kcyBhbnlbXSB8IEZ1bmN0aW9uIHwgTm9kZVxuICA/IFRcbiAgOiBUIGV4dGVuZHMgb2JqZWN0XG4gID8geyBba2V5IGluIGtleW9mIFRdPzogRGVlcFBhcnRpYWw8VFtrZXldPiB9XG4gIDogVDtcblxuLyoqXG4gKiBBbiBpdGVtIHRoYXQgbWF5IChbW0lkXV0pIG9yIG1heSBub3QgKGFic2VudCwgdW5kZWZpbmVkIG9yIG51bGwpIGhhdmUgYW4gaWQgcHJvcGVydHkuXG4gKlxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cbiAqL1xuZXhwb3J0IHR5cGUgUGFydEl0ZW08SWRQcm9wIGV4dGVuZHMgc3RyaW5nPiA9IFBhcnRpYWw8UmVjb3JkPElkUHJvcCwgT3B0SWQ+Pjtcbi8qKlxuICogQW4gaXRlbSB0aGF0IGhhcyBhIHByb3BlcnR5IGNvbnRhaW5pbmcgYW4gaWQgYW5kIGFsbCBvdGhlciByZXF1aXJlZCBwcm9wZXJ0aWVzIG9mIGdpdmVuIGl0ZW0gdHlwZS5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cbiAqL1xuZXhwb3J0IHR5cGUgRnVsbEl0ZW08XG4gIEl0ZW0gZXh0ZW5kcyBQYXJ0SXRlbTxJZFByb3A+LFxuICBJZFByb3AgZXh0ZW5kcyBzdHJpbmdcbj4gPSBJdGVtICYgUmVjb3JkPElkUHJvcCwgSWQ+O1xuLyoqXG4gKiBBbiBpdGVtIHRoYXQgaGFzIGEgcHJvcGVydHkgY29udGFpbmluZyBhbiBpZCBhbmQgb3B0aW9uYWxseSBvdGhlciBwcm9wZXJ0aWVzIG9mIGdpdmVuIGl0ZW0gdHlwZS5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cbiAqL1xuZXhwb3J0IHR5cGUgVXBkYXRlSXRlbTxcbiAgSXRlbSBleHRlbmRzIFBhcnRJdGVtPElkUHJvcD4sXG4gIElkUHJvcCBleHRlbmRzIHN0cmluZ1xuPiA9IEFzc2lnbmFibGU8RnVsbEl0ZW08SXRlbSwgSWRQcm9wPj4gJiBSZWNvcmQ8SWRQcm9wLCBJZD47XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIGl0ZW0gaGFzIGFuIGlkIChpcyBhIFtbRnVsbEl0ZW1dXSkuXG4gKlxuICogQHBhcmFtIGl0ZW0gLSBUaGUgaXRlbSB0byBiZSB0ZXN0ZWQuXG4gKiBAcGFyYW0gaWRQcm9wIC0gTmFtZSBvZiB0aGUgaWQgcHJvcGVydHkuXG4gKlxuICogQHR5cGVQYXJhbSBJdGVtIC0gSXRlbSB0eXBlIHRoYXQgbWF5IG9yIG1heSBub3QgaGF2ZSBhbiBpZC5cbiAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXG4gKlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIHZhbHVlIGlzIGEgW1tGdWxsSXRlbV1dLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bGxJdGVtPFxuICBJdGVtIGV4dGVuZHMgUGFydEl0ZW08SWRQcm9wPixcbiAgSWRQcm9wIGV4dGVuZHMgc3RyaW5nXG4+KGl0ZW06IEl0ZW0sIGlkUHJvcDogSWRQcm9wKTogaXRlbSBpcyBGdWxsSXRlbTxJdGVtLCBJZFByb3A+IHtcbiAgcmV0dXJuIGl0ZW1baWRQcm9wXSAhPSBudWxsO1xufVxuXG4vKiogQWRkIGV2ZW50IHBheWxvYWQuICovXG5leHBvcnQgaW50ZXJmYWNlIEFkZEV2ZW50UGF5bG9hZCB7XG4gIC8qKiBJZHMgb2YgYWRkZWQgaXRlbXMuICovXG4gIGl0ZW1zOiBJZFtdO1xufVxuLyoqIFVwZGF0ZSBldmVudCBwYXlsb2FkLiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVFdmVudFBheWxvYWQ8SXRlbSwgSWRQcm9wIGV4dGVuZHMgc3RyaW5nPiB7XG4gIC8qKiBJZHMgb2YgdXBkYXRlZCBpdGVtcy4gKi9cbiAgaXRlbXM6IElkW107XG4gIC8qKiBJdGVtcyBhcyB0aGV5IHdlcmUgYmVmb3JlIHRoaXMgdXBkYXRlLiAqL1xuICBvbGREYXRhOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W107XG4gIC8qKlxuICAgKiBJdGVtcyBhcyB0aGV5IGFyZSBub3cuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEp1c3QgZ2V0IHRoZSBkYXRhIGZyb20gdGhlIGRhdGEgc2V0IG9yIGRhdGEgdmlldy5cbiAgICovXG4gIGRhdGE6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD5bXTtcbn1cbi8qKiBSZW1vdmUgZXZlbnQgcGF5bG9hZC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3ZlRXZlbnRQYXlsb2FkPEl0ZW0sIElkUHJvcCBleHRlbmRzIHN0cmluZz4ge1xuICAvKiogSWRzIG9mIHJlbW92ZWQgaXRlbXMuICovXG4gIGl0ZW1zOiBJZFtdO1xuICAvKiogSXRlbXMgYXMgdGhleSB3ZXJlIGJlZm9yZSB0aGVpciByZW1vdmFsLiAqL1xuICBvbGREYXRhOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W107XG59XG5cbi8qKlxuICogTWFwIG9mIGV2ZW50IHBheWxvYWQgdHlwZXMgKGV2ZW50IG5hbWUg4oaSIHBheWxvYWQpLlxuICpcbiAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXG4gKiBAdHlwZVBhcmFtIElkUHJvcCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGlkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50UGF5bG9hZHM8SXRlbSwgSWRQcm9wIGV4dGVuZHMgc3RyaW5nPiB7XG4gIGFkZDogQWRkRXZlbnRQYXlsb2FkO1xuICB1cGRhdGU6IFVwZGF0ZUV2ZW50UGF5bG9hZDxJdGVtLCBJZFByb3A+O1xuICByZW1vdmU6IFJlbW92ZUV2ZW50UGF5bG9hZDxJdGVtLCBJZFByb3A+O1xufVxuLyoqXG4gKiBNYXAgb2YgZXZlbnQgcGF5bG9hZCB0eXBlcyBpbmNsdWRpbmcgYW55IGV2ZW50IChldmVudCBuYW1lIOKGkiBwYXlsb2FkKS5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFdmVudFBheWxvYWRzV2l0aEFueTxJdGVtLCBJZFByb3AgZXh0ZW5kcyBzdHJpbmc+XG4gIGV4dGVuZHMgRXZlbnRQYXlsb2FkczxJdGVtLCBJZFByb3A+IHtcbiAgXCIqXCI6IFZhbHVlT2Y8RXZlbnRQYXlsb2FkczxJdGVtLCBJZFByb3A+Pjtcbn1cblxuLyoqXG4gKiBNYXAgb2YgZXZlbnQgY2FsbGJhY2sgdHlwZXMgKGV2ZW50IG5hbWUg4oaSIGNhbGxiYWNrKS5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFdmVudENhbGxiYWNrczxJdGVtLCBJZFByb3AgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChbW0V2ZW50TmFtZV1dKS5cbiAgICogQHBhcmFtIHBheWxvYWQgLSBEYXRhIGFib3V0IHRoZSBpdGVtcyBhZmZlY3RlZCBieSB0aGlzIGV2ZW50LlxuICAgKiBAcGFyYW0gc2VuZGVySWQgLSBBIHNlbmRlcklkLCBvcHRpb25hbGx5IHByb3ZpZGVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBjb2RlIHdoaWNoIHRyaWdnZXJlZCB0aGUgZXZlbnQuIElmIHNlbmRlcklkIGlzIG5vdCBwcm92aWRlZCwgdGhlIGFyZ3VtZW50IHdpbGwgYmUgYG51bGxgLlxuICAgKi9cbiAgYWRkKG5hbWU6IFwiYWRkXCIsIHBheWxvYWQ6IEFkZEV2ZW50UGF5bG9hZCB8IG51bGwsIHNlbmRlcklkPzogSWQgfCBudWxsKTogdm9pZDtcbiAgLyoqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChbW0V2ZW50TmFtZV1dKS5cbiAgICogQHBhcmFtIHBheWxvYWQgLSBEYXRhIGFib3V0IHRoZSBpdGVtcyBhZmZlY3RlZCBieSB0aGlzIGV2ZW50LlxuICAgKiBAcGFyYW0gc2VuZGVySWQgLSBBIHNlbmRlcklkLCBvcHRpb25hbGx5IHByb3ZpZGVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBjb2RlIHdoaWNoIHRyaWdnZXJlZCB0aGUgZXZlbnQuIElmIHNlbmRlcklkIGlzIG5vdCBwcm92aWRlZCwgdGhlIGFyZ3VtZW50IHdpbGwgYmUgYG51bGxgLlxuICAgKi9cbiAgdXBkYXRlKFxuICAgIG5hbWU6IFwidXBkYXRlXCIsXG4gICAgcGF5bG9hZDogVXBkYXRlRXZlbnRQYXlsb2FkPEl0ZW0sIElkUHJvcD4gfCBudWxsLFxuICAgIHNlbmRlcklkPzogSWQgfCBudWxsXG4gICk6IHZvaWQ7XG4gIC8qKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoW1tFdmVudE5hbWVdXSkuXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gRGF0YSBhYm91dCB0aGUgaXRlbXMgYWZmZWN0ZWQgYnkgdGhpcyBldmVudC5cbiAgICogQHBhcmFtIHNlbmRlcklkIC0gQSBzZW5kZXJJZCwgb3B0aW9uYWxseSBwcm92aWRlZCBieSB0aGUgYXBwbGljYXRpb24gY29kZSB3aGljaCB0cmlnZ2VyZWQgdGhlIGV2ZW50LiBJZiBzZW5kZXJJZCBpcyBub3QgcHJvdmlkZWQsIHRoZSBhcmd1bWVudCB3aWxsIGJlIGBudWxsYC5cbiAgICovXG4gIHJlbW92ZShcbiAgICBuYW1lOiBcInJlbW92ZVwiLFxuICAgIHBheWxvYWQ6IFJlbW92ZUV2ZW50UGF5bG9hZDxJdGVtLCBJZFByb3A+IHwgbnVsbCxcbiAgICBzZW5kZXJJZD86IElkIHwgbnVsbFxuICApOiB2b2lkO1xufVxuLyoqXG4gKiBNYXAgb2YgZXZlbnQgY2FsbGJhY2sgdHlwZXMgaW5jbHVkaW5nIGFueSBldmVudCAoZXZlbnQgbmFtZSDihpIgY2FsbGJhY2spLlxuICpcbiAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXG4gKiBAdHlwZVBhcmFtIElkUHJvcCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGlkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50Q2FsbGJhY2tzV2l0aEFueTxJdGVtLCBJZFByb3AgZXh0ZW5kcyBzdHJpbmc+XG4gIGV4dGVuZHMgRXZlbnRDYWxsYmFja3M8SXRlbSwgSWRQcm9wPiB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoW1tFdmVudE5hbWVdXSkuXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gRGF0YSBhYm91dCB0aGUgaXRlbXMgYWZmZWN0ZWQgYnkgdGhpcyBldmVudC5cbiAgICogQHBhcmFtIHNlbmRlcklkIC0gQSBzZW5kZXJJZCwgb3B0aW9uYWxseSBwcm92aWRlZCBieSB0aGUgYXBwbGljYXRpb24gY29kZSB3aGljaCB0cmlnZ2VyZWQgdGhlIGV2ZW50LiBJZiBzZW5kZXJJZCBpcyBub3QgcHJvdmlkZWQsIHRoZSBhcmd1bWVudCB3aWxsIGJlIGBudWxsYC5cbiAgICovXG4gIFwiKlwiPE4gZXh0ZW5kcyBrZXlvZiBFdmVudENhbGxiYWNrczxJdGVtLCBJZFByb3A+PihcbiAgICBuYW1lOiBOLFxuICAgIHBheWxvYWQ6IEV2ZW50UGF5bG9hZHM8SXRlbSwgSWRQcm9wPltOXSxcbiAgICBzZW5kZXJJZD86IElkIHwgbnVsbFxuICApOiB2b2lkO1xufVxuXG4vKiogQXZhaWxhYmxlIGV2ZW50IG5hbWVzLiAqL1xuZXhwb3J0IHR5cGUgRXZlbnROYW1lID0ga2V5b2YgRXZlbnRQYXlsb2FkczxuZXZlciwgXCJcIj47XG4vKiogQXZhaWxhYmxlIGV2ZW50IG5hbWVzIGFuZCAnKicgdG8gbGlzdGVuIGZvciBhbGwuICovXG5leHBvcnQgdHlwZSBFdmVudE5hbWVXaXRoQW55ID0ga2V5b2YgRXZlbnRQYXlsb2Fkc1dpdGhBbnk8bmV2ZXIsIFwiXCI+O1xuXG4vKipcbiAqIERhdGEgaW50ZXJmYWNlIG9yZGVyIHBhcmFtZXRlci5cbiAqIC0gQSBzdHJpbmcgdmFsdWUgZGV0ZXJtaW5lcyB3aGljaCBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQgZm9yIHNvcnRpbmcgKHVzaW5nIDwgYW5kID4gb3BlcmF0b3JzIGZvciBudW1lcmljIGNvbXBhcmlzb24pLlxuICogLSBBIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCB0aGUgc2FtZSB3YXkgYXMgaW4gQXJyYXkuc29ydC5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICovXG5leHBvcnQgdHlwZSBEYXRhSW50ZXJmYWNlT3JkZXI8SXRlbT4gPVxuICB8IGtleW9mIEl0ZW1cbiAgfCAoKGE6IEl0ZW0sIGI6IEl0ZW0pID0+IG51bWJlcik7XG5cbi8qKlxuICogRGF0YSBpbnRlcmZhY2UgZ2V0IG9wdGlvbnMgKHJldHVybiB0eXBlIGluZGVwZW5kZW50KS5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERhdGFJbnRlcmZhY2VHZXRPcHRpb25zQmFzZTxJdGVtPiB7XG4gIC8qKlxuICAgKiBBbiBhcnJheSB3aXRoIGZpZWxkIG5hbWVzLCBvciBhbiBvYmplY3Qgd2l0aCBjdXJyZW50IGZpZWxkIG5hbWUgYW5kIG5ldyBmaWVsZCBuYW1lIHRoYXQgdGhlIGZpZWxkIGlzIHJldHVybmVkIGFzLiBCeSBkZWZhdWx0LCBhbGwgcHJvcGVydGllcyBvZiB0aGUgaXRlbXMgYXJlIGVtaXR0ZWQuIFdoZW4gZmllbGRzIGlzIGRlZmluZWQsIG9ubHkgdGhlIHByb3BlcnRpZXMgd2hvc2UgbmFtZSBpcyBzcGVjaWZpZWQgaW4gZmllbGRzIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJldHVybmVkIGl0ZW1zLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiAqKldhcm5pbmcqKjogVGhlcmUgaXMgbm8gVHlwZVNjcmlwdCBzdXBwb3J0IGZvciB0aGlzLlxuICAgKi9cbiAgZmllbGRzPzogc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAvKiogSXRlbXMgY2FuIGJlIGZpbHRlcmVkIG9uIHNwZWNpZmljIHByb3BlcnRpZXMgYnkgcHJvdmlkaW5nIGEgZmlsdGVyIGZ1bmN0aW9uLiBBIGZpbHRlciBmdW5jdGlvbiBpcyBleGVjdXRlZCBmb3IgZWFjaCBvZiB0aGUgaXRlbXMgaW4gdGhlIERhdGFTZXQsIGFuZCBpcyBjYWxsZWQgd2l0aCB0aGUgaXRlbSBhcyBwYXJhbWV0ZXIuIFRoZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIGJvb2xlYW4uIEFsbCBpdGVtcyBmb3Igd2hpY2ggdGhlIGZpbHRlciBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2lsbCBiZSBlbWl0dGVkLiAqL1xuICBmaWx0ZXI/OiAoaXRlbTogSXRlbSkgPT4gYm9vbGVhbjtcbiAgLyoqIE9yZGVyIHRoZSBpdGVtcyBieSBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uICovXG4gIG9yZGVyPzogRGF0YUludGVyZmFjZU9yZGVyPEl0ZW0+O1xufVxuXG4vKipcbiAqIERhdGEgaW50ZXJmYWNlIGdldCBvcHRpb25zIChyZXR1cm5zIGEgc2luZ2xlIGl0ZW0gb3IgYW4gYXJyYXkpLlxuICpcbiAqIEByZW1hcmtzXG4gKiBXaGV0aGVyIGFuIGl0ZW0gb3IgYW5kIGFycmF5IG9mIGl0ZW1zIGlzIHJldHVybmVkIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgb2YgdGhlIGlkKHMpIGFyZ3VtZW50LlxuICogSWYgYW4gYXJyYXkgb2YgaWRzIGlzIHJlcXVlc3RlZCBhbiBhcnJheSBvZiBpdGVtcyB3aWxsIGJlIHJldHVybmVkLlxuICogSWYgYSBzaW5nbGUgaWQgaXMgcmVxdWVzdGVkIGEgc2luZ2xlIGl0ZW0gKG9yIG51bGwgaWYgdGhlIGlkIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhbnkgaXRlbSkgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERhdGFJbnRlcmZhY2VHZXRPcHRpb25zQXJyYXk8SXRlbT5cbiAgZXh0ZW5kcyBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uc0Jhc2U8SXRlbT4ge1xuICAvKiogSXRlbXMgd2lsbCBiZSByZXR1cm5lZCBhcyBhIHNpbmdsZSBpdGVtIChpZiBpbnZva2VkIHdpdGggYW4gaWQpIG9yIGFuIGFycmF5IG9mIGl0ZW1zIChpZiBpbnZva2VkIHdpdGggYW4gYXJyYXkgb2YgaWRzKS4gKi9cbiAgcmV0dXJuVHlwZT86IHVuZGVmaW5lZCB8IFwiQXJyYXlcIjtcbn1cbi8qKlxuICogRGF0YSBpbnRlcmZhY2UgZ2V0IG9wdGlvbnMgKHJldHVybnMgYW4gb2JqZWN0KS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHJldHVybmVkIG9iamVjdCBoYXMgaWRzIGFzIGtleXMgYW5kIGl0ZW1zIGFzIHZhbHVlcyBvZiBjb3JyZXNwb25kaW5nIGlkcy5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERhdGFJbnRlcmZhY2VHZXRPcHRpb25zT2JqZWN0PEl0ZW0+XG4gIGV4dGVuZHMgRGF0YUludGVyZmFjZUdldE9wdGlvbnNCYXNlPEl0ZW0+IHtcbiAgLyoqIEl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gb2JqZWN0IG1hcCAoaWQg4oaSIGl0ZW0pLiAqL1xuICByZXR1cm5UeXBlOiBcIk9iamVjdFwiO1xufVxuLyoqXG4gKiBEYXRhIGludGVyZmFjZSBnZXQgb3B0aW9ucyAocmV0dXJucyBzaW5nbGUgaXRlbSwgYW4gYXJyYXkgb3Igb2JqZWN0KS5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICovXG5leHBvcnQgdHlwZSBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uczxJdGVtPiA9XG4gIHwgRGF0YUludGVyZmFjZUdldE9wdGlvbnNBcnJheTxJdGVtPlxuICB8IERhdGFJbnRlcmZhY2VHZXRPcHRpb25zT2JqZWN0PEl0ZW0+O1xuXG4vKipcbiAqIERhdGEgaW50ZXJmYWNlIGdldCBpZHMgb3B0aW9ucy5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERhdGFJbnRlcmZhY2VHZXRJZHNPcHRpb25zPEl0ZW0+IHtcbiAgLyoqIEl0ZW1zIGNhbiBiZSBmaWx0ZXJlZCBvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzIGJ5IHByb3ZpZGluZyBhIGZpbHRlciBmdW5jdGlvbi4gQSBmaWx0ZXIgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZm9yIGVhY2ggb2YgdGhlIGl0ZW1zIGluIHRoZSBEYXRhU2V0LCBhbmQgaXMgY2FsbGVkIHdpdGggdGhlIGl0ZW0gYXMgcGFyYW1ldGVyLiBUaGUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBib29sZWFuLiBBbGwgaXRlbXMgZm9yIHdoaWNoIHRoZSBmaWx0ZXIgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdpbGwgYmUgZW1pdHRlZC4gKi9cbiAgZmlsdGVyPzogKGl0ZW06IEl0ZW0pID0+IGJvb2xlYW47XG4gIC8qKiBPcmRlciB0aGUgaXRlbXMgYnkgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLiAqL1xuICBvcmRlcj86IERhdGFJbnRlcmZhY2VPcmRlcjxJdGVtPjtcbn1cblxuLyoqXG4gKiBEYXRhIGludGVyZmFjZSBmb3IgZWFjaCBvcHRpb25zLlxuICpcbiAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YUludGVyZmFjZUZvckVhY2hPcHRpb25zPEl0ZW0+IHtcbiAgLyoqIEFuIGFycmF5IHdpdGggZmllbGQgbmFtZXMsIG9yIGFuIG9iamVjdCB3aXRoIGN1cnJlbnQgZmllbGQgbmFtZSBhbmQgbmV3IGZpZWxkIG5hbWUgdGhhdCB0aGUgZmllbGQgaXMgcmV0dXJuZWQgYXMuIEJ5IGRlZmF1bHQsIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBpdGVtcyBhcmUgZW1pdHRlZC4gV2hlbiBmaWVsZHMgaXMgZGVmaW5lZCwgb25seSB0aGUgcHJvcGVydGllcyB3aG9zZSBuYW1lIGlzIHNwZWNpZmllZCBpbiBmaWVsZHMgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmV0dXJuZWQgaXRlbXMuICovXG4gIGZpZWxkcz86IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgLyoqIEl0ZW1zIGNhbiBiZSBmaWx0ZXJlZCBvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzIGJ5IHByb3ZpZGluZyBhIGZpbHRlciBmdW5jdGlvbi4gQSBmaWx0ZXIgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZm9yIGVhY2ggb2YgdGhlIGl0ZW1zIGluIHRoZSBEYXRhU2V0LCBhbmQgaXMgY2FsbGVkIHdpdGggdGhlIGl0ZW0gYXMgcGFyYW1ldGVyLiBUaGUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBib29sZWFuLiBBbGwgaXRlbXMgZm9yIHdoaWNoIHRoZSBmaWx0ZXIgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdpbGwgYmUgZW1pdHRlZC4gKi9cbiAgZmlsdGVyPzogKGl0ZW06IEl0ZW0pID0+IGJvb2xlYW47XG4gIC8qKiBPcmRlciB0aGUgaXRlbXMgYnkgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLiAqL1xuICBvcmRlcj86IERhdGFJbnRlcmZhY2VPcmRlcjxJdGVtPjtcbn1cblxuLyoqXG4gKiBEYXRhIGludGVyZmFjZSBtYXAgb3ByaW9ucy5cbiAqXG4gKiBAdHlwZVBhcmFtIE9yaWdpbmFsIC0gVGhlIG9yaWdpbmFsIGl0ZW0gdHlwZSBpbiB0aGUgZGF0YS5cbiAqIEB0eXBlUGFyYW0gTWFwcGVkIC0gVGhlIHR5cGUgYWZ0ZXIgbWFwcGluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEYXRhSW50ZXJmYWNlTWFwT3B0aW9uczxPcmlnaW5hbCwgTWFwcGVkPiB7XG4gIC8qKiBBbiBhcnJheSB3aXRoIGZpZWxkIG5hbWVzLCBvciBhbiBvYmplY3Qgd2l0aCBjdXJyZW50IGZpZWxkIG5hbWUgYW5kIG5ldyBmaWVsZCBuYW1lIHRoYXQgdGhlIGZpZWxkIGlzIHJldHVybmVkIGFzLiBCeSBkZWZhdWx0LCBhbGwgcHJvcGVydGllcyBvZiB0aGUgaXRlbXMgYXJlIGVtaXR0ZWQuIFdoZW4gZmllbGRzIGlzIGRlZmluZWQsIG9ubHkgdGhlIHByb3BlcnRpZXMgd2hvc2UgbmFtZSBpcyBzcGVjaWZpZWQgaW4gZmllbGRzIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJldHVybmVkIGl0ZW1zLiAqL1xuICBmaWVsZHM/OiBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIC8qKiBJdGVtcyBjYW4gYmUgZmlsdGVyZWQgb24gc3BlY2lmaWMgcHJvcGVydGllcyBieSBwcm92aWRpbmcgYSBmaWx0ZXIgZnVuY3Rpb24uIEEgZmlsdGVyIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGZvciBlYWNoIG9mIHRoZSBpdGVtcyBpbiB0aGUgRGF0YVNldCwgYW5kIGlzIGNhbGxlZCB3aXRoIHRoZSBpdGVtIGFzIHBhcmFtZXRlci4gVGhlIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgYm9vbGVhbi4gQWxsIGl0ZW1zIGZvciB3aGljaCB0aGUgZmlsdGVyIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB3aWxsIGJlIGVtaXR0ZWQuICovXG4gIGZpbHRlcj86IChpdGVtOiBPcmlnaW5hbCkgPT4gYm9vbGVhbjtcbiAgLyoqIE9yZGVyIHRoZSBpdGVtcyBieSBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uICovXG4gIG9yZGVyPzogRGF0YUludGVyZmFjZU9yZGVyPE1hcHBlZD47XG59XG5cbi8qKlxuICogQ29tbW9uIGludGVyZmFjZSBmb3IgZGF0YSBzZXRzIGFuZCBkYXRhIHZpZXcuXG4gKlxuICogQHR5cGVQYXJhbSBJdGVtIC0gSXRlbSB0eXBlIHRoYXQgbWF5IG9yIG1heSBub3QgaGF2ZSBhbiBpZCAobWlzc2luZyBpZHMgd2lsbCBiZSBnZW5lcmF0ZWQgdXBvbiBpbnNlcnRpb24pLlxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSBvbiB0aGUgSXRlbSB0eXBlIHRoYXQgY29udGFpbnMgdGhlIGlkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERhdGFJbnRlcmZhY2U8XG4gIEl0ZW0gZXh0ZW5kcyBQYXJ0SXRlbTxJZFByb3A+LFxuICBJZFByb3AgZXh0ZW5kcyBzdHJpbmcgPSBcImlkXCJcbj4ge1xuICAvKiogVGhlIG51bWJlciBvZiBpdGVtcy4gKi9cbiAgbGVuZ3RoOiBudW1iZXI7XG5cbiAgLyoqIFRoZSBrZXkgb2YgaWQgcHJvcGVydHkuICovXG4gIGlkUHJvcDogSWRQcm9wO1xuXG4gIC8qKlxuICAgKiBBZGQgYSB1bml2ZXJzYWwgZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEByZW1hcmtzIFRoZSBgKmAgZXZlbnQgaXMgdHJpZ2dlcmVkIHdoZW4gYW55IG9mIHRoZSBldmVudHMgYGFkZGAsIGB1cGRhdGVgLCBhbmQgYHJlbW92ZWAgb2NjdXJzLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBFdmVudCBuYW1lLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIG9uKGV2ZW50OiBcIipcIiwgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2tzV2l0aEFueTxJdGVtLCBJZFByb3A+W1wiKlwiXSk6IHZvaWQ7XG4gIC8qKlxuICAgKiBBZGQgYW4gYGFkZGAgZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEByZW1hcmtzIFRoZSBgYWRkYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiBhbiBpdGVtIG9yIGEgc2V0IG9mIGl0ZW1zIGlzIGFkZGVkLCBvciB3aGVuIGFuIGl0ZW0gaXMgdXBkYXRlZCB3aGlsZSBub3QgeWV0IGV4aXN0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBFdmVudCBuYW1lLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIG9uKGV2ZW50OiBcImFkZFwiLCBjYWxsYmFjazogRXZlbnRDYWxsYmFja3NXaXRoQW55PEl0ZW0sIElkUHJvcD5bXCJhZGRcIl0pOiB2b2lkO1xuICAvKipcbiAgICogQWRkIGEgYHJlbW92ZWAgZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEByZW1hcmtzIFRoZSBgcmVtb3ZlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiBhbiBpdGVtIG9yIGEgc2V0IG9mIGl0ZW1zIGlzIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIEV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgb24oXG4gICAgZXZlbnQ6IFwicmVtb3ZlXCIsXG4gICAgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2tzV2l0aEFueTxJdGVtLCBJZFByb3A+W1wicmVtb3ZlXCJdXG4gICk6IHZvaWQ7XG4gIC8qKlxuICAgKiBBZGQgYW4gYHVwZGF0ZWAgZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEByZW1hcmtzIFRoZSBgdXBkYXRlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiBhbiBleGlzdGluZyBpdGVtIG9yIGEgc2V0IG9mIGV4aXN0aW5nIGl0ZW1zIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIEV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgb24oXG4gICAgZXZlbnQ6IFwidXBkYXRlXCIsXG4gICAgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2tzV2l0aEFueTxJdGVtLCBJZFByb3A+W1widXBkYXRlXCJdXG4gICk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHVuaXZlcnNhbCBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBvZmYoZXZlbnQ6IFwiKlwiLCBjYWxsYmFjazogRXZlbnRDYWxsYmFja3NXaXRoQW55PEl0ZW0sIElkUHJvcD5bXCIqXCJdKTogdm9pZDtcbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBgYWRkYCBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBvZmYoZXZlbnQ6IFwiYWRkXCIsIGNhbGxiYWNrOiBFdmVudENhbGxiYWNrc1dpdGhBbnk8SXRlbSwgSWRQcm9wPltcImFkZFwiXSk6IHZvaWQ7XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBgcmVtb3ZlYCBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBvZmYoXG4gICAgZXZlbnQ6IFwicmVtb3ZlXCIsXG4gICAgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2tzV2l0aEFueTxJdGVtLCBJZFByb3A+W1wicmVtb3ZlXCJdXG4gICk6IHZvaWQ7XG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gYHVwZGF0ZWAgZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIEV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgb2ZmKFxuICAgIGV2ZW50OiBcInVwZGF0ZVwiLFxuICAgIGNhbGxiYWNrOiBFdmVudENhbGxiYWNrc1dpdGhBbnk8SXRlbSwgSWRQcm9wPltcInVwZGF0ZVwiXVxuICApOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBpdGVtcy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGl0ZW1zLlxuICAgKi9cbiAgZ2V0KCk6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD5bXTtcbiAgLyoqXG4gICAqIEdldCBhbGwgdGhlIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyByZXF1ZXN0ZWQgaXRlbXMuXG4gICAqL1xuICBnZXQob3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnNBcnJheTxJdGVtPik6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD5bXTtcbiAgLyoqXG4gICAqIEdldCBhbGwgdGhlIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gb2JqZWN0IG1hcCBvZiBpdGVtcyAobWF5IGJlIGFuIGVtcHR5IG9iamVjdCBpZiB0aGVyZSBhcmUgbm8gaXRlbXMpLlxuICAgKi9cbiAgZ2V0KFxuICAgIG9wdGlvbnM6IERhdGFJbnRlcmZhY2VHZXRPcHRpb25zT2JqZWN0PEl0ZW0+XG4gICk6IFJlY29yZDxJZCwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPj47XG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBpdGVtcy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgcmVxdWVzdGVkIGl0ZW1zIG9yIGlmIHJlcXVlc3RlZCBhbiBvYmplY3QgbWFwIG9mIGl0ZW1zIChtYXkgYmUgYW4gZW1wdHkgb2JqZWN0IGlmIHRoZXJlIGFyZSBubyBpdGVtcykuXG4gICAqL1xuICBnZXQoXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnM8SXRlbT5cbiAgKTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdIHwgUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqXG4gICAqIEdldCBvbmUgaXRlbS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBpdGVtLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgaXRlbSBvciBudWxsIGlmIHRoZSBpZCBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gYW55IGl0ZW0uXG4gICAqL1xuICBnZXQoaWQ6IElkKTogbnVsbCB8IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD47XG4gIC8qKlxuICAgKiBHZXQgb25lIGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgaXRlbS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBpdGVtIG9yIG51bGwgaWYgdGhlIGlkIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhbnkgaXRlbS5cbiAgICovXG4gIGdldChcbiAgICBpZDogSWQsXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnNBcnJheTxJdGVtPlxuICApOiBudWxsIHwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPjtcbiAgLyoqXG4gICAqIEdldCBvbmUgaXRlbS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBpdGVtLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gb2JqZWN0IG1hcCBvZiBpdGVtcyAobWF5IGJlIGFuIGVtcHR5IG9iamVjdCBpZiBubyBpdGVtIHdhcyBmb3VuZCkuXG4gICAqL1xuICBnZXQoXG4gICAgaWQ6IElkLFxuICAgIG9wdGlvbnM6IERhdGFJbnRlcmZhY2VHZXRPcHRpb25zT2JqZWN0PEl0ZW0+XG4gICk6IFJlY29yZDxJZCwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPj47XG4gIC8qKlxuICAgKiBHZXQgb25lIGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgaXRlbS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBpdGVtIGlmIGZvdW5kIG9yIG51bGwgb3RoZXJ3aXNlLiBJZiByZXF1ZXN0ZWQgYW4gb2JqZWN0IG1hcCB3aXRoIDAgdG8gMSBpdGVtcy5cbiAgICovXG4gIGdldChcbiAgICBpZDogSWQsXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnM8SXRlbT5cbiAgKTogbnVsbCB8IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD4gfCBSZWNvcmQ8SWQsIEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD4+O1xuICAvKipcbiAgICogR2V0IG11bHRpcGxlIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0gaWRzIC0gQW4gYXJyYXkgb2YgcmVxdWVzdGVkIGlkcy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgZm91bmQgaXRlbXMgKGlkcyB0aGF0IGRvIG5vdCBjb3JyZXNwb25kIHRvIGFueSBpdGVtIGFyZSBvbWl0dGVkKS5cbiAgICovXG4gIGdldChpZHM6IElkW10pOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W107XG4gIC8qKlxuICAgKiBHZXQgbXVsdGlwbGUgaXRlbXMuXG4gICAqXG4gICAqIEBwYXJhbSBpZHMgLSBBbiBhcnJheSBvZiByZXF1ZXN0ZWQgaWRzLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgZm91bmQgaXRlbXMgKGlkcyB0aGF0IGRvIG5vdCBjb3JyZXNwb25kIHRvIGFueSBpdGVtIGFyZSBvbWl0dGVkKS5cbiAgICovXG4gIGdldChcbiAgICBpZHM6IElkW10sXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnNBcnJheTxJdGVtPlxuICApOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W107XG4gIC8qKlxuICAgKiBHZXQgbXVsdGlwbGUgaXRlbXMuXG4gICAqXG4gICAqIEBwYXJhbSBpZHMgLSBBbiBhcnJheSBvZiByZXF1ZXN0ZWQgaWRzLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gb2JqZWN0IG1hcCBvZiBpdGVtcyAobWF5IGJlIGFuIGVtcHR5IG9iamVjdCBpZiBubyBpdGVtIHdhcyBmb3VuZCkuXG4gICAqL1xuICBnZXQoXG4gICAgaWRzOiBJZFtdLFxuICAgIG9wdGlvbnM6IERhdGFJbnRlcmZhY2VHZXRPcHRpb25zT2JqZWN0PEl0ZW0+XG4gICk6IFJlY29yZDxJZCwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPj47XG4gIC8qKlxuICAgKiBHZXQgbXVsdGlwbGUgaXRlbXMuXG4gICAqXG4gICAqIEBwYXJhbSBpZHMgLSBBbiBhcnJheSBvZiByZXF1ZXN0ZWQgaWRzLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgZm91bmQgaXRlbXMgKGlkcyB0aGF0IGRvIG5vdCBjb3JyZXNwb25kIHRvIGFueSBpdGVtIGFyZSBvbWl0dGVkKS5cbiAgICogSWYgcmVxdWVzdGVkIGFuIG9iamVjdCBtYXAgb2YgaXRlbXMgKG1heSBiZSBhbiBlbXB0eSBvYmplY3QgaWYgbm8gaXRlbSB3YXMgZm91bmQpLlxuICAgKi9cbiAgZ2V0KFxuICAgIGlkczogSWRbXSxcbiAgICBvcHRpb25zOiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uczxJdGVtPlxuICApOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W10gfCBSZWNvcmQ8SWQsIEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD4+O1xuICAvKipcbiAgICogR2V0IGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0gaWRzIC0gSWQgb3IgaWRzIHRvIGJlIHJldHVybmVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc3BlY2lmeSBpdGVyYXRpb24gZGV0YWlscy5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGl0ZW1zIChmb3JtYXQgaXMgZGV0ZXJtaW5lZCBieSBpZHMgKHNpbmdsZSBvciBhcnJheSkgYW5kIHRoZSBvcHRpb25zLlxuICAgKi9cbiAgZ2V0KFxuICAgIGlkczogSWQgfCBJZFtdLFxuICAgIG9wdGlvbnM/OiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uczxJdGVtPlxuICApOlxuICAgIHwgbnVsbFxuICAgIHwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPlxuICAgIHwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdXG4gICAgfCBSZWNvcmQ8SWQsIEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD4+O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIERhdGFTZXQgdG8gd2hpY2ggdGhlIGluc3RhbmNlIGltcGxlbWVudGluZyB0aGlzIGludGVyZmFjZSBpcyBjb25uZWN0ZWQuXG4gICAqIEluIGNhc2UgdGhlcmUgaXMgYSBjaGFpbiBvZiBtdWx0aXBsZSBEYXRhVmlld3MsIHRoZSByb290IERhdGFTZXQgb2YgdGhpcyBjaGFpbiBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGRhdGEgc2V0IHRoYXQgYWN0dWFsbHkgY29udGFpbnMgdGhlIGRhdGEuXG4gICAqL1xuICBnZXREYXRhU2V0KCk6IERhdGFTZXQ8SXRlbSwgSWRQcm9wPjtcblxuICAvKipcbiAgICogR2V0IGlkcyBvZiBpdGVtcy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogTm8gZ3VhcmFudGVlIGlzIGdpdmVuIGFib3V0IHRoZSBvcmRlciBvZiByZXR1cm5lZCBpZHMgdW5sZXNzIGFuIG9yZGVyaW5nIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgcmVxdWVzdGVkIGlkcy5cbiAgICovXG4gIGdldElkcyhvcHRpb25zPzogRGF0YUludGVyZmFjZUdldElkc09wdGlvbnM8SXRlbT4pOiBJZFtdO1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogTm8gZ3VhcmFudGVlIGlzIGdpdmVuIGFib3V0IHRoZSBvcmRlciBvZiBpdGVyYXRpb24gdW5sZXNzIGFuIG9yZGVyaW5nIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBFeGVjdXRlZCBpbiBzaW1pbGFyIGZhc2hpb24gdG8gQXJyYXkuZm9yRWFjaCBjYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgaXRlbSwgaW5kZXgsIGFycmF5IHJlY2VpdmVzIGl0ZW0sIGlkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc3BlY2lmeSBpdGVyYXRpb24gZGV0YWlscy5cbiAgICovXG4gIGZvckVhY2goXG4gICAgY2FsbGJhY2s6IChpdGVtOiBJdGVtLCBpZDogSWQpID0+IHZvaWQsXG4gICAgb3B0aW9ucz86IERhdGFJbnRlcmZhY2VGb3JFYWNoT3B0aW9uczxJdGVtPlxuICApOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBNYXAgZWFjaCBpdGVtIGludG8gZGlmZmVyZW50IGl0ZW0gYW5kIHJldHVybiB0aGVtIGFzIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBObyBndWFyYW50ZWUgaXMgZ2l2ZW4gYWJvdXQgdGhlIG9yZGVyIG9mIGl0ZXJhdGlvbiBldmVuIGlmIG9yZGVyaW5nIGZ1bmN0aW9uIGlzIHN1cHBsaWVkICh0aGUgaXRlbXMgYXJlIHNvcnRlZCBhZnRlciB0aGUgbWFwcGluZykuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIEFycmF5Lm1hcC1saWtlIGNhbGxiYWNrLCBidXQgb25seSB3aXRoIHRoZSBmaXJzdCB0d28gcGFyYW1zLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc3BlY2lmeSBpdGVyYXRpb24gZGV0YWlscy5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIG1hcHBlZCBpdGVtcy5cbiAgICovXG4gIG1hcDxUPihcbiAgICBjYWxsYmFjazogKGl0ZW06IEl0ZW0sIGlkOiBJZCkgPT4gVCxcbiAgICBvcHRpb25zPzogRGF0YUludGVyZmFjZU1hcE9wdGlvbnM8SXRlbSwgVD5cbiAgKTogVFtdO1xuXG4gIC8qKlxuICAgKiBTdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSBpZHMgLSBJZHMgb2YgdGhlIGl0ZW1zIHRvIGJlIGluY2x1ZGVkIGluIHRoaXMgc3RyZWFtIChtaXNzaW5nIGFyZSBpZ25vcmVkKSwgYWxsIGlmIG9taXR0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBkYXRhIHN0cmVhbSBmb3IgdGhpcyBkYXRhIHNldC5cbiAgICovXG4gIHN0cmVhbShpZHM/OiBJdGVyYWJsZTxJZD4pOiBEYXRhU3RyZWFtPEl0ZW0+O1xufVxuIiwiLyoqIFF1ZXVlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWV1ZU9wdGlvbnMge1xuICAvKiogVGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZCBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEJ5IGRlZmF1bHQgdGhlcmUgaXMgbm8gYXV0b21hdGljIGZsdXNoaW5nIChgbnVsbGApLiAqL1xuICBkZWxheT86IG51bGwgfCBudW1iZXI7XG4gIC8qKiBXaGVuIHRoZSBxdWV1ZSBleGNlZWRzIHRoZSBnaXZlbiBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzLCB0aGUgcXVldWUgaXMgZmx1c2hlZCBhdXRvbWF0aWNhbGx5LiBEZWZhdWx0IHZhbHVlIGlzIGBJbmZpbml0eWAuICovXG4gIG1heD86IG51bWJlcjtcbn1cbi8qKlxuICogUXVldWUgZXh0ZW5kaW5nIG9wdGlvbnMuXG4gKlxuICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgbWV0aG9kIG5hbWVzIHRvIGJlIHJlcGxhY2VkIGJ5IHF1ZXVlZCB2ZXJzaW9ucy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWV1ZUV4dGVuZE9wdGlvbnM8VD4ge1xuICAvKiogQSBsaXN0IHdpdGggbWV0aG9kIG5hbWVzIG9mIHRoZSBtZXRob2RzIG9uIHRoZSBvYmplY3QgdG8gYmUgcmVwbGFjZWQgd2l0aCBxdWV1ZWQgb25lcy4gKi9cbiAgcmVwbGFjZTogVFtdO1xuICAvKiogV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZCBhdXRvbWF0aWNhbGx5IGFmdGVyIGFuIGluYWN0aXZpdHkgb2YgdGhpcyBkZWxheSBpbiBtaWxsaXNlY29uZHMuIERlZmF1bHQgdmFsdWUgaXMgbnVsbC4gKi9cbiAgZGVsYXk/OiBudW1iZXI7XG4gIC8qKiBXaGVuIHRoZSBxdWV1ZSBleGNlZWRzIHRoZSBnaXZlbiBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzLCB0aGUgcXVldWUgaXMgZmx1c2hlZCBhdXRvbWF0aWNhbGx5LiBEZWZhdWx0IHZhbHVlIG9mIG1heCBpcyBJbmZpbml0eS4gKi9cbiAgbWF4PzogbnVtYmVyO1xufVxuLyoqXG4gKiBRdWV1ZSBjYWxsIGVudHJ5LlxuICogLSBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICogLSBBbiBvYmplY3Qgd2l0aCBmdW5jdGlvbiwgYXJncywgY29udGV4dCAobGlrZSBmdW5jdGlvbi5iaW5kKGNvbnRleHQsIC4uLmFyZ3MpKS5cbiAqL1xudHlwZSBRdWV1ZUNhbGxFbnRyeSA9XG4gIHwgRnVuY3Rpb25cbiAgfCB7XG4gICAgICBmbjogRnVuY3Rpb247XG4gICAgICBhcmdzOiB1bmtub3duW107XG4gICAgfVxuICB8IHtcbiAgICAgIGZuOiBGdW5jdGlvbjtcbiAgICAgIGFyZ3M6IHVua25vd25bXTtcbiAgICAgIGNvbnRleHQ6IHVua25vd247XG4gICAgfTtcblxuaW50ZXJmYWNlIFF1ZXVlRXh0ZW5kZWQ8Tz4ge1xuICBvYmplY3Q6IE87XG4gIG1ldGhvZHM6IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgb3JpZ2luYWw6IHVua25vd247XG4gIH1bXTtcbn1cblxuLyoqXG4gKiBBIHF1ZXVlLlxuICpcbiAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIG1ldGhvZCBuYW1lcyB0byBiZSByZXBsYWNlZCBieSBxdWV1ZWQgdmVyc2lvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWV1ZTxUID0gbmV2ZXI+IHtcbiAgLyoqIERlbGF5IGluIG1pbGxpc2Vjb25kcy4gSWYgZGVmaW5lZCB0aGUgcXVldWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgZmx1c2hlZC4gKi9cbiAgcHVibGljIGRlbGF5OiBudWxsIHwgbnVtYmVyO1xuICAvKiogTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUgYmVmb3JlIGl0IHdpbGwgYmUgZmx1c2hlZC4gKi9cbiAgcHVibGljIG1heDogbnVtYmVyO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX3F1ZXVlOiB7XG4gICAgZm46IEZ1bmN0aW9uO1xuICAgIGFyZ3M/OiB1bmtub3duW107XG4gICAgY29udGV4dD86IHVua25vd247XG4gIH1bXSA9IFtdO1xuXG4gIHByaXZhdGUgX3RpbWVvdXQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2V4dGVuZGVkOiBudWxsIHwgUXVldWVFeHRlbmRlZDxUPiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBRdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBRdWV1ZSBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBRdWV1ZU9wdGlvbnMpIHtcbiAgICAvLyBvcHRpb25zXG4gICAgdGhpcy5kZWxheSA9IG51bGw7XG4gICAgdGhpcy5tYXggPSBJbmZpbml0eTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFF1ZXVlIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBwdWJsaWMgc2V0T3B0aW9ucyhvcHRpb25zPzogUXVldWVPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuZGVsYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMubWF4ID0gb3B0aW9ucy5tYXg7XG4gICAgfVxuXG4gICAgdGhpcy5fZmx1c2hJZk5lZWRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCBxdWV1aW5nIGZ1bmN0aW9uYWxpdHkuXG4gICAqIFRoZSBvYmplY3Qgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGEgZnVuY3Rpb24gZmx1c2gsIGFuZCB0aGUgbWV0aG9kcyBwcm92aWRlZCBpbiBvcHRpb25zLnJlcGxhY2Ugd2lsbCBiZSByZXBsYWNlZCB3aXRoIHF1ZXVlZCBvbmVzLlxuICAgKlxuICAgKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHF1ZXVlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBleHRlbmQ8TyBleHRlbmRzIHsgZmx1c2g/OiAoKSA9PiB2b2lkIH0sIEsgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIG9iamVjdDogTyxcbiAgICBvcHRpb25zOiBRdWV1ZUV4dGVuZE9wdGlvbnM8Sz5cbiAgKTogUXVldWU8Tz4ge1xuICAgIGNvbnN0IHF1ZXVlID0gbmV3IFF1ZXVlPE8+KG9wdGlvbnMpO1xuXG4gICAgaWYgKG9iamVjdC5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQgb2JqZWN0IGFscmVhZHkgaGFzIGEgcHJvcGVydHkgZmx1c2hcIik7XG4gICAgfVxuICAgIG9iamVjdC5mbHVzaCA9ICgpOiB2b2lkID0+IHtcbiAgICAgIHF1ZXVlLmZsdXNoKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG1ldGhvZHM6IFF1ZXVlRXh0ZW5kZWQ8Tz5bXCJtZXRob2RzXCJdID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcImZsdXNoXCIsXG4gICAgICAgIG9yaWdpbmFsOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5yZXBsYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvcHRpb25zLnJlcGxhY2VbaV07XG4gICAgICAgIG1ldGhvZHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAvLyBAVE9ETzogYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgICAgIG9yaWdpbmFsOiAoKG9iamVjdCBhcyB1bmtub3duKSBhcyBSZWNvcmQ8SywgKCkgPT4gdm9pZD4pW25hbWVdLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQFRPRE86IGJldHRlciBzb2x1dGlvbj9cbiAgICAgICAgcXVldWUucmVwbGFjZSgob2JqZWN0IGFzIHVua25vd24pIGFzIFJlY29yZDxLLCAoKSA9PiB2b2lkPiwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVldWUuX2V4dGVuZGVkID0ge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBtZXRob2RzOiBtZXRob2RzLFxuICAgIH07XG5cbiAgICByZXR1cm4gcXVldWU7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgcXVldWUuIFRoZSBxdWV1ZSB3aWxsIGZpcnN0IGZsdXNoIGFsbCBxdWV1ZWQgYWN0aW9ucywgYW5kIGluIGNhc2UgaXQgaGFzIGV4dGVuZGVkIGFuIG9iamVjdCwgd2lsbCByZXN0b3JlIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmZsdXNoKCk7XG5cbiAgICBpZiAodGhpcy5fZXh0ZW5kZWQpIHtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuX2V4dGVuZGVkLm9iamVjdDtcbiAgICAgIGNvbnN0IG1ldGhvZHMgPSB0aGlzLl9leHRlbmRlZC5tZXRob2RzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IG1ldGhvZHNbaV07XG4gICAgICAgIGlmIChtZXRob2Qub3JpZ2luYWwpIHtcbiAgICAgICAgICAvLyBAVE9ETzogYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgICAgIChvYmplY3QgYXMgYW55KVttZXRob2QubmFtZV0gPSBtZXRob2Qub3JpZ2luYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQFRPRE86IGJldHRlciBzb2x1dGlvbj9cbiAgICAgICAgICBkZWxldGUgKG9iamVjdCBhcyBhbnkpW21ldGhvZC5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZXh0ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIGEgbWV0aG9kIG9uIGFuIG9iamVjdCB3aXRoIGEgcXVldWVkIHZlcnNpb24uXG4gICAqXG4gICAqIEBwYXJhbSBvYmplY3QgLSBPYmplY3QgaGF2aW5nIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbWV0aG9kIG5hbWUuXG4gICAqL1xuICBwdWJsaWMgcmVwbGFjZTxNIGV4dGVuZHMgc3RyaW5nPihcbiAgICBvYmplY3Q6IFJlY29yZDxNLCAoKSA9PiB2b2lkPixcbiAgICBtZXRob2Q6IE1cbiAgKTogdm9pZCB7XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzIC0tIEZ1bmN0aW9uIHRoaXMgaXMgbmVjZXNzYXJ5IGluIHRoZSBmdW5jdGlvbiBiZWxsb3csIHNvIGNsYXNzIHRoaXMgaGFzIHRvIGJlIHNhdmVkIGludG8gYSB2YXJpYWJsZSBoZXJlLiAqL1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBvcmlnaW5hbCA9IG9iamVjdFttZXRob2RdO1xuICAgIGlmICghb3JpZ2luYWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBcIiArIG1ldGhvZCArIFwiIHVuZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICBvYmplY3RbbWV0aG9kXSA9IGZ1bmN0aW9uICguLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICAgIC8vIGFkZCB0aGlzIGNhbGwgdG8gdGhlIHF1ZXVlXG4gICAgICBtZS5xdWV1ZSh7XG4gICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgIGZuOiBvcmlnaW5hbCxcbiAgICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUXVldWUgYSBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZW50cnkgLSBUaGUgZnVuY3Rpb24gb3IgZW50cnkgdG8gYmUgcXVldWVkLlxuICAgKi9cbiAgcHVibGljIHF1ZXVlKGVudHJ5OiBRdWV1ZUNhbGxFbnRyeSk6IHZvaWQge1xuICAgIGlmICh0eXBlb2YgZW50cnkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5fcXVldWUucHVzaCh7IGZuOiBlbnRyeSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWUucHVzaChlbnRyeSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmx1c2hJZk5lZWRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHF1ZXVlIG5lZWRzIHRvIGJlIGZsdXNoZWQuXG4gICAqL1xuICBwcml2YXRlIF9mbHVzaElmTmVlZGVkKCk6IHZvaWQge1xuICAgIC8vIGZsdXNoIHdoZW4gdGhlIG1heGltdW0gaXMgZXhjZWVkZWQuXG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgLy8gZmx1c2ggYWZ0ZXIgYSBwZXJpb2Qgb2YgaW5hY3Rpdml0eSB3aGVuIGEgZGVsYXkgaXMgY29uZmlndXJlZFxuICAgIGlmICh0aGlzLl90aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwICYmIHR5cGVvZiB0aGlzLmRlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH0sIHRoaXMuZGVsYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCBhbGwgcXVldWVkIGNhbGxzXG4gICAqL1xuICBwdWJsaWMgZmx1c2goKTogdm9pZCB7XG4gICAgdGhpcy5fcXVldWUuc3BsaWNlKDApLmZvckVhY2goKGVudHJ5KTogdm9pZCA9PiB7XG4gICAgICBlbnRyeS5mbi5hcHBseShlbnRyeS5jb250ZXh0IHx8IGVudHJ5LmZuLCBlbnRyeS5hcmdzIHx8IFtdKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgRGF0YUludGVyZmFjZSxcbiAgRXZlbnRDYWxsYmFja3NXaXRoQW55LFxuICBFdmVudE5hbWUsXG4gIEV2ZW50TmFtZVdpdGhBbnksXG4gIEV2ZW50UGF5bG9hZHMsXG4gIElkLFxufSBmcm9tIFwiLi9kYXRhLWludGVyZmFjZVwiO1xuXG50eXBlIEV2ZW50U3Vic2NyaWJlcnM8SXRlbSwgSWRQcm9wIGV4dGVuZHMgc3RyaW5nPiA9IHtcbiAgW05hbWUgaW4ga2V5b2YgRXZlbnRDYWxsYmFja3NXaXRoQW55PEl0ZW0sIElkUHJvcD5dOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQ7XG59O1xuXG4vKipcbiAqIFtbRGF0YVNldF1dIGNvZGUgdGhhdCBjYW4gYmUgcmV1c2VkIGluIFtbRGF0YVZpZXddXSBvciBvdGhlciBzaW1pbGFyIGltcGxlbWVudGF0aW9ucyBvZiBbW0RhdGFJbnRlcmZhY2VdXS5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGFTZXRQYXJ0PEl0ZW0sIElkUHJvcCBleHRlbmRzIHN0cmluZz5cbiAgaW1wbGVtZW50cyBQaWNrPERhdGFJbnRlcmZhY2U8SXRlbSwgSWRQcm9wPiwgXCJvblwiIHwgXCJvZmZcIj4ge1xuICBwcml2YXRlIHJlYWRvbmx5IF9zdWJzY3JpYmVyczoge1xuICAgIFtOYW1lIGluIEV2ZW50TmFtZVdpdGhBbnldOiBFdmVudFN1YnNjcmliZXJzPEl0ZW0sIElkUHJvcD5bTmFtZV1bXTtcbiAgfSA9IHtcbiAgICBcIipcIjogW10sXG4gICAgYWRkOiBbXSxcbiAgICByZW1vdmU6IFtdLFxuICAgIHVwZGF0ZTogW10sXG4gIH07XG5cbiAgcHJvdGVjdGVkIF90cmlnZ2VyKFxuICAgIGV2ZW50OiBcImFkZFwiLFxuICAgIHBheWxvYWQ6IEV2ZW50UGF5bG9hZHM8SXRlbSwgSWRQcm9wPltcImFkZFwiXSxcbiAgICBzZW5kZXJJZD86IElkIHwgbnVsbFxuICApOiB2b2lkO1xuICBwcm90ZWN0ZWQgX3RyaWdnZXIoXG4gICAgZXZlbnQ6IFwidXBkYXRlXCIsXG4gICAgcGF5bG9hZDogRXZlbnRQYXlsb2FkczxJdGVtLCBJZFByb3A+W1widXBkYXRlXCJdLFxuICAgIHNlbmRlcklkPzogSWQgfCBudWxsXG4gICk6IHZvaWQ7XG4gIHByb3RlY3RlZCBfdHJpZ2dlcihcbiAgICBldmVudDogXCJyZW1vdmVcIixcbiAgICBwYXlsb2FkOiBFdmVudFBheWxvYWRzPEl0ZW0sIElkUHJvcD5bXCJyZW1vdmVcIl0sXG4gICAgc2VuZGVySWQ/OiBJZCB8IG51bGxcbiAgKTogdm9pZDtcbiAgLyoqXG4gICAqIFRyaWdnZXIgYW4gZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHBheWxvYWQgLSBFdmVudCBwYXlsb2FkLlxuICAgKiBAcGFyYW0gc2VuZGVySWQgLSBJZCBvZiB0aGUgc2VuZGVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIF90cmlnZ2VyPE5hbWUgZXh0ZW5kcyBFdmVudE5hbWU+KFxuICAgIGV2ZW50OiBOYW1lLFxuICAgIHBheWxvYWQ6IEV2ZW50UGF5bG9hZHM8SXRlbSwgSWRQcm9wPltOYW1lXSxcbiAgICBzZW5kZXJJZD86IElkIHwgbnVsbFxuICApOiB2b2lkIHtcbiAgICBpZiAoKGV2ZW50IGFzIHN0cmluZykgPT09IFwiKlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJpZ2dlciBldmVudCAqXCIpO1xuICAgIH1cblxuICAgIFsuLi50aGlzLl9zdWJzY3JpYmVyc1tldmVudF0sIC4uLnRoaXMuX3N1YnNjcmliZXJzW1wiKlwiXV0uZm9yRWFjaChcbiAgICAgIChzdWJzY3JpYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIHN1YnNjcmliZXIoZXZlbnQsIHBheWxvYWQsIHNlbmRlcklkICE9IG51bGwgPyBzZW5kZXJJZCA6IG51bGwpO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIG9uKFxuICAgIGV2ZW50OiBcIipcIixcbiAgICBjYWxsYmFjazogRXZlbnRDYWxsYmFja3NXaXRoQW55PEl0ZW0sIElkUHJvcD5bXCIqXCJdXG4gICk6IHZvaWQ7XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgb24oXG4gICAgZXZlbnQ6IFwiYWRkXCIsXG4gICAgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2tzV2l0aEFueTxJdGVtLCBJZFByb3A+W1wiYWRkXCJdXG4gICk6IHZvaWQ7XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgb24oXG4gICAgZXZlbnQ6IFwicmVtb3ZlXCIsXG4gICAgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2tzV2l0aEFueTxJdGVtLCBJZFByb3A+W1wicmVtb3ZlXCJdXG4gICk6IHZvaWQ7XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgb24oXG4gICAgZXZlbnQ6IFwidXBkYXRlXCIsXG4gICAgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2tzV2l0aEFueTxJdGVtLCBJZFByb3A+W1widXBkYXRlXCJdXG4gICk6IHZvaWQ7XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnQsIGFkZCBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHJlbWFya3MgTm9uLWZ1bmN0aW9uIGNhbGxiYWNrcyBhcmUgaWdub3JlZC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgbWV0aG9kLlxuICAgKi9cbiAgcHVibGljIG9uPE5hbWUgZXh0ZW5kcyBFdmVudE5hbWVXaXRoQW55PihcbiAgICBldmVudDogTmFtZSxcbiAgICBjYWxsYmFjazogRXZlbnRDYWxsYmFja3NXaXRoQW55PEl0ZW0sIElkUHJvcD5bTmFtZV1cbiAgKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBNYXliZSB0aHJvdyBmb3IgaW52YWxpZCBjYWxsYmFja3M/XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIG9mZihcbiAgICBldmVudDogXCIqXCIsXG4gICAgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2tzV2l0aEFueTxJdGVtLCBJZFByb3A+W1wiKlwiXVxuICApOiB2b2lkO1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIG9mZihcbiAgICBldmVudDogXCJhZGRcIixcbiAgICBjYWxsYmFjazogRXZlbnRDYWxsYmFja3NXaXRoQW55PEl0ZW0sIElkUHJvcD5bXCJhZGRcIl1cbiAgKTogdm9pZDtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBvZmYoXG4gICAgZXZlbnQ6IFwicmVtb3ZlXCIsXG4gICAgY2FsbGJhY2s6IEV2ZW50Q2FsbGJhY2tzV2l0aEFueTxJdGVtLCBJZFByb3A+W1wicmVtb3ZlXCJdXG4gICk6IHZvaWQ7XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgb2ZmKFxuICAgIGV2ZW50OiBcInVwZGF0ZVwiLFxuICAgIGNhbGxiYWNrOiBFdmVudENhbGxiYWNrc1dpdGhBbnk8SXRlbSwgSWRQcm9wPltcInVwZGF0ZVwiXVxuICApOiB2b2lkO1xuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudCwgcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcmVtYXJrcyBJZiB0aGUgc2FtZSBjYWxsYmFjayB3YXMgc3Vic2NyaWJlZCBtb3JlIHRoYW4gb25jZSAqKmFsbCoqIG9jY3VyZW5jZXMgd2lsbCBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBFdmVudCBuYW1lLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBtZXRob2QuXG4gICAqL1xuICBwdWJsaWMgb2ZmPE5hbWUgZXh0ZW5kcyBFdmVudE5hbWVXaXRoQW55PihcbiAgICBldmVudDogTmFtZSxcbiAgICBjYWxsYmFjazogRXZlbnRDYWxsYmFja3NXaXRoQW55PEl0ZW0sIElkUHJvcD5bTmFtZV1cbiAgKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdLmZpbHRlcihcbiAgICAgIChzdWJzY3JpYmVyKTogYm9vbGVhbiA9PiBzdWJzY3JpYmVyICE9PSBjYWxsYmFja1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG9uIGluc3RlYWQgKFBTOiBEYXRhVmlldy5zdWJzY3JpYmUgPT09IERhdGFWaWV3Lm9uKS5cbiAgICovXG4gIHB1YmxpYyBzdWJzY3JpYmU6IERhdGFTZXRQYXJ0PEl0ZW0sIElkUHJvcD5bXCJvblwiXSA9IERhdGFTZXRQYXJ0LnByb3RvdHlwZS5vbjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBvZmYgaW5zdGVhZCAoUFM6IERhdGFWaWV3LnVuc3Vic2NyaWJlID09PSBEYXRhVmlldy5vZmYpLlxuICAgKi9cbiAgcHVibGljIHVuc3Vic2NyaWJlOiBEYXRhU2V0UGFydDxJdGVtLCBJZFByb3A+W1wib2ZmXCJdID1cbiAgICBEYXRhU2V0UGFydC5wcm90b3R5cGUub2ZmO1xuXG4gIC8qIGRldmVsYmxvY2s6c3RhcnQgKi9cbiAgcHVibGljIGdldCB0ZXN0TGVha1N1YnNjcmliZXJzKCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZXJzO1xuICB9XG4gIC8qIGRldmVsYmxvY2s6ZW5kICovXG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb2xsZWN0aW9uJyk7XG52YXIgY29sbGVjdGlvblN0cm9uZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyBgU2V0YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2V0LW9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gY29sbGVjdGlvbignU2V0JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCBjb2xsZWN0aW9uU3Ryb25nKTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc2V0Jyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3InKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLlNldDtcbiIsInZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9zZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL3NldFwiKTsiLCJpbXBvcnQgeyBJZCB9IGZyb20gXCIuL2RhdGEtaW50ZXJmYWNlXCI7XG5cbi8qKlxuICogRGF0YSBzdHJlYW1cbiAqXG4gKiBAcmVtYXJrc1xuICogW1tEYXRhU3RyZWFtXV0gb2ZmZXJzIGFuIGFsd2F5cyB1cCB0byBkYXRlIHN0cmVhbSBvZiBpdGVtcyBmcm9tIGEgW1tEYXRhU2V0XV0gb3IgW1tEYXRhVmlld11dLlxuICogVGhhdCBtZWFucyB0aGF0IHRoZSBzdHJlYW0gaXMgZXZhbHVhdGVkIGF0IHRoZSB0aW1lIG9mIGl0ZXJhdGlvbiwgY29udmVyc2lvbiB0byBhbm90aGVyIGRhdGEgdHlwZSBvciB3aGVuIFtbY2FjaGVdXSBpcyBjYWxsZWQsIG5vdCB3aGVuIHRoZSBbW0RhdGFTdHJlYW1dXSB3YXMgY3JlYXRlZC5cbiAqIE11bHRpcGxlIGludm9jYXRpb25zIG9mIGZvciBleGFtcGxlIFtbdG9JdGVtQXJyYXldXSBtYXkgeWllbGQgZGlmZmVyZW50IHJlc3VsdHMgKGlmIHRoZSBkYXRhIHNvdXJjZSBsaWtlIGZvciBleGFtcGxlIFtbRGF0YVNldF1dIGdldHMgbW9kaWZpZWQpLlxuICpcbiAqIEB0eXBlUGFyYW0gSXRlbSAtIFRoZSBpdGVtIHR5cGUgdGhpcyBzdHJlYW0gaXMgZ29pbmcgdG8gd29yayB3aXRoLlxuICovXG5leHBvcnQgY2xhc3MgRGF0YVN0cmVhbTxJdGVtPiBpbXBsZW1lbnRzIEl0ZXJhYmxlPFtJZCwgSXRlbV0+IHtcbiAgcHJpdmF0ZSByZWFkb25seSBfcGFpcnM6IEl0ZXJhYmxlPFtJZCwgSXRlbV0+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZGF0YSBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSBwYWlycyAtIFRoZSBpZCwgaXRlbSBwYWlycy5cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihwYWlyczogSXRlcmFibGU8W0lkLCBJdGVtXT4pIHtcbiAgICB0aGlzLl9wYWlycyA9IHBhaXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiBrZXksIHZhbHVlIHBhaXJzIGZvciBldmVyeSBlbnRyeSBpbiB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcHVibGljICpbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYWJsZUl0ZXJhdG9yPFtJZCwgSXRlbV0+IHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgaXRlbV0gb2YgdGhpcy5fcGFpcnMpIHtcbiAgICAgIHlpZWxkIFtpZCwgaXRlbV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpdGVyYWJsZSBvZiBrZXksIHZhbHVlIHBhaXJzIGZvciBldmVyeSBlbnRyeSBpbiB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcHVibGljICplbnRyaWVzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8W0lkLCBJdGVtXT4ge1xuICAgIGZvciAoY29uc3QgW2lkLCBpdGVtXSBvZiB0aGlzLl9wYWlycykge1xuICAgICAgeWllbGQgW2lkLCBpdGVtXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIGtleXMgaW4gdGhlIHN0cmVhbS5cbiAgICovXG4gIHB1YmxpYyAqa2V5cygpOiBJdGVyYWJsZUl0ZXJhdG9yPElkPiB7XG4gICAgZm9yIChjb25zdCBbaWRdIG9mIHRoaXMuX3BhaXJzKSB7XG4gICAgICB5aWVsZCBpZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIHZhbHVlcyBpbiB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcHVibGljICp2YWx1ZXMoKTogSXRlcmFibGVJdGVyYXRvcjxJdGVtPiB7XG4gICAgZm9yIChjb25zdCBbLCBpdGVtXSBvZiB0aGlzLl9wYWlycykge1xuICAgICAgeWllbGQgaXRlbTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBpZHMgaW4gdGhpcyBzdHJlYW0uXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSBhcnJheSBtYXkgY29udGFpbiBkdXBsaWNpdGllcy5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggYWxsIGlkcyBmcm9tIHRoaXMgc3RyZWFtLlxuICAgKi9cbiAgcHVibGljIHRvSWRBcnJheSgpOiBJZFtdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3BhaXJzXS5tYXAoKHBhaXIpOiBJZCA9PiBwYWlyWzBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGl0ZW1zIGluIHRoaXMgc3RyZWFtLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgYXJyYXkgbWF5IGNvbnRhaW4gZHVwbGljaXRpZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBhcnJheSB3aXRoIGFsbCBpdGVtcyBmcm9tIHRoaXMgc3RyZWFtLlxuICAgKi9cbiAgcHVibGljIHRvSXRlbUFycmF5KCk6IEl0ZW1bXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9wYWlyc10ubWFwKChwYWlyKTogSXRlbSA9PiBwYWlyWzFdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGVudHJpZXMgaW4gdGhpcyBzdHJlYW0uXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSBhcnJheSBtYXkgY29udGFpbiBkdXBsaWNpdGllcy5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGFycmF5IHdpdGggYWxsIGVudHJpZXMgZnJvbSB0aGlzIHN0cmVhbS5cbiAgICovXG4gIHB1YmxpYyB0b0VudHJ5QXJyYXkoKTogW0lkLCBJdGVtXVtdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3BhaXJzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IG1hcCBjb250YWluaW5nIGFsbCB0aGUgaXRlbXMgaW4gdGhpcyBzdHJlYW0gYWNjZXNzaWJsZSBieSBpZHMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEluIGNhc2Ugb2YgZHVwbGljYXRlIGlkcyAoY29lcmNlZCB0byBzdHJpbmcgc28gYDcgPT0gJzcnYCkgdGhlIGxhc3QgZW5jb3V0ZXJlZCBhcHBlYXJzIGluIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBvYmplY3QgbWFwIG9mIGFsbCBpZCDihpIgaXRlbSBwYWlycyBmcm9tIHRoaXMgc3RyZWFtLlxuICAgKi9cbiAgcHVibGljIHRvT2JqZWN0TWFwKCk6IFJlY29yZDxJZCwgSXRlbT4ge1xuICAgIGNvbnN0IG1hcDogUmVjb3JkPElkLCBJdGVtPiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBbaWQsIGl0ZW1dIG9mIHRoaXMuX3BhaXJzKSB7XG4gICAgICBtYXBbaWRdID0gaXRlbTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGl0ZW1zIGluIHRoaXMgc3RyZWFtIGFjY2Vzc2libGUgYnkgaWRzLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgbWFwIG9mIGFsbCBpZCDihpIgaXRlbSBwYWlycyBmcm9tIHRoaXMgc3RyZWFtLlxuICAgKi9cbiAgcHVibGljIHRvTWFwKCk6IE1hcDxJZCwgSXRlbT4ge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMuX3BhaXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzZXQgY29udGFpbmluZyBhbGwgdGhlICh1bmlxdWUpIGlkcyBpbiB0aGlzIHN0cmVhbS5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHNldCBvZiBhbGwgaWRzIGZyb20gdGhpcyBzdHJlYW0uXG4gICAqL1xuICBwdWJsaWMgdG9JZFNldCgpOiBTZXQ8SWQ+IHtcbiAgICByZXR1cm4gbmV3IFNldCh0aGlzLnRvSWRBcnJheSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzZXQgY29udGFpbmluZyBhbGwgdGhlICh1bmlxdWUpIGl0ZW1zIGluIHRoaXMgc3RyZWFtLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgc2V0IG9mIGFsbCBpdGVtcyBmcm9tIHRoaXMgc3RyZWFtLlxuICAgKi9cbiAgcHVibGljIHRvSXRlbVNldCgpOiBTZXQ8SXRlbT4ge1xuICAgIHJldHVybiBuZXcgU2V0KHRoaXMudG9JdGVtQXJyYXkoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FjaGUgdGhlIGl0ZW1zIGZyb20gdGhpcyBzdHJlYW0uXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoaXMgbWV0aG9kIGFsbG93cyBmb3IgaXRlbXMgdG8gYmUgZmV0Y2hlZCBpbW1lZGlhdGVsbHkgYW5kIHVzZWQgKHBvc3NpYmx5IG11bHRpcGxlIHRpbWVzKSBsYXRlci5cbiAgICogSXQgY2FuIGFsc28gYmUgdXNlZCB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBhcyBbW0RhdGFTdHJlYW1dXSB3b3VsZCBvdGhlcndpc2UgcmVldmFsdWF0ZSBldmVyeXRoaW5nIHVwb24gZWFjaCBpdGVyYXRpb24uXG4gICAqXG4gICAqICMjIEV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBjb25zdCBkcyA9IG5ldyBEYXRhU2V0KFvigKZdKVxuICAgKlxuICAgKiBjb25zdCBjYWNoZWRTdHJlYW0gPSBkcy5zdHJlYW0oKVxuICAgKiAgIC5maWx0ZXIo4oCmKVxuICAgKiAgIC5zb3J0KOKApilcbiAgICogICAubWFwKOKApilcbiAgICogICAuY2FjaGVkKOKApikgLy8gRGF0YSBhcmUgZmV0Y2hlZCwgcHJvY2Vzc2VkIGFuZCBjYWNoZWQgaGVyZS5cbiAgICpcbiAgICogZHMuY2xlYXIoKVxuICAgKiBjaGFjaGVkU3RyZWFtIC8vIFN0aWxsIGhhcyBhbGwgdGhlIGl0ZW1zLlxuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMgQSBuZXcgW1tEYXRhU3RyZWFtXV0gd2l0aCBjYWNoZWQgaXRlbXMgKGRldGFjaGVkIGZyb20gdGhlIG9yaWdpbmFsIFtbRGF0YVNldF1dKS5cbiAgICovXG4gIHB1YmxpYyBjYWNoZSgpOiBEYXRhU3RyZWFtPEl0ZW0+IHtcbiAgICByZXR1cm4gbmV3IERhdGFTdHJlYW0oWy4uLnRoaXMuX3BhaXJzXSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkaXN0aW5jdCB2YWx1ZXMgb2YgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHBpY2tzIGFuZCBwb3NzaWJseSBjb252ZXJ0cyB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEB0eXBlUGFyYW0gVCAtIFRoZSB0eXBlIG9mIHRoZSBkaXN0aW5jdCB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybnMgQSBzZXQgb2YgYWxsIGRpc3RpbmN0IHByb3BlcnRpZXMuXG4gICAqL1xuICBwdWJsaWMgZGlzdGluY3Q8VD4oY2FsbGJhY2s6IChpdGVtOiBJdGVtLCBpZDogSWQpID0+IFQpOiBTZXQ8VD4ge1xuICAgIGNvbnN0IHNldCA9IG5ldyBTZXQ8VD4oKTtcblxuICAgIGZvciAoY29uc3QgW2lkLCBpdGVtXSBvZiB0aGlzLl9wYWlycykge1xuICAgICAgc2V0LmFkZChjYWxsYmFjayhpdGVtLCBpZCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICAvKipcbiAgICogRmlsdGVyIHRoZSBpdGVtcyBvZiB0aGUgc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBkZWNpZGVzIHdoZXRoZXIgYW4gaXRlbSB3aWxsIGJlIGluY2x1ZGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIG5ldyBkYXRhIHN0cmVhbSB3aXRoIHRoZSBmaWx0ZXJlZCBpdGVtcy5cbiAgICovXG4gIHB1YmxpYyBmaWx0ZXIoY2FsbGJhY2s6IChpdGVtOiBJdGVtLCBpZDogSWQpID0+IGJvb2xlYW4pOiBEYXRhU3RyZWFtPEl0ZW0+IHtcbiAgICBjb25zdCBwYWlycyA9IHRoaXMuX3BhaXJzO1xuICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbTxJdGVtPih7XG4gICAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxbSWQsIEl0ZW1dPiB7XG4gICAgICAgIGZvciAoY29uc3QgW2lkLCBpdGVtXSBvZiBwYWlycykge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVtLCBpZCkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtpZCwgaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBpdGVtIG9mIHRoZSBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCBmb3IgZWFjaCBpdGVtLlxuICAgKi9cbiAgcHVibGljIGZvckVhY2goY2FsbGJhY2s6IChpdGVtOiBJdGVtLCBpZDogSWQpID0+IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgaXRlbV0gb2YgdGhpcy5fcGFpcnMpIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFwIHRoZSBpdGVtcyBpbnRvIGEgZGlmZmVyZW50IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IGRvZXMgdGhlIGNvbnZlcnNpb24uXG4gICAqXG4gICAqIEB0eXBlUGFyYW0gTWFwcGVkIC0gVGhlIHR5cGUgb2YgdGhlIGl0ZW0gYWZ0ZXIgbWFwcGluZy5cbiAgICpcbiAgICogQHJldHVybnMgQSBuZXcgZGF0YSBzdHJlYW0gd2l0aCB0aGUgbWFwcGVkIGl0ZW1zLlxuICAgKi9cbiAgcHVibGljIG1hcDxNYXBwZWQ+KFxuICAgIGNhbGxiYWNrOiAoaXRlbTogSXRlbSwgaWQ6IElkKSA9PiBNYXBwZWRcbiAgKTogRGF0YVN0cmVhbTxNYXBwZWQ+IHtcbiAgICBjb25zdCBwYWlycyA9IHRoaXMuX3BhaXJzO1xuICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbTxNYXBwZWQ+KHtcbiAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYWJsZUl0ZXJhdG9yPFtJZCwgTWFwcGVkXT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtpZCwgaXRlbV0gb2YgcGFpcnMpIHtcbiAgICAgICAgICB5aWVsZCBbaWQsIGNhbGxiYWNrKGl0ZW0sIGlkKV07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpdGVtIHdpdGggdGhlIG1heGltdW0gdmFsdWUgb2YgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHBpY2tzIGFuZCBwb3NzaWJseSBjb252ZXJ0cyB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBpdGVtIHdpdGggdGhlIG1heGltdW0gaWYgZm91bmQgb3RoZXJ3aXNlIG51bGwuXG4gICAqL1xuICBwdWJsaWMgbWF4KGNhbGxiYWNrOiAoaXRlbTogSXRlbSwgaWQ6IElkKSA9PiBudW1iZXIpOiBJdGVtIHwgbnVsbCB7XG4gICAgY29uc3QgaXRlciA9IHRoaXMuX3BhaXJzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBsZXQgY3VyciA9IGl0ZXIubmV4dCgpO1xuICAgIGlmIChjdXJyLmRvbmUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBtYXhJdGVtOiBJdGVtID0gY3Vyci52YWx1ZVsxXTtcbiAgICBsZXQgbWF4VmFsdWU6IG51bWJlciA9IGNhbGxiYWNrKGN1cnIudmFsdWVbMV0sIGN1cnIudmFsdWVbMF0pO1xuICAgIHdoaWxlICghKGN1cnIgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgY29uc3QgW2lkLCBpdGVtXSA9IGN1cnIudmFsdWU7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgIG1heFZhbHVlID0gdmFsdWU7XG4gICAgICAgIG1heEl0ZW0gPSBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXhJdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaXRlbSB3aXRoIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGdpdmVuIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdGhhdCBwaWNrcyBhbmQgcG9zc2libHkgY29udmVydHMgdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgaXRlbSB3aXRoIHRoZSBtaW5pbXVtIGlmIGZvdW5kIG90aGVyd2lzZSBudWxsLlxuICAgKi9cbiAgcHVibGljIG1pbihjYWxsYmFjazogKGl0ZW06IEl0ZW0sIGlkOiBJZCkgPT4gbnVtYmVyKTogSXRlbSB8IG51bGwge1xuICAgIGNvbnN0IGl0ZXIgPSB0aGlzLl9wYWlyc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgbGV0IGN1cnIgPSBpdGVyLm5leHQoKTtcbiAgICBpZiAoY3Vyci5kb25lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgbWluSXRlbTogSXRlbSA9IGN1cnIudmFsdWVbMV07XG4gICAgbGV0IG1pblZhbHVlOiBudW1iZXIgPSBjYWxsYmFjayhjdXJyLnZhbHVlWzFdLCBjdXJyLnZhbHVlWzBdKTtcbiAgICB3aGlsZSAoIShjdXJyID0gaXRlci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIGNvbnN0IFtpZCwgaXRlbV0gPSBjdXJyLnZhbHVlO1xuICAgICAgY29uc3QgdmFsdWUgPSBjYWxsYmFjayhpdGVtLCBpZCk7XG4gICAgICBpZiAodmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgICAgICBtaW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICBtaW5JdGVtID0gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluSXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWR1Y2UgdGhlIGl0ZW1zIGludG8gYSBzaW5nbGUgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IGRvZXMgdGhlIHJlZHVjdGlvbi5cbiAgICogQHBhcmFtIGFjY3VtdWxhdG9yIC0gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgKlxuICAgKiBAdHlwZVBhcmFtIFQgLSBUaGUgdHlwZSBvZiB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSByZWR1Y2VkIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHJlZHVjZTxUPihcbiAgICBjYWxsYmFjazogKGFjY3VtdWxhdG9yOiBULCBpdGVtOiBJdGVtLCBpZDogSWQpID0+IFQsXG4gICAgYWNjdW11bGF0b3I6IFRcbiAgKTogVCB7XG4gICAgZm9yIChjb25zdCBbaWQsIGl0ZW1dIG9mIHRoaXMuX3BhaXJzKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBpdGVtLCBpZCk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0IHRoZSBpdGVtcy5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gSXRlbSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIG5ldyBzdHJlYW0gd2l0aCBzb3J0ZWQgaXRlbXMuXG4gICAqL1xuICBwdWJsaWMgc29ydChcbiAgICBjYWxsYmFjazogKGl0ZW1BOiBJdGVtLCBpdGVtQjogSXRlbSwgaWRBOiBJZCwgaWRCOiBJZCkgPT4gbnVtYmVyXG4gICk6IERhdGFTdHJlYW08SXRlbT4ge1xuICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbSh7XG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCk6IEl0ZXJhYmxlSXRlcmF0b3I8W0lkLCBJdGVtXT4gPT5cbiAgICAgICAgWy4uLnRoaXMuX3BhaXJzXVxuICAgICAgICAgIC5zb3J0KChbaWRBLCBpdGVtQV0sIFtpZEIsIGl0ZW1CXSk6IG51bWJlciA9PlxuICAgICAgICAgICAgY2FsbGJhY2soaXRlbUEsIGl0ZW1CLCBpZEEsIGlkQilcbiAgICAgICAgICApXG4gICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSxcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdjQgYXMgdXVpZDQgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgcHVyZURlZXBPYmplY3RBc3NpZ24gfSBmcm9tIFwidmlzLXV0aWwvZXNuZXh0XCI7XG5cbmltcG9ydCB7XG4gIERhdGFJbnRlcmZhY2UsXG4gIERhdGFJbnRlcmZhY2VGb3JFYWNoT3B0aW9ucyxcbiAgRGF0YUludGVyZmFjZUdldElkc09wdGlvbnMsXG4gIERhdGFJbnRlcmZhY2VHZXRPcHRpb25zLFxuICBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uc0FycmF5LFxuICBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uc09iamVjdCxcbiAgRGF0YUludGVyZmFjZU1hcE9wdGlvbnMsXG4gIERhdGFJbnRlcmZhY2VPcmRlcixcbiAgRGVlcFBhcnRpYWwsXG4gIEV2ZW50UGF5bG9hZHMsXG4gIEZ1bGxJdGVtLFxuICBJZCxcbiAgT3B0SWQsXG4gIFBhcnRJdGVtLFxuICBVcGRhdGVJdGVtLFxuICBpc0lkLFxufSBmcm9tIFwiLi9kYXRhLWludGVyZmFjZVwiO1xuXG5pbXBvcnQgeyBRdWV1ZSwgUXVldWVPcHRpb25zIH0gZnJvbSBcIi4vcXVldWVcIjtcbmltcG9ydCB7IERhdGFTZXRQYXJ0IH0gZnJvbSBcIi4vZGF0YS1zZXQtcGFydFwiO1xuaW1wb3J0IHsgRGF0YVN0cmVhbSB9IGZyb20gXCIuL2RhdGEtc3RyZWFtXCI7XG5cbi8qKlxuICogSW5pdGlhbCBEYXRhU2V0IGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICpcbiAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVNldEluaXRpYWxPcHRpb25zPElkUHJvcCBleHRlbmRzIHN0cmluZz4ge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgdGhlIGlkIG9mIHRoZSBpdGVtcy4gV2hlbiBkYXRhIGlzIGZldGNoZWQgZnJvbSBhIHNlcnZlciB3aGljaCB1c2VzIHNvbWUgc3BlY2lmaWMgZmllbGQgdG8gaWRlbnRpZnkgaXRlbXMsIHRoaXMgZmllbGQgbmFtZSBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBEYXRhU2V0IHVzaW5nIHRoZSBvcHRpb24gYGZpZWxkSWRgLiBGb3IgZXhhbXBsZSBbQ291Y2hEQl0oaHR0cDovL2NvdWNoZGIuYXBhY2hlLm9yZy8pIHVzZXMgdGhlIGZpZWxkIGAnX2lkJ2AgdG8gaWRlbnRpZnkgZG9jdW1lbnRzLlxuICAgKi9cbiAgZmllbGRJZD86IElkUHJvcDtcbiAgLyoqXG4gICAqIFF1ZXVlIGRhdGEgY2hhbmdlcyAoJ2FkZCcsICd1cGRhdGUnLCAncmVtb3ZlJykgYW5kIGZsdXNoIHRoZW0gYXQgb25jZS4gVGhlIHF1ZXVlIGNhbiBiZSBmbHVzaGVkIG1hbnVhbGx5IGJ5IGNhbGxpbmcgYERhdGFTZXQuZmx1c2goKWAsIG9yIGNhbiBiZSBmbHVzaGVkIGFmdGVyIGEgY29uZmlndXJlZCBkZWxheSBvciBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzLlxuICAgKlxuICAgKiBXaGVuIHF1ZXVlIGlzIHRydWUsIGEgcXVldWUgaXMgY3JlYXRlZCB3aXRoIGRlZmF1bHQgb3B0aW9ucy4gT3B0aW9ucyBjYW4gYmUgc3BlY2lmaWVkIGJ5IHByb3ZpZGluZyBhbiBvYmplY3QuXG4gICAqL1xuICBxdWV1ZT86IFF1ZXVlT3B0aW9ucyB8IGZhbHNlO1xufVxuLyoqIERhdGFTZXQgY29uZmlndXJhdGlvbiBvYmplY3QuICovXG5leHBvcnQgaW50ZXJmYWNlIERhdGFTZXRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFF1ZXVlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGZhbHNlIGlmIG5vIHF1ZXVlIHNob3VsZCBiZSB1c2VkLlxuICAgKlxuICAgKiAtIElmIGZhbHNlIGFuZCB0aGVyZSB3YXMgYSBxdWV1ZSBiZWZvcmUgaXQgd2lsbCBiZSBmbHVzaGVkIGFuZCB0aGVuIHJlbW92ZWQuXG4gICAqIC0gSWYgW1tRdWV1ZU9wdGlvbnNdXSB0aGUgZXhpc3RpbmcgcXVldWUgd2lsbCBiZSByZWNvbmZpZ3VyZWQgb3IgYSBuZXcgcXVldWUgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgcXVldWU/OiBRdWV1ZSB8IFF1ZXVlT3B0aW9ucyB8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhbiBpZCB0byBnaXZlbiBpdGVtIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmUgYWxyZWFkeS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIGl0ZW0gd2lsbCBiZSBtb2RpZmllZC5cbiAqXG4gKiBAcGFyYW0gaXRlbSAtIFRoZSBpdGVtIHRoYXQgd2lsbCBoYXZlIGFuIGlkIGFmdGVyIGEgY2FsbCB0byB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIGlkUHJvcCAtIFRoZSBrZXkgb2YgdGhlIGlkIHByb3BlcnR5LlxuICpcbiAqIEB0eXBlUGFyYW0gSXRlbSAtIEl0ZW0gdHlwZSB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gaWQuXG4gKiBAdHlwZVBhcmFtIElkUHJvcCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGlkLlxuICpcbiAqIEByZXR1cm5zIHRydWVcbiAqL1xuZnVuY3Rpb24gZW5zdXJlRnVsbEl0ZW08SXRlbSBleHRlbmRzIFBhcnRJdGVtPElkUHJvcD4sIElkUHJvcCBleHRlbmRzIHN0cmluZz4oXG4gIGl0ZW06IEl0ZW0sXG4gIGlkUHJvcDogSWRQcm9wXG4pOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+IHtcbiAgaWYgKGl0ZW1baWRQcm9wXSA9PSBudWxsKSB7XG4gICAgLy8gZ2VuZXJhdGUgYW4gaWRcbiAgICBpdGVtW2lkUHJvcF0gPSB1dWlkNCgpIGFzIGFueTtcbiAgfVxuXG4gIHJldHVybiBpdGVtIGFzIEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD47XG59XG5cbi8qKlxuICogIyBEYXRhU2V0XG4gKlxuICogVmlzLmpzIGNvbWVzIHdpdGggYSBmbGV4aWJsZSBEYXRhU2V0LCB3aGljaCBjYW4gYmUgdXNlZCB0byBob2xkIGFuZFxuICogbWFuaXB1bGF0ZSB1bnN0cnVjdHVyZWQgZGF0YSBhbmQgbGlzdGVuIGZvciBjaGFuZ2VzIGluIHRoZSBkYXRhLiBUaGUgRGF0YVNldFxuICogaXMga2V5L3ZhbHVlIGJhc2VkLiBEYXRhIGl0ZW1zIGNhbiBiZSBhZGRlZCwgdXBkYXRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZVxuICogRGF0YVNldCwgYW5kIG9uZSBjYW4gc3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gdGhlIERhdGFTZXQuIFRoZSBkYXRhIGluIHRoZVxuICogRGF0YVNldCBjYW4gYmUgZmlsdGVyZWQgYW5kIG9yZGVyZWQuIERhdGEgY2FuIGJlIG5vcm1hbGl6ZWQgd2hlbiBhcHBlbmRpbmcgaXRcbiAqIHRvIHRoZSBEYXRhU2V0IGFzIHdlbGwuXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gdXNlIGEgRGF0YVNldC5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjcmVhdGUgYSBEYXRhU2V0XG4gKiB2YXIgb3B0aW9ucyA9IHt9O1xuICogdmFyIGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQob3B0aW9ucyk7XG4gKlxuICogLy8gYWRkIGl0ZW1zXG4gKiAvLyBub3RlIHRoYXQgdGhlIGRhdGEgaXRlbXMgY2FuIGNvbnRhaW4gZGlmZmVyZW50IHByb3BlcnRpZXMgYW5kIGRhdGEgZm9ybWF0c1xuICogZGF0YS5hZGQoW1xuICogICB7aWQ6IDEsIHRleHQ6ICdpdGVtIDEnLCBkYXRlOiBuZXcgRGF0ZSgyMDEzLCA2LCAyMCksIGdyb3VwOiAxLCBmaXJzdDogdHJ1ZX0sXG4gKiAgIHtpZDogMiwgdGV4dDogJ2l0ZW0gMicsIGRhdGU6ICcyMDEzLTA2LTIzJywgZ3JvdXA6IDJ9LFxuICogICB7aWQ6IDMsIHRleHQ6ICdpdGVtIDMnLCBkYXRlOiAnMjAxMy0wNi0yNScsIGdyb3VwOiAyfSxcbiAqICAge2lkOiA0LCB0ZXh0OiAnaXRlbSA0J31cbiAqIF0pO1xuICpcbiAqIC8vIHN1YnNjcmliZSB0byBhbnkgY2hhbmdlIGluIHRoZSBEYXRhU2V0XG4gKiBkYXRhLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50LCBwcm9wZXJ0aWVzLCBzZW5kZXJJZCkge1xuICogICBjb25zb2xlLmxvZygnZXZlbnQnLCBldmVudCwgcHJvcGVydGllcyk7XG4gKiB9KTtcbiAqXG4gKiAvLyB1cGRhdGUgYW4gZXhpc3RpbmcgaXRlbVxuICogZGF0YS51cGRhdGUoe2lkOiAyLCBncm91cDogMX0pO1xuICpcbiAqIC8vIHJlbW92ZSBhbiBpdGVtXG4gKiBkYXRhLnJlbW92ZSg0KTtcbiAqXG4gKiAvLyBnZXQgYWxsIGlkc1xuICogdmFyIGlkcyA9IGRhdGEuZ2V0SWRzKCk7XG4gKiBjb25zb2xlLmxvZygnaWRzJywgaWRzKTtcbiAqXG4gKiAvLyBnZXQgYSBzcGVjaWZpYyBpdGVtXG4gKiB2YXIgaXRlbTEgPSBkYXRhLmdldCgxKTtcbiAqIGNvbnNvbGUubG9nKCdpdGVtMScsIGl0ZW0xKTtcbiAqXG4gKiAvLyByZXRyaWV2ZSBhIGZpbHRlcmVkIHN1YnNldCBvZiB0aGUgZGF0YVxuICogdmFyIGl0ZW1zID0gZGF0YS5nZXQoe1xuICogICBmaWx0ZXI6IGZ1bmN0aW9uIChpdGVtKSB7XG4gKiAgICAgcmV0dXJuIGl0ZW0uZ3JvdXAgPT0gMTtcbiAqICAgfVxuICogfSk7XG4gKiBjb25zb2xlLmxvZygnZmlsdGVyZWQgaXRlbXMnLCBpdGVtcyk7XG4gKiBgYGBcbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFTZXQ8XG4gICAgSXRlbSBleHRlbmRzIFBhcnRJdGVtPElkUHJvcD4sXG4gICAgSWRQcm9wIGV4dGVuZHMgc3RyaW5nID0gXCJpZFwiXG4gID5cbiAgZXh0ZW5kcyBEYXRhU2V0UGFydDxJdGVtLCBJZFByb3A+XG4gIGltcGxlbWVudHMgRGF0YUludGVyZmFjZTxJdGVtLCBJZFByb3A+IHtcbiAgLyoqIEZsdXNoIGFsbCBxdWV1ZWQgY2FsbHMuICovXG4gIHB1YmxpYyBmbHVzaD86ICgpID0+IHZvaWQ7XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgbGVuZ3RoOiBudW1iZXI7XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgZ2V0IGlkUHJvcCgpOiBJZFByb3Age1xuICAgIHJldHVybiB0aGlzLl9pZFByb3A7XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IF9vcHRpb25zOiBEYXRhU2V0SW5pdGlhbE9wdGlvbnM8SWRQcm9wPjtcbiAgcHJpdmF0ZSByZWFkb25seSBfZGF0YTogTWFwPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgcHJpdmF0ZSByZWFkb25seSBfaWRQcm9wOiBJZFByb3A7XG4gIHByaXZhdGUgX3F1ZXVlOiBRdWV1ZTx0aGlzPiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIERhdGFTZXQgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihvcHRpb25zPzogRGF0YVNldEluaXRpYWxPcHRpb25zPElkUHJvcD4pO1xuICAvKipcbiAgICogQHBhcmFtIGRhdGEgLSBBbiBpbml0aWFsIHNldCBvZiBpdGVtcyBmb3IgdGhlIG5ldyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBEYXRhU2V0IGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoZGF0YTogSXRlbVtdLCBvcHRpb25zPzogRGF0YVNldEluaXRpYWxPcHRpb25zPElkUHJvcD4pO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IERhdGFTZXQuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gSW5pdGlhbCBkYXRhIG9yIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyAodHlwZSBlcnJvciBpZiBkYXRhIGlzIGFsc28gb3B0aW9ucykuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgZGF0YT86IEl0ZW1bXSB8IERhdGFTZXRJbml0aWFsT3B0aW9uczxJZFByb3A+LFxuICAgIG9wdGlvbnM/OiBEYXRhU2V0SW5pdGlhbE9wdGlvbnM8SWRQcm9wPlxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gY29ycmVjdGx5IHJlYWQgb3B0aW9uYWwgYXJndW1lbnRzXG4gICAgaWYgKGRhdGEgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIG9wdGlvbnMgPSBkYXRhO1xuICAgICAgZGF0YSA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX2RhdGEgPSBuZXcgTWFwKCk7IC8vIG1hcCB3aXRoIGRhdGEgaW5kZXhlZCBieSBpZFxuICAgIHRoaXMubGVuZ3RoID0gMDsgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBEYXRhU2V0XG4gICAgdGhpcy5faWRQcm9wID0gdGhpcy5fb3B0aW9ucy5maWVsZElkIHx8IChcImlkXCIgYXMgSWRQcm9wKTsgLy8gbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyBpZFxuXG4gICAgLy8gYWRkIGluaXRpYWwgZGF0YSB3aGVuIHByb3ZpZGVkXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYWRkKGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG5ldyBvcHRpb25zLlxuICAgKi9cbiAgcHVibGljIHNldE9wdGlvbnMob3B0aW9ucz86IERhdGFTZXRPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5xdWV1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5xdWV1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gZGVsZXRlIHF1ZXVlIGlmIGxvYWRlZFxuICAgICAgICBpZiAodGhpcy5fcXVldWUpIHtcbiAgICAgICAgICB0aGlzLl9xdWV1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy5fcXVldWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgcXVldWUgYW5kIHVwZGF0ZSBpdHMgb3B0aW9uc1xuICAgICAgICBpZiAoIXRoaXMuX3F1ZXVlKSB7XG4gICAgICAgICAgdGhpcy5fcXVldWUgPSBRdWV1ZS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgcmVwbGFjZTogW1wiYWRkXCIsIFwidXBkYXRlXCIsIFwicmVtb3ZlXCJdLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucXVldWUgJiYgdHlwZW9mIG9wdGlvbnMucXVldWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aGlzLl9xdWV1ZS5zZXRPcHRpb25zKG9wdGlvbnMucXVldWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGRhdGEgaXRlbSBvciBhbiBhcnJheSB3aXRoIGl0ZW1zLlxuICAgKlxuICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIGFkZGVkIHRvIHRoZSBEYXRhU2V0LCB0aGUgRGF0YVNldCB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgYGFkZGAuIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqICMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBjcmVhdGUgYSBEYXRhU2V0XG4gICAqIGNvbnN0IGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoKVxuICAgKlxuICAgKiAvLyBhZGQgaXRlbXNcbiAgICogY29uc3QgaWRzID0gZGF0YS5hZGQoW1xuICAgKiAgIHsgaWQ6IDEsIHRleHQ6ICdpdGVtIDEnIH0sXG4gICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMicgfSxcbiAgICogICB7IHRleHQ6ICdpdGVtIHdpdGhvdXQgYW4gaWQnIH1cbiAgICogXSlcbiAgICpcbiAgICogY29uc29sZS5sb2coaWRzKSAvLyBbMSwgMiwgJzxVVUlEdjQ+J11cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gSXRlbXMgdG8gYmUgYWRkZWQgKGlkcyB3aWxsIGJlIGdlbmVyYXRlZCBpZiBtaXNzaW5nKS5cbiAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhZGRlZElkcyAtIEFycmF5IHdpdGggdGhlIGlkcyAoZ2VuZXJhdGVkIGlmIG5vdCBwcmVzZW50KSBvZiB0aGUgYWRkZWQgaXRlbXMuXG4gICAqXG4gICAqIEB0aHJvd3MgV2hlbiBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQgYXMgYW55IG9mIHRoZSBhZGRlZCBpdGVtcyBhbHJlYWR5IGV4aXN0cy5cbiAgICovXG4gIHB1YmxpYyBhZGQoZGF0YTogSXRlbSB8IEl0ZW1bXSwgc2VuZGVySWQ/OiBJZCB8IG51bGwpOiAoc3RyaW5nIHwgbnVtYmVyKVtdIHtcbiAgICBjb25zdCBhZGRlZElkczogSWRbXSA9IFtdO1xuICAgIGxldCBpZDogSWQ7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgLy8gQXJyYXlcbiAgICAgIGNvbnN0IGlkc1RvQWRkOiBJZFtdID0gZGF0YS5tYXAoKGQpID0+IGRbdGhpcy5faWRQcm9wXSBhcyBJZCk7XG4gICAgICBpZiAoaWRzVG9BZGQuc29tZSgoaWQpID0+IHRoaXMuX2RhdGEuaGFzKGlkKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBkdXBsaWNhdGUgaWQgd2FzIGZvdW5kIGluIHRoZSBwYXJhbWV0ZXIgYXJyYXkuXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWQgPSB0aGlzLl9hZGRJdGVtKGRhdGFbaV0pO1xuICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgICBpZCA9IHRoaXMuX2FkZEl0ZW0oZGF0YSk7XG4gICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhVHlwZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHsgaXRlbXM6IGFkZGVkSWRzIH0sIHNlbmRlcklkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkZWRJZHM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlIHByb3ZpZGVkIHByb3BlcnRpZXMgd2lsbCBiZSBtZXJnZWQgaW4gdGhlIGV4aXN0aW5nIGl0ZW0uIFdoZW4gYW4gaXRlbSBkb2VzIG5vdCBleGlzdCwgaXQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKlxuICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIHVwZGF0ZWQsIHRoZSBEYXRhU2V0IHdpbGwgdHJpZ2dlciBhbiBldmVudCBgYWRkYCBmb3IgdGhlIGFkZGVkIGl0ZW1zLCBhbmQgYW4gZXZlbnQgYHVwZGF0ZWAuIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqICMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBjcmVhdGUgYSBEYXRhU2V0XG4gICAqIGNvbnN0IGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoW1xuICAgKiAgIHsgaWQ6IDEsIHRleHQ6ICdpdGVtIDEnIH0sXG4gICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMicgfSxcbiAgICogICB7IGlkOiAzLCB0ZXh0OiAnaXRlbSAzJyB9XG4gICAqIF0pXG4gICAqXG4gICAqIC8vIHVwZGF0ZSBpdGVtc1xuICAgKiBjb25zdCBpZHMgPSBkYXRhLnVwZGF0ZShbXG4gICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMiAodXBkYXRlZCknIH0sXG4gICAqICAgeyBpZDogNCwgdGV4dDogJ2l0ZW0gNCAobmV3KScgfVxuICAgKiBdKVxuICAgKlxuICAgKiBjb25zb2xlLmxvZyhpZHMpIC8vIFsyLCA0XVxuICAgKiBgYGBcbiAgICpcbiAgICogIyMgV2FybmluZyBmb3IgVHlwZVNjcmlwdCB1c2Vyc1xuICAgKiBUaGlzIG1ldGhvZCBtYXkgaW50cm9kdWNlIHBhcnRpYWwgaXRlbXMgaW50byB0aGUgZGF0YSBzZXQuIFVzZSBhZGQgb3IgdXBkYXRlT25seSBpbnN0ZWFkIGZvciBiZXR0ZXIgdHlwZSBzYWZldHkuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gSXRlbXMgdG8gYmUgdXBkYXRlZCAoaWYgdGhlIGlkIGlzIGFscmVhZHkgcHJlc2VudCkgb3IgYWRkZWQgKGlmIHRoZSBpZCBpcyBtaXNzaW5nKS5cbiAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxuICAgKlxuICAgKiBAcmV0dXJucyB1cGRhdGVkSWRzIC0gVGhlIGlkcyBvZiB0aGUgYWRkZWQgKHRoZXNlIG1heSBiZSBuZXdseSBnZW5lcmF0ZWQgaWYgdGhlcmUgd2FzIG5vIGlkIGluIHRoZSBpdGVtIGZyb20gdGhlIGRhdGEpIG9yIHVwZGF0ZWQgaXRlbXMuXG4gICAqXG4gICAqIEB0aHJvd3MgV2hlbiB0aGUgc3VwcGxpZWQgZGF0YSBpcyBuZWl0aGVyIGFuIGl0ZW0gbm9yIGFuIGFycmF5IG9mIGl0ZW1zLlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZShcbiAgICBkYXRhOiBEZWVwUGFydGlhbDxJdGVtPiB8IERlZXBQYXJ0aWFsPEl0ZW0+W10sXG4gICAgc2VuZGVySWQ/OiBJZCB8IG51bGxcbiAgKTogSWRbXSB7XG4gICAgY29uc3QgYWRkZWRJZHM6IElkW10gPSBbXTtcbiAgICBjb25zdCB1cGRhdGVkSWRzOiBJZFtdID0gW107XG4gICAgY29uc3Qgb2xkRGF0YTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdID0gW107XG4gICAgY29uc3QgdXBkYXRlZERhdGE6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD5bXSA9IFtdO1xuICAgIGNvbnN0IGlkUHJvcCA9IHRoaXMuX2lkUHJvcDtcblxuICAgIGNvbnN0IGFkZE9yVXBkYXRlID0gKGl0ZW06IERlZXBQYXJ0aWFsPEl0ZW0+KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBvcmlnSWQ6IE9wdElkID0gaXRlbVtpZFByb3BdO1xuICAgICAgaWYgKG9yaWdJZCAhPSBudWxsICYmIHRoaXMuX2RhdGEuaGFzKG9yaWdJZCkpIHtcbiAgICAgICAgY29uc3QgZnVsbEl0ZW0gPSBpdGVtIGFzIEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD47IC8vIGl0IGhhcyBhbiBpZCwgdGhlcmVmb3JlIGl0IGlzIGEgZnVsbGl0ZW1cbiAgICAgICAgY29uc3Qgb2xkSXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2RhdGEuZ2V0KG9yaWdJZCkpO1xuICAgICAgICAvLyB1cGRhdGUgaXRlbVxuICAgICAgICBjb25zdCBpZCA9IHRoaXMuX3VwZGF0ZUl0ZW0oZnVsbEl0ZW0pO1xuICAgICAgICB1cGRhdGVkSWRzLnB1c2goaWQpO1xuICAgICAgICB1cGRhdGVkRGF0YS5wdXNoKGZ1bGxJdGVtKTtcbiAgICAgICAgb2xkRGF0YS5wdXNoKG9sZEl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkIG5ldyBpdGVtXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fYWRkSXRlbShpdGVtIGFzIGFueSk7XG4gICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgLy8gQXJyYXlcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2ldICYmIHR5cGVvZiBkYXRhW2ldID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgYWRkT3JVcGRhdGUoZGF0YVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJJZ25vcmluZyBpbnB1dCBpdGVtLCB3aGljaCBpcyBub3QgYW4gb2JqZWN0IGF0IGluZGV4IFwiICsgaVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgICBhZGRPclVwZGF0ZShkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhVHlwZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoYWRkZWRJZHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKFwiYWRkXCIsIHsgaXRlbXM6IGFkZGVkSWRzIH0sIHNlbmRlcklkKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IHsgaXRlbXM6IHVwZGF0ZWRJZHMsIG9sZERhdGE6IG9sZERhdGEsIGRhdGE6IHVwZGF0ZWREYXRhIH07XG4gICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBwcm9wZXJ0eSAnZGF0YScgc29tZSBkYXlcbiAgICAgIC8vT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAnZGF0YScsIHtcbiAgICAgIC8vICAnZ2V0JzogKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSBkYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0LmdldChpZHMpIHRvIHJldHJpZXZlIHRoZSBuZXcgZGF0YSwgdXNlIHRoZSBvbGREYXRhIHByb3BlcnR5IG9uIHRoaXMgb2JqZWN0IHRvIGdldCB0aGUgb2xkIGRhdGEnKTtcbiAgICAgIC8vICAgIHJldHVybiB1cGRhdGVkRGF0YTtcbiAgICAgIC8vICB9KS5iaW5kKHRoaXMpXG4gICAgICAvL30pO1xuICAgICAgdGhpcy5fdHJpZ2dlcihcInVwZGF0ZVwiLCBwcm9wcywgc2VuZGVySWQpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRlZElkcy5jb25jYXQodXBkYXRlZElkcyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGV4aXN0aW5nIGl0ZW1zLiBXaGVuIGFuIGl0ZW0gZG9lcyBub3QgZXhpc3QsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgcHJvdmlkZWQgcHJvcGVydGllcyB3aWxsIGJlIGRlZXBseSBtZXJnZWQgaW50byB0aGUgZXhpc3RpbmcgaXRlbS5cbiAgICogV2hlbiBhbiBpdGVtIGRvZXMgbm90IGV4aXN0IChpZCBub3QgcHJlc2VudCBpbiB0aGUgZGF0YSBzZXQgb3IgYWJzZW50KSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gYW5kIG5vdGhpbmcgd2lsbCBiZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIHVwZGF0ZWQsIHRoZSBEYXRhU2V0IHdpbGwgdHJpZ2dlciBhbiBldmVudCBgdXBkYXRlYC5cbiAgICogV2hlbiBhIGBzZW5kZXJJZGAgaXMgcHJvdmlkZWQsIHRoaXMgaWQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgdHJpZ2dlcmVkIGV2ZW50IHRvIGFsbCBzdWJzY3JpYmVycy5cbiAgICpcbiAgICogIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIC8vIGNyZWF0ZSBhIERhdGFTZXRcbiAgICogY29uc3QgZGF0YSA9IG5ldyB2aXMuRGF0YVNldChbXG4gICAqICAgeyBpZDogMSwgdGV4dDogJ2l0ZW0gMScgfSxcbiAgICogICB7IGlkOiAyLCB0ZXh0OiAnaXRlbSAyJyB9LFxuICAgKiAgIHsgaWQ6IDMsIHRleHQ6ICdpdGVtIDMnIH0sXG4gICAqIF0pXG4gICAqXG4gICAqIC8vIHVwZGF0ZSBpdGVtc1xuICAgKiBjb25zdCBpZHMgPSBkYXRhLnVwZGF0ZShbXG4gICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMiAodXBkYXRlZCknIH0sIC8vIHdvcmtzXG4gICAqICAgLy8geyBpZDogNCwgdGV4dDogJ2l0ZW0gNCAobmV3KScgfSwgLy8gd291bGQgdGhyb3dcbiAgICogICAvLyB7IHRleHQ6ICdpdGVtIDQgKG5ldyknIH0sIC8vIHdvdWxkIGFsc28gdGhyb3dcbiAgICogXSlcbiAgICpcbiAgICogY29uc29sZS5sb2coaWRzKSAvLyBbMl1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gVXBkYXRlcyAodGhlIGlkIGFuZCBvcHRpb25hbGx5IG90aGVyIHByb3BzKSB0byB0aGUgaXRlbXMgaW4gdGhpcyBkYXRhIHNldC5cbiAgICogQHBhcmFtIHNlbmRlcklkIC0gU2VuZGVyIGlkLlxuICAgKlxuICAgKiBAcmV0dXJucyB1cGRhdGVkSWRzIC0gVGhlIGlkcyBvZiB0aGUgdXBkYXRlZCBpdGVtcy5cbiAgICpcbiAgICogQHRocm93cyBXaGVuIHRoZSBzdXBwbGllZCBkYXRhIGlzIG5laXRoZXIgYW4gaXRlbSBub3IgYW4gYXJyYXkgb2YgaXRlbXMsIHdoZW4gdGhlIGlkcyBhcmUgbWlzc2luZy5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGVPbmx5KFxuICAgIGRhdGE6IFVwZGF0ZUl0ZW08SXRlbSwgSWRQcm9wPiB8IFVwZGF0ZUl0ZW08SXRlbSwgSWRQcm9wPltdLFxuICAgIHNlbmRlcklkPzogSWQgfCBudWxsXG4gICk6IElkW10ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVFdmVudERhdGEgPSBkYXRhXG4gICAgICAubWFwKCh1cGRhdGUpOiB7XG4gICAgICAgIG9sZERhdGE6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD47XG4gICAgICAgIHVwZGF0ZTogVXBkYXRlSXRlbTxJdGVtLCBJZFByb3A+O1xuICAgICAgfSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZERhdGEgPSB0aGlzLl9kYXRhLmdldCh1cGRhdGVbdGhpcy5faWRQcm9wXSk7XG4gICAgICAgIGlmIChvbGREYXRhID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVcGRhdGluZyBub24tZXhpc3RlbnQgaXRlbXMgaXMgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG9sZERhdGEsIHVwZGF0ZSB9O1xuICAgICAgfSlcbiAgICAgIC5tYXAoKHsgb2xkRGF0YSwgdXBkYXRlIH0pOiB7XG4gICAgICAgIGlkOiBJZDtcbiAgICAgICAgb2xkRGF0YTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPjtcbiAgICAgICAgdXBkYXRlZERhdGE6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD47XG4gICAgICB9ID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBvbGREYXRhW3RoaXMuX2lkUHJvcF07XG4gICAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0gcHVyZURlZXBPYmplY3RBc3NpZ24ob2xkRGF0YSwgdXBkYXRlKTtcblxuICAgICAgICB0aGlzLl9kYXRhLnNldChpZCwgdXBkYXRlZERhdGEpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgb2xkRGF0YTogb2xkRGF0YSxcbiAgICAgICAgICB1cGRhdGVkRGF0YSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKHVwZGF0ZUV2ZW50RGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHByb3BzOiBFdmVudFBheWxvYWRzPEl0ZW0sIElkUHJvcD5bXCJ1cGRhdGVcIl0gPSB7XG4gICAgICAgIGl0ZW1zOiB1cGRhdGVFdmVudERhdGEubWFwKCh2YWx1ZSk6IElkID0+IHZhbHVlLmlkKSxcbiAgICAgICAgb2xkRGF0YTogdXBkYXRlRXZlbnREYXRhLm1hcChcbiAgICAgICAgICAodmFsdWUpOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+ID0+IHZhbHVlLm9sZERhdGFcbiAgICAgICAgKSxcbiAgICAgICAgZGF0YTogdXBkYXRlRXZlbnREYXRhLm1hcChcbiAgICAgICAgICAodmFsdWUpOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+ID0+IHZhbHVlLnVwZGF0ZWREYXRhXG4gICAgICAgICksXG4gICAgICB9O1xuICAgICAgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgcHJvcGVydHkgJ2RhdGEnIHNvbWUgZGF5XG4gICAgICAvL09iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2RhdGEnLCB7XG4gICAgICAvLyAgJ2dldCc6IChmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgIGNvbnNvbGUud2FybignUHJvcGVydHkgZGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgRGF0YVNldC5nZXQoaWRzKSB0byByZXRyaWV2ZSB0aGUgbmV3IGRhdGEsIHVzZSB0aGUgb2xkRGF0YSBwcm9wZXJ0eSBvbiB0aGlzIG9iamVjdCB0byBnZXQgdGhlIG9sZCBkYXRhJyk7XG4gICAgICAvLyAgICByZXR1cm4gdXBkYXRlZERhdGE7XG4gICAgICAvLyAgfSkuYmluZCh0aGlzKVxuICAgICAgLy99KTtcbiAgICAgIHRoaXMuX3RyaWdnZXIoXCJ1cGRhdGVcIiwgcHJvcHMsIHNlbmRlcklkKTtcblxuICAgICAgcmV0dXJuIHByb3BzLml0ZW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoKTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdO1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGdldChcbiAgICBvcHRpb25zOiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uc0FycmF5PEl0ZW0+XG4gICk6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD5bXTtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnNPYmplY3Q8SXRlbT5cbiAgKTogUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnM8SXRlbT5cbiAgKTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdIHwgUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoaWQ6IElkKTogbnVsbCB8IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD47XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgZ2V0KFxuICAgIGlkOiBJZCxcbiAgICBvcHRpb25zOiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uc0FycmF5PEl0ZW0+XG4gICk6IG51bGwgfCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+O1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGdldChcbiAgICBpZDogSWQsXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnNPYmplY3Q8SXRlbT5cbiAgKTogUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoXG4gICAgaWQ6IElkLFxuICAgIG9wdGlvbnM6IERhdGFJbnRlcmZhY2VHZXRPcHRpb25zPEl0ZW0+XG4gICk6IG51bGwgfCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+IHwgUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoaWRzOiBJZFtdKTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdO1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGdldChcbiAgICBpZHM6IElkW10sXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnNBcnJheTxJdGVtPlxuICApOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W107XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgZ2V0KFxuICAgIGlkczogSWRbXSxcbiAgICBvcHRpb25zOiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uc09iamVjdDxJdGVtPlxuICApOiBSZWNvcmQ8SWQsIEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD4+O1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGdldChcbiAgICBpZHM6IElkW10sXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnM8SXRlbT5cbiAgKTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdIHwgUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoXG4gICAgaWRzOiBJZCB8IElkW10sXG4gICAgb3B0aW9ucz86IERhdGFJbnRlcmZhY2VHZXRPcHRpb25zPEl0ZW0+XG4gICk6XG4gICAgfCBudWxsXG4gICAgfCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+XG4gICAgfCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W11cbiAgICB8IFJlY29yZDxJZCwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPj47XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoXG4gICAgZmlyc3Q/OiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uczxJdGVtPiB8IElkIHwgSWRbXSxcbiAgICBzZWNvbmQ/OiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uczxJdGVtPlxuICApOlxuICAgIHwgbnVsbFxuICAgIHwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPlxuICAgIHwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdXG4gICAgfCBSZWNvcmQ8SWQsIEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD4+IHtcbiAgICAvLyBAVE9ETzogV291ZG4ndCBpdCBiZSBiZXR0ZXIgdG8gc3BsaXQgdGhpcyBpbnRvIG11bHRpcGxlIG1ldGhvZHM/XG5cbiAgICAvLyBwYXJzZSB0aGUgYXJndW1lbnRzXG4gICAgbGV0IGlkOiBJZCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgaWRzOiBJZFtdIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGxldCBvcHRpb25zOiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uczxJdGVtPiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNJZChmaXJzdCkpIHtcbiAgICAgIC8vIGdldChpZCBbLCBvcHRpb25zXSlcbiAgICAgIGlkID0gZmlyc3Q7XG4gICAgICBvcHRpb25zID0gc2Vjb25kO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgIC8vIGdldChpZHMgWywgb3B0aW9uc10pXG4gICAgICBpZHMgPSBmaXJzdDtcbiAgICAgIG9wdGlvbnMgPSBzZWNvbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldChbLCBvcHRpb25zXSlcbiAgICAgIG9wdGlvbnMgPSBmaXJzdDtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlXG4gICAgY29uc3QgcmV0dXJuVHlwZSA9XG4gICAgICBvcHRpb25zICYmIG9wdGlvbnMucmV0dXJuVHlwZSA9PT0gXCJPYmplY3RcIiA/IFwiT2JqZWN0XCIgOiBcIkFycmF5XCI7XG4gICAgLy8gQFRPRE86IFdURiBpcyB0aGlzPyBPciBhbSBJIG1pc3Npbmcgc29tZXRoaW5nP1xuICAgIC8vIHZhciByZXR1cm5UeXBlXG4gICAgLy8gaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXR1cm5UeXBlKSB7XG4gICAgLy8gICB2YXIgYWxsb3dlZFZhbHVlcyA9IFsnQXJyYXknLCAnT2JqZWN0J11cbiAgICAvLyAgIHJldHVyblR5cGUgPVxuICAgIC8vICAgICBhbGxvd2VkVmFsdWVzLmluZGV4T2Yob3B0aW9ucy5yZXR1cm5UeXBlKSA9PSAtMVxuICAgIC8vICAgICAgID8gJ0FycmF5J1xuICAgIC8vICAgICAgIDogb3B0aW9ucy5yZXR1cm5UeXBlXG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgIHJldHVyblR5cGUgPSAnQXJyYXknXG4gICAgLy8gfVxuXG4gICAgLy8gYnVpbGQgb3B0aW9uc1xuICAgIGNvbnN0IGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXI7XG4gICAgY29uc3QgaXRlbXM6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD5bXSA9IFtdO1xuICAgIGxldCBpdGVtOiB1bmRlZmluZWQgfCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+ID0gdW5kZWZpbmVkO1xuICAgIGxldCBpdGVtSWRzOiB1bmRlZmluZWQgfCBJZFtdID0gdW5kZWZpbmVkO1xuICAgIGxldCBpdGVtSWQ6IHVuZGVmaW5lZCB8IElkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gY29udmVydCBpdGVtc1xuICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAvLyByZXR1cm4gYSBzaW5nbGUgaXRlbVxuICAgICAgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcbiAgICAgIGlmIChpdGVtICYmIGZpbHRlciAmJiAhZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIGl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpZHMgIT0gbnVsbCkge1xuICAgICAgLy8gcmV0dXJuIGEgc3Vic2V0IG9mIGl0ZW1zXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZHNbaV0pO1xuICAgICAgICBpZiAoaXRlbSAhPSBudWxsICYmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBhbGwgaXRlbXNcbiAgICAgIGl0ZW1JZHMgPSBbLi4udGhpcy5fZGF0YS5rZXlzKCldO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaXRlbUlkID0gaXRlbUlkc1tpXTtcbiAgICAgICAgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGl0ZW1JZCk7XG4gICAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvcmRlciB0aGUgcmVzdWx0c1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIgJiYgaWQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgZmllbGRzIG9mIHRoZSBpdGVtc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBjb25zdCBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICAgIGlmIChpZCAhPSB1bmRlZmluZWQgJiYgaXRlbSAhPSBudWxsKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9maWx0ZXJGaWVsZHMoaXRlbSwgZmllbGRzKSBhcyBGdWxsSXRlbTxJdGVtLCBJZFByb3A+O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaXRlbXNbaV0gPSB0aGlzLl9maWx0ZXJGaWVsZHMoaXRlbXNbaV0sIGZpZWxkcykgYXMgRnVsbEl0ZW08XG4gICAgICAgICAgICBJdGVtLFxuICAgICAgICAgICAgSWRQcm9wXG4gICAgICAgICAgPjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiB0aGUgcmVzdWx0c1xuICAgIGlmIChyZXR1cm5UeXBlID09IFwiT2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPj4gPSB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCByZXN1bHRhbnQgPSBpdGVtc1tpXTtcbiAgICAgICAgLy8gQFRPRE86IFNob3Vkbid0IHRoaXMgYmUgdGhpcy5fZmllbGRJZD9cbiAgICAgICAgLy8gcmVzdWx0W3Jlc3VsdGFudC5pZF0gPSByZXN1bHRhbnRcbiAgICAgICAgY29uc3QgaWQ6IElkID0gcmVzdWx0YW50W3RoaXMuX2lkUHJvcF07XG4gICAgICAgIHJlc3VsdFtpZF0gPSByZXN1bHRhbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAvLyBhIHNpbmdsZSBpdGVtXG4gICAgICAgIHJldHVybiBpdGVtID8/IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBqdXN0IHJldHVybiBvdXIgYXJyYXlcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgZ2V0SWRzKG9wdGlvbnM/OiBEYXRhSW50ZXJmYWNlR2V0SWRzT3B0aW9uczxJdGVtPik6IElkW10ge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXI7XG4gICAgY29uc3Qgb3JkZXIgPSBvcHRpb25zICYmIG9wdGlvbnMub3JkZXI7XG4gICAgY29uc3QgaXRlbUlkcyA9IFsuLi5kYXRhLmtleXMoKV07XG4gICAgY29uc3QgaWRzOiBJZFtdID0gW107XG5cbiAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAvLyBnZXQgZmlsdGVyZWQgaXRlbXNcbiAgICAgIGlmIChvcmRlcikge1xuICAgICAgICAvLyBjcmVhdGUgb3JkZXJlZCBsaXN0XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZCk7XG4gICAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCAmJiBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc29ydChpdGVtcywgb3JkZXIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkcy5wdXNoKGl0ZW1zW2ldW3RoaXMuX2lkUHJvcF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgdW5vcmRlcmVkIGxpc3RcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoaXRlbSAhPSBudWxsICYmIGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgICAgaWRzLnB1c2goaXRlbVt0aGlzLl9pZFByb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0IGFsbCBpdGVtc1xuICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBvcmRlcmVkIGxpc3RcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGl0ZW1JZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICAgICAgaXRlbXMucHVzaChkYXRhLmdldChpZCkhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NvcnQoaXRlbXMsIG9yZGVyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZHMucHVzaChpdGVtc1tpXVt0aGlzLl9pZFByb3BdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIHVub3JkZXJlZCBsaXN0XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhLmdldChpZCk7XG4gICAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWRzLnB1c2goaXRlbVt0aGlzLl9pZFByb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaWRzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXREYXRhU2V0KCk6IERhdGFTZXQ8SXRlbSwgSWRQcm9wPiB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGZvckVhY2goXG4gICAgY2FsbGJhY2s6IChpdGVtOiBJdGVtLCBpZDogSWQpID0+IHZvaWQsXG4gICAgb3B0aW9ucz86IERhdGFJbnRlcmZhY2VGb3JFYWNoT3B0aW9uczxJdGVtPlxuICApOiB2b2lkIHtcbiAgICBjb25zdCBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGl0ZW1JZHMgPSBbLi4uZGF0YS5rZXlzKCldO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcikge1xuICAgICAgLy8gZXhlY3V0ZSBmb3JFYWNoIG9uIG9yZGVyZWQgbGlzdFxuICAgICAgY29uc3QgaXRlbXM6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD5bXSA9IHRoaXMuZ2V0KG9wdGlvbnMpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBjb25zdCBpZCA9IGl0ZW1bdGhpcy5faWRQcm9wXTtcbiAgICAgICAgY2FsbGJhY2soaXRlbSwgaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bm9yZGVyZWRcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGlkID0gaXRlbUlkc1tpXTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpKSB7XG4gICAgICAgICAgY2FsbGJhY2soaXRlbSwgaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBtYXA8VD4oXG4gICAgY2FsbGJhY2s6IChpdGVtOiBJdGVtLCBpZDogSWQpID0+IFQsXG4gICAgb3B0aW9ucz86IERhdGFJbnRlcmZhY2VNYXBPcHRpb25zPEl0ZW0sIFQ+XG4gICk6IFRbXSB7XG4gICAgY29uc3QgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcjtcbiAgICBjb25zdCBtYXBwZWRJdGVtczogVFtdID0gW107XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgaXRlbUlkcyA9IFsuLi5kYXRhLmtleXMoKV07XG5cbiAgICAvLyBjb252ZXJ0IGFuZCBmaWx0ZXIgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaXRlbUlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgaWQgPSBpdGVtSWRzW2ldO1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcbiAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSkge1xuICAgICAgICBtYXBwZWRJdGVtcy5wdXNoKGNhbGxiYWNrKGl0ZW0sIGlkKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb3JkZXIgaXRlbXNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyKSB7XG4gICAgICB0aGlzLl9zb3J0KG1hcHBlZEl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGVkSXRlbXM7XG4gIH1cblxuICBwcml2YXRlIF9maWx0ZXJGaWVsZHM8SyBleHRlbmRzIHN0cmluZz4oaXRlbTogbnVsbCwgZmllbGRzOiBLW10pOiBudWxsO1xuICBwcml2YXRlIF9maWx0ZXJGaWVsZHM8SyBleHRlbmRzIHN0cmluZz4oXG4gICAgaXRlbTogUmVjb3JkPEssIHVua25vd24+LFxuICAgIGZpZWxkczogS1tdXG4gICk6IFJlY29yZDxLLCB1bmtub3duPjtcbiAgcHJpdmF0ZSBfZmlsdGVyRmllbGRzPEsgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGl0ZW06IFJlY29yZDxLLCB1bmtub3duPixcbiAgICBmaWVsZHM6IEtbXSB8IFJlY29yZDxLLCBzdHJpbmc+XG4gICk6IGFueTtcbiAgLyoqXG4gICAqIEZpbHRlciB0aGUgZmllbGRzIG9mIGFuIGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gVGhlIGl0ZW0gd2hvc2UgZmllbGRzIHNob3VsZCBiZSBmaWx0ZXJlZC5cbiAgICogQHBhcmFtIGZpZWxkcyAtIFRoZSBuYW1lcyBvZiB0aGUgZmllbGRzIHRoYXQgd2lsbCBiZSBrZXB0LlxuICAgKlxuICAgKiBAdHlwZVBhcmFtIEsgLSBGaWVsZCBuYW1lIHR5cGUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBpdGVtIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgZmllbGRzLlxuICAgKi9cbiAgcHJpdmF0ZSBfZmlsdGVyRmllbGRzPEsgZXh0ZW5kcyBzdHJpbmc+KFxuICAgIGl0ZW06IFJlY29yZDxLLCB1bmtub3duPiB8IG51bGwsXG4gICAgZmllbGRzOiBLW10gfCBSZWNvcmQ8SywgdW5rbm93bj5cbiAgKTogUmVjb3JkPEssIHVua25vd24+IHwgbnVsbCB7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICAvLyBpdGVtIGlzIG51bGxcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShmaWVsZHMpXG4gICAgICA/IC8vIFVzZSB0aGUgc3VwcGxpZWQgYXJyYXlcbiAgICAgICAgZmllbGRzXG4gICAgICA6IC8vIFVzZSB0aGUga2V5cyBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0XG4gICAgICAgIChPYmplY3Qua2V5cyhmaWVsZHMpIGFzIEtbXSlcbiAgICApLnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKGZpbHRlcmVkSXRlbSwgZmllbGQpOiBSZWNvcmQ8XG4gICAgICBzdHJpbmcsXG4gICAgICB1bmtub3duXG4gICAgPiA9PiB7XG4gICAgICBmaWx0ZXJlZEl0ZW1bZmllbGRdID0gaXRlbVtmaWVsZF07XG4gICAgICByZXR1cm4gZmlsdGVyZWRJdGVtO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0IHRoZSBwcm92aWRlZCBhcnJheSB3aXRoIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0gaXRlbXMgLSBJdGVtcyB0byBiZSBzb3J0ZWQgaW4gcGxhY2UuXG4gICAqIEBwYXJhbSBvcmRlciAtIEEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHR5cGVQYXJhbSBUIC0gVGhlIHR5cGUgb2YgdGhlIGl0ZW1zIGluIHRoZSBpdGVtcyBhcnJheS5cbiAgICovXG4gIHByaXZhdGUgX3NvcnQ8VD4oaXRlbXM6IFRbXSwgb3JkZXI6IERhdGFJbnRlcmZhY2VPcmRlcjxUPik6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIG9yZGVyIGJ5IHByb3ZpZGVkIGZpZWxkIG5hbWVcbiAgICAgIGNvbnN0IG5hbWUgPSBvcmRlcjsgLy8gZmllbGQgbmFtZVxuICAgICAgaXRlbXMuc29ydCgoYSwgYik6IC0xIHwgMCB8IDEgPT4ge1xuICAgICAgICAvLyBAVE9ETzogSG93IHRvIHRyZWF0IG1pc3NpbmcgcHJvcGVydGllcz9cbiAgICAgICAgY29uc3QgYXYgPSAoYSBhcyBhbnkpW25hbWVdO1xuICAgICAgICBjb25zdCBidiA9IChiIGFzIGFueSlbbmFtZV07XG4gICAgICAgIHJldHVybiBhdiA+IGJ2ID8gMSA6IGF2IDwgYnYgPyAtMSA6IDA7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcmRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAvLyBvcmRlciBieSBzb3J0IGZ1bmN0aW9uXG4gICAgICBpdGVtcy5zb3J0KG9yZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogZXh0ZW5kIG9yZGVyIGJ5IGFuIE9iamVjdCB7ZmllbGQ6c3RyaW5nLCBkaXJlY3Rpb246c3RyaW5nfVxuICAgICAgLy8gICAgICAgd2hlcmUgZGlyZWN0aW9uIGNhbiBiZSAnYXNjJyBvciAnZGVzYydcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPcmRlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIG9yIG11bHRpcGxlIGl0ZW1zIGJ5IOKAnHJlZmVyZW5jZeKAnSAob25seSB0aGUgaWQgaXMgdXNlZCkgb3IgYnkgaWQuXG4gICAqXG4gICAqIFRoZSBtZXRob2QgaWdub3JlcyByZW1vdmFsIG9mIG5vbi1leGlzdGluZyBpdGVtcywgYW5kIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgaWRzIG9mIHRoZSBpdGVtcyB3aGljaCBhcmUgYWN0dWFsbHkgcmVtb3ZlZCBmcm9tIHRoZSBEYXRhU2V0LlxuICAgKlxuICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIHJlbW92ZWQsIHRoZSBEYXRhU2V0IHdpbGwgdHJpZ2dlciBhbiBldmVudCBgcmVtb3ZlYCBmb3IgdGhlIHJlbW92ZWQgaXRlbXMuIFdoZW4gYSBgc2VuZGVySWRgIGlzIHByb3ZpZGVkLCB0aGlzIGlkIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIHRyaWdnZXJlZCBldmVudCB0byBhbGwgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqICMjIEV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiAvLyBjcmVhdGUgYSBEYXRhU2V0XG4gICAqIGNvbnN0IGRhdGEgPSBuZXcgdmlzLkRhdGFTZXQoW1xuICAgKiAgIHsgaWQ6IDEsIHRleHQ6ICdpdGVtIDEnIH0sXG4gICAqICAgeyBpZDogMiwgdGV4dDogJ2l0ZW0gMicgfSxcbiAgICogICB7IGlkOiAzLCB0ZXh0OiAnaXRlbSAzJyB9XG4gICAqIF0pXG4gICAqXG4gICAqIC8vIHJlbW92ZSBpdGVtc1xuICAgKiBjb25zdCBpZHMgPSBkYXRhLnJlbW92ZShbMiwgeyBpZDogMyB9LCA0XSlcbiAgICpcbiAgICogY29uc29sZS5sb2coaWRzKSAvLyBbMiwgM11cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE9uZSBvciBtb3JlIGl0ZW1zIG9yIGlkcyBvZiBpdGVtcyB0byBiZSByZW1vdmVkLlxuICAgKiBAcGFyYW0gc2VuZGVySWQgLSBTZW5kZXIgaWQuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBpZHMgb2YgdGhlIHJlbW92ZWQgaXRlbXMuXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlKGlkOiBJZCB8IEl0ZW0gfCAoSWQgfCBJdGVtKVtdLCBzZW5kZXJJZD86IElkIHwgbnVsbCk6IElkW10ge1xuICAgIGNvbnN0IHJlbW92ZWRJZHM6IElkW10gPSBbXTtcbiAgICBjb25zdCByZW1vdmVkSXRlbXM6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD5bXSA9IFtdO1xuXG4gICAgLy8gZm9yY2UgZXZlcnl0aGluZyB0byBiZSBhbiBhcnJheSBmb3Igc2ltcGxpY2l0eVxuICAgIGNvbnN0IGlkcyA9IEFycmF5LmlzQXJyYXkoaWQpID8gaWQgOiBbaWRdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX3JlbW92ZShpZHNbaV0pO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgaXRlbUlkOiBPcHRJZCA9IGl0ZW1bdGhpcy5faWRQcm9wXTtcbiAgICAgICAgaWYgKGl0ZW1JZCAhPSBudWxsKSB7XG4gICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKGl0ZW1JZCk7XG4gICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoXG4gICAgICAgIFwicmVtb3ZlXCIsXG4gICAgICAgIHsgaXRlbXM6IHJlbW92ZWRJZHMsIG9sZERhdGE6IHJlbW92ZWRJdGVtcyB9LFxuICAgICAgICBzZW5kZXJJZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtb3ZlZElkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaXRlbSBieSBpdHMgaWQgb3IgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBJZCBvZiBhbiBpdGVtIG9yIHRoZSBpdGVtIGl0c2VsZi5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHJlbW92ZWQgaXRlbSBpZiByZW1vdmVkLCBudWxsIG90aGVyd2lzZS5cbiAgICovXG4gIHByaXZhdGUgX3JlbW92ZShpZDogSWQgfCBJdGVtKTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPiB8IG51bGwge1xuICAgIC8vIEBUT0RPOiBJdCBvcmlnaWFubGx5IHJldHVybmVkIHRoZSBpdGVtIGFsdGhvdWdoIHRoZSBkb2NzIHNheSBpZC5cbiAgICAvLyBUaGUgY29kZSBleHBlY3RzIHRoZSBpdGVtLCBzbyBwcm9iYWJseSBhbiBlcnJvciBpbiB0aGUgZG9jcy5cbiAgICBsZXQgaWRlbnQ6IE9wdElkO1xuXG4gICAgLy8gY29uZmlybSB0aGUgaWQgdG8gdXNlIGJhc2VkIG9uIHRoZSBhcmdzIHR5cGVcbiAgICBpZiAoaXNJZChpZCkpIHtcbiAgICAgIGlkZW50ID0gaWQ7XG4gICAgfSBlbHNlIGlmIChpZCAmJiB0eXBlb2YgaWQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlkZW50ID0gaWRbdGhpcy5faWRQcm9wXTsgLy8gbG9vayBmb3IgdGhlIGlkZW50aWZpZXIgZmllbGQgdXNpbmcgLl9pZFByb3BcbiAgICB9XG5cbiAgICAvLyBkbyB0aGUgcmVtb3ZpbmcgaWYgdGhlIGl0ZW0gaXMgZm91bmRcbiAgICBpZiAoaWRlbnQgIT0gbnVsbCAmJiB0aGlzLl9kYXRhLmhhcyhpZGVudCkpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9kYXRhLmdldChpZGVudCkgfHwgbnVsbDtcbiAgICAgIHRoaXMuX2RhdGEuZGVsZXRlKGlkZW50KTtcbiAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgZW50aXJlIGRhdGEgc2V0LlxuICAgKlxuICAgKiBBZnRlciB0aGUgaXRlbXMgYXJlIHJlbW92ZWQsIHRoZSBbW0RhdGFTZXRdXSB3aWxsIHRyaWdnZXIgYW4gZXZlbnQgYHJlbW92ZWAgZm9yIGFsbCByZW1vdmVkIGl0ZW1zLiBXaGVuIGEgYHNlbmRlcklkYCBpcyBwcm92aWRlZCwgdGhpcyBpZCB3aWxsIGJlIHBhc3NlZCB3aXRoIHRoZSB0cmlnZ2VyZWQgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gc2VuZGVySWQgLSBTZW5kZXIgaWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHJlbW92ZWRJZHMgLSBUaGUgaWRzIG9mIGFsbCByZW1vdmVkIGl0ZW1zLlxuICAgKi9cbiAgcHVibGljIGNsZWFyKHNlbmRlcklkPzogSWQgfCBudWxsKTogSWRbXSB7XG4gICAgY29uc3QgaWRzID0gWy4uLnRoaXMuX2RhdGEua2V5cygpXTtcbiAgICBjb25zdCBpdGVtczogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtcy5wdXNoKHRoaXMuX2RhdGEuZ2V0KGlkc1tpXSkhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhLmNsZWFyKCk7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCB7IGl0ZW1zOiBpZHMsIG9sZERhdGE6IGl0ZW1zIH0sIHNlbmRlcklkKTtcblxuICAgIHJldHVybiBpZHM7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgaXRlbSB3aXRoIG1heGltdW0gdmFsdWUgb2YgYSBzcGVjaWZpZWQgZmllbGQuXG4gICAqXG4gICAqIEBwYXJhbSBmaWVsZCAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIGZvciBtYXggdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm5zIEl0ZW0gY29udGFpbmluZyBtYXggdmFsdWUsIG9yIG51bGwgaWYgbm8gaXRlbXMuXG4gICAqL1xuICBwdWJsaWMgbWF4KGZpZWxkOiBrZXlvZiBJdGVtKTogSXRlbSB8IG51bGwge1xuICAgIGxldCBtYXggPSBudWxsO1xuICAgIGxldCBtYXhGaWVsZCA9IG51bGw7XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5fZGF0YS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgaXRlbUZpZWxkID0gaXRlbVtmaWVsZF07XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBpdGVtRmllbGQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgKG1heEZpZWxkID09IG51bGwgfHwgaXRlbUZpZWxkID4gbWF4RmllbGQpXG4gICAgICApIHtcbiAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgbWF4RmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heCB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtaW5pbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gZmllbGQgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBzZWFyY2hlZCBmb3IgbWluIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyBJdGVtIGNvbnRhaW5pbmcgbWluIHZhbHVlLCBvciBudWxsIGlmIG5vIGl0ZW1zLlxuICAgKi9cbiAgcHVibGljIG1pbihmaWVsZDoga2V5b2YgSXRlbSk6IEl0ZW0gfCBudWxsIHtcbiAgICBsZXQgbWluID0gbnVsbDtcbiAgICBsZXQgbWluRmllbGQgPSBudWxsO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2RhdGEudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgaXRlbUZpZWxkID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIChtaW5GaWVsZCA9PSBudWxsIHx8IGl0ZW1GaWVsZCA8IG1pbkZpZWxkKVxuICAgICAgKSB7XG4gICAgICAgIG1pbiA9IGl0ZW07XG4gICAgICAgIG1pbkZpZWxkID0gaXRlbUZpZWxkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW4gfHwgbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBkaXN0aW5jdDxUIGV4dGVuZHMga2V5b2YgSXRlbT4ocHJvcDogVCk6IEl0ZW1bVF1bXTtcbiAgcHVibGljIGRpc3RpbmN0KHByb3A6IHN0cmluZyk6IHVua25vd25bXTtcbiAgLyoqXG4gICAqIEZpbmQgYWxsIGRpc3RpbmN0IHZhbHVlcyBvZiBhIHNwZWNpZmllZCBmaWVsZFxuICAgKlxuICAgKiBAcGFyYW0gcHJvcCAtIFRoZSBwcm9wZXJ0eSBuYW1lIHdob3NlIGRpc3RpbmN0IHZhbHVlcyBzaG91bGQgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIFVub3JkZXJlZCBhcnJheSBjb250YWluaW5nIGFsbCBkaXN0aW5jdCB2YWx1ZXMuIEl0ZW1zIHdpdGhvdXQgc3BlY2lmaWVkIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgKi9cbiAgcHVibGljIGRpc3RpbmN0PFQgZXh0ZW5kcyBzdHJpbmc+KHByb3A6IFQpOiB1bmtub3duW10ge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGl0ZW1JZHMgPSBbLi4uZGF0YS5rZXlzKCldO1xuICAgIGNvbnN0IHZhbHVlczogdW5rbm93bltdID0gW107XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpdGVtSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBpZCA9IGl0ZW1JZHNbaV07XG4gICAgICBjb25zdCBpdGVtID0gZGF0YS5nZXQoaWQpO1xuICAgICAgY29uc3QgdmFsdWUgPSAoaXRlbSBhcyBhbnkpW3Byb3BdO1xuICAgICAgbGV0IGV4aXN0cyA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbal0gPT0gdmFsdWUpIHtcbiAgICAgICAgICBleGlzdHMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWV4aXN0cyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlc1tjb3VudF0gPSB2YWx1ZTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBpdGVtLiBXaWxsIGZhaWwgd2hlbiBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQgYWxyZWFkeSBleGlzdHMuXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gQSBuZXcgaXRlbSB0byBiZSBhZGRlZC5cbiAgICpcbiAgICogQHJldHVybnMgQWRkZWQgaXRlbSdzIGlkLiBBbiBpZCBpcyBnZW5lcmF0ZWQgd2hlbiBpdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgaXRlbS5cbiAgICovXG4gIHByaXZhdGUgX2FkZEl0ZW0oaXRlbTogSXRlbSk6IElkIHtcbiAgICBjb25zdCBmdWxsSXRlbSA9IGVuc3VyZUZ1bGxJdGVtKGl0ZW0sIHRoaXMuX2lkUHJvcCk7XG4gICAgY29uc3QgaWQgPSBmdWxsSXRlbVt0aGlzLl9pZFByb3BdO1xuXG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGlzIGlkIGlzIGFscmVhZHkgdGFrZW5cbiAgICBpZiAodGhpcy5fZGF0YS5oYXMoaWQpKSB7XG4gICAgICAvLyBpdGVtIGFscmVhZHkgZXhpc3RzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IGFkZCBpdGVtOiBpdGVtIHdpdGggaWQgXCIgKyBpZCArIFwiIGFscmVhZHkgZXhpc3RzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YS5zZXQoaWQsIGZ1bGxJdGVtKTtcbiAgICArK3RoaXMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIHNpbmdsZSBpdGVtOiBtZXJnZSB3aXRoIGV4aXN0aW5nIGl0ZW0uXG4gICAqIFdpbGwgZmFpbCB3aGVuIHRoZSBpdGVtIGhhcyBubyBpZCwgb3Igd2hlbiB0aGVyZSBkb2VzIG5vdCBleGlzdCBhbiBpdGVtIHdpdGggdGhlIHNhbWUgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB1cGRhdGUgLSBUaGUgbmV3IGl0ZW1cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGlkIG9mIHRoZSB1cGRhdGVkIGl0ZW0uXG4gICAqL1xuICBwcml2YXRlIF91cGRhdGVJdGVtKHVwZGF0ZTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPik6IElkIHtcbiAgICBjb25zdCBpZDogT3B0SWQgPSB1cGRhdGVbdGhpcy5faWRQcm9wXTtcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCB1cGRhdGUgaXRlbTogaXRlbSBoYXMgbm8gaWQgKGl0ZW06IFwiICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1cGRhdGUpICtcbiAgICAgICAgICBcIilcIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2RhdGEuZ2V0KGlkKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIC8vIGl0ZW0gZG9lc24ndCBleGlzdFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBpdGVtOiBubyBpdGVtIHdpdGggaWQgXCIgKyBpZCArIFwiIGZvdW5kXCIpO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGEuc2V0KGlkLCB7IC4uLml0ZW0sIC4uLnVwZGF0ZSB9KTtcblxuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgc3RyZWFtKGlkcz86IEl0ZXJhYmxlPElkPik6IERhdGFTdHJlYW08SXRlbT4ge1xuICAgIGlmIChpZHMpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICByZXR1cm4gbmV3IERhdGFTdHJlYW08SXRlbT4oe1xuICAgICAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxbSWQsIEl0ZW1dPiB7XG4gICAgICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoaXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHlpZWxkIFtpZCwgaXRlbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0YVN0cmVhbSh7XG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB0aGlzLl9kYXRhLmVudHJpZXMuYmluZCh0aGlzLl9kYXRhKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qIGRldmVsYmxvY2s6c3RhcnQgKi9cbiAgcHVibGljIGdldCB0ZXN0TGVha0RhdGEoKTogTWFwPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PiB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgcHVibGljIGdldCB0ZXN0TGVha0lkUHJvcCgpOiBJZFByb3Age1xuICAgIHJldHVybiB0aGlzLl9pZFByb3A7XG4gIH1cbiAgcHVibGljIGdldCB0ZXN0TGVha09wdGlvbnMoKTogRGF0YVNldEluaXRpYWxPcHRpb25zPElkUHJvcD4ge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIHB1YmxpYyBnZXQgdGVzdExlYWtRdWV1ZSgpOiBRdWV1ZTx0aGlzPiB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZTtcbiAgfVxuICBwdWJsaWMgc2V0IHRlc3RMZWFrUXVldWUodjogUXVldWU8dGhpcz4gfCBudWxsKSB7XG4gICAgdGhpcy5fcXVldWUgPSB2O1xuICB9XG4gIC8qIGRldmVsYmxvY2s6ZW5kICovXG59XG4iLCJpbXBvcnQge1xuICBEYXRhSW50ZXJmYWNlLFxuICBEYXRhSW50ZXJmYWNlRm9yRWFjaE9wdGlvbnMsXG4gIERhdGFJbnRlcmZhY2VHZXRJZHNPcHRpb25zLFxuICBEYXRhSW50ZXJmYWNlR2V0T3B0aW9ucyxcbiAgRGF0YUludGVyZmFjZUdldE9wdGlvbnNBcnJheSxcbiAgRGF0YUludGVyZmFjZUdldE9wdGlvbnNPYmplY3QsXG4gIERhdGFJbnRlcmZhY2VNYXBPcHRpb25zLFxuICBFdmVudENhbGxiYWNrc1dpdGhBbnksXG4gIEV2ZW50TmFtZSxcbiAgRXZlbnRQYXlsb2FkcyxcbiAgRnVsbEl0ZW0sXG4gIElkLFxuICBQYXJ0SXRlbSxcbiAgUmVtb3ZlRXZlbnRQYXlsb2FkLFxuICBVcGRhdGVFdmVudFBheWxvYWQsXG4gIGlzSWQsXG59IGZyb20gXCIuL2RhdGEtaW50ZXJmYWNlXCI7XG5cbmltcG9ydCB7IERhdGFTZXQgfSBmcm9tIFwiLi9kYXRhLXNldFwiO1xuaW1wb3J0IHsgRGF0YVNldFBhcnQgfSBmcm9tIFwiLi9kYXRhLXNldC1wYXJ0XCI7XG5pbXBvcnQgeyBEYXRhU3RyZWFtIH0gZnJvbSBcIi4vZGF0YS1zdHJlYW1cIjtcblxuLyoqXG4gKiBEYXRhIHZpZXcgb3B0aW9ucy5cbiAqXG4gKiBAdHlwZVBhcmFtIEl0ZW0gLSBJdGVtIHR5cGUgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGlkLlxuICogQHR5cGVQYXJhbSBJZFByb3AgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBpZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEYXRhVmlld09wdGlvbnM8SXRlbSwgSWRQcm9wIGV4dGVuZHMgc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyB0aGUgaWQgb2YgdGhlIGl0ZW1zLiBXaGVuIGRhdGEgaXMgZmV0Y2hlZCBmcm9tIGEgc2VydmVyIHdoaWNoIHVzZXMgc29tZSBzcGVjaWZpYyBmaWVsZCB0byBpZGVudGlmeSBpdGVtcywgdGhpcyBmaWVsZCBuYW1lIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIERhdGFTZXQgdXNpbmcgdGhlIG9wdGlvbiBgZmllbGRJZGAuIEZvciBleGFtcGxlIFtDb3VjaERCXShodHRwOi8vY291Y2hkYi5hcGFjaGUub3JnLykgdXNlcyB0aGUgZmllbGQgYCdfaWQnYCB0byBpZGVudGlmeSBkb2N1bWVudHMuXG4gICAqL1xuICBmaWVsZElkPzogSWRQcm9wO1xuICAvKiogSXRlbXMgY2FuIGJlIGZpbHRlcmVkIG9uIHNwZWNpZmljIHByb3BlcnRpZXMgYnkgcHJvdmlkaW5nIGEgZmlsdGVyIGZ1bmN0aW9uLiBBIGZpbHRlciBmdW5jdGlvbiBpcyBleGVjdXRlZCBmb3IgZWFjaCBvZiB0aGUgaXRlbXMgaW4gdGhlIERhdGFTZXQsIGFuZCBpcyBjYWxsZWQgd2l0aCB0aGUgaXRlbSBhcyBwYXJhbWV0ZXIuIFRoZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIGJvb2xlYW4uIEFsbCBpdGVtcyBmb3Igd2hpY2ggdGhlIGZpbHRlciBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2lsbCBiZSBlbWl0dGVkLiAqL1xuICBmaWx0ZXI/OiAoaXRlbTogSXRlbSkgPT4gYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBEYXRhVmlld1xuICpcbiAqIEEgRGF0YVZpZXcgb2ZmZXJzIGEgZmlsdGVyZWQgYW5kL29yIGZvcm1hdHRlZCB2aWV3IG9uIGEgRGF0YVNldC4gT25lIGNhbiBzdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiBhIERhdGFWaWV3LCBhbmQgZWFzaWx5IGdldCBmaWx0ZXJlZCBvciBmb3JtYXR0ZWQgZGF0YSB3aXRob3V0IGhhdmluZyB0byBzcGVjaWZ5IGZpbHRlcnMgYW5kIGZpZWxkIHR5cGVzIGFsbCB0aGUgdGltZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjcmVhdGUgYSBEYXRhU2V0XG4gKiB2YXIgZGF0YSA9IG5ldyB2aXMuRGF0YVNldCgpO1xuICogZGF0YS5hZGQoW1xuICogICB7aWQ6IDEsIHRleHQ6ICdpdGVtIDEnLCBkYXRlOiBuZXcgRGF0ZSgyMDEzLCA2LCAyMCksIGdyb3VwOiAxLCBmaXJzdDogdHJ1ZX0sXG4gKiAgIHtpZDogMiwgdGV4dDogJ2l0ZW0gMicsIGRhdGU6ICcyMDEzLTA2LTIzJywgZ3JvdXA6IDJ9LFxuICogICB7aWQ6IDMsIHRleHQ6ICdpdGVtIDMnLCBkYXRlOiAnMjAxMy0wNi0yNScsIGdyb3VwOiAyfSxcbiAqICAge2lkOiA0LCB0ZXh0OiAnaXRlbSA0J31cbiAqIF0pO1xuICpcbiAqIC8vIGNyZWF0ZSBhIERhdGFWaWV3XG4gKiAvLyB0aGUgdmlldyB3aWxsIG9ubHkgY29udGFpbiBpdGVtcyBoYXZpbmcgYSBwcm9wZXJ0eSBncm91cCB3aXRoIHZhbHVlIDEsXG4gKiAvLyBhbmQgd2lsbCBvbmx5IG91dHB1dCBmaWVsZHMgaWQsIHRleHQsIGFuZCBkYXRlLlxuICogdmFyIHZpZXcgPSBuZXcgdmlzLkRhdGFWaWV3KGRhdGEsIHtcbiAqICAgZmlsdGVyOiBmdW5jdGlvbiAoaXRlbSkge1xuICogICAgIHJldHVybiAoaXRlbS5ncm91cCA9PSAxKTtcbiAqICAgfSxcbiAqICAgZmllbGRzOiBbJ2lkJywgJ3RleHQnLCAnZGF0ZSddXG4gKiB9KTtcbiAqXG4gKiAvLyBzdWJzY3JpYmUgdG8gYW55IGNoYW5nZSBpbiB0aGUgRGF0YVZpZXdcbiAqIHZpZXcub24oJyonLCBmdW5jdGlvbiAoZXZlbnQsIHByb3BlcnRpZXMsIHNlbmRlcklkKSB7XG4gKiAgIGNvbnNvbGUubG9nKCdldmVudCcsIGV2ZW50LCBwcm9wZXJ0aWVzKTtcbiAqIH0pO1xuICpcbiAqIC8vIHVwZGF0ZSBhbiBpdGVtIGluIHRoZSBkYXRhIHNldFxuICogZGF0YS51cGRhdGUoe2lkOiAyLCBncm91cDogMX0pO1xuICpcbiAqIC8vIGdldCBhbGwgaWRzIGluIHRoZSB2aWV3XG4gKiB2YXIgaWRzID0gdmlldy5nZXRJZHMoKTtcbiAqIGNvbnNvbGUubG9nKCdpZHMnLCBpZHMpOyAvLyB3aWxsIG91dHB1dCBbMSwgMl1cbiAqXG4gKiAvLyBnZXQgYWxsIGl0ZW1zIGluIHRoZSB2aWV3XG4gKiB2YXIgaXRlbXMgPSB2aWV3LmdldCgpO1xuICogYGBgXG4gKlxuICogQHR5cGVQYXJhbSBJdGVtIC0gSXRlbSB0eXBlIHRoYXQgbWF5IG9yIG1heSBub3QgaGF2ZSBhbiBpZC5cbiAqIEB0eXBlUGFyYW0gSWRQcm9wIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhVmlldzxcbiAgICBJdGVtIGV4dGVuZHMgUGFydEl0ZW08SWRQcm9wPixcbiAgICBJZFByb3AgZXh0ZW5kcyBzdHJpbmcgPSBcImlkXCJcbiAgPlxuICBleHRlbmRzIERhdGFTZXRQYXJ0PEl0ZW0sIElkUHJvcD5cbiAgaW1wbGVtZW50cyBEYXRhSW50ZXJmYWNlPEl0ZW0sIElkUHJvcD4ge1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGxlbmd0aCA9IDA7XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgZ2V0IGlkUHJvcCgpOiBJZFByb3Age1xuICAgIHJldHVybiB0aGlzLmdldERhdGFTZXQoKS5pZFByb3A7XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IF9saXN0ZW5lcjogRXZlbnRDYWxsYmFja3NXaXRoQW55PEl0ZW0sIElkUHJvcD5bXCIqXCJdO1xuICBwcml2YXRlIF9kYXRhITogRGF0YUludGVyZmFjZTxJdGVtLCBJZFByb3A+OyAvLyBjb25zdHJ1Y3RvciDihpIgc2V0RGF0YVxuICBwcml2YXRlIHJlYWRvbmx5IF9pZHM6IFNldDxJZD4gPSBuZXcgU2V0KCk7IC8vIGlkcyBvZiB0aGUgaXRlbXMgY3VycmVudGx5IGluIG1lbW9yeSAoanVzdCBjb250YWlucyBhIGJvb2xlYW4gdHJ1ZSlcbiAgcHJpdmF0ZSByZWFkb25seSBfb3B0aW9uczogRGF0YVZpZXdPcHRpb25zPEl0ZW0sIElkUHJvcD47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGFWaWV3LlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBpbnN0YW5jZSBjb250YWluaW5nIGRhdGEgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHkpLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gY29uZmlndXJlIHRoaXMgZGF0YSB2aWV3LlxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIGRhdGE6IERhdGFJbnRlcmZhY2U8SXRlbSwgSWRQcm9wPixcbiAgICBvcHRpb25zPzogRGF0YVZpZXdPcHRpb25zPEl0ZW0sIElkUHJvcD5cbiAgKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5fbGlzdGVuZXIgPSB0aGlzLl9vbkV2ZW50LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gIH1cblxuICAvLyBUT0RPOiBpbXBsZW1lbnQgYSBmdW5jdGlvbiAuY29uZmlnKCkgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoaW5ncyBsaWtlIGNvbmZpZ3VyZWQgZmlsdGVyXG4gIC8vIGFuZCB0cmlnZ2VyIGNoYW5nZXMgYWNjb3JkaW5nbHlcblxuICAvKipcbiAgICogU2V0IGEgZGF0YSBzb3VyY2UgZm9yIHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBpbnN0YW5jZSBjb250YWluaW5nIGRhdGEgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHkpLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBOb3RlIHRoYXQgd2hlbiB0aGUgZGF0YSB2aWV3IGlzIGJvdW5kIHRvIGEgZGF0YSBzZXQgaXQgd29uJ3QgYmUgZ2FyYmFnZVxuICAgKiBjb2xsZWN0ZWQgdW5sZXNzIHRoZSBkYXRhIHNldCBpcyB0b28uIFVzZSBgZGF0YVZpZXcuc2V0RGF0YShudWxsKWAgb3JcbiAgICogYGRhdGFWaWV3LmRpc3Bvc2UoKWAgdG8gZW5hYmxlIGdhcmJhZ2UgY29sbGVjdGlvbiBiZWZvcmUgeW91IGxvc2UgdGhlIGxhc3RcbiAgICogcmVmZXJlbmNlLlxuICAgKi9cbiAgcHVibGljIHNldERhdGEoZGF0YTogRGF0YUludGVyZmFjZTxJdGVtLCBJZFByb3A+KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gY3VycmVudCBkYXRhc2V0XG4gICAgICBpZiAodGhpcy5fZGF0YS5vZmYpIHtcbiAgICAgICAgdGhpcy5fZGF0YS5vZmYoXCIqXCIsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gdHJpZ2dlciBhIHJlbW92ZSBvZiBhbGwgaXRlbXMgaW4gbWVtb3J5XG4gICAgICBjb25zdCBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7IGZpbHRlcjogdGhpcy5fb3B0aW9ucy5maWx0ZXIgfSk7XG4gICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2RhdGEuZ2V0KGlkcyk7XG5cbiAgICAgIHRoaXMuX2lkcy5jbGVhcigpO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCB7IGl0ZW1zOiBpZHMsIG9sZERhdGE6IGl0ZW1zIH0pO1xuICAgIH1cblxuICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuXG4gICAgICAvLyB0cmlnZ2VyIGFuIGFkZCBvZiBhbGwgYWRkZWQgaXRlbXNcbiAgICAgIGNvbnN0IGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHsgZmlsdGVyOiB0aGlzLl9vcHRpb25zLmZpbHRlciB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgaWQgPSBpZHNbaV07XG4gICAgICAgIHRoaXMuX2lkcy5hZGQoaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggPSBpZHMubGVuZ3RoO1xuICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7IGl0ZW1zOiBpZHMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBuZXcgRGF0YVNldDxJdGVtLCBJZFByb3A+KCk7XG4gICAgfVxuXG4gICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgaWYgKHRoaXMuX2RhdGEub24pIHtcbiAgICAgIHRoaXMuX2RhdGEub24oXCIqXCIsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgRGF0YVZpZXcuXG4gICAqIFVzZWZ1bCB3aGVuIHRoZSBEYXRhVmlldyBoYXMgYSBmaWx0ZXIgZnVuY3Rpb24gY29udGFpbmluZyBhIHZhcmlhYmxlIHBhcmFtZXRlci5cbiAgICovXG4gIHB1YmxpYyByZWZyZXNoKCk6IHZvaWQge1xuICAgIGNvbnN0IGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtcbiAgICAgIGZpbHRlcjogdGhpcy5fb3B0aW9ucy5maWx0ZXIsXG4gICAgfSk7XG4gICAgY29uc3Qgb2xkSWRzID0gWy4uLnRoaXMuX2lkc107XG4gICAgY29uc3QgbmV3SWRzOiBSZWNvcmQ8SWQsIGJvb2xlYW4+ID0ge307XG4gICAgY29uc3QgYWRkZWRJZHM6IElkW10gPSBbXTtcbiAgICBjb25zdCByZW1vdmVkSWRzOiBJZFtdID0gW107XG4gICAgY29uc3QgcmVtb3ZlZEl0ZW1zOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W10gPSBbXTtcblxuICAgIC8vIGNoZWNrIGZvciBhZGRpdGlvbnNcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBpZCA9IGlkc1tpXTtcbiAgICAgIG5ld0lkc1tpZF0gPSB0cnVlO1xuICAgICAgaWYgKCF0aGlzLl9pZHMuaGFzKGlkKSkge1xuICAgICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgdGhpcy5faWRzLmFkZChpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIHJlbW92YWxzXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9sZElkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgaWQgPSBvbGRJZHNbaV07XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5fZGF0YS5nZXQoaWQpO1xuICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgICAgICAvLyBAVE9ETzogSW52ZXN0aWdhdGUuXG4gICAgICAgIC8vIERvZXNuJ3QgaGFwcGVuIGR1cmluZyB0ZXN0cyBvciBleGFtcGxlcy5cbiAgICAgICAgLy8gSXMgaXQgcmVhbGx5IGltcG9zc2libGUgb3IgY291bGQgaXQgZXZlbnR1YWxseSBoYXBwZW4/XG4gICAgICAgIC8vIEhvdyB0byBoYW5kbGUgaXQgaWYgaXQgZG9lcz8gVGhlIHR5cGVzIGd1YXJhbnRlZSBub24tbnVsbGFibGUgaXRlbXMuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJZiB5b3Ugc2VlIHRoaXMsIHJlcG9ydCBpdCBwbGVhc2UuXCIpO1xuICAgICAgfSBlbHNlIGlmICghbmV3SWRzW2lkXSkge1xuICAgICAgICByZW1vdmVkSWRzLnB1c2goaWQpO1xuICAgICAgICByZW1vdmVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgdGhpcy5faWRzLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggKz0gYWRkZWRJZHMubGVuZ3RoIC0gcmVtb3ZlZElkcy5sZW5ndGg7XG5cbiAgICAvLyB0cmlnZ2VyIGV2ZW50c1xuICAgIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoXCJhZGRcIiwgeyBpdGVtczogYWRkZWRJZHMgfSk7XG4gICAgfVxuICAgIGlmIChyZW1vdmVkSWRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcihcInJlbW92ZVwiLCB7IGl0ZW1zOiByZW1vdmVkSWRzLCBvbGREYXRhOiByZW1vdmVkSXRlbXMgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoKTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdO1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGdldChcbiAgICBvcHRpb25zOiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uc0FycmF5PEl0ZW0+XG4gICk6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD5bXTtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnNPYmplY3Q8SXRlbT5cbiAgKTogUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnM8SXRlbT5cbiAgKTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdIHwgUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoaWQ6IElkKTogbnVsbCB8IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD47XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgZ2V0KFxuICAgIGlkOiBJZCxcbiAgICBvcHRpb25zOiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uc0FycmF5PEl0ZW0+XG4gICk6IG51bGwgfCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+O1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGdldChcbiAgICBpZDogSWQsXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnNPYmplY3Q8SXRlbT5cbiAgKTogUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoXG4gICAgaWQ6IElkLFxuICAgIG9wdGlvbnM6IERhdGFJbnRlcmZhY2VHZXRPcHRpb25zPEl0ZW0+XG4gICk6IG51bGwgfCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+IHwgUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoaWRzOiBJZFtdKTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdO1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGdldChcbiAgICBpZHM6IElkW10sXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnNBcnJheTxJdGVtPlxuICApOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W107XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBwdWJsaWMgZ2V0KFxuICAgIGlkczogSWRbXSxcbiAgICBvcHRpb25zOiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uc09iamVjdDxJdGVtPlxuICApOiBSZWNvcmQ8SWQsIEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD4+O1xuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGdldChcbiAgICBpZHM6IElkW10sXG4gICAgb3B0aW9uczogRGF0YUludGVyZmFjZUdldE9wdGlvbnM8SXRlbT5cbiAgKTogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdIHwgUmVjb3JkPElkLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PjtcbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoXG4gICAgaWRzOiBJZCB8IElkW10sXG4gICAgb3B0aW9ucz86IERhdGFJbnRlcmZhY2VHZXRPcHRpb25zPEl0ZW0+XG4gICk6XG4gICAgfCBudWxsXG4gICAgfCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+XG4gICAgfCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W11cbiAgICB8IFJlY29yZDxJZCwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPj47XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXQoXG4gICAgZmlyc3Q/OiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uczxJdGVtPiB8IElkIHwgSWRbXSxcbiAgICBzZWNvbmQ/OiBEYXRhSW50ZXJmYWNlR2V0T3B0aW9uczxJdGVtPlxuICApOlxuICAgIHwgbnVsbFxuICAgIHwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPlxuICAgIHwgRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdXG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBGdWxsSXRlbTxJdGVtLCBJZFByb3A+PiB7XG4gICAgaWYgKHRoaXMuX2RhdGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICAgIGxldCBpZHM6IElkIHwgSWRbXSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBvcHRpb25zOiBhbnk7XG4gICAgaWYgKGlzSWQoZmlyc3QpIHx8IEFycmF5LmlzQXJyYXkoZmlyc3QpKSB7XG4gICAgICBpZHMgPSBmaXJzdDtcbiAgICAgIG9wdGlvbnMgPSBzZWNvbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmaXJzdDtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgdGhlIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zIGFuZCBwcm92aWRlZCBvcHRpb25zXG4gICAgY29uc3Qgdmlld09wdGlvbnM6IERhdGFJbnRlcmZhY2VHZXRPcHRpb25zPEl0ZW0+ID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgLy8gY3JlYXRlIGEgY29tYmluZWQgZmlsdGVyIG1ldGhvZCB3aGVuIG5lZWRlZFxuICAgIGNvbnN0IHRoaXNGaWx0ZXIgPSB0aGlzLl9vcHRpb25zLmZpbHRlcjtcbiAgICBjb25zdCBvcHRpb25zRmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcjtcbiAgICBpZiAodGhpc0ZpbHRlciAmJiBvcHRpb25zRmlsdGVyKSB7XG4gICAgICB2aWV3T3B0aW9ucy5maWx0ZXIgPSAoaXRlbSk6IGJvb2xlYW4gPT4ge1xuICAgICAgICByZXR1cm4gdGhpc0ZpbHRlcihpdGVtKSAmJiBvcHRpb25zRmlsdGVyKGl0ZW0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaWRzID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldCh2aWV3T3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldChpZHMsIHZpZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGdldElkcyhvcHRpb25zPzogRGF0YUludGVyZmFjZUdldElkc09wdGlvbnM8SXRlbT4pOiBJZFtdIHtcbiAgICBpZiAodGhpcy5fZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRGaWx0ZXIgPSB0aGlzLl9vcHRpb25zLmZpbHRlcjtcbiAgICAgIGNvbnN0IG9wdGlvbnNGaWx0ZXIgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLmZpbHRlciA6IG51bGw7XG4gICAgICBsZXQgZmlsdGVyOiBEYXRhSW50ZXJmYWNlR2V0SWRzT3B0aW9uczxJdGVtPltcImZpbHRlclwiXTtcblxuICAgICAgaWYgKG9wdGlvbnNGaWx0ZXIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRGaWx0ZXIpIHtcbiAgICAgICAgICBmaWx0ZXIgPSAoaXRlbSk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9uc0ZpbHRlcihpdGVtKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlciA9IG9wdGlvbnNGaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldElkcyh7XG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHVibGljIGZvckVhY2goXG4gICAgY2FsbGJhY2s6IChpdGVtOiBJdGVtLCBpZDogSWQpID0+IHZvaWQsXG4gICAgb3B0aW9ucz86IERhdGFJbnRlcmZhY2VGb3JFYWNoT3B0aW9uczxJdGVtPlxuICApOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgY29uc3QgZGVmYXVsdEZpbHRlciA9IHRoaXMuX29wdGlvbnMuZmlsdGVyO1xuICAgICAgY29uc3Qgb3B0aW9uc0ZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXI7XG4gICAgICBsZXQgZmlsdGVyOiB1bmRlZmluZWQgfCAoKGl0ZW06IEl0ZW0pID0+IGJvb2xlYW4pO1xuXG4gICAgICBpZiAob3B0aW9uc0ZpbHRlcikge1xuICAgICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uIChpdGVtOiBJdGVtKTogYm9vbGVhbiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEZpbHRlcihpdGVtKSAmJiBvcHRpb25zRmlsdGVyKGl0ZW0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyID0gb3B0aW9uc0ZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGF0YS5mb3JFYWNoKGNhbGxiYWNrLCB7XG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBvcmRlcjogb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBtYXA8VD4oXG4gICAgY2FsbGJhY2s6IChpdGVtOiBJdGVtLCBpZDogSWQpID0+IFQsXG4gICAgb3B0aW9ucz86IERhdGFJbnRlcmZhY2VNYXBPcHRpb25zPEl0ZW0sIFQ+XG4gICk6IFRbXSB7XG4gICAgdHlwZSBGaWx0ZXIgPSBOb25OdWxsYWJsZTxEYXRhSW50ZXJmYWNlTWFwT3B0aW9uczxJdGVtLCBUPltcImZpbHRlclwiXT47XG5cbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgY29uc3QgZGVmYXVsdEZpbHRlciA9IHRoaXMuX29wdGlvbnMuZmlsdGVyO1xuICAgICAgY29uc3Qgb3B0aW9uc0ZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXI7XG4gICAgICBsZXQgZmlsdGVyOiB1bmRlZmluZWQgfCBGaWx0ZXI7XG5cbiAgICAgIGlmIChvcHRpb25zRmlsdGVyKSB7XG4gICAgICAgIGlmIChkZWZhdWx0RmlsdGVyKSB7XG4gICAgICAgICAgZmlsdGVyID0gKGl0ZW0pOiBSZXR1cm5UeXBlPEZpbHRlcj4gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWx0ZXIoaXRlbSkgJiYgb3B0aW9uc0ZpbHRlcihpdGVtKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlciA9IG9wdGlvbnNGaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kYXRhLm1hcChjYWxsYmFjaywge1xuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgb3JkZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcixcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBnZXREYXRhU2V0KCk6IERhdGFTZXQ8SXRlbSwgSWRQcm9wPiB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0RGF0YVNldCgpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHB1YmxpYyBzdHJlYW0oaWRzPzogSXRlcmFibGU8SWQ+KTogRGF0YVN0cmVhbTxJdGVtPiB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc3RyZWFtKFxuICAgICAgaWRzIHx8IHtcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06IHRoaXMuX2lkcy5rZXlzLmJpbmQodGhpcy5faWRzKSxcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgaW5zdGFuY2UgdW51c2FibGUgcHJpb3IgdG8gZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgaW50ZW50aW9uIG9mIHRoaXMgbWV0aG9kIGlzIHRvIGhlbHAgZGlzY292ZXIgc2NlbmFyaW9zIHdoZXJlIHRoZSBkYXRhXG4gICAqIHZpZXcgaXMgYmVpbmcgdXNlZCB3aGVuIHRoZSBwcm9ncmFtbWVyIHRoaW5rcyBpdCBoYXMgYmVlbiBnYXJiYWdlIGNvbGxlY3RlZFxuICAgKiBhbHJlYWR5LiBJdCdzIHN0cmljdGVyIHZlcnNpb24gb2YgYGRhdGFWaWV3LnNldERhdGEobnVsbClgLlxuICAgKi9cbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2RhdGE/Lm9mZikge1xuICAgICAgdGhpcy5fZGF0YS5vZmYoXCIqXCIsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlID0gXCJUaGlzIGRhdGEgdmlldyBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkIG9mLlwiO1xuICAgIGNvbnN0IHJlcGxhY2VtZW50ID0ge1xuICAgICAgZ2V0OiAoKTogdm9pZCA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6ICgpOiB2b2lkID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSxcblxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFJlZmxlY3Qub3duS2V5cyhEYXRhVmlldy5wcm90b3R5cGUpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCByZXBsYWNlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGxpc3RlbmVyLiBXaWxsIHByb3BhZ2F0ZSBhbGwgZXZlbnRzIGZyb20gdGhlIGNvbm5lY3RlZCBkYXRhIHNldCB0byB0aGUgc3Vic2NyaWJlcnMgb2YgdGhlIERhdGFWaWV3LCBidXQgd2lsbCBmaWx0ZXIgdGhlIGl0ZW1zIGFuZCBvbmx5IHRyaWdnZXIgd2hlbiB0aGVyZSBhcmUgY2hhbmdlcyBpbiB0aGUgZmlsdGVyZWQgZGF0YSBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgb2YgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0gc2VuZGVySWQgLSBJZCBzdXBwbGllZCBieSB0aGUgc2VuZGVyLlxuICAgKi9cbiAgcHJpdmF0ZSBfb25FdmVudDxFTiBleHRlbmRzIEV2ZW50TmFtZT4oXG4gICAgZXZlbnQ6IEVOLFxuICAgIHBhcmFtczogRXZlbnRQYXlsb2FkczxJdGVtLCBJZFByb3A+W0VOXSxcbiAgICBzZW5kZXJJZD86IElkIHwgbnVsbFxuICApOiB2b2lkIHtcbiAgICBpZiAoIXBhcmFtcyB8fCAhcGFyYW1zLml0ZW1zIHx8ICF0aGlzLl9kYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaWRzID0gcGFyYW1zLml0ZW1zO1xuICAgIGNvbnN0IGFkZGVkSWRzOiBJZFtdID0gW107XG4gICAgY29uc3QgdXBkYXRlZElkczogSWRbXSA9IFtdO1xuICAgIGNvbnN0IHJlbW92ZWRJZHM6IElkW10gPSBbXTtcbiAgICBjb25zdCBvbGRJdGVtczogRnVsbEl0ZW08SXRlbSwgSWRQcm9wPltdID0gW107XG4gICAgY29uc3QgdXBkYXRlZEl0ZW1zOiBGdWxsSXRlbTxJdGVtLCBJZFByb3A+W10gPSBbXTtcbiAgICBjb25zdCByZW1vdmVkSXRlbXM6IEZ1bGxJdGVtPEl0ZW0sIElkUHJvcD5bXSA9IFtdO1xuXG4gICAgc3dpdGNoIChldmVudCkge1xuICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAvLyBmaWx0ZXIgdGhlIGlkcyBvZiB0aGUgYWRkZWQgaXRlbXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbnN0IGlkID0gaWRzW2ldO1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2lkcy5hZGQoaWQpO1xuICAgICAgICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBldmVudCBmcm9tIHRoZSB2aWV3cyB2aWV3cG9pbnQ6IGFuIHVwZGF0ZWRcbiAgICAgICAgLy8gaXRlbSBjYW4gYmUgYWRkZWQsIHVwZGF0ZWQsIG9yIHJlbW92ZWQgZnJvbSB0aGlzIHZpZXcuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5nZXQoaWQpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgICB1cGRhdGVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgICB1cGRhdGVkSXRlbXMucHVzaChcbiAgICAgICAgICAgICAgICAocGFyYW1zIGFzIFVwZGF0ZUV2ZW50UGF5bG9hZDxJdGVtLCBJZFByb3A+KS5kYXRhW2ldXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG9sZEl0ZW1zLnB1c2goXG4gICAgICAgICAgICAgICAgKHBhcmFtcyBhcyBVcGRhdGVFdmVudFBheWxvYWQ8SXRlbSwgSWRQcm9wPikub2xkRGF0YVtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5faWRzLmFkZChpZCk7XG4gICAgICAgICAgICAgIGFkZGVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5faWRzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgIHJlbW92ZWRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKFxuICAgICAgICAgICAgICAgIChwYXJhbXMgYXMgVXBkYXRlRXZlbnRQYXlsb2FkPEl0ZW0sIElkUHJvcD4pLm9sZERhdGFbaV1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG5vdGhpbmcgaW50ZXJlc3RpbmcgZm9yIG1lIDotKFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgIC8vIGZpbHRlciB0aGUgaWRzIG9mIHRoZSByZW1vdmVkIGl0ZW1zXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBpZiAodGhpcy5faWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcmVtb3ZlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKFxuICAgICAgICAgICAgICAocGFyYW1zIGFzIFJlbW92ZUV2ZW50UGF5bG9hZDxJdGVtLCBJZFByb3A+KS5vbGREYXRhW2ldXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoICs9IGFkZGVkSWRzLmxlbmd0aCAtIHJlbW92ZWRJZHMubGVuZ3RoO1xuXG4gICAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcihcImFkZFwiLCB7IGl0ZW1zOiBhZGRlZElkcyB9LCBzZW5kZXJJZCk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVkSWRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcihcbiAgICAgICAgXCJ1cGRhdGVcIixcbiAgICAgICAgeyBpdGVtczogdXBkYXRlZElkcywgb2xkRGF0YTogb2xkSXRlbXMsIGRhdGE6IHVwZGF0ZWRJdGVtcyB9LFxuICAgICAgICBzZW5kZXJJZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKFxuICAgICAgICBcInJlbW92ZVwiLFxuICAgICAgICB7IGl0ZW1zOiByZW1vdmVkSWRzLCBvbGREYXRhOiByZW1vdmVkSXRlbXMgfSxcbiAgICAgICAgc2VuZGVySWRcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBQYXJ0SXRlbSB9IGZyb20gXCIuL2RhdGEtaW50ZXJmYWNlXCI7XG5pbXBvcnQgeyBEYXRhU2V0IH0gZnJvbSBcIi4vZGF0YS1zZXRcIjtcblxuLyoqXG4gKiBDaGVjayB0aGF0IGdpdmVuIHZhbHVlIGlzIGNvbXBhdGlibGUgd2l0aCBWaXMgRGF0YSBTZXQgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBpZFByb3AgLSBUaGUgZXhwZWN0ZWQgcHJvcGVydHkgdG8gY29udGFpbiBpdGVtIGlkLlxuICogQHBhcmFtIHYgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkLlxuICpcbiAqIEByZXR1cm5zIFRydWUgaWYgYWxsIGV4cGVjdGVkIHZhbHVlcyBhbmQgbWV0aG9kcyBtYXRjaCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRhU2V0TGlrZTxcbiAgSXRlbSBleHRlbmRzIFBhcnRJdGVtPElkUHJvcD4sXG4gIElkUHJvcCBleHRlbmRzIHN0cmluZyA9IFwiaWRcIlxuPihpZFByb3A6IElkUHJvcCwgdjogYW55KTogdiBpcyBEYXRhU2V0PEl0ZW0sIElkUHJvcD4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmXG4gICAgdiAhPT0gbnVsbCAmJlxuICAgIGlkUHJvcCA9PT0gdi5pZFByb3AgJiZcbiAgICB0eXBlb2Ygdi5hZGQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiB2LmNsZWFyID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2Ygdi5kaXN0aW5jdCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHYuZm9yRWFjaCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHYuZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2Ygdi5nZXREYXRhU2V0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2Ygdi5nZXRJZHMgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiB2Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJlxuICAgIHR5cGVvZiB2Lm1hcCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHYubWF4ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2Ygdi5taW4gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiB2Lm9mZiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHYub24gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiB2LnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHYuc2V0T3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHYuc3RyZWFtID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2Ygdi51cGRhdGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiB2LnVwZGF0ZU9ubHkgPT09IFwiZnVuY3Rpb25cIlxuICApO1xufVxuIiwiaW1wb3J0IHsgRGF0YVZpZXcgfSBmcm9tIFwiLi9kYXRhLXZpZXdcIjtcbmltcG9ydCB7IFBhcnRJdGVtIH0gZnJvbSBcIi4vZGF0YS1pbnRlcmZhY2VcIjtcbmltcG9ydCB7IGlzRGF0YVNldExpa2UgfSBmcm9tIFwiLi9kYXRhLXNldC1jaGVja1wiO1xuXG4vKipcbiAqIENoZWNrIHRoYXQgZ2l2ZW4gdmFsdWUgaXMgY29tcGF0aWJsZSB3aXRoIFZpcyBEYXRhIFZpZXcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBpZFByb3AgLSBUaGUgZXhwZWN0ZWQgcHJvcGVydHkgdG8gY29udGFpbiBpdGVtIGlkLlxuICogQHBhcmFtIHYgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkLlxuICpcbiAqIEByZXR1cm5zIFRydWUgaWYgYWxsIGV4cGVjdGVkIHZhbHVlcyBhbmQgbWV0aG9kcyBtYXRjaCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRhVmlld0xpa2U8XG4gIEl0ZW0gZXh0ZW5kcyBQYXJ0SXRlbTxJZFByb3A+LFxuICBJZFByb3AgZXh0ZW5kcyBzdHJpbmcgPSBcImlkXCJcbj4oaWRQcm9wOiBJZFByb3AsIHY6IGFueSk6IHYgaXMgRGF0YVZpZXc8SXRlbSwgSWRQcm9wPiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiZcbiAgICB2ICE9PSBudWxsICYmXG4gICAgaWRQcm9wID09PSB2LmlkUHJvcCAmJlxuICAgIHR5cGVvZiB2LmZvckVhY2ggPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiB2LmdldCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHYuZ2V0RGF0YVNldCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHYuZ2V0SWRzID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2Ygdi5sZW5ndGggPT09IFwibnVtYmVyXCIgJiZcbiAgICB0eXBlb2Ygdi5tYXAgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiB2Lm9mZiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHYub24gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiB2LnN0cmVhbSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgaXNEYXRhU2V0TGlrZShpZFByb3AsIHYuZ2V0RGF0YVNldCgpKVxuICApO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vis-data/peer/esm/vis-data.js\n");

/***/ }),

/***/ "./node_modules/vis-network/peer/esm/vis-network.js":
/*!**********************************************************!*\
  !*** ./node_modules/vis-network/peer/esm/vis-network.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Network\": () => (/* binding */ Network),\n/* harmony export */   \"NetworkImages\": () => (/* binding */ Images),\n/* harmony export */   \"networkDOTParser\": () => (/* binding */ dotparser),\n/* harmony export */   \"networkGephiParser\": () => (/* binding */ gephiParser),\n/* harmony export */   \"networkOptions\": () => (/* binding */ options),\n/* harmony export */   \"parseDOTNetwork\": () => (/* binding */ parseDOTNetwork),\n/* harmony export */   \"parseGephiNetwork\": () => (/* binding */ parseGephi)\n/* harmony export */ });\n/* harmony import */ var vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vis-data/peer/esm/vis-data.js */ \"./node_modules/vis-data/peer/esm/vis-data.js\");\n/**\n * vis-network\n * https://visjs.github.io/vis-network/\n *\n * A dynamic, browser-based visualization library.\n *\n * @version 8.5.4\n * @date    2020-11-23T19:50:32.883Z\n *\n * @copyright (c) 2011-2017 Almende B.V, http://almende.com\n * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs\n *\n * @license\n * vis.js is dual licensed under both\n *\n *   1. The Apache 2.0 License\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   and\n *\n *   2. The MIT License\n *      http://opensource.org/licenses/MIT\n *\n * vis.js may be distributed under either license.\n */\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, basedir, module) {\n  return module = {\n    path: basedir,\n    exports: {},\n    require: function (path, base) {\n      return commonjsRequire(path, base === undefined || base === null ? module.path : base);\n    }\n  }, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire() {\n  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\n\nvar global_1 = // eslint-disable-next-line no-undef\ncheck(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func\nfunction () {\n  return this;\n}() || Function('return this')();\n\nvar fails = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar descriptors = !fails(function () {\n  return Object.defineProperty({}, 1, {\n    get: function () {\n      return 7;\n    }\n  })[1] != 7;\n});\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug\n\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({\n  1: 2\n}, 1); // `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable\n\nvar f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\nvar objectPropertyIsEnumerable = {\n  f: f\n};\n\nvar createPropertyDescriptor = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar toString = {}.toString;\n\nvar classofRaw = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\nvar split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings\n\nvar indexedObject = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object; // `RequireObjectCoercible` abstract operation\n// https://tc39.github.io/ecma262/#sec-requireobjectcoercible\n\nvar requireObjectCoercible = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n\nvar toIndexedObject = function (it) {\n  return indexedObject(requireObjectCoercible(it));\n};\n\nvar isObject = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n}; // https://tc39.github.io/ecma262/#sec-toprimitive\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\n\n\nvar toPrimitive = function (input, PREFERRED_STRING) {\n  if (!isObject(input)) return input;\n  var fn, val;\n  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nvar has = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\nvar document$1 = global_1.document; // typeof document.createElement is 'object' in old IE\n\nvar EXISTS = isObject(document$1) && isObject(document$1.createElement);\n\nvar documentCreateElement = function (it) {\n  return EXISTS ? document$1.createElement(it) : {};\n};\n\nvar ie8DomDefine = !descriptors && !fails(function () {\n  return Object.defineProperty(documentCreateElement('div'), 'a', {\n    get: function () {\n      return 7;\n    }\n  }).a != 7;\n});\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\n\nvar f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (ie8DomDefine) try {\n    return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) {\n    /* empty */\n  }\n  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);\n};\nvar objectGetOwnPropertyDescriptor = {\n  f: f$1\n};\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\nvar isForced_1 = isForced;\nvar path = {};\n\nvar aFunction = function (it) {\n  if (typeof it != 'function') {\n    throw TypeError(String(it) + ' is not a function');\n  }\n\n  return it;\n};\n\nvar functionBindContext = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n\n  switch (length) {\n    case 0:\n      return function () {\n        return fn.call(that);\n      };\n\n    case 1:\n      return function (a) {\n        return fn.call(that, a);\n      };\n\n    case 2:\n      return function (a, b) {\n        return fn.call(that, a, b);\n      };\n\n    case 3:\n      return function (a, b, c) {\n        return fn.call(that, a, b, c);\n      };\n  }\n\n  return function ()\n  /* ...args */\n  {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar anObject = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + ' is not an object');\n  }\n\n  return it;\n};\n\nvar nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method\n// https://tc39.github.io/ecma262/#sec-object.defineproperty\n\nvar f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (ie8DomDefine) try {\n    return nativeDefineProperty(O, P, Attributes);\n  } catch (error) {\n    /* empty */\n  }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\nvar objectDefineProperty = {\n  f: f$2\n};\nvar createNonEnumerableProperty = descriptors ? function (object, key, value) {\n  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\nvar wrapConstructor = function (NativeConstructor) {\n  var Wrapper = function (a, b, c) {\n    if (this instanceof NativeConstructor) {\n      switch (arguments.length) {\n        case 0:\n          return new NativeConstructor();\n\n        case 1:\n          return new NativeConstructor(a);\n\n        case 2:\n          return new NativeConstructor(a, b);\n      }\n\n      return new NativeConstructor(a, b, c);\n    }\n\n    return NativeConstructor.apply(this, arguments);\n  };\n\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\n\n\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var PROTO = options.proto;\n  var nativeSource = GLOBAL ? global_1 : STATIC ? global_1[TARGET] : (global_1[TARGET] || {}).prototype;\n  var target = GLOBAL ? path : path[TARGET] || (path[TARGET] = {});\n  var targetPrototype = target.prototype;\n  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n\n  for (key in source) {\n    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contains in native\n\n    USE_NATIVE = !FORCED && nativeSource && has(nativeSource, key);\n    targetProperty = target[key];\n    if (USE_NATIVE) if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor$1(nativeSource, key);\n      nativeProperty = descriptor && descriptor.value;\n    } else nativeProperty = nativeSource[key]; // export native or implementation\n\n    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];\n    if (USE_NATIVE && typeof targetProperty === typeof sourceProperty) continue; // bind timers to global for call from export context\n\n    if (options.bind && USE_NATIVE) resultProperty = functionBindContext(sourceProperty, global_1); // wrap global constructors for prevent changs in this version\n    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty); // make static versions for prototype methods\n    else if (PROTO && typeof sourceProperty == 'function') resultProperty = functionBindContext(Function.call, sourceProperty); // default case\n    else resultProperty = sourceProperty; // add a flag to not completely full polyfills\n\n    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {\n      createNonEnumerableProperty(resultProperty, 'sham', true);\n    }\n\n    target[key] = resultProperty;\n\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';\n\n      if (!has(path, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});\n      } // export virtual prototype methods\n\n\n      path[VIRTUAL_PROTOTYPE][key] = sourceProperty; // export real prototype methods\n\n      if (options.real && targetPrototype && !targetPrototype[key]) {\n        createNonEnumerableProperty(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n};\n\nvar slice = [].slice;\nvar factories = {};\n\nvar construct = function (C, argsLength, args) {\n  if (!(argsLength in factories)) {\n    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func\n\n\n    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');\n  }\n\n  return factories[argsLength](C, args);\n}; // `Function.prototype.bind` method implementation\n// https://tc39.github.io/ecma262/#sec-function.prototype.bind\n\n\nvar functionBind = Function.bind || function bind(that\n/* , ...args */\n) {\n  var fn = aFunction(this);\n  var partArgs = slice.call(arguments, 1);\n\n  var boundFunction = function bound()\n  /* args... */\n  {\n    var args = partArgs.concat(slice.call(arguments));\n    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);\n  };\n\n  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;\n  return boundFunction;\n}; // https://tc39.github.io/ecma262/#sec-function.prototype.bind\n\n\n_export({\n  target: 'Function',\n  proto: true\n}, {\n  bind: functionBind\n});\n\nvar entryVirtual = function (CONSTRUCTOR) {\n  return path[CONSTRUCTOR + 'Prototype'];\n};\n\nvar bind = entryVirtual('Function').bind;\nvar FunctionPrototype = Function.prototype;\n\nvar bind_1 = function (it) {\n  var own = it.bind;\n  return it === FunctionPrototype || it instanceof Function && own === FunctionPrototype.bind ? bind : own;\n};\n\nvar bind$1 = bind_1;\nvar bind$2 = bind$1;\nvar ceil = Math.ceil;\nvar floor = Math.floor; // `ToInteger` abstract operation\n// https://tc39.github.io/ecma262/#sec-tointeger\n\nvar toInteger = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\nvar min = Math.min; // `ToLength` abstract operation\n// https://tc39.github.io/ecma262/#sec-tolength\n\nvar toLength = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar max = Math.max;\nvar min$1 = Math.min; // Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n\nvar toAbsoluteIndex = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n};\n\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value; // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++]; // eslint-disable-next-line no-self-compare\n\n      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not\n    } else for (; length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    }\n    return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\nvar hiddenKeys = {};\nvar indexOf = arrayIncludes.indexOf;\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key); // Don't enum bug & hidden keys\n\n\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n\n  return result;\n}; // IE8- don't enum bug keys\n\n\nvar enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf']; // https://tc39.github.io/ecma262/#sec-object.keys\n\nvar objectKeys = Object.keys || function keys(O) {\n  return objectKeysInternal(O, enumBugKeys);\n};\n\nvar f$3 = Object.getOwnPropertySymbols;\nvar objectGetOwnPropertySymbols = {\n  f: f$3\n}; // https://tc39.github.io/ecma262/#sec-toobject\n\nvar toObject = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n\nvar nativeAssign = Object.assign;\nvar defineProperty = Object.defineProperty; // `Object.assign` method\n// https://tc39.github.io/ecma262/#sec-object.assign\n\nvar objectAssign = !nativeAssign || fails(function () {\n  // should have correct order of operations (Edge bug)\n  if (descriptors && nativeAssign({\n    b: 1\n  }, nativeAssign(defineProperty({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), {\n    b: 2\n  })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)\n\n  var A = {};\n  var B = {}; // eslint-disable-next-line no-undef\n\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) {\n    B[chr] = chr;\n  });\n  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) {\n  // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n  var propertyIsEnumerable = objectPropertyIsEnumerable.f;\n\n  while (argumentsLength > index) {\n    var S = indexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n\n    while (length > j) {\n      key = keys[j++];\n      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n    }\n  }\n\n  return T;\n} : nativeAssign; // https://tc39.github.io/ecma262/#sec-object.assign\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: Object.assign !== objectAssign\n}, {\n  assign: objectAssign\n});\n\nvar assign = path.Object.assign;\nvar assign$1 = assign;\nvar assign$2 = assign$1;\n/**\r\n * Draw a circle.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - The radius of the circle.\r\n */\n\nfunction drawCircle(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.arc(x, y, r, 0, 2 * Math.PI, false);\n  ctx.closePath();\n}\n/**\r\n * Draw a square.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the width and height of the square.\r\n */\n\n\nfunction drawSquare(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.rect(x - r, y - r, r * 2, r * 2);\n  ctx.closePath();\n}\n/**\r\n * Draw an equilateral triangle standing on a side.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the length of the sides.\r\n *\r\n * @remarks\r\n * http://en.wikipedia.org/wiki/Equilateral_triangle\r\n */\n\n\nfunction drawTriangle(ctx, x, y, r) {\n  ctx.beginPath(); // the change in radius and the offset is here to center the shape\n\n  r *= 1.15;\n  y += 0.275 * r;\n  var s = r * 2;\n  var s2 = s / 2;\n  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle\n\n  var h = Math.sqrt(s * s - s2 * s2); // height\n\n  ctx.moveTo(x, y - (h - ir));\n  ctx.lineTo(x + s2, y + ir);\n  ctx.lineTo(x - s2, y + ir);\n  ctx.lineTo(x, y - (h - ir));\n  ctx.closePath();\n}\n/**\r\n * Draw an equilateral triangle standing on a vertex.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the length of the sides.\r\n *\r\n * @remarks\r\n * http://en.wikipedia.org/wiki/Equilateral_triangle\r\n */\n\n\nfunction drawTriangleDown(ctx, x, y, r) {\n  ctx.beginPath(); // the change in radius and the offset is here to center the shape\n\n  r *= 1.15;\n  y -= 0.275 * r;\n  var s = r * 2;\n  var s2 = s / 2;\n  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle\n\n  var h = Math.sqrt(s * s - s2 * s2); // height\n\n  ctx.moveTo(x, y + (h - ir));\n  ctx.lineTo(x + s2, y - ir);\n  ctx.lineTo(x - s2, y - ir);\n  ctx.lineTo(x, y + (h - ir));\n  ctx.closePath();\n}\n/**\r\n * Draw a star.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - The outer radius of the star.\r\n */\n\n\nfunction drawStar(ctx, x, y, r) {\n  // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/\n  ctx.beginPath(); // the change in radius and the offset is here to center the shape\n\n  r *= 0.82;\n  y += 0.1 * r;\n\n  for (var n = 0; n < 10; n++) {\n    var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;\n    ctx.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));\n  }\n\n  ctx.closePath();\n}\n/**\r\n * Draw a diamond.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the width and height of the diamond.\r\n *\r\n * @remarks\r\n * http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/\r\n */\n\n\nfunction drawDiamond(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.lineTo(x, y + r);\n  ctx.lineTo(x + r, y);\n  ctx.lineTo(x, y - r);\n  ctx.lineTo(x - r, y);\n  ctx.closePath();\n}\n/**\r\n * Draw a rectangle with rounded corners.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param w - The width of the rectangle.\r\n * @param h - The height of the rectangle.\r\n * @param r - The radius of the corners.\r\n *\r\n * @remarks\r\n * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas\r\n */\n\n\nfunction drawRoundRect(ctx, x, y, w, h, r) {\n  var r2d = Math.PI / 180;\n\n  if (w - 2 * r < 0) {\n    r = w / 2;\n  } //ensure that the radius isn't too large for x\n\n\n  if (h - 2 * r < 0) {\n    r = h / 2;\n  } //ensure that the radius isn't too large for y\n\n\n  ctx.beginPath();\n  ctx.moveTo(x + r, y);\n  ctx.lineTo(x + w - r, y);\n  ctx.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);\n  ctx.lineTo(x + w, y + h - r);\n  ctx.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);\n  ctx.lineTo(x + r, y + h);\n  ctx.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);\n  ctx.lineTo(x, y + r);\n  ctx.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);\n  ctx.closePath();\n}\n/**\r\n * Draw an ellipse.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param w - The width of the ellipse.\r\n * @param h - The height of the ellipse.\r\n *\r\n * @remarks\r\n * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\r\n *\r\n * Postfix '_vis' added to discern it from standard method ellipse().\r\n */\n\n\nfunction drawEllipse(ctx, x, y, w, h) {\n  var kappa = 0.5522848,\n      ox = w / 2 * kappa,\n      // control point offset horizontal\n  oy = h / 2 * kappa,\n      // control point offset vertical\n  xe = x + w,\n      // x-end\n  ye = y + h,\n      // y-end\n  xm = x + w / 2,\n      // x-middle\n  ym = y + h / 2; // y-middle\n\n  ctx.beginPath();\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n}\n/**\r\n * Draw an isometric cylinder.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param w - The width of the database.\r\n * @param h - The height of the database.\r\n *\r\n * @remarks\r\n * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\r\n */\n\n\nfunction drawDatabase(ctx, x, y, w, h) {\n  var f = 1 / 3;\n  var wEllipse = w;\n  var hEllipse = h * f;\n  var kappa = 0.5522848,\n      ox = wEllipse / 2 * kappa,\n      // control point offset horizontal\n  oy = hEllipse / 2 * kappa,\n      // control point offset vertical\n  xe = x + wEllipse,\n      // x-end\n  ye = y + hEllipse,\n      // y-end\n  xm = x + wEllipse / 2,\n      // x-middle\n  ym = y + hEllipse / 2,\n      // y-middle\n  ymb = y + (h - hEllipse / 2),\n      // y-midlle, bottom ellipse\n  yeb = y + h; // y-end, bottom ellipse\n\n  ctx.beginPath();\n  ctx.moveTo(xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.lineTo(xe, ymb);\n  ctx.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);\n  ctx.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);\n  ctx.lineTo(x, ym);\n}\n/**\r\n * Draw a dashed line.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The start position on the x axis.\r\n * @param y - The start position on the y axis.\r\n * @param x2 - The end position on the x axis.\r\n * @param y2 - The end position on the y axis.\r\n * @param pattern - List of lengths starting with line and then alternating between space and line.\r\n *\r\n * @author David Jordan\r\n * @remarks\r\n * date 2012-08-08\r\n * http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas\r\n */\n\n\nfunction drawDashedLine(ctx, x, y, x2, y2, pattern) {\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  var patternLength = pattern.length;\n  var dx = x2 - x;\n  var dy = y2 - y;\n  var slope = dy / dx;\n  var distRemaining = Math.sqrt(dx * dx + dy * dy);\n  var patternIndex = 0;\n  var draw = true;\n  var xStep = 0;\n  var dashLength = +pattern[0];\n\n  while (distRemaining >= 0.1) {\n    dashLength = +pattern[patternIndex++ % patternLength];\n\n    if (dashLength > distRemaining) {\n      dashLength = distRemaining;\n    }\n\n    xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));\n    xStep = dx < 0 ? -xStep : xStep;\n    x += xStep;\n    y += slope * xStep;\n\n    if (draw === true) {\n      ctx.lineTo(x, y);\n    } else {\n      ctx.moveTo(x, y);\n    }\n\n    distRemaining -= dashLength;\n    draw = !draw;\n  }\n}\n/**\r\n * Draw a hexagon.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - The radius of the hexagon.\r\n */\n\n\nfunction drawHexagon(ctx, x, y, r) {\n  ctx.beginPath();\n  var sides = 6;\n  var a = Math.PI * 2 / sides;\n  ctx.moveTo(x + r, y);\n\n  for (var i = 1; i < sides; i++) {\n    ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));\n  }\n\n  ctx.closePath();\n}\n\nvar shapeMap = {\n  circle: drawCircle,\n  dashedLine: drawDashedLine,\n  database: drawDatabase,\n  diamond: drawDiamond,\n  ellipse: drawEllipse,\n  ellipse_vis: drawEllipse,\n  hexagon: drawHexagon,\n  roundRect: drawRoundRect,\n  square: drawSquare,\n  star: drawStar,\n  triangle: drawTriangle,\n  triangleDown: drawTriangleDown\n};\n/**\r\n * Returns either custom or native drawing function base on supplied name.\r\n *\r\n * @param name - The name of the function. Either the name of a\r\n * CanvasRenderingContext2D property or an export from shapes.ts without the\r\n * draw prefix.\r\n *\r\n * @returns The function that can be used for rendering. In case of native\r\n * CanvasRenderingContext2D function the API is normalized to\r\n * `(ctx: CanvasRenderingContext2D, ...originalArgs) => void`.\r\n */\n\nfunction getShape(name) {\n  if (Object.prototype.hasOwnProperty.call(shapeMap, name)) {\n    return shapeMap[name];\n  } else {\n    return function (ctx) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      CanvasRenderingContext2D.prototype[name].call(ctx, args);\n    };\n  }\n}\n\nvar componentEmitter = createCommonjsModule(function (module) {\n  /**\r\n   * Expose `Emitter`.\r\n   */\n  {\n    module.exports = Emitter;\n  }\n  /**\r\n   * Initialize a new `Emitter`.\r\n   *\r\n   * @api public\r\n   */\n\n  function Emitter(obj) {\n    if (obj) return mixin(obj);\n  }\n  /**\r\n   * Mixin the emitter properties.\r\n   *\r\n   * @param {Object} obj\r\n   * @return {Object}\r\n   * @api private\r\n   */\n\n\n  function mixin(obj) {\n    for (var key in Emitter.prototype) {\n      obj[key] = Emitter.prototype[key];\n    }\n\n    return obj;\n  }\n  /**\r\n   * Listen on the given `event` with `fn`.\r\n   *\r\n   * @param {String} event\r\n   * @param {Function} fn\r\n   * @return {Emitter}\r\n   * @api public\r\n   */\n\n\n  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {\n    this._callbacks = this._callbacks || {};\n    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);\n    return this;\n  };\n  /**\r\n   * Adds an `event` listener that will be invoked a single\r\n   * time then automatically removed.\r\n   *\r\n   * @param {String} event\r\n   * @param {Function} fn\r\n   * @return {Emitter}\r\n   * @api public\r\n   */\n\n\n  Emitter.prototype.once = function (event, fn) {\n    function on() {\n      this.off(event, on);\n      fn.apply(this, arguments);\n    }\n\n    on.fn = fn;\n    this.on(event, on);\n    return this;\n  };\n  /**\r\n   * Remove the given callback for `event` or all\r\n   * registered callbacks.\r\n   *\r\n   * @param {String} event\r\n   * @param {Function} fn\r\n   * @return {Emitter}\r\n   * @api public\r\n   */\n\n\n  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {\n    this._callbacks = this._callbacks || {}; // all\n\n    if (0 == arguments.length) {\n      this._callbacks = {};\n      return this;\n    } // specific event\n\n\n    var callbacks = this._callbacks['$' + event];\n    if (!callbacks) return this; // remove all handlers\n\n    if (1 == arguments.length) {\n      delete this._callbacks['$' + event];\n      return this;\n    } // remove specific handler\n\n\n    var cb;\n\n    for (var i = 0; i < callbacks.length; i++) {\n      cb = callbacks[i];\n\n      if (cb === fn || cb.fn === fn) {\n        callbacks.splice(i, 1);\n        break;\n      }\n    } // Remove event specific arrays for event types that no\n    // one is subscribed for to avoid memory leak.\n\n\n    if (callbacks.length === 0) {\n      delete this._callbacks['$' + event];\n    }\n\n    return this;\n  };\n  /**\r\n   * Emit `event` with the given args.\r\n   *\r\n   * @param {String} event\r\n   * @param {Mixed} ...\r\n   * @return {Emitter}\r\n   */\n\n\n  Emitter.prototype.emit = function (event) {\n    this._callbacks = this._callbacks || {};\n    var args = new Array(arguments.length - 1),\n        callbacks = this._callbacks['$' + event];\n\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    if (callbacks) {\n      callbacks = callbacks.slice(0);\n\n      for (var i = 0, len = callbacks.length; i < len; ++i) {\n        callbacks[i].apply(this, args);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Return array of callbacks for `event`.\r\n   *\r\n   * @param {String} event\r\n   * @return {Array}\r\n   * @api public\r\n   */\n\n\n  Emitter.prototype.listeners = function (event) {\n    this._callbacks = this._callbacks || {};\n    return this._callbacks['$' + event] || [];\n  };\n  /**\r\n   * Check if this emitter has `event` handlers.\r\n   *\r\n   * @param {String} event\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\n\n\n  Emitter.prototype.hasListeners = function (event) {\n    return !!this.listeners(event).length;\n  };\n}); // https://tc39.github.io/ecma262/#sec-object.defineproperty\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: !descriptors,\n  sham: !descriptors\n}, {\n  defineProperty: objectDefineProperty.f\n});\n\nvar defineProperty_1 = createCommonjsModule(function (module) {\n  var Object = path.Object;\n\n  var defineProperty = module.exports = function defineProperty(it, key, desc) {\n    return Object.defineProperty(it, key, desc);\n  };\n\n  if (Object.defineProperty.sham) defineProperty.sham = true;\n});\nvar defineProperty$1 = defineProperty_1;\nvar defineProperty$2 = defineProperty$1; // https://tc39.github.io/ecma262/#sec-object.defineproperties\n\nvar objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n\n  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);\n\n  return O;\n}; // https://tc39.github.io/ecma262/#sec-object.defineproperties\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: !descriptors,\n  sham: !descriptors\n}, {\n  defineProperties: objectDefineProperties\n});\n\nvar defineProperties_1 = createCommonjsModule(function (module) {\n  var Object = path.Object;\n\n  var defineProperties = module.exports = function defineProperties(T, D) {\n    return Object.defineProperties(T, D);\n  };\n\n  if (Object.defineProperties.sham) defineProperties.sham = true;\n});\nvar defineProperties = defineProperties_1;\nvar defineProperties$1 = defineProperties;\n\nvar aFunction$1 = function (variable) {\n  return typeof variable == 'function' ? variable : undefined;\n};\n\nvar getBuiltIn = function (namespace, method) {\n  return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];\n};\n\nvar hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n\nvar f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return objectKeysInternal(O, hiddenKeys$1);\n};\n\nvar objectGetOwnPropertyNames = {\n  f: f$4\n};\n\nvar ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = objectGetOwnPropertyNames.f(anObject(it));\n  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\nvar createProperty = function (object, key, value) {\n  var propertyKey = toPrimitive(key);\n  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;\n}; // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors\n\n\n_export({\n  target: 'Object',\n  stat: true,\n  sham: !descriptors\n}, {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIndexedObject(object);\n    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var index = 0;\n    var key, descriptor;\n\n    while (keys.length > index) {\n      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);\n      if (descriptor !== undefined) createProperty(result, key, descriptor);\n    }\n\n    return result;\n  }\n});\n\nvar getOwnPropertyDescriptors = path.Object.getOwnPropertyDescriptors;\nvar getOwnPropertyDescriptors$1 = getOwnPropertyDescriptors;\nvar getOwnPropertyDescriptors$2 = getOwnPropertyDescriptors$1;\nvar nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar FAILS_ON_PRIMITIVES = fails(function () {\n  nativeGetOwnPropertyDescriptor$1(1);\n});\nvar FORCED = !descriptors || FAILS_ON_PRIMITIVES; // `Object.getOwnPropertyDescriptor` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: FORCED,\n  sham: !descriptors\n}, {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {\n    return nativeGetOwnPropertyDescriptor$1(toIndexedObject(it), key);\n  }\n});\n\nvar getOwnPropertyDescriptor_1 = createCommonjsModule(function (module) {\n  var Object = path.Object;\n\n  var getOwnPropertyDescriptor = module.exports = function getOwnPropertyDescriptor(it, key) {\n    return Object.getOwnPropertyDescriptor(it, key);\n  };\n\n  if (Object.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor.sham = true;\n});\nvar getOwnPropertyDescriptor$2 = getOwnPropertyDescriptor_1;\nvar getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor$2;\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {\n  // Chrome 38 Symbol has incorrect toString conversion\n  // eslint-disable-next-line no-undef\n  return !String(Symbol());\n});\nvar useSymbolAsUid = nativeSymbol // eslint-disable-next-line no-undef\n&& !Symbol.sham // eslint-disable-next-line no-undef\n&& typeof Symbol.iterator == 'symbol'; // https://tc39.github.io/ecma262/#sec-isarray\n\nvar isArray = Array.isArray || function isArray(arg) {\n  return classofRaw(arg) == 'Array';\n};\n\nvar html = getBuiltIn('document', 'documentElement');\n\nvar setGlobal = function (key, value) {\n  try {\n    createNonEnumerableProperty(global_1, key, value);\n  } catch (error) {\n    global_1[key] = value;\n  }\n\n  return value;\n};\n\nvar SHARED = '__core-js_shared__';\nvar store = global_1[SHARED] || setGlobal(SHARED, {});\nvar sharedStore = store;\nvar shared = createCommonjsModule(function (module) {\n  (module.exports = function (key, value) {\n    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});\n  })('versions', []).push({\n    version: '3.7.0',\n    mode: 'pure',\n    copyright: '© 2020 Denis Pushkarev (zloirock.ru)'\n  });\n});\nvar id = 0;\nvar postfix = Math.random();\n\nvar uid = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n\nvar keys = shared('keys');\n\nvar sharedKey = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () {\n  /* empty */\n};\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n\n\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n\n  return temp;\n}; // Create object with fake `null` prototype: use iframe Object with cleared prototype\n\n\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475\n\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n}; // Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\n\n\nvar activeXDocument;\n\nvar NullProtoObject = function () {\n  try {\n    /* global ActiveXObject */\n    activeXDocument = document.domain && new ActiveXObject('htmlfile');\n  } catch (error) {\n    /* ignore */\n  }\n\n  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n  var length = enumBugKeys.length;\n\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true; // `Object.create` method\n// https://tc39.github.io/ecma262/#sec-object.create\n\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null; // add \"__proto__\" for Object.getPrototypeOf polyfill\n\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n\n  return Properties === undefined ? result : objectDefineProperties(result, Properties);\n};\n\nvar nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;\nvar toString$1 = {}.toString;\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return nativeGetOwnPropertyNames(it);\n  } catch (error) {\n    return windowNames.slice();\n  }\n}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\n\nvar f$5 = function getOwnPropertyNames(it) {\n  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));\n};\n\nvar objectGetOwnPropertyNamesExternal = {\n  f: f$5\n};\n\nvar redefine = function (target, key, value, options) {\n  if (options && options.enumerable) target[key] = value;else createNonEnumerableProperty(target, key, value);\n};\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol$1 = global_1.Symbol;\nvar createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;\n\nvar wellKnownSymbol = function (name) {\n  if (!has(WellKnownSymbolsStore, name)) {\n    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n  }\n\n  return WellKnownSymbolsStore[name];\n};\n\nvar f$6 = wellKnownSymbol;\nvar wellKnownSymbolWrapped = {\n  f: f$6\n};\nvar defineProperty$3 = objectDefineProperty.f;\n\nvar defineWellKnownSymbol = function (NAME) {\n  var Symbol = path.Symbol || (path.Symbol = {});\n  if (!has(Symbol, NAME)) defineProperty$3(Symbol, NAME, {\n    value: wellKnownSymbolWrapped.f(NAME)\n  });\n};\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\ntest[TO_STRING_TAG] = 'z';\nvar toStringTagSupport = String(test) === '[object z]';\nvar TO_STRING_TAG$1 = wellKnownSymbol('toStringTag'); // ES3 wrong here\n\nvar CORRECT_ARGUMENTS = classofRaw(function () {\n  return arguments;\n}()) == 'Arguments'; // fallback for IE11 Script Access Denied error\n\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) {\n    /* empty */\n  }\n}; // getting tag from ES6+ `Object.prototype.toString`\n\n\nvar classof = toStringTagSupport ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case\n  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case\n  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback\n  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n}; // https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n\nvar objectToString = toStringTagSupport ? {}.toString : function toString() {\n  return '[object ' + classof(this) + ']';\n};\nvar defineProperty$4 = objectDefineProperty.f;\nvar TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');\n\nvar setToStringTag = function (it, TAG, STATIC, SET_METHOD) {\n  if (it) {\n    var target = STATIC ? it : it.prototype;\n\n    if (!has(target, TO_STRING_TAG$2)) {\n      defineProperty$4(target, TO_STRING_TAG$2, {\n        configurable: true,\n        value: TAG\n      });\n    }\n\n    if (SET_METHOD && !toStringTagSupport) {\n      createNonEnumerableProperty(target, 'toString', objectToString);\n    }\n  }\n};\n\nvar functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper\n\nif (typeof sharedStore.inspectSource != 'function') {\n  sharedStore.inspectSource = function (it) {\n    return functionToString.call(it);\n  };\n}\n\nvar inspectSource = sharedStore.inspectSource;\nvar WeakMap = global_1.WeakMap;\nvar nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\nvar WeakMap$1 = global_1.WeakMap;\nvar set, get, has$1;\n\nvar enforce = function (it) {\n  return has$1(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    }\n\n    return state;\n  };\n};\n\nif (nativeWeakMap) {\n  var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$1());\n  var wmget = store$1.get;\n  var wmhas = store$1.has;\n  var wmset = store$1.set;\n\n  set = function (it, metadata) {\n    metadata.facade = it;\n    wmset.call(store$1, it, metadata);\n    return metadata;\n  };\n\n  get = function (it) {\n    return wmget.call(store$1, it) || {};\n  };\n\n  has$1 = function (it) {\n    return wmhas.call(store$1, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n\n  set = function (it, metadata) {\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n\n  get = function (it) {\n    return has(it, STATE) ? it[STATE] : {};\n  };\n\n  has$1 = function (it) {\n    return has(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set,\n  get: get,\n  has: has$1,\n  enforce: enforce,\n  getterFor: getterFor\n};\nvar SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation\n// https://tc39.github.io/ecma262/#sec-arrayspeciescreate\n\nvar arraySpeciesCreate = function (originalArray, length) {\n  var C;\n\n  if (isArray(originalArray)) {\n    C = originalArray.constructor; // cross-realm fallback\n\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  }\n\n  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n};\n\nvar push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation\n\nvar createMethod$1 = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = indexedObject(O);\n    var boundFunction = functionBindContext(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var value, result;\n\n    for (; length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3:\n            return true;\n          // some\n\n          case 5:\n            return value;\n          // find\n\n          case 6:\n            return index;\n          // findIndex\n\n          case 2:\n            push.call(target, value);\n          // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nvar arrayIteration = {\n  // `Array.prototype.forEach` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod$1(0),\n  // `Array.prototype.map` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.map\n  map: createMethod$1(1),\n  // `Array.prototype.filter` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.filter\n  filter: createMethod$1(2),\n  // `Array.prototype.some` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.some\n  some: createMethod$1(3),\n  // `Array.prototype.every` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.every\n  every: createMethod$1(4),\n  // `Array.prototype.find` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.find\n  find: createMethod$1(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod$1(6)\n};\nvar $forEach = arrayIteration.forEach;\nvar HIDDEN = sharedKey('hidden');\nvar SYMBOL = 'Symbol';\nvar PROTOTYPE$1 = 'prototype';\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\nvar setInternalState = internalState.set;\nvar getInternalState = internalState.getterFor(SYMBOL);\nvar ObjectPrototype = Object[PROTOTYPE$1];\nvar $Symbol = global_1.Symbol;\nvar $stringify = getBuiltIn('JSON', 'stringify');\nvar nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\nvar nativeDefineProperty$1 = objectDefineProperty.f;\nvar nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;\nvar nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;\nvar AllSymbols = shared('symbols');\nvar ObjectPrototypeSymbols = shared('op-symbols');\nvar StringToSymbolRegistry = shared('string-to-symbol-registry');\nvar SymbolToStringRegistry = shared('symbol-to-string-registry');\nvar WellKnownSymbolsStore$1 = shared('wks');\nvar QObject = global_1.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\nvar USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\nvar setSymbolDescriptor = descriptors && fails(function () {\n  return objectCreate(nativeDefineProperty$1({}, 'a', {\n    get: function () {\n      return nativeDefineProperty$1(this, 'a', {\n        value: 7\n      }).a;\n    }\n  })).a != 7;\n}) ? function (O, P, Attributes) {\n  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$2(ObjectPrototype, P);\n  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];\n  nativeDefineProperty$1(O, P, Attributes);\n\n  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {\n    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);\n  }\n} : nativeDefineProperty$1;\n\nvar wrap = function (tag, description) {\n  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);\n  setInternalState(symbol, {\n    type: SYMBOL,\n    tag: tag,\n    description: description\n  });\n  if (!descriptors) symbol.description = description;\n  return symbol;\n};\n\nvar isSymbol = useSymbolAsUid ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return Object(it) instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(O, P, Attributes) {\n  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n  anObject(O);\n  var key = toPrimitive(P, true);\n  anObject(Attributes);\n\n  if (has(AllSymbols, key)) {\n    if (!Attributes.enumerable) {\n      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));\n      O[HIDDEN][key] = true;\n    } else {\n      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n      Attributes = objectCreate(Attributes, {\n        enumerable: createPropertyDescriptor(0, false)\n      });\n    }\n\n    return setSymbolDescriptor(O, key, Attributes);\n  }\n\n  return nativeDefineProperty$1(O, key, Attributes);\n};\n\nvar $defineProperties = function defineProperties(O, Properties) {\n  anObject(O);\n  var properties = toIndexedObject(Properties);\n  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n  $forEach(keys, function (key) {\n    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);\n  });\n  return O;\n};\n\nvar $create = function create(O, Properties) {\n  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);\n};\n\nvar $propertyIsEnumerable = function propertyIsEnumerable(V) {\n  var P = toPrimitive(V, true);\n  var enumerable = nativePropertyIsEnumerable$1.call(this, P);\n  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;\n  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n};\n\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n  var it = toIndexedObject(O);\n  var key = toPrimitive(P, true);\n  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;\n  var descriptor = nativeGetOwnPropertyDescriptor$2(it, key);\n\n  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {\n    descriptor.enumerable = true;\n  }\n\n  return descriptor;\n};\n\nvar $getOwnPropertyNames = function getOwnPropertyNames(O) {\n  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));\n  var result = [];\n  $forEach(names, function (key) {\n    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);\n  });\n  return result;\n};\n\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;\n  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));\n  var result = [];\n  $forEach(names, function (key) {\n    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {\n      result.push(AllSymbols[key]);\n    }\n  });\n  return result;\n}; // `Symbol` constructor\n// https://tc39.github.io/ecma262/#sec-symbol-constructor\n\n\nif (!nativeSymbol) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');\n    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);\n    var tag = uid(description);\n\n    var setter = function (value) {\n      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n    };\n\n    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {\n      configurable: true,\n      set: setter\n    });\n    return wrap(tag, description);\n  };\n\n  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {\n    return getInternalState(this).tag;\n  });\n  redefine($Symbol, 'withoutSetter', function (description) {\n    return wrap(uid(description), description);\n  });\n  objectPropertyIsEnumerable.f = $propertyIsEnumerable;\n  objectDefineProperty.f = $defineProperty;\n  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;\n  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;\n\n  wellKnownSymbolWrapped.f = function (name) {\n    return wrap(wellKnownSymbol(name), name);\n  };\n\n  if (descriptors) {\n    // https://github.com/tc39/proposal-Symbol-description\n    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {\n      configurable: true,\n      get: function description() {\n        return getInternalState(this).description;\n      }\n    });\n  }\n}\n\n_export({\n  global: true,\n  wrap: true,\n  forced: !nativeSymbol,\n  sham: !nativeSymbol\n}, {\n  Symbol: $Symbol\n});\n\n$forEach(objectKeys(WellKnownSymbolsStore$1), function (name) {\n  defineWellKnownSymbol(name);\n});\n\n_export({\n  target: SYMBOL,\n  stat: true,\n  forced: !nativeSymbol\n}, {\n  // `Symbol.for` method\n  // https://tc39.github.io/ecma262/#sec-symbol.for\n  'for': function (key) {\n    var string = String(key);\n    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n    var symbol = $Symbol(string);\n    StringToSymbolRegistry[string] = symbol;\n    SymbolToStringRegistry[symbol] = string;\n    return symbol;\n  },\n  // `Symbol.keyFor` method\n  // https://tc39.github.io/ecma262/#sec-symbol.keyfor\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');\n    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n  },\n  useSetter: function () {\n    USE_SETTER = true;\n  },\n  useSimple: function () {\n    USE_SETTER = false;\n  }\n});\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: !nativeSymbol,\n  sham: !descriptors\n}, {\n  // `Object.create` method\n  // https://tc39.github.io/ecma262/#sec-object.create\n  create: $create,\n  // `Object.defineProperty` method\n  // https://tc39.github.io/ecma262/#sec-object.defineproperty\n  defineProperty: $defineProperty,\n  // `Object.defineProperties` method\n  // https://tc39.github.io/ecma262/#sec-object.defineproperties\n  defineProperties: $defineProperties,\n  // `Object.getOwnPropertyDescriptor` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n});\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: !nativeSymbol\n}, {\n  // `Object.getOwnPropertyNames` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // `Object.getOwnPropertySymbols` method\n  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols\n  getOwnPropertySymbols: $getOwnPropertySymbols\n}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\n\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: fails(function () {\n    objectGetOwnPropertySymbols.f(1);\n  })\n}, {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    return objectGetOwnPropertySymbols.f(toObject(it));\n  }\n}); // `JSON.stringify` method behavior with symbols\n// https://tc39.github.io/ecma262/#sec-json.stringify\n\n\nif ($stringify) {\n  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {\n    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}\n\n    return $stringify([symbol]) != '[null]' // WebKit converts symbol values to JSON as null\n    || $stringify({\n      a: symbol\n    }) != '{}' // V8 throws on boxed symbols\n    || $stringify(Object(symbol)) != '{}';\n  });\n\n  _export({\n    target: 'JSON',\n    stat: true,\n    forced: FORCED_JSON_STRINGIFY\n  }, {\n    // eslint-disable-next-line no-unused-vars\n    stringify: function stringify(it, replacer, space) {\n      var args = [it];\n      var index = 1;\n      var $replacer;\n\n      while (arguments.length > index) args.push(arguments[index++]);\n\n      $replacer = replacer;\n      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n\n      if (!isArray(replacer)) replacer = function (key, value) {\n        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n        if (!isSymbol(value)) return value;\n      };\n      args[1] = replacer;\n      return $stringify.apply(null, args);\n    }\n  });\n} // `Symbol.prototype[@@toPrimitive]` method\n// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive\n\n\nif (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {\n  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);\n} // `Symbol.prototype[@@toStringTag]` property\n// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag\n\n\nsetToStringTag($Symbol, SYMBOL);\nhiddenKeys[HIDDEN] = true;\nvar getOwnPropertySymbols = path.Object.getOwnPropertySymbols;\nvar getOwnPropertySymbols$1 = getOwnPropertySymbols;\nvar getOwnPropertySymbols$2 = getOwnPropertySymbols$1;\nvar iterators = {};\nvar correctPrototypeGetter = !fails(function () {\n  function F() {\n    /* empty */\n  }\n\n  F.prototype.constructor = null;\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\nvar IE_PROTO$1 = sharedKey('IE_PROTO');\nvar ObjectPrototype$1 = Object.prototype; // `Object.getPrototypeOf` method\n// https://tc39.github.io/ecma262/#sec-object.getprototypeof\n\nvar objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];\n\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  }\n\n  return O instanceof Object ? ObjectPrototype$1 : null;\n};\nvar ITERATOR = wellKnownSymbol('iterator');\nvar BUGGY_SAFARI_ITERATORS = false; // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\n\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\nif ([].keys) {\n  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`\n\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {\n    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nif (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n\nvar returnThis = function () {\n  return this;\n};\n\nvar createIteratorConstructor = function (IteratorConstructor, NAME, next) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {\n    next: createPropertyDescriptor(1, next)\n  });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\nvar aPossiblePrototype = function (it) {\n  if (!isObject(it) && it !== null) {\n    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n  }\n\n  return it;\n}; // https://tc39.github.io/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n\n/* eslint-disable no-proto */\n\n\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n\n  try {\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n    setter.call(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) {\n    /* empty */\n  }\n\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\nvar IteratorPrototype$2 = iteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$1 = wellKnownSymbol('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis$1 = function () {\n  return this;\n};\n\nvar defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];\n\n    switch (KIND) {\n      case KEYS:\n        return function keys() {\n          return new IteratorConstructor(this, KIND);\n        };\n\n      case VALUES:\n        return function values() {\n          return new IteratorConstructor(this, KIND);\n        };\n\n      case ENTRIES:\n        return function entries() {\n          return new IteratorConstructor(this, KIND);\n        };\n    }\n\n    return function () {\n      return new IteratorConstructor(this);\n    };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY; // fix native\n\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n\n    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      iterators[TO_STRING_TAG] = returnThis$1;\n    }\n  } // fix Array#{values, @@iterator}.name in V8 / FF\n\n\n  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    INCORRECT_VALUES_NAME = true;\n\n    defaultIterator = function values() {\n      return nativeIterator.call(this);\n    };\n  } // define iterator\n\n\n  if (FORCED && IterablePrototype[ITERATOR$1] !== defaultIterator) {\n    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);\n  }\n\n  iterators[NAME] = defaultIterator; // export additional methods\n\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        redefine(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else _export({\n      target: NAME,\n      proto: true,\n      forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME\n    }, methods);\n  }\n\n  return methods;\n};\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$1 = internalState.set;\nvar getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.github.io/ecma262/#sec-createarrayiterator\n\nvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState$1(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated),\n    // target\n    index: 0,\n    // next index\n    kind: kind // kind\n\n  }); // `%ArrayIteratorPrototype%.next` method\n  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState$1(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  if (kind == 'keys') return {\n    value: index,\n    done: false\n  };\n  if (kind == 'values') return {\n    value: target[index],\n    done: false\n  };\n  return {\n    value: [index, target[index]],\n    done: false\n  };\n}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject\n\niterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\n\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\nvar TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');\n\nfor (var COLLECTION_NAME in domIterables) {\n  var Collection = global_1[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n\n  if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG$3) {\n    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);\n  }\n\n  iterators[COLLECTION_NAME] = iterators.Array;\n}\n\nvar createMethod$2 = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = String(requireObjectCoercible($this));\n    var position = toInteger(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = S.charCodeAt(position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nvar stringMultibyte = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod$2(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod$2(true)\n};\nvar charAt = stringMultibyte.charAt;\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState$2 = internalState.set;\nvar getInternalState$2 = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator\n\ndefineIterator(String, 'String', function (iterated) {\n  setInternalState$2(this, {\n    type: STRING_ITERATOR,\n    string: String(iterated),\n    index: 0\n  }); // `%StringIteratorPrototype%.next` method\n  // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState$2(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return {\n    value: undefined,\n    done: true\n  };\n  point = charAt(string, index);\n  state.index += point.length;\n  return {\n    value: point,\n    done: false\n  };\n});\nvar ITERATOR$2 = wellKnownSymbol('iterator');\n\nvar getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || iterators[classof(it)];\n};\n\nvar getIterator = function (it) {\n  var iteratorMethod = getIteratorMethod(it);\n\n  if (typeof iteratorMethod != 'function') {\n    throw TypeError(String(it) + ' is not iterable');\n  }\n\n  return anObject(iteratorMethod.call(it));\n};\n\nvar getIterator_1 = getIterator;\nvar getIterator$1 = getIterator_1;\nvar getIteratorMethod_1 = getIteratorMethod;\nvar getIteratorMethod$1 = getIteratorMethod_1;\n\nvar iteratorClose = function (iterator) {\n  var returnMethod = iterator['return'];\n\n  if (returnMethod !== undefined) {\n    return anObject(returnMethod.call(iterator)).value;\n  }\n};\n\nvar callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)\n  } catch (error) {\n    iteratorClose(iterator);\n    throw error;\n  }\n};\n\nvar ITERATOR$3 = wellKnownSymbol('iterator');\nvar ArrayPrototype = Array.prototype; // check on default Array iterator\n\nvar isArrayIteratorMethod = function (it) {\n  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR$3] === it);\n}; // https://tc39.github.io/ecma262/#sec-array.from\n\n\nvar arrayFrom = function from(arrayLike\n/* , mapfn = undefined, thisArg = undefined */\n) {\n  var O = toObject(arrayLike);\n  var C = typeof this == 'function' ? this : Array;\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var iteratorMethod = getIteratorMethod(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); // if the target is not iterable or it's an array with the default iterator - use a simple case\n\n  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = iteratorMethod.call(O);\n    next = iterator.next;\n    result = new C();\n\n    for (; !(step = next.call(iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty(result, index, value);\n    }\n  } else {\n    length = toLength(O.length);\n    result = new C(length);\n\n    for (; length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty(result, index, value);\n    }\n  }\n\n  result.length = index;\n  return result;\n};\n\nvar ITERATOR$4 = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return {\n        done: !!called++\n      };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n\n  iteratorWithReturn[ITERATOR$4] = function () {\n    return this;\n  }; // eslint-disable-next-line no-throw-literal\n\n\n  Array.from(iteratorWithReturn, function () {\n    throw 2;\n  });\n} catch (error) {\n  /* empty */\n}\n\nvar checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n\n  try {\n    var object = {};\n\n    object[ITERATOR$4] = function () {\n      return {\n        next: function () {\n          return {\n            done: ITERATION_SUPPORT = true\n          };\n        }\n      };\n    };\n\n    exec(object);\n  } catch (error) {\n    /* empty */\n  }\n\n  return ITERATION_SUPPORT;\n};\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  Array.from(iterable);\n}); // `Array.from` method\n// https://tc39.github.io/ecma262/#sec-array.from\n\n_export({\n  target: 'Array',\n  stat: true,\n  forced: INCORRECT_ITERATION\n}, {\n  from: arrayFrom\n});\n\nvar from_1 = path.Array.from;\nvar from_1$1 = from_1;\nvar from_1$2 = from_1$1; // https://tc39.github.io/ecma262/#sec-object.create\n\n_export({\n  target: 'Object',\n  stat: true,\n  sham: !descriptors\n}, {\n  create: objectCreate\n});\n\nvar Object$1 = path.Object;\n\nvar create = function create(P, D) {\n  return Object$1.create(P, D);\n};\n\nvar create$1 = create;\nvar create$2 = create$1;\nvar defineProperty$5 = defineProperty_1;\nvar defineProperty$6 = defineProperty$5;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    defineProperty$6(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defineProperty$7 = _defineProperty; // a string of all valid unicode whitespaces\n// eslint-disable-next-line max-len\n\nvar whitespaces = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\n\nvar createMethod$3 = function (TYPE) {\n  return function ($this) {\n    var string = String(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nvar stringTrim = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart\n  start: createMethod$3(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend\n  end: createMethod$3(2),\n  // `String.prototype.trim` method\n  // https://tc39.github.io/ecma262/#sec-string.prototype.trim\n  trim: createMethod$3(3)\n};\nvar non = '\\u200B\\u0085\\u180E'; // check that a method works with the correct list\n// of whitespaces and has a correct name\n\nvar stringTrimForced = function (METHOD_NAME) {\n  return fails(function () {\n    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\n\nvar $trim = stringTrim.trim; // `String.prototype.trim` method\n// https://tc39.github.io/ecma262/#sec-string.prototype.trim\n\n_export({\n  target: 'String',\n  proto: true,\n  forced: stringTrimForced('trim')\n}, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n\nvar trim = entryVirtual('String').trim;\n\nvar arrayMethodIsStrict = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call,no-throw-literal\n    method.call(null, argument || function () {\n      throw 1;\n    }, 1);\n  });\n};\n\nvar defineProperty$8 = Object.defineProperty;\nvar cache = {};\n\nvar thrower = function (it) {\n  throw it;\n};\n\nvar arrayMethodUsesToLength = function (METHOD_NAME, options) {\n  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];\n  if (!options) options = {};\n  var method = [][METHOD_NAME];\n  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;\n  var argument0 = has(options, 0) ? options[0] : thrower;\n  var argument1 = has(options, 1) ? options[1] : undefined;\n  return cache[METHOD_NAME] = !!method && !fails(function () {\n    if (ACCESSORS && !descriptors) return true;\n    var O = {\n      length: -1\n    };\n    if (ACCESSORS) defineProperty$8(O, 1, {\n      enumerable: true,\n      get: thrower\n    });else O[1] = 1;\n    method.call(O, argument0, argument1);\n  });\n};\n\nvar $forEach$1 = arrayIteration.forEach;\nvar STRICT_METHOD = arrayMethodIsStrict('forEach');\nvar USES_TO_LENGTH = arrayMethodUsesToLength('forEach'); // `Array.prototype.forEach` method implementation\n// https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n\nvar arrayForEach = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn\n/* , thisArg */\n) {\n  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n} : [].forEach; // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: [].forEach != arrayForEach\n}, {\n  forEach: arrayForEach\n});\n\nvar forEach = entryVirtual('Array').forEach;\nvar forEach$1 = forEach;\nvar ArrayPrototype$1 = Array.prototype;\nvar DOMIterables = {\n  DOMTokenList: true,\n  NodeList: true\n};\n\nvar forEach_1 = function (it) {\n  var own = it.forEach;\n  return it === ArrayPrototype$1 || it instanceof Array && own === ArrayPrototype$1.forEach // eslint-disable-next-line no-prototype-builtins\n  || DOMIterables.hasOwnProperty(classof(it)) ? forEach$1 : own;\n};\n\nvar forEach$2 = forEach_1;\nvar trim$1 = stringTrim.trim;\nvar $parseInt = global_1.parseInt;\nvar hex = /^[+-]?0[Xx]/;\nvar FORCED$1 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22; // `parseInt` method\n// https://tc39.github.io/ecma262/#sec-parseint-string-radix\n\nvar numberParseInt = FORCED$1 ? function parseInt(string, radix) {\n  var S = trim$1(String(string));\n  return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));\n} : $parseInt; // https://tc39.github.io/ecma262/#sec-parseint-string-radix\n\n_export({\n  global: true,\n  forced: parseInt != numberParseInt\n}, {\n  parseInt: numberParseInt\n});\n\nvar _parseInt = path.parseInt;\nvar _parseInt$1 = _parseInt;\nvar _parseInt$2 = _parseInt$1;\nvar propertyIsEnumerable = objectPropertyIsEnumerable.f; // `Object.{ entries, values }` methods implementation\n\nvar createMethod$4 = function (TO_ENTRIES) {\n  return function (it) {\n    var O = toIndexedObject(it);\n    var keys = objectKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n\n    while (length > i) {\n      key = keys[i++];\n\n      if (!descriptors || propertyIsEnumerable.call(O, key)) {\n        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);\n      }\n    }\n\n    return result;\n  };\n};\n\nvar objectToArray = {\n  // `Object.entries` method\n  // https://tc39.github.io/ecma262/#sec-object.entries\n  entries: createMethod$4(true),\n  // `Object.values` method\n  // https://tc39.github.io/ecma262/#sec-object.values\n  values: createMethod$4(false)\n};\nvar $values = objectToArray.values; // `Object.values` method\n// https://tc39.github.io/ecma262/#sec-object.values\n\n_export({\n  target: 'Object',\n  stat: true\n}, {\n  values: function values(O) {\n    return $values(O);\n  }\n});\n\nvar values = path.Object.values;\nvar engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';\nvar process = global_1.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  version = match[0] + match[1];\n} else if (engineUserAgent) {\n  match = engineUserAgent.match(/Edge\\/(\\d+)/);\n\n  if (!match || match[1] >= 74) {\n    match = engineUserAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = match[1];\n  }\n}\n\nvar engineV8Version = version && +version;\nvar SPECIES$1 = wellKnownSymbol('species');\n\nvar arrayMethodHasSpeciesSupport = function (METHOD_NAME) {\n  // We can't use this feature detection in V8 since it causes\n  // deoptimization and serious performance degradation\n  // https://github.com/zloirock/core-js/issues/677\n  return engineV8Version >= 51 || !fails(function () {\n    var array = [];\n    var constructor = array.constructor = {};\n\n    constructor[SPECIES$1] = function () {\n      return {\n        foo: 1\n      };\n    };\n\n    return array[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\n\nvar $filter = arrayIteration.filter;\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter'); // Edge 14- issue\n\nvar USES_TO_LENGTH$1 = arrayMethodUsesToLength('filter'); // `Array.prototype.filter` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.filter\n// with adding support of @@species\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$1\n}, {\n  filter: function filter(callbackfn\n  /* , thisArg */\n  ) {\n    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar filter = entryVirtual('Array').filter;\nvar ArrayPrototype$2 = Array.prototype;\n\nvar filter_1 = function (it) {\n  var own = it.filter;\n  return it === ArrayPrototype$2 || it instanceof Array && own === ArrayPrototype$2.filter ? filter : own;\n};\n\nvar filter$1 = filter_1;\nvar filter$2 = filter$1;\nvar FAILS_ON_PRIMITIVES$1 = fails(function () {\n  objectGetPrototypeOf(1);\n}); // `Object.getPrototypeOf` method\n// https://tc39.github.io/ecma262/#sec-object.getprototypeof\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: FAILS_ON_PRIMITIVES$1,\n  sham: !correctPrototypeGetter\n}, {\n  getPrototypeOf: function getPrototypeOf(it) {\n    return objectGetPrototypeOf(toObject(it));\n  }\n});\n\nvar getPrototypeOf = path.Object.getPrototypeOf;\nvar getPrototypeOf$1 = getPrototypeOf;\nvar getPrototypeOf$2 = getPrototypeOf$1;\nvar $indexOf = arrayIncludes.indexOf;\nvar nativeIndexOf = [].indexOf;\nvar NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;\nvar STRICT_METHOD$1 = arrayMethodIsStrict('indexOf');\nvar USES_TO_LENGTH$2 = arrayMethodUsesToLength('indexOf', {\n  ACCESSORS: true,\n  1: 0\n}); // `Array.prototype.indexOf` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: NEGATIVE_ZERO || !STRICT_METHOD$1 || !USES_TO_LENGTH$2\n}, {\n  indexOf: function indexOf(searchElement\n  /* , fromIndex = 0 */\n  ) {\n    return NEGATIVE_ZERO // convert -0 to +0\n    ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar indexOf$1 = entryVirtual('Array').indexOf;\nvar ArrayPrototype$3 = Array.prototype;\n\nvar indexOf_1 = function (it) {\n  var own = it.indexOf;\n  return it === ArrayPrototype$3 || it instanceof Array && own === ArrayPrototype$3.indexOf ? indexOf$1 : own;\n};\n\nvar indexOf$2 = indexOf_1;\nvar indexOf$3 = indexOf$2; // https://tc39.github.io/ecma262/#sec-array.isarray\n\n_export({\n  target: 'Array',\n  stat: true\n}, {\n  isArray: isArray\n});\n\nvar isArray$1 = path.Array.isArray;\nvar isArray$2 = isArray$1;\nvar isArray$3 = isArray$2;\n\nfunction _arrayWithHoles(arr) {\n  if (isArray$3(arr)) return arr;\n}\n\nvar arrayWithHoles = _arrayWithHoles;\nvar ITERATOR$5 = wellKnownSymbol('iterator');\n\nvar isIterable = function (it) {\n  var O = Object(it);\n  return O[ITERATOR$5] !== undefined || '@@iterator' in O // eslint-disable-next-line no-prototype-builtins\n  || iterators.hasOwnProperty(classof(O));\n};\n\nvar isIterable_1 = isIterable;\nvar isIterable$1 = isIterable_1;\nvar IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'; // We can't use this feature detection in V8 since it causes\n// deoptimization and serious performance degradation\n// https://github.com/zloirock/core-js/issues/679\n\nvar IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {\n  var array = [];\n  array[IS_CONCAT_SPREADABLE] = false;\n  return array.concat()[0] !== array;\n});\nvar SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');\n\nvar isConcatSpreadable = function (O) {\n  if (!isObject(O)) return false;\n  var spreadable = O[IS_CONCAT_SPREADABLE];\n  return spreadable !== undefined ? !!spreadable : isArray(O);\n};\n\nvar FORCED$2 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.concat\n// with adding support of @@isConcatSpreadable and @@species\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: FORCED$2\n}, {\n  concat: function concat(arg) {\n    // eslint-disable-line no-unused-vars\n    var O = toObject(this);\n    var A = arraySpeciesCreate(O, 0);\n    var n = 0;\n    var i, k, length, len, E;\n\n    for (i = -1, length = arguments.length; i < length; i++) {\n      E = i === -1 ? O : arguments[i];\n\n      if (isConcatSpreadable(E)) {\n        len = toLength(E.length);\n        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n\n        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);\n      } else {\n        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n        createProperty(A, n++, E);\n      }\n    }\n\n    A.length = n;\n    return A;\n  }\n}); // https://tc39.github.io/ecma262/#sec-symbol.asynciterator\n\n\ndefineWellKnownSymbol('asyncIterator'); // https://tc39.github.io/ecma262/#sec-symbol.hasinstance\n\ndefineWellKnownSymbol('hasInstance'); // https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable\n\ndefineWellKnownSymbol('isConcatSpreadable'); // https://tc39.github.io/ecma262/#sec-symbol.iterator\n\ndefineWellKnownSymbol('iterator'); // https://tc39.github.io/ecma262/#sec-symbol.match\n\ndefineWellKnownSymbol('match');\ndefineWellKnownSymbol('matchAll'); // https://tc39.github.io/ecma262/#sec-symbol.replace\n\ndefineWellKnownSymbol('replace'); // https://tc39.github.io/ecma262/#sec-symbol.search\n\ndefineWellKnownSymbol('search'); // https://tc39.github.io/ecma262/#sec-symbol.species\n\ndefineWellKnownSymbol('species'); // https://tc39.github.io/ecma262/#sec-symbol.split\n\ndefineWellKnownSymbol('split'); // https://tc39.github.io/ecma262/#sec-symbol.toprimitive\n\ndefineWellKnownSymbol('toPrimitive'); // https://tc39.github.io/ecma262/#sec-symbol.tostringtag\n\ndefineWellKnownSymbol('toStringTag'); // https://tc39.github.io/ecma262/#sec-symbol.unscopables\n\ndefineWellKnownSymbol('unscopables'); // https://tc39.github.io/ecma262/#sec-json-@@tostringtag\n\nsetToStringTag(global_1.JSON, 'JSON', true);\nvar symbol = path.Symbol; // https://github.com/tc39/proposal-using-statement\n\ndefineWellKnownSymbol('asyncDispose'); // https://github.com/tc39/proposal-using-statement\n\ndefineWellKnownSymbol('dispose'); // https://github.com/tc39/proposal-observable\n\ndefineWellKnownSymbol('observable'); // https://github.com/tc39/proposal-pattern-matching\n\ndefineWellKnownSymbol('patternMatch');\ndefineWellKnownSymbol('replaceAll');\nvar symbol$1 = symbol;\nvar symbol$2 = symbol$1;\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof symbol$2 === \"undefined\" || !isIterable$1(Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = getIterator$1(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nvar iterableToArrayLimit = _iterableToArrayLimit;\nvar from_1$3 = from_1;\nvar from_1$4 = from_1$3;\nvar HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('slice');\nvar USES_TO_LENGTH$3 = arrayMethodUsesToLength('slice', {\n  ACCESSORS: true,\n  0: 0,\n  1: 2\n});\nvar SPECIES$2 = wellKnownSymbol('species');\nvar nativeSlice = [].slice;\nvar max$1 = Math.max; // `Array.prototype.slice` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.slice\n// fallback for not array-like ES3 strings and DOM objects\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$3\n}, {\n  slice: function slice(start, end) {\n    var O = toIndexedObject(this);\n    var length = toLength(O.length);\n    var k = toAbsoluteIndex(start, length);\n    var fin = toAbsoluteIndex(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible\n\n    var Constructor, result, n;\n\n    if (isArray(O)) {\n      Constructor = O.constructor; // cross-realm fallback\n\n      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {\n        Constructor = undefined;\n      } else if (isObject(Constructor)) {\n        Constructor = Constructor[SPECIES$2];\n        if (Constructor === null) Constructor = undefined;\n      }\n\n      if (Constructor === Array || Constructor === undefined) {\n        return nativeSlice.call(O, k, fin);\n      }\n    }\n\n    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));\n\n    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);\n\n    result.length = n;\n    return result;\n  }\n});\n\nvar slice$1 = entryVirtual('Array').slice;\nvar ArrayPrototype$4 = Array.prototype;\n\nvar slice_1 = function (it) {\n  var own = it.slice;\n  return it === ArrayPrototype$4 || it instanceof Array && own === ArrayPrototype$4.slice ? slice$1 : own;\n};\n\nvar slice$2 = slice_1;\nvar slice$3 = slice$2;\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar arrayLikeToArray = _arrayLikeToArray;\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context;\n\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = slice$3(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from_1$4(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nvar unsupportedIterableToArray = _unsupportedIterableToArray;\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar nonIterableRest = _nonIterableRest;\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nvar slicedToArray = _slicedToArray; // https://tc39.github.io/ecma262/#sec-date.now\n\n_export({\n  target: 'Date',\n  stat: true\n}, {\n  now: function now() {\n    return new Date().getTime();\n  }\n});\n\nvar now = path.Date.now;\nvar now$1 = now;\nvar now$2 = now$1;\nvar FAILS_ON_PRIMITIVES$2 = fails(function () {\n  objectKeys(1);\n}); // `Object.keys` method\n// https://tc39.github.io/ecma262/#sec-object.keys\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: FAILS_ON_PRIMITIVES$2\n}, {\n  keys: function keys(it) {\n    return objectKeys(toObject(it));\n  }\n});\n\nvar keys$1 = path.Object.keys;\nvar keys$2 = keys$1;\nvar keys$3 = keys$2;\nvar $map = arrayIteration.map;\nvar HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('map'); // FF49- issue\n\nvar USES_TO_LENGTH$4 = arrayMethodUsesToLength('map'); // `Array.prototype.map` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$4\n}, {\n  map: function map(callbackfn\n  /* , thisArg */\n  ) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar map = entryVirtual('Array').map;\nvar ArrayPrototype$5 = Array.prototype;\n\nvar map_1 = function (it) {\n  var own = it.map;\n  return it === ArrayPrototype$5 || it instanceof Array && own === ArrayPrototype$5.map ? map : own;\n};\n\nvar map$1 = map_1;\nvar map$2 = map$1;\nvar isArray$4 = isArray$1;\nvar isArray$5 = isArray$4;\nvar iterator = wellKnownSymbolWrapped.f('iterator');\nvar iterator$1 = iterator;\nvar iterator$2 = iterator$1;\n\nvar _typeof_1 = createCommonjsModule(function (module) {\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof symbol$2 === \"function\" && typeof iterator$2 === \"symbol\") {\n      module.exports = _typeof = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      module.exports = _typeof = function _typeof(obj) {\n        return obj && typeof symbol$2 === \"function\" && obj.constructor === symbol$2 && obj !== symbol$2.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  module.exports = _typeof;\n}); // https://tc39.github.io/ecma262/#sec-reflect.ownkeys\n\n\n_export({\n  target: 'Reflect',\n  stat: true\n}, {\n  ownKeys: ownKeys\n});\n\nvar ownKeys$1 = path.Reflect.ownKeys;\nvar slice$4 = slice_1;\nvar slice$5 = slice$4;\n\nfunction _arrayWithoutHoles(arr) {\n  if (isArray$3(arr)) return arrayLikeToArray(arr);\n}\n\nvar arrayWithoutHoles = _arrayWithoutHoles;\n\nfunction _iterableToArray(iter) {\n  if (typeof symbol$2 !== \"undefined\" && isIterable$1(Object(iter))) return from_1$4(iter);\n}\n\nvar iterableToArray = _iterableToArray;\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar nonIterableSpread = _nonIterableSpread;\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nvar toConsumableArray = _toConsumableArray;\nvar concat = entryVirtual('Array').concat;\nvar ArrayPrototype$6 = Array.prototype;\n\nvar concat_1 = function (it) {\n  var own = it.concat;\n  return it === ArrayPrototype$6 || it instanceof Array && own === ArrayPrototype$6.concat ? concat : own;\n};\n\nvar concat$1 = concat_1;\nvar concat$2 = concat$1;\nvar symbol$3 = symbol;\nvar symbol$4 = symbol$3;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$1(o, minLen) {\n  var _context13;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n  var n = slice$5(_context13 = Object.prototype.toString.call(o)).call(_context13, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from_1$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\n\nfunction _arrayLikeToArray$1(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * vis-util\n * https://github.com/visjs/vis-util\n *\n * utilitie collection for visjs\n *\n * @version 4.3.4\n * @date    2020-08-01T15:11:53.524Z\n *\n * @copyright (c) 2011-2017 Almende B.V, http://almende.com\n * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs\n *\n * @license\n * vis.js is dual licensed under both\n *\n *   1. The Apache 2.0 License\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   and\n *\n *   2. The MIT License\n *      http://opensource.org/licenses/MIT\n *\n * vis.js may be distributed under either license.\n */\n\n/**\r\n * Use this symbol to delete properies in deepObjectAssign.\r\n */\n\n\nvar DELETE = symbol$4(\"DELETE\");\n/**\r\n * Seedable, fast and reasonably good (not crypto but more than okay for our\r\n * needs) random number generator.\r\n *\r\n * @remarks\r\n * Adapted from {@link https://web.archive.org/web/20110429100736/http://baagoe.com:80/en/RandomMusings/javascript}.\r\n * Original algorithm created by Johannes Baagøe \\<baagoe\\@baagoe.com\\> in 2010.\r\n */\n\n/**\r\n * Create a seeded pseudo random generator based on Alea by Johannes Baagøe.\r\n *\r\n * @param seed - All supplied arguments will be used as a seed. In case nothing\r\n * is supplied the current time will be used to seed the generator.\r\n *\r\n * @returns A ready to use seeded generator.\r\n */\n\nfunction Alea() {\n  for (var _len3 = arguments.length, seed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    seed[_key3] = arguments[_key3];\n  }\n\n  return AleaImplementation(seed.length ? seed : [now$2()]);\n}\n/**\r\n * An implementation of [[Alea]] without user input validation.\r\n *\r\n * @param seed - The data that will be used to seed the generator.\r\n *\r\n * @returns A ready to use seeded generator.\r\n */\n\n\nfunction AleaImplementation(seed) {\n  var _mashSeed = mashSeed(seed),\n      _mashSeed2 = slicedToArray(_mashSeed, 3),\n      s0 = _mashSeed2[0],\n      s1 = _mashSeed2[1],\n      s2 = _mashSeed2[2];\n\n  var c = 1;\n\n  var random = function random() {\n    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n\n    s0 = s1;\n    s1 = s2;\n    return s2 = t - (c = t | 0);\n  };\n\n  random.uint32 = function () {\n    return random() * 0x100000000;\n  }; // 2^32\n\n\n  random.fract53 = function () {\n    return random() + (random() * 0x200000 | 0) * 1.1102230246251565e-16;\n  }; // 2^-53\n\n\n  random.algorithm = \"Alea\";\n  random.seed = seed;\n  random.version = \"0.9\";\n  return random;\n}\n/**\r\n * Turn arbitrary data into values [[AleaImplementation]] can use to generate\r\n * random numbers.\r\n *\r\n * @param seed - Arbitrary data that will be used as the seed.\r\n *\r\n * @returns Three numbers to use as initial values for [[AleaImplementation]].\r\n */\n\n\nfunction mashSeed() {\n  var mash = Mash();\n  var s0 = mash(\" \");\n  var s1 = mash(\" \");\n  var s2 = mash(\" \");\n\n  for (var i = 0; i < arguments.length; i++) {\n    s0 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n\n    if (s0 < 0) {\n      s0 += 1;\n    }\n\n    s1 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n\n    if (s1 < 0) {\n      s1 += 1;\n    }\n\n    s2 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n\n    if (s2 < 0) {\n      s2 += 1;\n    }\n  }\n\n  return [s0, s1, s2];\n}\n/**\r\n * Create a new mash function.\r\n *\r\n * @returns A nonpure function that takes arbitrary [[Mashable]] data and turns\r\n * them into numbers.\r\n */\n\n\nfunction Mash() {\n  var n = 0xefc8249d;\n  return function (data) {\n    var string = data.toString();\n\n    for (var i = 0; i < string.length; i++) {\n      n += string.charCodeAt(i);\n      var h = 0.02519603282416938 * n;\n      n = h >>> 0;\n      h -= n;\n      h *= n;\n      n = h >>> 0;\n      h -= n;\n      n += h * 0x100000000; // 2^32\n    }\n\n    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n  };\n} // utility functions\n\n\nvar fullHexRE = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\nvar shortHexRE = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\nvar rgbRE = /^rgb\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *\\)$/i;\nvar rgbaRE = /^rgba\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *([01]|0?\\.\\d+) *\\)$/i;\n/**\r\n * Remove everything in the DOM object.\r\n *\r\n * @param DOMobject - Node whose child nodes will be recursively deleted.\r\n */\n\nfunction recursiveDOMDelete(DOMobject) {\n  if (DOMobject) {\n    while (DOMobject.hasChildNodes() === true) {\n      var child = DOMobject.firstChild;\n\n      if (child) {\n        recursiveDOMDelete(child);\n        DOMobject.removeChild(child);\n      }\n    }\n  }\n}\n/**\r\n * Test whether given object is a string.\r\n *\r\n * @param value - Input value of unknown type.\r\n *\r\n * @returns True if string, false otherwise.\r\n */\n\n\nfunction isString(value) {\n  return value instanceof String || typeof value === \"string\";\n}\n/**\r\n * Test whether given object is a object (not primitive or null).\r\n *\r\n * @param value - Input value of unknown type.\r\n *\r\n * @returns True if not null object, false otherwise.\r\n */\n\n\nfunction isObject$1(value) {\n  return _typeof_1(value) === \"object\" && value !== null;\n}\n/**\r\n * Copy property from b to a if property present in a.\r\n * If property in b explicitly set to null, delete it if `allowDeletion` set.\r\n *\r\n * Internal helper routine, should not be exported. Not added to `exports` for that reason.\r\n *\r\n * @param a - Target object.\r\n * @param b - Source object.\r\n * @param prop - Name of property to copy from b to a.\r\n * @param allowDeletion - If true, delete property in a if explicitly set to null in b.\r\n */\n\n\nfunction copyOrDelete(a, b, prop, allowDeletion) {\n  var doDeletion = false;\n\n  if (allowDeletion === true) {\n    doDeletion = b[prop] === null && a[prop] !== undefined;\n  }\n\n  if (doDeletion) {\n    delete a[prop];\n  } else {\n    a[prop] = b[prop]; // Remember, this is a reference copy!\n  }\n}\n/**\r\n * Fill an object with a possibly partially defined other object.\r\n *\r\n * Only copies values for the properties already present in a.\r\n * That means an object is not created on a property if only the b object has it.\r\n *\r\n * @param a - The object that will have it's properties updated.\r\n * @param b - The object with property updates.\r\n * @param allowDeletion - If true, delete properties in a that are explicitly set to null in b.\r\n */\n\n\nfunction fillIfDefined(a, b) {\n  var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // NOTE: iteration of properties of a\n  // NOTE: prototype properties iterated over as well\n\n  for (var prop in a) {\n    if (b[prop] !== undefined) {\n      if (b[prop] === null || _typeof_1(b[prop]) !== \"object\") {\n        // Note: typeof null === 'object'\n        copyOrDelete(a, b, prop, allowDeletion);\n      } else {\n        var aProp = a[prop];\n        var bProp = b[prop];\n\n        if (isObject$1(aProp) && isObject$1(bProp)) {\n          fillIfDefined(aProp, bProp, allowDeletion);\n        }\n      }\n    }\n  }\n}\n/**\r\n * Extend object a with selected properties of object b.\r\n * Only properties with defined values are copied.\r\n *\r\n * @remarks\r\n * Previous version of this routine implied that multiple source objects could\r\n * be used; however, the implementation was **wrong**. Since multiple (\\>1)\r\n * sources weren't used anywhere in the `vis.js` code, this has been removed\r\n *\r\n * @param props - Names of first-level properties to copy over.\r\n * @param a - Target object.\r\n * @param b - Source object.\r\n * @param allowDeletion - If true, delete property in a if explicitly set to null in b.\r\n *\r\n * @returns Argument a.\r\n */\n\n\nfunction selectiveDeepExtend(props, a, b) {\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; // TODO: add support for Arrays to deepExtend\n\n  if (isArray$5(b)) {\n    throw new TypeError(\"Arrays are not supported by deepExtend\");\n  }\n\n  for (var p = 0; p < props.length; p++) {\n    var prop = props[p];\n\n    if (Object.prototype.hasOwnProperty.call(b, prop)) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === undefined) {\n          a[prop] = {};\n        }\n\n        if (a[prop].constructor === Object) {\n          deepExtend(a[prop], b[prop], false, allowDeletion);\n        } else {\n          copyOrDelete(a, b, prop, allowDeletion);\n        }\n      } else if (isArray$5(b[prop])) {\n        throw new TypeError(\"Arrays are not supported by deepExtend\");\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    }\n  }\n\n  return a;\n}\n/**\r\n * Extend object `a` with properties of object `b`, ignoring properties which\r\n * are explicitly specified to be excluded.\r\n *\r\n * @remarks\r\n * The properties of `b` are considered for copying. Properties which are\r\n * themselves objects are are also extended. Only properties with defined\r\n * values are copied.\r\n *\r\n * @param propsToExclude - Names of properties which should *not* be copied.\r\n * @param a - Object to extend.\r\n * @param b - Object to take properties from for extension.\r\n * @param allowDeletion - If true, delete properties in a that are explicitly\r\n * set to null in b.\r\n *\r\n * @returns Argument a.\r\n */\n\n\nfunction selectiveNotDeepExtend(propsToExclude, a, b) {\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; // TODO: add support for Arrays to deepExtend\n  // NOTE: array properties have an else-below; apparently, there is a problem here.\n\n  if (isArray$5(b)) {\n    throw new TypeError(\"Arrays are not supported by deepExtend\");\n  }\n\n  for (var prop in b) {\n    if (!Object.prototype.hasOwnProperty.call(b, prop)) {\n      continue;\n    } // Handle local properties only\n\n\n    if (indexOf$3(propsToExclude).call(propsToExclude, prop) !== -1) {\n      continue;\n    } // In exclusion list, skip\n\n\n    if (b[prop] && b[prop].constructor === Object) {\n      if (a[prop] === undefined) {\n        a[prop] = {};\n      }\n\n      if (a[prop].constructor === Object) {\n        deepExtend(a[prop], b[prop]); // NOTE: allowDeletion not propagated!\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    } else if (isArray$5(b[prop])) {\n      a[prop] = [];\n\n      for (var i = 0; i < b[prop].length; i++) {\n        a[prop].push(b[prop][i]);\n      }\n    } else {\n      copyOrDelete(a, b, prop, allowDeletion);\n    }\n  }\n\n  return a;\n}\n/**\r\n * Deep extend an object a with the properties of object b.\r\n *\r\n * @param a - Target object.\r\n * @param b - Source object.\r\n * @param protoExtend - If true, the prototype values will also be extended.\r\n * (That is the options objects that inherit from others will also get the\r\n * inherited options).\r\n * @param allowDeletion - If true, the values of fields that are null will be deleted.\r\n *\r\n * @returns Argument a.\r\n */\n\n\nfunction deepExtend(a, b) {\n  var protoExtend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  for (var prop in b) {\n    if (Object.prototype.hasOwnProperty.call(b, prop) || protoExtend === true) {\n      if (_typeof_1(b[prop]) === \"object\" && b[prop] !== null && getPrototypeOf$2(b[prop]) === Object.prototype) {\n        if (a[prop] === undefined) {\n          a[prop] = deepExtend({}, b[prop], protoExtend); // NOTE: allowDeletion not propagated!\n        } else if (_typeof_1(a[prop]) === \"object\" && a[prop] !== null && getPrototypeOf$2(a[prop]) === Object.prototype) {\n          deepExtend(a[prop], b[prop], protoExtend); // NOTE: allowDeletion not propagated!\n        } else {\n          copyOrDelete(a, b, prop, allowDeletion);\n        }\n      } else if (isArray$5(b[prop])) {\n        var _context3;\n\n        a[prop] = slice$5(_context3 = b[prop]).call(_context3);\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    }\n  }\n\n  return a;\n}\n/**\r\n * Used to extend an array and copy it. This is used to propagate paths recursively.\r\n *\r\n * @param arr - First part.\r\n * @param newValue - The value to be aadded into the array.\r\n *\r\n * @returns A new array with all items from arr and newValue (which is last).\r\n */\n\n\nfunction copyAndExtendArray(arr, newValue) {\n  var _context4;\n\n  return concat$2(_context4 = []).call(_context4, toConsumableArray(arr), [newValue]);\n}\n/**\r\n * Used to extend an array and copy it. This is used to propagate paths recursively.\r\n *\r\n * @param arr - The array to be copied.\r\n *\r\n * @returns Shallow copy of arr.\r\n */\n\n\nfunction copyArray(arr) {\n  return slice$5(arr).call(arr);\n}\n/**\r\n * Retrieve the absolute left value of a DOM element.\r\n *\r\n * @param elem - A dom element, for example a div.\r\n *\r\n * @returns The absolute left position of this element in the browser page.\r\n */\n\n\nfunction getAbsoluteLeft(elem) {\n  return elem.getBoundingClientRect().left;\n}\n/**\r\n * Retrieve the absolute top value of a DOM element.\r\n *\r\n * @param elem - A dom element, for example a div.\r\n *\r\n * @returns The absolute top position of this element in the browser page.\r\n */\n\n\nfunction getAbsoluteTop(elem) {\n  return elem.getBoundingClientRect().top;\n}\n/**\r\n * Add a className to the given elements style.\r\n *\r\n * @param elem - The element to which the classes will be added.\r\n * @param classNames - Space separated list of classes.\r\n */\n\n\nfunction addClassName(elem, classNames) {\n  var classes = elem.className.split(\" \");\n  var newClasses = classNames.split(\" \");\n  classes = concat$2(classes).call(classes, filter$2(newClasses).call(newClasses, function (className) {\n    return indexOf$3(classes).call(classes, className) < 0;\n  }));\n  elem.className = classes.join(\" \");\n}\n/**\r\n * Remove a className from the given elements style.\r\n *\r\n * @param elem - The element from which the classes will be removed.\r\n * @param classNames - Space separated list of classes.\r\n */\n\n\nfunction removeClassName(elem, classNames) {\n  var classes = elem.className.split(\" \");\n  var oldClasses = classNames.split(\" \");\n  classes = filter$2(classes).call(classes, function (className) {\n    return indexOf$3(oldClasses).call(oldClasses, className) < 0;\n  });\n  elem.className = classes.join(\" \");\n}\n/**\r\n * For each method for both arrays and objects.\r\n * In case of an array, the built-in Array.forEach() is applied (**No, it's not!**).\r\n * In case of an Object, the method loops over all properties of the object.\r\n *\r\n * @param object - An Object or Array to be iterated over.\r\n * @param callback - Array.forEach-like callback.\r\n */\n\n\nfunction forEach$3(object, callback) {\n  if (isArray$5(object)) {\n    // array\n    var len = object.length;\n\n    for (var i = 0; i < len; i++) {\n      callback(object[i], i, object);\n    }\n  } else {\n    // object\n    for (var key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        callback(object[key], key, object);\n      }\n    }\n  }\n}\n/**\r\n * Add and event listener. Works for all browsers.\r\n *\r\n * @param element - The element to bind the event listener to.\r\n * @param action - Same as Element.addEventListener(action, —, —).\r\n * @param listener - Same as Element.addEventListener(—, listener, —).\r\n * @param useCapture - Same as Element.addEventListener(—, —, useCapture).\r\n */\n\n\nfunction addEventListener(element, action, listener, useCapture) {\n  if (element.addEventListener) {\n    var _context5;\n\n    if (useCapture === undefined) {\n      useCapture = false;\n    }\n\n    if (action === \"mousewheel\" && indexOf$3(_context5 = navigator.userAgent).call(_context5, \"Firefox\") >= 0) {\n      action = \"DOMMouseScroll\"; // For Firefox\n    }\n\n    element.addEventListener(action, listener, useCapture);\n  } else {\n    // @TODO: IE types? Does anyone care?\n    element.attachEvent(\"on\" + action, listener); // IE browsers\n  }\n}\n/**\r\n * Remove an event listener from an element.\r\n *\r\n * @param element - The element to bind the event listener to.\r\n * @param action - Same as Element.removeEventListener(action, —, —).\r\n * @param listener - Same as Element.removeEventListener(—, listener, —).\r\n * @param useCapture - Same as Element.removeEventListener(—, —, useCapture).\r\n */\n\n\nfunction removeEventListener(element, action, listener, useCapture) {\n  if (element.removeEventListener) {\n    var _context6; // non-IE browsers\n\n\n    if (useCapture === undefined) {\n      useCapture = false;\n    }\n\n    if (action === \"mousewheel\" && indexOf$3(_context6 = navigator.userAgent).call(_context6, \"Firefox\") >= 0) {\n      action = \"DOMMouseScroll\"; // For Firefox\n    }\n\n    element.removeEventListener(action, listener, useCapture);\n  } else {\n    // @TODO: IE types? Does anyone care?\n    element.detachEvent(\"on\" + action, listener); // IE browsers\n  }\n}\n/**\r\n * Convert hex color string into RGB color object.\r\n *\r\n * @remarks\r\n * {@link http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb}\r\n *\r\n * @param hex - Hex color string (3 or 6 digits, with or without #).\r\n *\r\n * @returns RGB color object.\r\n */\n\n\nfunction hexToRGB(hex) {\n  var result;\n\n  switch (hex.length) {\n    case 3:\n    case 4:\n      result = shortHexRE.exec(hex);\n      return result ? {\n        r: _parseInt$2(result[1] + result[1], 16),\n        g: _parseInt$2(result[2] + result[2], 16),\n        b: _parseInt$2(result[3] + result[3], 16)\n      } : null;\n\n    case 6:\n    case 7:\n      result = fullHexRE.exec(hex);\n      return result ? {\n        r: _parseInt$2(result[1], 16),\n        g: _parseInt$2(result[2], 16),\n        b: _parseInt$2(result[3], 16)\n      } : null;\n\n    default:\n      return null;\n  }\n}\n/**\r\n * This function takes string color in hex or RGB format and adds the opacity, RGBA is passed through unchanged.\r\n *\r\n * @param color - The color string (hex, RGB, RGBA).\r\n * @param opacity - The new opacity.\r\n *\r\n * @returns RGBA string, for example 'rgba(255, 0, 127, 0.3)'.\r\n */\n\n\nfunction overrideOpacity(color, opacity) {\n  if (indexOf$3(color).call(color, \"rgba\") !== -1) {\n    return color;\n  } else if (indexOf$3(color).call(color, \"rgb\") !== -1) {\n    var rgb = color.substr(indexOf$3(color).call(color, \"(\") + 1).replace(\")\", \"\").split(\",\");\n    return \"rgba(\" + rgb[0] + \",\" + rgb[1] + \",\" + rgb[2] + \",\" + opacity + \")\";\n  } else {\n    var _rgb = hexToRGB(color);\n\n    if (_rgb == null) {\n      return color;\n    } else {\n      return \"rgba(\" + _rgb.r + \",\" + _rgb.g + \",\" + _rgb.b + \",\" + opacity + \")\";\n    }\n  }\n}\n/**\r\n * Convert RGB \\<0, 255\\> into hex color string.\r\n *\r\n * @param red - Red channel.\r\n * @param green - Green channel.\r\n * @param blue - Blue channel.\r\n *\r\n * @returns Hex color string (for example: '#0acdc0').\r\n */\n\n\nfunction RGBToHex(red, green, blue) {\n  var _context7;\n\n  return \"#\" + slice$5(_context7 = ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16)).call(_context7, 1);\n}\n/**\r\n * Parse a color property into an object with border, background, and highlight colors.\r\n *\r\n * @param inputColor - Shorthand color string or input color object.\r\n * @param defaultColor - Full color object to fill in missing values in inputColor.\r\n *\r\n * @returns Color object.\r\n */\n\n\nfunction parseColor(inputColor, defaultColor) {\n  if (isString(inputColor)) {\n    var colorStr = inputColor;\n\n    if (isValidRGB(colorStr)) {\n      var _context8;\n\n      var rgb = map$2(_context8 = colorStr.substr(4).substr(0, colorStr.length - 5).split(\",\")).call(_context8, function (value) {\n        return _parseInt$2(value);\n      });\n      colorStr = RGBToHex(rgb[0], rgb[1], rgb[2]);\n    }\n\n    if (isValidHex(colorStr) === true) {\n      var hsv = hexToHSV(colorStr);\n      var lighterColorHSV = {\n        h: hsv.h,\n        s: hsv.s * 0.8,\n        v: Math.min(1, hsv.v * 1.02)\n      };\n      var darkerColorHSV = {\n        h: hsv.h,\n        s: Math.min(1, hsv.s * 1.25),\n        v: hsv.v * 0.8\n      };\n      var darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);\n      var lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);\n      return {\n        background: colorStr,\n        border: darkerColorHex,\n        highlight: {\n          background: lighterColorHex,\n          border: darkerColorHex\n        },\n        hover: {\n          background: lighterColorHex,\n          border: darkerColorHex\n        }\n      };\n    } else {\n      return {\n        background: colorStr,\n        border: colorStr,\n        highlight: {\n          background: colorStr,\n          border: colorStr\n        },\n        hover: {\n          background: colorStr,\n          border: colorStr\n        }\n      };\n    }\n  } else {\n    if (defaultColor) {\n      var color = {\n        background: inputColor.background || defaultColor.background,\n        border: inputColor.border || defaultColor.border,\n        highlight: isString(inputColor.highlight) ? {\n          border: inputColor.highlight,\n          background: inputColor.highlight\n        } : {\n          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,\n          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border\n        },\n        hover: isString(inputColor.hover) ? {\n          border: inputColor.hover,\n          background: inputColor.hover\n        } : {\n          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,\n          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background\n        }\n      };\n      return color;\n    } else {\n      var _color = {\n        background: inputColor.background || undefined,\n        border: inputColor.border || undefined,\n        highlight: isString(inputColor.highlight) ? {\n          border: inputColor.highlight,\n          background: inputColor.highlight\n        } : {\n          background: inputColor.highlight && inputColor.highlight.background || undefined,\n          border: inputColor.highlight && inputColor.highlight.border || undefined\n        },\n        hover: isString(inputColor.hover) ? {\n          border: inputColor.hover,\n          background: inputColor.hover\n        } : {\n          border: inputColor.hover && inputColor.hover.border || undefined,\n          background: inputColor.hover && inputColor.hover.background || undefined\n        }\n      };\n      return _color;\n    }\n  }\n}\n/**\r\n * Convert RGB \\<0, 255\\> into HSV object.\r\n *\r\n * @remarks\r\n * {@link http://www.javascripter.net/faq/rgb2hsv.htm}\r\n *\r\n * @param red - Red channel.\r\n * @param green - Green channel.\r\n * @param blue - Blue channel.\r\n *\r\n * @returns HSV color object.\r\n */\n\n\nfunction RGBToHSV(red, green, blue) {\n  red = red / 255;\n  green = green / 255;\n  blue = blue / 255;\n  var minRGB = Math.min(red, Math.min(green, blue));\n  var maxRGB = Math.max(red, Math.max(green, blue)); // Black-gray-white\n\n  if (minRGB === maxRGB) {\n    return {\n      h: 0,\n      s: 0,\n      v: minRGB\n    };\n  } // Colors other than black-gray-white:\n\n\n  var d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;\n  var h = red === minRGB ? 3 : blue === minRGB ? 1 : 5;\n  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;\n  var saturation = (maxRGB - minRGB) / maxRGB;\n  var value = maxRGB;\n  return {\n    h: hue,\n    s: saturation,\n    v: value\n  };\n}\n/**\r\n * Convert HSV \\<0, 1\\> into RGB color object.\r\n *\r\n * @remarks\r\n * {@link https://gist.github.com/mjijackson/5311256}\r\n *\r\n * @param h - Hue.\r\n * @param s - Saturation.\r\n * @param v - Value.\r\n *\r\n * @returns RGB color object.\r\n */\n\n\nfunction HSVToRGB(h, s, v) {\n  var r;\n  var g;\n  var b;\n  var i = Math.floor(h * 6);\n  var f = h * 6 - i;\n  var p = v * (1 - s);\n  var q = v * (1 - f * s);\n  var t = v * (1 - (1 - f) * s);\n\n  switch (i % 6) {\n    case 0:\n      r = v, g = t, b = p;\n      break;\n\n    case 1:\n      r = q, g = v, b = p;\n      break;\n\n    case 2:\n      r = p, g = v, b = t;\n      break;\n\n    case 3:\n      r = p, g = q, b = v;\n      break;\n\n    case 4:\n      r = t, g = p, b = v;\n      break;\n\n    case 5:\n      r = v, g = p, b = q;\n      break;\n  }\n\n  return {\n    r: Math.floor(r * 255),\n    g: Math.floor(g * 255),\n    b: Math.floor(b * 255)\n  };\n}\n/**\r\n * Convert HSV \\<0, 1\\> into hex color string.\r\n *\r\n * @param h - Hue.\r\n * @param s - Saturation.\r\n * @param v - Value.\r\n *\r\n * @returns Hex color string.\r\n */\n\n\nfunction HSVToHex(h, s, v) {\n  var rgb = HSVToRGB(h, s, v);\n  return RGBToHex(rgb.r, rgb.g, rgb.b);\n}\n/**\r\n * Convert hex color string into HSV \\<0, 1\\>.\r\n *\r\n * @param hex - Hex color string.\r\n *\r\n * @returns HSV color object.\r\n */\n\n\nfunction hexToHSV(hex) {\n  var rgb = hexToRGB(hex);\n\n  if (!rgb) {\n    throw new TypeError(\"'\".concat(hex, \"' is not a valid color.\"));\n  }\n\n  return RGBToHSV(rgb.r, rgb.g, rgb.b);\n}\n/**\r\n * Validate hex color string.\r\n *\r\n * @param hex - Unknown string that may contain a color.\r\n *\r\n * @returns True if the string is valid, false otherwise.\r\n */\n\n\nfunction isValidHex(hex) {\n  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);\n  return isOk;\n}\n/**\r\n * Validate RGB color string.\r\n *\r\n * @param rgb - Unknown string that may contain a color.\r\n *\r\n * @returns True if the string is valid, false otherwise.\r\n */\n\n\nfunction isValidRGB(rgb) {\n  return rgbRE.test(rgb);\n}\n/**\r\n * Validate RGBA color string.\r\n *\r\n * @param rgba - Unknown string that may contain a color.\r\n *\r\n * @returns True if the string is valid, false otherwise.\r\n */\n\n\nfunction isValidRGBA(rgba) {\n  return rgbaRE.test(rgba);\n}\n/**\r\n * This recursively redirects the prototype of JSON objects to the referenceObject.\r\n * This is used for default options.\r\n *\r\n * @param referenceObject - The original object.\r\n *\r\n * @returns The Element if the referenceObject is an Element, or a new object inheriting from the referenceObject.\r\n */\n\n\nfunction bridgeObject(referenceObject) {\n  if (referenceObject === null || _typeof_1(referenceObject) !== \"object\") {\n    return null;\n  }\n\n  if (referenceObject instanceof Element) {\n    // Avoid bridging DOM objects\n    return referenceObject;\n  }\n\n  var objectTo = create$2(referenceObject);\n\n  for (var i in referenceObject) {\n    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {\n      if (_typeof_1(referenceObject[i]) == \"object\") {\n        objectTo[i] = bridgeObject(referenceObject[i]);\n      }\n    }\n  }\n\n  return objectTo;\n}\n/**\r\n * This is used to set the options of subobjects in the options object.\r\n *\r\n * A requirement of these subobjects is that they have an 'enabled' element\r\n * which is optional for the user but mandatory for the program.\r\n *\r\n * The added value here of the merge is that option 'enabled' is set as required.\r\n *\r\n * @param mergeTarget - Either this.options or the options used for the groups.\r\n * @param options - Options.\r\n * @param option - Option key in the options argument.\r\n * @param globalOptions - Global options, passed in to determine value of option 'enabled'.\r\n */\n\n\nfunction mergeOptions(mergeTarget, options, option) {\n  var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}; // Local helpers\n\n  var isPresent = function isPresent(obj) {\n    return obj !== null && obj !== undefined;\n  };\n\n  var isObject = function isObject(obj) {\n    return obj !== null && _typeof_1(obj) === \"object\";\n  }; // https://stackoverflow.com/a/34491287/1223531\n\n\n  var isEmpty = function isEmpty(obj) {\n    for (var x in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, x)) {\n        return false;\n      }\n    }\n\n    return true;\n  }; // Guards\n\n\n  if (!isObject(mergeTarget)) {\n    throw new Error(\"Parameter mergeTarget must be an object\");\n  }\n\n  if (!isObject(options)) {\n    throw new Error(\"Parameter options must be an object\");\n  }\n\n  if (!isPresent(option)) {\n    throw new Error(\"Parameter option must have a value\");\n  }\n\n  if (!isObject(globalOptions)) {\n    throw new Error(\"Parameter globalOptions must be an object\");\n  } //\n  // Actual merge routine, separated from main logic\n  // Only a single level of options is merged. Deeper levels are ref'd. This may actually be an issue.\n  //\n\n\n  var doMerge = function doMerge(target, options, option) {\n    if (!isObject(target[option])) {\n      target[option] = {};\n    }\n\n    var src = options[option];\n    var dst = target[option];\n\n    for (var prop in src) {\n      if (Object.prototype.hasOwnProperty.call(src, prop)) {\n        dst[prop] = src[prop];\n      }\n    }\n  }; // Local initialization\n\n\n  var srcOption = options[option];\n  var globalPassed = isObject(globalOptions) && !isEmpty(globalOptions);\n  var globalOption = globalPassed ? globalOptions[option] : undefined;\n  var globalEnabled = globalOption ? globalOption.enabled : undefined; /////////////////////////////////////////\n  // Main routine\n  /////////////////////////////////////////\n\n  if (srcOption === undefined) {\n    return; // Nothing to do\n  }\n\n  if (typeof srcOption === \"boolean\") {\n    if (!isObject(mergeTarget[option])) {\n      mergeTarget[option] = {};\n    }\n\n    mergeTarget[option].enabled = srcOption;\n    return;\n  }\n\n  if (srcOption === null && !isObject(mergeTarget[option])) {\n    // If possible, explicit copy from globals\n    if (isPresent(globalOption)) {\n      mergeTarget[option] = create$2(globalOption);\n    } else {\n      return; // Nothing to do\n    }\n  }\n\n  if (!isObject(srcOption)) {\n    return;\n  } //\n  // Ensure that 'enabled' is properly set. It is required internally\n  // Note that the value from options will always overwrite the existing value\n  //\n\n\n  var enabled = true; // default value\n\n  if (srcOption.enabled !== undefined) {\n    enabled = srcOption.enabled;\n  } else {\n    // Take from globals, if present\n    if (globalEnabled !== undefined) {\n      enabled = globalOption.enabled;\n    }\n  }\n\n  doMerge(mergeTarget, options, option);\n  mergeTarget[option].enabled = enabled;\n}\n/*\r\n * Easing Functions.\r\n * Only considering the t value for the range [0, 1] => [0, 1].\r\n *\r\n * Inspiration: from http://gizma.com/easing/\r\n * https://gist.github.com/gre/1650294\r\n */\n\n\nvar easingFunctions = {\n  /**\r\n   * Provides no easing and no acceleration.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  linear: function linear(t) {\n    return t;\n  },\n\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeInQuad: function easeInQuad(t) {\n    return t * t;\n  },\n\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeOutQuad: function easeOutQuad(t) {\n    return t * (2 - t);\n  },\n\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeInOutQuad: function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  },\n\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeInCubic: function easeInCubic(t) {\n    return t * t * t;\n  },\n\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeOutCubic: function easeOutCubic(t) {\n    return --t * t * t + 1;\n  },\n\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeInOutCubic: function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n  },\n\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeInQuart: function easeInQuart(t) {\n    return t * t * t * t;\n  },\n\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeOutQuart: function easeOutQuart(t) {\n    return 1 - --t * t * t * t;\n  },\n\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeInOutQuart: function easeInOutQuart(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  },\n\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeInQuint: function easeInQuint(t) {\n    return t * t * t * t * t;\n  },\n\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeOutQuint: function easeOutQuint(t) {\n    return 1 + --t * t * t * t * t;\n  },\n\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   *\r\n   * @returns Value at time t.\r\n   */\n  easeInOutQuint: function easeInOutQuint(t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n  }\n}; // It works only for single property objects,\n// otherwise it combines all of the types in a union.\n// export function topMost<K1 extends string, V1> (\n//   pile: Record<K1, undefined | V1>[],\n//   accessors: K1 | [K1]\n// ): undefined | V1\n// export function topMost<K1 extends string, K2 extends string, V1, V2> (\n//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2>>[],\n//   accessors: [K1, K2]\n// ): undefined | V1 | V2\n// export function topMost<K1 extends string, K2 extends string, K3 extends string, V1, V2, V3> (\n//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2 | Record<K3, undefined | V3>>>[],\n//   accessors: [K1, K2, K3]\n// ): undefined | V1 | V2 | V3\n\n/**\r\n * Get the top most property value from a pile of objects.\r\n *\r\n * @param pile - Array of objects, no required format.\r\n * @param accessors - Array of property names.\r\n * For example `object['foo']['bar']` → `['foo', 'bar']`.\r\n *\r\n * @returns Value of the property with given accessors path from the first pile item where it's not undefined.\r\n */\n\nfunction topMost(pile, accessors) {\n  var candidate;\n\n  if (!isArray$5(accessors)) {\n    accessors = [accessors];\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(pile),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var member = _step2.value;\n\n      if (member) {\n        candidate = member[accessors[0]];\n\n        for (var i = 1; i < accessors.length; i++) {\n          if (candidate) {\n            candidate = candidate[accessors[i]];\n          }\n        }\n\n        if (typeof candidate !== \"undefined\") {\n          break;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return candidate;\n}\n\nvar HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('splice');\nvar USES_TO_LENGTH$5 = arrayMethodUsesToLength('splice', {\n  ACCESSORS: true,\n  0: 0,\n  1: 2\n});\nvar max$2 = Math.max;\nvar min$2 = Math.min;\nvar MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.splice\n// with adding support of @@species\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$5\n}, {\n  splice: function splice(start, deleteCount\n  /* , ...items */\n  ) {\n    var O = toObject(this);\n    var len = toLength(O.length);\n    var actualStart = toAbsoluteIndex(start, len);\n    var argumentsLength = arguments.length;\n    var insertCount, actualDeleteCount, A, k, from, to;\n\n    if (argumentsLength === 0) {\n      insertCount = actualDeleteCount = 0;\n    } else if (argumentsLength === 1) {\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n    } else {\n      insertCount = argumentsLength - 2;\n      actualDeleteCount = min$2(max$2(toInteger(deleteCount), 0), len - actualStart);\n    }\n\n    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {\n      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);\n    }\n\n    A = arraySpeciesCreate(O, actualDeleteCount);\n\n    for (k = 0; k < actualDeleteCount; k++) {\n      from = actualStart + k;\n      if (from in O) createProperty(A, k, O[from]);\n    }\n\n    A.length = actualDeleteCount;\n\n    if (insertCount < actualDeleteCount) {\n      for (k = actualStart; k < len - actualDeleteCount; k++) {\n        from = k + actualDeleteCount;\n        to = k + insertCount;\n        if (from in O) O[to] = O[from];else delete O[to];\n      }\n\n      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];\n    } else if (insertCount > actualDeleteCount) {\n      for (k = len - actualDeleteCount; k > actualStart; k--) {\n        from = k + actualDeleteCount - 1;\n        to = k + insertCount - 1;\n        if (from in O) O[to] = O[from];else delete O[to];\n      }\n    }\n\n    for (k = 0; k < insertCount; k++) {\n      O[k + actualStart] = arguments[k + 2];\n    }\n\n    O.length = len - actualDeleteCount + insertCount;\n    return A;\n  }\n});\n\nvar splice = entryVirtual('Array').splice;\nvar ArrayPrototype$7 = Array.prototype;\n\nvar splice_1 = function (it) {\n  var own = it.splice;\n  return it === ArrayPrototype$7 || it instanceof Array && own === ArrayPrototype$7.splice ? splice : own;\n};\n\nvar splice$1 = splice_1;\nvar splice$2 = splice$1;\nvar $includes = arrayIncludes.includes;\nvar USES_TO_LENGTH$6 = arrayMethodUsesToLength('indexOf', {\n  ACCESSORS: true,\n  1: 0\n}); // `Array.prototype.includes` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.includes\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !USES_TO_LENGTH$6\n}, {\n  includes: function includes(el\n  /* , fromIndex = 0 */\n  ) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\n\nvar includes = entryVirtual('Array').includes;\nvar MATCH = wellKnownSymbol('match'); // `IsRegExp` abstract operation\n// https://tc39.github.io/ecma262/#sec-isregexp\n\nvar isRegexp = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');\n};\n\nvar notARegexp = function (it) {\n  if (isRegexp(it)) {\n    throw TypeError(\"The method doesn't accept regular expressions\");\n  }\n\n  return it;\n};\n\nvar MATCH$1 = wellKnownSymbol('match');\n\nvar correctIsRegexpLogic = function (METHOD_NAME) {\n  var regexp = /./;\n\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH$1] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) {\n      /* empty */\n    }\n  }\n\n  return false;\n}; // https://tc39.github.io/ecma262/#sec-string.prototype.includes\n\n\n_export({\n  target: 'String',\n  proto: true,\n  forced: !correctIsRegexpLogic('includes')\n}, {\n  includes: function includes(searchString\n  /* , position = 0 */\n  ) {\n    return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar includes$1 = entryVirtual('String').includes;\nvar ArrayPrototype$8 = Array.prototype;\nvar StringPrototype = String.prototype;\n\nvar includes$2 = function (it) {\n  var own = it.includes;\n  if (it === ArrayPrototype$8 || it instanceof Array && own === ArrayPrototype$8.includes) return includes;\n\n  if (typeof it === 'string' || it === StringPrototype || it instanceof String && own === StringPrototype.includes) {\n    return includes$1;\n  }\n\n  return own;\n};\n\nvar includes$3 = includes$2;\nvar includes$4 = includes$3;\n/* eslint-disable no-prototype-builtins */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable no-var */\n\n/**\n * Parse a text source containing data in DOT language into a JSON object.\n * The object contains two lists: one with nodes and one with edges.\n *\n * DOT language reference: http://www.graphviz.org/doc/info/lang.html\n *\n * DOT language attributes: http://graphviz.org/content/attrs\n *\n * @param {string} data     Text containing a graph in DOT-notation\n * @returns {object} graph   An object containing two parameters:\n *                          {Object[]} nodes\n *                          {Object[]} edges\n *\n * -------------------------------------------\n * TODO\n * ====\n *\n * For label handling, this is an incomplete implementation. From docs (quote #3015):\n *\n * > the escape sequences \"\\n\", \"\\l\" and \"\\r\" divide the label into lines, centered,\n * > left-justified, and right-justified, respectively.\n *\n * Source: http://www.graphviz.org/content/attrs#kescString\n *\n * > As another aid for readability, dot allows double-quoted strings to span multiple physical\n * > lines using the standard C convention of a backslash immediately preceding a newline\n * > character\n * > In addition, double-quoted strings can be concatenated using a '+' operator.\n * > As HTML strings can contain newline characters, which are used solely for formatting,\n * > the language does not allow escaped newlines or concatenation operators to be used\n * > within them.\n *\n * - Currently, only '\\\\n' is handled\n * - Note that text explicitly says 'labels'; the dot parser currently handles escape\n *   sequences in **all** strings.\n */\n\nfunction parseDOT(data) {\n  dot = data;\n  return parseGraph();\n} // mapping of attributes from DOT (the keys) to vis.js (the values)\n\n\nvar NODE_ATTR_MAPPING = {\n  fontsize: \"font.size\",\n  fontcolor: \"font.color\",\n  labelfontcolor: \"font.color\",\n  fontname: \"font.face\",\n  color: [\"color.border\", \"color.background\"],\n  fillcolor: \"color.background\",\n  tooltip: \"title\",\n  labeltooltip: \"title\"\n};\nvar EDGE_ATTR_MAPPING = create$2(NODE_ATTR_MAPPING);\nEDGE_ATTR_MAPPING.color = \"color.color\";\nEDGE_ATTR_MAPPING.style = \"dashes\"; // token types enumeration\n\nvar TOKENTYPE = {\n  NULL: 0,\n  DELIMITER: 1,\n  IDENTIFIER: 2,\n  UNKNOWN: 3\n}; // map with all delimiters\n\nvar DELIMITERS = {\n  \"{\": true,\n  \"}\": true,\n  \"[\": true,\n  \"]\": true,\n  \";\": true,\n  \"=\": true,\n  \",\": true,\n  \"->\": true,\n  \"--\": true\n};\nvar dot = \"\"; // current dot file\n\nvar index = 0; // current index in dot file\n\nvar c = \"\"; // current token character in expr\n\nvar token = \"\"; // current token\n\nvar tokenType = TOKENTYPE.NULL; // type of the token\n\n/**\n * Get the first character from the dot file.\n * The character is stored into the char c. If the end of the dot file is\n * reached, the function puts an empty string in c.\n */\n\nfunction first() {\n  index = 0;\n  c = dot.charAt(0);\n}\n/**\n * Get the next character from the dot file.\n * The character is stored into the char c. If the end of the dot file is\n * reached, the function puts an empty string in c.\n */\n\n\nfunction next() {\n  index++;\n  c = dot.charAt(index);\n}\n/**\n * Preview the next character from the dot file.\n *\n * @returns {string} cNext\n */\n\n\nfunction nextPreview() {\n  return dot.charAt(index + 1);\n}\n\nvar regexAlphaNumeric = /[a-zA-Z_0-9.:#]/;\n/**\n * Test whether given character is alphabetic or numeric\n *\n * @param {string} c\n * @returns {boolean} isAlphaNumeric\n */\n\nfunction isAlphaNumeric(c) {\n  return regexAlphaNumeric.test(c);\n}\n/**\n * Merge all options of object b into object b\n *\n * @param {object} a\n * @param {object} b\n * @returns {object} a\n */\n\n\nfunction merge(a, b) {\n  if (!a) {\n    a = {};\n  }\n\n  if (b) {\n    for (var name in b) {\n      if (b.hasOwnProperty(name)) {\n        a[name] = b[name];\n      }\n    }\n  }\n\n  return a;\n}\n/**\n * Set a value in an object, where the provided parameter name can be a\n * path with nested parameters. For example:\n *\n *     var obj = {a: 2};\n *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}\n *\n * @param {object} obj\n * @param {string} path  A parameter name or dot-separated parameter path,\n *                      like \"color.highlight.border\".\n * @param {*} value\n */\n\n\nfunction setValue(obj, path, value) {\n  var keys = path.split(\".\");\n  var o = obj;\n\n  while (keys.length) {\n    var key = keys.shift();\n\n    if (keys.length) {\n      // this isn't the end point\n      if (!o[key]) {\n        o[key] = {};\n      }\n\n      o = o[key];\n    } else {\n      // this is the end point\n      o[key] = value;\n    }\n  }\n}\n/**\n * Add a node to a graph object. If there is already a node with\n * the same id, their attributes will be merged.\n *\n * @param {object} graph\n * @param {object} node\n */\n\n\nfunction addNode(graph, node) {\n  var i, len;\n  var current = null; // find root graph (in case of subgraph)\n\n  var graphs = [graph]; // list with all graphs from current graph to root graph\n\n  var root = graph;\n\n  while (root.parent) {\n    graphs.push(root.parent);\n    root = root.parent;\n  } // find existing node (at root level) by its id\n\n\n  if (root.nodes) {\n    for (i = 0, len = root.nodes.length; i < len; i++) {\n      if (node.id === root.nodes[i].id) {\n        current = root.nodes[i];\n        break;\n      }\n    }\n  }\n\n  if (!current) {\n    // this is a new node\n    current = {\n      id: node.id\n    };\n\n    if (graph.node) {\n      // clone default attributes\n      current.attr = merge(current.attr, graph.node);\n    }\n  } // add node to this (sub)graph and all its parent graphs\n\n\n  for (i = graphs.length - 1; i >= 0; i--) {\n    var _context;\n\n    var g = graphs[i];\n\n    if (!g.nodes) {\n      g.nodes = [];\n    }\n\n    if (indexOf$3(_context = g.nodes).call(_context, current) === -1) {\n      g.nodes.push(current);\n    }\n  } // merge attributes\n\n\n  if (node.attr) {\n    current.attr = merge(current.attr, node.attr);\n  }\n}\n/**\n * Add an edge to a graph object\n *\n * @param {object} graph\n * @param {object} edge\n */\n\n\nfunction addEdge(graph, edge) {\n  if (!graph.edges) {\n    graph.edges = [];\n  }\n\n  graph.edges.push(edge);\n\n  if (graph.edge) {\n    var attr = merge({}, graph.edge); // clone default attributes\n\n    edge.attr = merge(attr, edge.attr); // merge attributes\n  }\n}\n/**\n * Create an edge to a graph object\n *\n * @param {object} graph\n * @param {string | number | object} from\n * @param {string | number | object} to\n * @param {string} type\n * @param {object | null} attr\n * @returns {object} edge\n */\n\n\nfunction createEdge(graph, from, to, type, attr) {\n  var edge = {\n    from: from,\n    to: to,\n    type: type\n  };\n\n  if (graph.edge) {\n    edge.attr = merge({}, graph.edge); // clone default attributes\n  }\n\n  edge.attr = merge(edge.attr || {}, attr); // merge attributes\n  // Move arrows attribute from attr to edge temporally created in\n  // parseAttributeList().\n\n  if (attr != null) {\n    if (attr.hasOwnProperty(\"arrows\") && attr[\"arrows\"] != null) {\n      edge[\"arrows\"] = {\n        to: {\n          enabled: true,\n          type: attr.arrows.type\n        }\n      };\n      attr[\"arrows\"] = null;\n    }\n  }\n\n  return edge;\n}\n/**\n * Get next token in the current dot file.\n * The token and token type are available as token and tokenType\n */\n\n\nfunction getToken() {\n  tokenType = TOKENTYPE.NULL;\n  token = \"\"; // skip over whitespaces\n\n  while (c === \" \" || c === \"\\t\" || c === \"\\n\" || c === \"\\r\") {\n    // space, tab, enter\n    next();\n  }\n\n  do {\n    var isComment = false; // skip comment\n\n    if (c === \"#\") {\n      // find the previous non-space character\n      var i = index - 1;\n\n      while (dot.charAt(i) === \" \" || dot.charAt(i) === \"\\t\") {\n        i--;\n      }\n\n      if (dot.charAt(i) === \"\\n\" || dot.charAt(i) === \"\") {\n        // the # is at the start of a line, this is indeed a line comment\n        while (c != \"\" && c != \"\\n\") {\n          next();\n        }\n\n        isComment = true;\n      }\n    }\n\n    if (c === \"/\" && nextPreview() === \"/\") {\n      // skip line comment\n      while (c != \"\" && c != \"\\n\") {\n        next();\n      }\n\n      isComment = true;\n    }\n\n    if (c === \"/\" && nextPreview() === \"*\") {\n      // skip block comment\n      while (c != \"\") {\n        if (c === \"*\" && nextPreview() === \"/\") {\n          // end of block comment found. skip these last two characters\n          next();\n          next();\n          break;\n        } else {\n          next();\n        }\n      }\n\n      isComment = true;\n    } // skip over whitespaces\n\n\n    while (c === \" \" || c === \"\\t\" || c === \"\\n\" || c === \"\\r\") {\n      // space, tab, enter\n      next();\n    }\n  } while (isComment); // check for end of dot file\n\n\n  if (c === \"\") {\n    // token is still empty\n    tokenType = TOKENTYPE.DELIMITER;\n    return;\n  } // check for delimiters consisting of 2 characters\n\n\n  var c2 = c + nextPreview();\n\n  if (DELIMITERS[c2]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c2;\n    next();\n    next();\n    return;\n  } // check for delimiters consisting of 1 character\n\n\n  if (DELIMITERS[c]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c;\n    next();\n    return;\n  } // check for an identifier (number or string)\n  // TODO: more precise parsing of numbers/strings (and the port separator ':')\n\n\n  if (isAlphaNumeric(c) || c === \"-\") {\n    token += c;\n    next();\n\n    while (isAlphaNumeric(c)) {\n      token += c;\n      next();\n    }\n\n    if (token === \"false\") {\n      token = false; // convert to boolean\n    } else if (token === \"true\") {\n      token = true; // convert to boolean\n    } else if (!isNaN(Number(token))) {\n      token = Number(token); // convert to number\n    }\n\n    tokenType = TOKENTYPE.IDENTIFIER;\n    return;\n  } // check for a string enclosed by double quotes\n\n\n  if (c === '\"') {\n    next();\n\n    while (c != \"\" && (c != '\"' || c === '\"' && nextPreview() === '\"')) {\n      if (c === '\"') {\n        // skip the escape character\n        token += c;\n        next();\n      } else if (c === \"\\\\\" && nextPreview() === \"n\") {\n        // Honor a newline escape sequence\n        token += \"\\n\";\n        next();\n      } else {\n        token += c;\n      }\n\n      next();\n    }\n\n    if (c != '\"') {\n      throw newSyntaxError('End of string \" expected');\n    }\n\n    next();\n    tokenType = TOKENTYPE.IDENTIFIER;\n    return;\n  } // something unknown is found, wrong characters, a syntax error\n\n\n  tokenType = TOKENTYPE.UNKNOWN;\n\n  while (c != \"\") {\n    token += c;\n    next();\n  }\n\n  throw new SyntaxError('Syntax error in part \"' + chop(token, 30) + '\"');\n}\n/**\n * Parse a graph.\n *\n * @returns {object} graph\n */\n\n\nfunction parseGraph() {\n  var graph = {};\n  first();\n  getToken(); // optional strict keyword\n\n  if (token === \"strict\") {\n    graph.strict = true;\n    getToken();\n  } // graph or digraph keyword\n\n\n  if (token === \"graph\" || token === \"digraph\") {\n    graph.type = token;\n    getToken();\n  } // optional graph id\n\n\n  if (tokenType === TOKENTYPE.IDENTIFIER) {\n    graph.id = token;\n    getToken();\n  } // open angle bracket\n\n\n  if (token != \"{\") {\n    throw newSyntaxError(\"Angle bracket { expected\");\n  }\n\n  getToken(); // statements\n\n  parseStatements(graph); // close angle bracket\n\n  if (token != \"}\") {\n    throw newSyntaxError(\"Angle bracket } expected\");\n  }\n\n  getToken(); // end of file\n\n  if (token !== \"\") {\n    throw newSyntaxError(\"End of file expected\");\n  }\n\n  getToken(); // remove temporary default options\n\n  delete graph.node;\n  delete graph.edge;\n  delete graph.graph;\n  return graph;\n}\n/**\n * Parse a list with statements.\n *\n * @param {object} graph\n */\n\n\nfunction parseStatements(graph) {\n  while (token !== \"\" && token != \"}\") {\n    parseStatement(graph);\n\n    if (token === \";\") {\n      getToken();\n    }\n  }\n}\n/**\n * Parse a single statement. Can be a an attribute statement, node\n * statement, a series of node statements and edge statements, or a\n * parameter.\n *\n * @param {object} graph\n */\n\n\nfunction parseStatement(graph) {\n  // parse subgraph\n  var subgraph = parseSubgraph(graph);\n\n  if (subgraph) {\n    // edge statements\n    parseEdge(graph, subgraph);\n    return;\n  } // parse an attribute statement\n\n\n  var attr = parseAttributeStatement(graph);\n\n  if (attr) {\n    return;\n  } // parse node\n\n\n  if (tokenType != TOKENTYPE.IDENTIFIER) {\n    throw newSyntaxError(\"Identifier expected\");\n  }\n\n  var id = token; // id can be a string or a number\n\n  getToken();\n\n  if (token === \"=\") {\n    // id statement\n    getToken();\n\n    if (tokenType != TOKENTYPE.IDENTIFIER) {\n      throw newSyntaxError(\"Identifier expected\");\n    }\n\n    graph[id] = token;\n    getToken(); // TODO: implement comma separated list with \"a_list: ID=ID [','] [a_list] \"\n  } else {\n    parseNodeStatement(graph, id);\n  }\n}\n/**\n * Parse a subgraph\n *\n * @param {object} graph    parent graph object\n * @returns {object | null} subgraph\n */\n\n\nfunction parseSubgraph(graph) {\n  var subgraph = null; // optional subgraph keyword\n\n  if (token === \"subgraph\") {\n    subgraph = {};\n    subgraph.type = \"subgraph\";\n    getToken(); // optional graph id\n\n    if (tokenType === TOKENTYPE.IDENTIFIER) {\n      subgraph.id = token;\n      getToken();\n    }\n  } // open angle bracket\n\n\n  if (token === \"{\") {\n    getToken();\n\n    if (!subgraph) {\n      subgraph = {};\n    }\n\n    subgraph.parent = graph;\n    subgraph.node = graph.node;\n    subgraph.edge = graph.edge;\n    subgraph.graph = graph.graph; // statements\n\n    parseStatements(subgraph); // close angle bracket\n\n    if (token != \"}\") {\n      throw newSyntaxError(\"Angle bracket } expected\");\n    }\n\n    getToken(); // remove temporary default options\n\n    delete subgraph.node;\n    delete subgraph.edge;\n    delete subgraph.graph;\n    delete subgraph.parent; // register at the parent graph\n\n    if (!graph.subgraphs) {\n      graph.subgraphs = [];\n    }\n\n    graph.subgraphs.push(subgraph);\n  }\n\n  return subgraph;\n}\n/**\n * parse an attribute statement like \"node [shape=circle fontSize=16]\".\n * Available keywords are 'node', 'edge', 'graph'.\n * The previous list with default attributes will be replaced\n *\n * @param {object} graph\n * @returns {string | null} keyword Returns the name of the parsed attribute\n *                                  (node, edge, graph), or null if nothing\n *                                  is parsed.\n */\n\n\nfunction parseAttributeStatement(graph) {\n  // attribute statements\n  if (token === \"node\") {\n    getToken(); // node attributes\n\n    graph.node = parseAttributeList();\n    return \"node\";\n  } else if (token === \"edge\") {\n    getToken(); // edge attributes\n\n    graph.edge = parseAttributeList();\n    return \"edge\";\n  } else if (token === \"graph\") {\n    getToken(); // graph attributes\n\n    graph.graph = parseAttributeList();\n    return \"graph\";\n  }\n\n  return null;\n}\n/**\n * parse a node statement\n *\n * @param {object} graph\n * @param {string | number} id\n */\n\n\nfunction parseNodeStatement(graph, id) {\n  // node statement\n  var node = {\n    id: id\n  };\n  var attr = parseAttributeList();\n\n  if (attr) {\n    node.attr = attr;\n  }\n\n  addNode(graph, node); // edge statements\n\n  parseEdge(graph, id);\n}\n/**\n * Parse an edge or a series of edges\n *\n * @param {object} graph\n * @param {string | number} from        Id of the from node\n */\n\n\nfunction parseEdge(graph, from) {\n  while (token === \"->\" || token === \"--\") {\n    var to;\n    var type = token;\n    getToken();\n    var subgraph = parseSubgraph(graph);\n\n    if (subgraph) {\n      to = subgraph;\n    } else {\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Identifier or subgraph expected\");\n      }\n\n      to = token;\n      addNode(graph, {\n        id: to\n      });\n      getToken();\n    } // parse edge attributes\n\n\n    var attr = parseAttributeList(); // create edge\n\n    var edge = createEdge(graph, from, to, type, attr);\n    addEdge(graph, edge);\n    from = to;\n  }\n}\n/**\n * Parse a set with attributes,\n * for example [label=\"1.000\", shape=solid]\n *\n * @returns {object | null} attr\n */\n\n\nfunction parseAttributeList() {\n  var i;\n  var attr = null; // edge styles of dot and vis\n\n  var edgeStyles = {\n    dashed: true,\n    solid: false,\n    dotted: [1, 5]\n  };\n  /**\n   * Define arrow types.\n   * vis currently supports types defined in 'arrowTypes'.\n   * Details of arrow shapes are described in\n   * http://www.graphviz.org/content/arrow-shapes\n   */\n\n  var arrowTypes = {\n    dot: \"circle\",\n    box: \"box\",\n    crow: \"crow\",\n    curve: \"curve\",\n    icurve: \"inv_curve\",\n    normal: \"triangle\",\n    inv: \"inv_triangle\",\n    diamond: \"diamond\",\n    tee: \"bar\",\n    vee: \"vee\"\n  };\n  /**\n   * 'attr_list' contains attributes for checking if some of them are affected\n   * later. For instance, both of 'arrowhead' and 'dir' (edge style defined\n   * in DOT) make changes to 'arrows' attribute in vis.\n   */\n\n  var attr_list = new Array();\n  var attr_names = new Array(); // used for checking the case.\n  // parse attributes\n\n  while (token === \"[\") {\n    getToken();\n    attr = {};\n\n    while (token !== \"\" && token != \"]\") {\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Attribute name expected\");\n      }\n\n      var name = token;\n      getToken();\n\n      if (token != \"=\") {\n        throw newSyntaxError(\"Equal sign = expected\");\n      }\n\n      getToken();\n\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Attribute value expected\");\n      }\n\n      var value = token; // convert from dot style to vis\n\n      if (name === \"style\") {\n        value = edgeStyles[value];\n      }\n\n      var arrowType;\n\n      if (name === \"arrowhead\") {\n        arrowType = arrowTypes[value];\n        name = \"arrows\";\n        value = {\n          to: {\n            enabled: true,\n            type: arrowType\n          }\n        };\n      }\n\n      if (name === \"arrowtail\") {\n        arrowType = arrowTypes[value];\n        name = \"arrows\";\n        value = {\n          from: {\n            enabled: true,\n            type: arrowType\n          }\n        };\n      }\n\n      attr_list.push({\n        attr: attr,\n        name: name,\n        value: value\n      });\n      attr_names.push(name);\n      getToken();\n\n      if (token == \",\") {\n        getToken();\n      }\n    }\n\n    if (token != \"]\") {\n      throw newSyntaxError(\"Bracket ] expected\");\n    }\n\n    getToken();\n  }\n  /**\n   * As explained in [1], graphviz has limitations for combination of\n   * arrow[head|tail] and dir. If attribute list includes 'dir',\n   * following cases just be supported.\n   *   1. both or none + arrowhead, arrowtail\n   *   2. forward + arrowhead (arrowtail is not affedted)\n   *   3. back + arrowtail (arrowhead is not affected)\n   * [1] https://www.graphviz.org/doc/info/attrs.html#h:undir_note\n   */\n\n\n  if (includes$4(attr_names).call(attr_names, \"dir\")) {\n    var idx = {}; // get index of 'arrows' and 'dir'\n\n    idx.arrows = {};\n\n    for (i = 0; i < attr_list.length; i++) {\n      if (attr_list[i].name === \"arrows\") {\n        if (attr_list[i].value.to != null) {\n          idx.arrows.to = i;\n        } else if (attr_list[i].value.from != null) {\n          idx.arrows.from = i;\n        } else {\n          throw newSyntaxError(\"Invalid value of arrows\");\n        }\n      } else if (attr_list[i].name === \"dir\") {\n        idx.dir = i;\n      }\n    } // first, add default arrow shape if it is not assigned to avoid error\n\n\n    var dir_type = attr_list[idx.dir].value;\n\n    if (!includes$4(attr_names).call(attr_names, \"arrows\")) {\n      if (dir_type === \"both\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            to: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.to = attr_list.length - 1;\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            from: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.from = attr_list.length - 1;\n      } else if (dir_type === \"forward\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            to: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.to = attr_list.length - 1;\n      } else if (dir_type === \"back\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            from: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.from = attr_list.length - 1;\n      } else if (dir_type === \"none\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: \"\"\n        });\n        idx.arrows.to = attr_list.length - 1;\n      } else {\n        throw newSyntaxError('Invalid dir type \"' + dir_type + '\"');\n      }\n    }\n\n    var from_type;\n    var to_type; // update 'arrows' attribute from 'dir'.\n\n    if (dir_type === \"both\") {\n      // both of shapes of 'from' and 'to' are given\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n        splice$2(attr_list).call(attr_list, idx.arrows.from, 1); // shape of 'to' is assigned and use default to 'from'\n      } else if (idx.arrows.to) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"arrow\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        }; // only shape of 'from' is assigned and use default for 'to'\n      } else if (idx.arrows.from) {\n        to_type = \"arrow\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n    } else if (dir_type === \"back\") {\n      // given both of shapes, but use only 'from'\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = \"\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        }; // given shape of 'to', but does not use it\n      } else if (idx.arrows.to) {\n        to_type = \"\";\n        from_type = \"arrow\";\n        idx.arrows.from = idx.arrows.to;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        }; // assign given 'from' shape\n      } else if (idx.arrows.from) {\n        to_type = \"\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n\n      attr_list[idx.arrows.from] = {\n        attr: attr_list[idx.arrows.from].attr,\n        name: attr_list[idx.arrows.from].name,\n        value: {\n          from: {\n            enabled: true,\n            type: attr_list[idx.arrows.from].value.from.type\n          }\n        }\n      };\n    } else if (dir_type === \"none\") {\n      var idx_arrow;\n\n      if (idx.arrows.to) {\n        idx_arrow = idx.arrows.to;\n      } else {\n        idx_arrow = idx.arrows.from;\n      }\n\n      attr_list[idx_arrow] = {\n        attr: attr_list[idx_arrow].attr,\n        name: attr_list[idx_arrow].name,\n        value: \"\"\n      };\n    } else if (dir_type === \"forward\") {\n      // given both of shapes, but use only 'to'\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        }; // assign given 'to' shape\n      } else if (idx.arrows.to) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        }; // given shape of 'from', but does not use it\n      } else if (idx.arrows.from) {\n        to_type = \"arrow\";\n        from_type = \"\";\n        idx.arrows.to = idx.arrows.from;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n\n      attr_list[idx.arrows.to] = {\n        attr: attr_list[idx.arrows.to].attr,\n        name: attr_list[idx.arrows.to].name,\n        value: {\n          to: {\n            enabled: true,\n            type: attr_list[idx.arrows.to].value.to.type\n          }\n        }\n      };\n    } else {\n      throw newSyntaxError('Invalid dir type \"' + dir_type + '\"');\n    } // remove 'dir' attribute no need anymore\n\n\n    splice$2(attr_list).call(attr_list, idx.dir, 1);\n  } // parse 'penwidth'\n\n\n  var nof_attr_list;\n\n  if (includes$4(attr_names).call(attr_names, \"penwidth\")) {\n    var tmp_attr_list = [];\n    nof_attr_list = attr_list.length;\n\n    for (i = 0; i < nof_attr_list; i++) {\n      // exclude 'width' from attr_list if 'penwidth' exists\n      if (attr_list[i].name !== \"width\") {\n        if (attr_list[i].name === \"penwidth\") {\n          attr_list[i].name = \"width\";\n        }\n\n        tmp_attr_list.push(attr_list[i]);\n      }\n    }\n\n    attr_list = tmp_attr_list;\n  }\n\n  nof_attr_list = attr_list.length;\n\n  for (i = 0; i < nof_attr_list; i++) {\n    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);\n  }\n\n  return attr;\n}\n/**\n * Create a syntax error with extra information on current token and index.\n *\n * @param {string} message\n * @returns {SyntaxError} err\n */\n\n\nfunction newSyntaxError(message) {\n  return new SyntaxError(message + ', got \"' + chop(token, 30) + '\" (char ' + index + \")\");\n}\n/**\n * Chop off text after a maximum length\n *\n * @param {string} text\n * @param {number} maxLength\n * @returns {string}\n */\n\n\nfunction chop(text, maxLength) {\n  return text.length <= maxLength ? text : text.substr(0, 27) + \"...\";\n}\n/**\n * Execute a function fn for each pair of elements in two arrays\n *\n * @param {Array | *} array1\n * @param {Array | *} array2\n * @param {Function} fn\n */\n\n\nfunction forEach2(array1, array2, fn) {\n  if (isArray$5(array1)) {\n    forEach$2(array1).call(array1, function (elem1) {\n      if (isArray$5(array2)) {\n        forEach$2(array2).call(array2, function (elem2) {\n          fn(elem1, elem2);\n        });\n      } else {\n        fn(elem1, array2);\n      }\n    });\n  } else {\n    if (isArray$5(array2)) {\n      forEach$2(array2).call(array2, function (elem2) {\n        fn(array1, elem2);\n      });\n    } else {\n      fn(array1, array2);\n    }\n  }\n}\n/**\n * Set a nested property on an object\n * When nested objects are missing, they will be created.\n * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}\n *\n * @param {object} object\n * @param {string} path   A dot separated string like 'font.color'\n * @param {*} value       Value for the property\n * @returns {object} Returns the original object, allows for chaining.\n */\n\n\nfunction setProp(object, path, value) {\n  var names = path.split(\".\");\n  var prop = names.pop(); // traverse over the nested objects\n\n  var obj = object;\n\n  for (var i = 0; i < names.length; i++) {\n    var name = names[i];\n\n    if (!(name in obj)) {\n      obj[name] = {};\n    }\n\n    obj = obj[name];\n  } // set the property value\n\n\n  obj[prop] = value;\n  return object;\n}\n/**\n * Convert an object with DOT attributes to their vis.js equivalents.\n *\n * @param {object} attr     Object with DOT attributes\n * @param {object} mapping\n * @returns {object}         Returns an object with vis.js attributes\n */\n\n\nfunction convertAttr(attr, mapping) {\n  var converted = {};\n\n  for (var prop in attr) {\n    if (attr.hasOwnProperty(prop)) {\n      var visProp = mapping[prop];\n\n      if (isArray$5(visProp)) {\n        forEach$2(visProp).call(visProp, function (visPropI) {\n          setProp(converted, visPropI, attr[prop]);\n        });\n      } else if (typeof visProp === \"string\") {\n        setProp(converted, visProp, attr[prop]);\n      } else {\n        setProp(converted, prop, attr[prop]);\n      }\n    }\n  }\n\n  return converted;\n}\n/**\n * Convert a string containing a graph in DOT language into a map containing\n * with nodes and edges in the format of graph.\n *\n * @param {string} data         Text containing a graph in DOT-notation\n * @returns {object} graphData\n */\n\n\nfunction DOTToGraph(data) {\n  // parse the DOT file\n  var dotData = parseDOT(data);\n  var graphData = {\n    nodes: [],\n    edges: [],\n    options: {}\n  }; // copy the nodes\n\n  if (dotData.nodes) {\n    var _context2;\n\n    forEach$2(_context2 = dotData.nodes).call(_context2, function (dotNode) {\n      var graphNode = {\n        id: dotNode.id,\n        label: String(dotNode.label || dotNode.id)\n      };\n      merge(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));\n\n      if (graphNode.image) {\n        graphNode.shape = \"image\";\n      }\n\n      graphData.nodes.push(graphNode);\n    });\n  } // copy the edges\n\n\n  if (dotData.edges) {\n    var _context3;\n    /**\n     * Convert an edge in DOT format to an edge with VisGraph format\n     *\n     * @param {object} dotEdge\n     * @returns {object} graphEdge\n     */\n\n\n    var convertEdge = function convertEdge(dotEdge) {\n      var graphEdge = {\n        from: dotEdge.from,\n        to: dotEdge.to\n      };\n      merge(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING)); // Add arrows attribute to default styled arrow.\n      // The reason why default style is not added in parseAttributeList() is\n      // because only default is cleared before here.\n\n      if (graphEdge.arrows == null && dotEdge.type === \"->\") {\n        graphEdge.arrows = \"to\";\n      }\n\n      return graphEdge;\n    };\n\n    forEach$2(_context3 = dotData.edges).call(_context3, function (dotEdge) {\n      var from, to;\n\n      if (dotEdge.from instanceof Object) {\n        from = dotEdge.from.nodes;\n      } else {\n        from = {\n          id: dotEdge.from\n        };\n      }\n\n      if (dotEdge.to instanceof Object) {\n        to = dotEdge.to.nodes;\n      } else {\n        to = {\n          id: dotEdge.to\n        };\n      }\n\n      if (dotEdge.from instanceof Object && dotEdge.from.edges) {\n        var _context4;\n\n        forEach$2(_context4 = dotEdge.from.edges).call(_context4, function (subEdge) {\n          var graphEdge = convertEdge(subEdge);\n          graphData.edges.push(graphEdge);\n        });\n      }\n\n      forEach2(from, to, function (from, to) {\n        var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);\n        var graphEdge = convertEdge(subEdge);\n        graphData.edges.push(graphEdge);\n      });\n\n      if (dotEdge.to instanceof Object && dotEdge.to.edges) {\n        var _context5;\n\n        forEach$2(_context5 = dotEdge.to.edges).call(_context5, function (subEdge) {\n          var graphEdge = convertEdge(subEdge);\n          graphData.edges.push(graphEdge);\n        });\n      }\n    });\n  } // copy the options\n\n\n  if (dotData.attr) {\n    graphData.options = dotData.attr;\n  }\n\n  return graphData;\n}\n/* eslint-enable no-var */\n\n/* eslint-enable no-unused-vars */\n\n/* eslint-enable no-prototype-builtins */\n\n\nvar dotparser = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  parseDOT: parseDOT,\n  DOTToGraph: DOTToGraph\n});\n/**\r\n * Convert Gephi to Vis.\r\n *\r\n * @param gephiJSON - The parsed JSON data in Gephi format.\r\n * @param optionsObj - Additional options.\r\n *\r\n * @returns The converted data ready to be used in Vis.\r\n */\n\nfunction parseGephi(gephiJSON, optionsObj) {\n  var _context;\n\n  var options = {\n    edges: {\n      inheritColor: false\n    },\n    nodes: {\n      fixed: false,\n      parseColor: false\n    }\n  };\n\n  if (optionsObj != null) {\n    if (optionsObj.fixed != null) {\n      options.nodes.fixed = optionsObj.fixed;\n    }\n\n    if (optionsObj.parseColor != null) {\n      options.nodes.parseColor = optionsObj.parseColor;\n    }\n\n    if (optionsObj.inheritColor != null) {\n      options.edges.inheritColor = optionsObj.inheritColor;\n    }\n  }\n\n  var gEdges = gephiJSON.edges;\n  var vEdges = map$2(gEdges).call(gEdges, function (gEdge) {\n    var vEdge = {\n      from: gEdge.source,\n      id: gEdge.id,\n      to: gEdge.target\n    };\n\n    if (gEdge.attributes != null) {\n      vEdge.attributes = gEdge.attributes;\n    }\n\n    if (gEdge.label != null) {\n      vEdge.label = gEdge.label;\n    }\n\n    if (gEdge.attributes != null && gEdge.attributes.title != null) {\n      vEdge.title = gEdge.attributes.title;\n    }\n\n    if (gEdge.type === \"Directed\") {\n      vEdge.arrows = \"to\";\n    } // edge['value'] = gEdge.attributes != null ? gEdge.attributes.Weight : undefined;\n    // edge['width'] = edge['value'] != null ? undefined : edgegEdge.size;\n\n\n    if (gEdge.color && options.edges.inheritColor === false) {\n      vEdge.color = gEdge.color;\n    }\n\n    return vEdge;\n  });\n  var vNodes = map$2(_context = gephiJSON.nodes).call(_context, function (gNode) {\n    var vNode = {\n      id: gNode.id,\n      fixed: options.nodes.fixed && gNode.x != null && gNode.y != null\n    };\n\n    if (gNode.attributes != null) {\n      vNode.attributes = gNode.attributes;\n    }\n\n    if (gNode.label != null) {\n      vNode.label = gNode.label;\n    }\n\n    if (gNode.size != null) {\n      vNode.size = gNode.size;\n    }\n\n    if (gNode.attributes != null && gNode.attributes.title != null) {\n      vNode.title = gNode.attributes.title;\n    }\n\n    if (gNode.title != null) {\n      vNode.title = gNode.title;\n    }\n\n    if (gNode.x != null) {\n      vNode.x = gNode.x;\n    }\n\n    if (gNode.y != null) {\n      vNode.y = gNode.y;\n    }\n\n    if (gNode.color != null) {\n      if (options.nodes.parseColor === true) {\n        vNode.color = gNode.color;\n      } else {\n        vNode.color = {\n          background: gNode.color,\n          border: gNode.color,\n          highlight: {\n            background: gNode.color,\n            border: gNode.color\n          },\n          hover: {\n            background: gNode.color,\n            border: gNode.color\n          }\n        };\n      }\n    }\n\n    return vNode;\n  });\n  return {\n    nodes: vNodes,\n    edges: vEdges\n  };\n}\n\nvar gephiParser = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  parseGephi: parseGephi\n});\n/**\r\n * Created by Alex on 11/6/2014.\r\n */\n\nfunction keycharm(options) {\n  var preventDefault = options && options.preventDefault || false;\n  var container = options && options.container || window;\n  var _exportFunctions = {};\n  var _bound = {\n    keydown: {},\n    keyup: {}\n  };\n  var _keys = {};\n  var i; // a - z\n\n  for (i = 97; i <= 122; i++) {\n    _keys[String.fromCharCode(i)] = {\n      code: 65 + (i - 97),\n      shift: false\n    };\n  } // A - Z\n\n\n  for (i = 65; i <= 90; i++) {\n    _keys[String.fromCharCode(i)] = {\n      code: i,\n      shift: true\n    };\n  } // 0 - 9\n\n\n  for (i = 0; i <= 9; i++) {\n    _keys['' + i] = {\n      code: 48 + i,\n      shift: false\n    };\n  } // F1 - F12\n\n\n  for (i = 1; i <= 12; i++) {\n    _keys['F' + i] = {\n      code: 111 + i,\n      shift: false\n    };\n  } // num0 - num9\n\n\n  for (i = 0; i <= 9; i++) {\n    _keys['num' + i] = {\n      code: 96 + i,\n      shift: false\n    };\n  } // numpad misc\n\n\n  _keys['num*'] = {\n    code: 106,\n    shift: false\n  };\n  _keys['num+'] = {\n    code: 107,\n    shift: false\n  };\n  _keys['num-'] = {\n    code: 109,\n    shift: false\n  };\n  _keys['num/'] = {\n    code: 111,\n    shift: false\n  };\n  _keys['num.'] = {\n    code: 110,\n    shift: false\n  }; // arrows\n\n  _keys['left'] = {\n    code: 37,\n    shift: false\n  };\n  _keys['up'] = {\n    code: 38,\n    shift: false\n  };\n  _keys['right'] = {\n    code: 39,\n    shift: false\n  };\n  _keys['down'] = {\n    code: 40,\n    shift: false\n  }; // extra keys\n\n  _keys['space'] = {\n    code: 32,\n    shift: false\n  };\n  _keys['enter'] = {\n    code: 13,\n    shift: false\n  };\n  _keys['shift'] = {\n    code: 16,\n    shift: undefined\n  };\n  _keys['esc'] = {\n    code: 27,\n    shift: false\n  };\n  _keys['backspace'] = {\n    code: 8,\n    shift: false\n  };\n  _keys['tab'] = {\n    code: 9,\n    shift: false\n  };\n  _keys['ctrl'] = {\n    code: 17,\n    shift: false\n  };\n  _keys['alt'] = {\n    code: 18,\n    shift: false\n  };\n  _keys['delete'] = {\n    code: 46,\n    shift: false\n  };\n  _keys['pageup'] = {\n    code: 33,\n    shift: false\n  };\n  _keys['pagedown'] = {\n    code: 34,\n    shift: false\n  }; // symbols\n\n  _keys['='] = {\n    code: 187,\n    shift: false\n  };\n  _keys['-'] = {\n    code: 189,\n    shift: false\n  };\n  _keys[']'] = {\n    code: 221,\n    shift: false\n  };\n  _keys['['] = {\n    code: 219,\n    shift: false\n  };\n\n  var down = function (event) {\n    handleEvent(event, 'keydown');\n  };\n\n  var up = function (event) {\n    handleEvent(event, 'keyup');\n  }; // handle the actualy bound key with the event\n\n\n  var handleEvent = function (event, type) {\n    if (_bound[type][event.keyCode] !== undefined) {\n      var bound = _bound[type][event.keyCode];\n\n      for (var i = 0; i < bound.length; i++) {\n        if (bound[i].shift === undefined) {\n          bound[i].fn(event);\n        } else if (bound[i].shift == true && event.shiftKey == true) {\n          bound[i].fn(event);\n        } else if (bound[i].shift == false && event.shiftKey == false) {\n          bound[i].fn(event);\n        }\n      }\n\n      if (preventDefault == true) {\n        event.preventDefault();\n      }\n    }\n  }; // bind a key to a callback\n\n\n  _exportFunctions.bind = function (key, callback, type) {\n    if (type === undefined) {\n      type = 'keydown';\n    }\n\n    if (_keys[key] === undefined) {\n      throw new Error(\"unsupported key: \" + key);\n    }\n\n    if (_bound[type][_keys[key].code] === undefined) {\n      _bound[type][_keys[key].code] = [];\n    }\n\n    _bound[type][_keys[key].code].push({\n      fn: callback,\n      shift: _keys[key].shift\n    });\n  }; // bind all keys to a call back (demo purposes)\n\n\n  _exportFunctions.bindAll = function (callback, type) {\n    if (type === undefined) {\n      type = 'keydown';\n    }\n\n    for (var key in _keys) {\n      if (_keys.hasOwnProperty(key)) {\n        _exportFunctions.bind(key, callback, type);\n      }\n    }\n  }; // get the key label from an event\n\n\n  _exportFunctions.getKey = function (event) {\n    for (var key in _keys) {\n      if (_keys.hasOwnProperty(key)) {\n        if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {\n          return key;\n        } else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {\n          return key;\n        } else if (event.keyCode == _keys[key].code && key == 'shift') {\n          return key;\n        }\n      }\n    }\n\n    return \"unknown key, currently not supported\";\n  }; // unbind either a specific callback from a key or all of them (by leaving callback undefined)\n\n\n  _exportFunctions.unbind = function (key, callback, type) {\n    if (type === undefined) {\n      type = 'keydown';\n    }\n\n    if (_keys[key] === undefined) {\n      throw new Error(\"unsupported key: \" + key);\n    }\n\n    if (callback !== undefined) {\n      var newBindings = [];\n      var bound = _bound[type][_keys[key].code];\n\n      if (bound !== undefined) {\n        for (var i = 0; i < bound.length; i++) {\n          if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {\n            newBindings.push(_bound[type][_keys[key].code][i]);\n          }\n        }\n      }\n\n      _bound[type][_keys[key].code] = newBindings;\n    } else {\n      _bound[type][_keys[key].code] = [];\n    }\n  }; // reset all bound variables.\n\n\n  _exportFunctions.reset = function () {\n    _bound = {\n      keydown: {},\n      keyup: {}\n    };\n  }; // unbind all listeners and reset all variables.\n\n\n  _exportFunctions.destroy = function () {\n    _bound = {\n      keydown: {},\n      keyup: {}\n    };\n    container.removeEventListener('keydown', down, true);\n    container.removeEventListener('keyup', up, true);\n  }; // create listeners.\n\n\n  container.addEventListener('keydown', down, true);\n  container.addEventListener('keyup', up, true); // return the public functions.\n\n  return _exportFunctions;\n}\n/*! Hammer.JS - v2.0.17-rc - 2019-12-16\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\n\n\nvar assign$3;\n\nif (typeof Object.assign !== 'function') {\n  assign$3 = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n} else {\n  assign$3 = Object.assign;\n}\n\nvar assign$1$1 = assign$3;\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n    abs = Math.abs;\nvar now$3 = Date.now;\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n\n    i++;\n  }\n\n  return undefined;\n}\n/* eslint-disable no-new-func, no-nested-ternary */\n\n\nvar win;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = ('ontouchstart' in win);\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\n\nfunction each(obj, iterator, context) {\n  var i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n\n  return val;\n}\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\n\n\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\n\nvar TouchAction = /*#__PURE__*/function () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n\n  var _proto = TouchAction.prototype;\n\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n\n  return TouchAction;\n}();\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\n\n\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  var x = 0;\n  var y = 0;\n  var i = 0;\n\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now$3(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\n\n\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  var firstInput = session.firstInput,\n      firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now$3();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n\n  input.target = target;\n}\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\n\n\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\n\n\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\n\nvar Input = /*#__PURE__*/function () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n\n  var _proto = Input.prototype;\n\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n\n  return Input;\n}();\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\n\n\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n\n      i++;\n    }\n\n    return -1;\n  }\n}\n\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n};\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\n\nvar PointerEventInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n\n  function PointerEventInput() {\n    var _this;\n\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = PointerEventInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n\n  return PointerEventInput;\n}(Input);\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\n\n\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n\n  function TouchInput() {\n    var _this;\n\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;\n\n    return _this;\n  }\n\n  var _proto = TouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return TouchInput;\n}(Input);\n\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n  i = 0;\n\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\n\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n\n  function MouseInput() {\n    var _this;\n\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = MouseInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n\n  return MouseInput;\n}(Input);\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n      touch = _eventData$changedPoi[0];\n\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar TouchMouseInput = /*#__PURE__*/function () {\n  var TouchMouseInput = /*#__PURE__*/function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n\n      _this = _Input.call(this, _manager, callback) || this;\n\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {\n          return;\n        }\n\n        _this.callback(manager, inputEvent, inputData);\n      };\n\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n\n    var _proto = TouchMouseInput.prototype;\n    /**\n     * @private\n     * remove the event listeners\n     */\n\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n\n    return TouchMouseInput;\n  }(Input);\n\n  return TouchMouseInput;\n}();\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n\n  return new Type(manager, inputHandler);\n}\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n\n  return false;\n}\n\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\n\nvar _uniqueId = 1;\n\nfunction uniqueId() {\n  return _uniqueId++;\n}\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\n\n\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n\n  return otherRecognizer;\n}\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n\n  return '';\n}\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\n\nvar Recognizer = /*#__PURE__*/function () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n\n  var _proto = Recognizer.prototype;\n\n  _proto.set = function set(options) {\n    assign$1$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n\n  _proto.reset = function reset() {};\n\n  return Recognizer;\n}();\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\n\nvar TapRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n\n  function TapRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  var _proto = TapRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return TapRecognizer;\n}(Recognizer);\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\n\nvar AttrRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n\n  var _proto = AttrRecognizer.prototype;\n\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n\n      return state | STATE_CHANGED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  return AttrRecognizer;\n}(Recognizer);\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n\n  return '';\n}\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar PanRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n\n  function PanRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n\n  var _proto = PanRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n\n    return actions;\n  };\n\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PanRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar SwipeRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n\n  var _proto = SwipeRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  };\n\n  return SwipeRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar PinchRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PinchRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\n\nvar RotateRecognizer = /*#__PURE__*/function (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = RotateRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  return RotateRecognizer;\n}(AttrRecognizer);\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\n\nvar PressRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n\n  function PressRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n\n  var _proto = PressRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now$3();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return PressRecognizer;\n}(Recognizer);\n\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\n\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, ['rotate']], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, ['swipe']], [TapRecognizer], [TapRecognizer, {\n  event: 'doubletap',\n  taps: 2\n}, ['tap']], [PressRecognizer]];\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n\n  if (!element.style) {\n    return;\n  }\n\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Manager = /*#__PURE__*/function () {\n  function Manager(element, options) {\n    var _this = this;\n\n    this.options = assign$1$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n\n  var _proto = Manager.prototype;\n\n  _proto.set = function set(options) {\n    assign$1$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    var i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && ( // 1\n      !curRecognizer || recognizer === curRecognizer || // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    var recognizers = this.recognizers;\n\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n\n    var existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    var i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n\n  return Manager;\n}();\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n\n  function SingleTouchInput() {\n    var _this;\n\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n\n  var _proto = SingleTouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return SingleTouchInput;\n}(Input);\n\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\n\n\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n\n    i++;\n  }\n\n  return dest;\n}, 'extend', 'Use `assign`.');\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge$1 = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign$1$1(childP, properties);\n  }\n}\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\n\n\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Hammer = /*#__PURE__*/function () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n\n  Hammer.VERSION = \"2.0.17-rc\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge$1;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = assign$1$1({}, defaults, {\n    preset: preset\n  });\n  return Hammer;\n}(); //  style loader but by script tag, not by the loader.\n\n/**\n * Setup a mock hammer.js object, for unit testing.\n *\n * Inspiration: https://github.com/uber/deck.gl/pull/658\n *\n * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}\n */\n\n\nfunction hammerMock() {\n  var noop = function noop() {};\n\n  return {\n    on: noop,\n    off: noop,\n    destroy: noop,\n    emit: noop,\n    get: function get() {\n      return {\n        set: noop\n      };\n    }\n  };\n}\n\nvar Hammer$1 = typeof window !== \"undefined\" ? window.Hammer || Hammer : function () {\n  // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.\n  return hammerMock();\n};\n/**\n * Turn an element into an clickToUse element.\n * When not active, the element has a transparent overlay. When the overlay is\n * clicked, the mode is changed to active.\n * When active, the element is displayed with a blue border around it, and\n * the interactive contents of the element can be used. When clicked outside\n * the element, the elements mode is changed to inactive.\n *\n * @param {Element} container\n * @class Activator\n */\n\nfunction Activator(container) {\n  var _context,\n      _this = this,\n      _context2;\n\n  this.active = false;\n  this.dom = {\n    container: container\n  };\n  this.dom.overlay = document.createElement(\"div\");\n  this.dom.overlay.className = \"vis-overlay\";\n  this.dom.container.appendChild(this.dom.overlay);\n  this.hammer = Hammer$1(this.dom.overlay);\n  this.hammer.on(\"tap\", bind$2(_context = this._onTapOverlay).call(_context, this)); // block all touch events (except tap)\n\n  var events = [\"tap\", \"doubletap\", \"press\", \"pinch\", \"pan\", \"panstart\", \"panmove\", \"panend\"];\n  forEach$2(events).call(events, function (event) {\n    _this.hammer.on(event, function (event) {\n      event.srcEvent.stopPropagation();\n    });\n  }); // attach a click event to the window, in order to deactivate when clicking outside the timeline\n\n  if (document && document.body) {\n    this.onClick = function (event) {\n      if (!_hasParent(event.target, container)) {\n        _this.deactivate();\n      }\n    };\n\n    document.body.addEventListener(\"click\", this.onClick);\n  }\n\n  if (this.keycharm !== undefined) {\n    this.keycharm.destroy();\n  }\n\n  this.keycharm = keycharm(); // keycharm listener only bounded when active)\n\n  this.escListener = bind$2(_context2 = this.deactivate).call(_context2, this);\n} // turn into an event emitter\n\n\ncomponentEmitter(Activator.prototype); // The currently active activator\n\nActivator.current = null;\n/**\n * Destroy the activator. Cleans up all created DOM and event listeners\n */\n\nActivator.prototype.destroy = function () {\n  this.deactivate(); // remove dom\n\n  this.dom.overlay.parentNode.removeChild(this.dom.overlay); // remove global event listener\n\n  if (this.onClick) {\n    document.body.removeEventListener(\"click\", this.onClick);\n  } // remove keycharm\n\n\n  if (this.keycharm !== undefined) {\n    this.keycharm.destroy();\n  }\n\n  this.keycharm = null; // cleanup hammer instances\n\n  this.hammer.destroy();\n  this.hammer = null; // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)\n};\n/**\n * Activate the element\n * Overlay is hidden, element is decorated with a blue shadow border\n */\n\n\nActivator.prototype.activate = function () {\n  var _context3; // we allow only one active activator at a time\n\n\n  if (Activator.current) {\n    Activator.current.deactivate();\n  }\n\n  Activator.current = this;\n  this.active = true;\n  this.dom.overlay.style.display = \"none\";\n  addClassName(this.dom.container, \"vis-active\");\n  this.emit(\"change\");\n  this.emit(\"activate\"); // ugly hack: bind ESC after emitting the events, as the Network rebinds all\n  // keyboard events on a 'change' event\n\n  bind$2(_context3 = this.keycharm).call(_context3, \"esc\", this.escListener);\n};\n/**\n * Deactivate the element\n * Overlay is displayed on top of the element\n */\n\n\nActivator.prototype.deactivate = function () {\n  this.active = false;\n  this.dom.overlay.style.display = \"block\";\n  removeClassName(this.dom.container, \"vis-active\");\n  this.keycharm.unbind(\"esc\", this.escListener);\n  this.emit(\"change\");\n  this.emit(\"deactivate\");\n};\n/**\n * Handle a tap event: activate the container\n *\n * @param {Event}  event   The event\n * @private\n */\n\n\nActivator.prototype._onTapOverlay = function (event) {\n  // activate the container\n  this.activate();\n  event.srcEvent.stopPropagation();\n};\n/**\n * Test whether the element has the requested parent element somewhere in\n * its chain of parent nodes.\n *\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @returns {boolean} Returns true when the parent is found somewhere in the\n *                    chain of parent nodes.\n * @private\n */\n\n\nfunction _hasParent(element, parent) {\n  while (element) {\n    if (element === parent) {\n      return true;\n    }\n\n    element = element.parentNode;\n  }\n\n  return false;\n} // English\n\n\nvar en = {\n  addDescription: \"Click in an empty space to place a new node.\",\n  addEdge: \"Add Edge\",\n  addNode: \"Add Node\",\n  back: \"Back\",\n  createEdgeError: \"Cannot link edges to a cluster.\",\n  del: \"Delete selected\",\n  deleteClusterError: \"Clusters cannot be deleted.\",\n  edgeDescription: \"Click on a node and drag the edge to another node to connect them.\",\n  edit: \"Edit\",\n  editClusterError: \"Clusters cannot be edited.\",\n  editEdge: \"Edit Edge\",\n  editEdgeDescription: \"Click on the control points and drag them to a node to connect to it.\",\n  editNode: \"Edit Node\"\n}; // German\n\nvar de = {\n  addDescription: \"Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.\",\n  addEdge: \"Kante hinzuf\\xFCgen\",\n  addNode: \"Knoten hinzuf\\xFCgen\",\n  back: \"Zur\\xFCck\",\n  createEdgeError: \"Es ist nicht m\\xF6glich, Kanten mit Clustern zu verbinden.\",\n  del: \"L\\xF6sche Auswahl\",\n  deleteClusterError: \"Cluster k\\xF6nnen nicht gel\\xF6scht werden.\",\n  edgeDescription: \"Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.\",\n  edit: \"Editieren\",\n  editClusterError: \"Cluster k\\xF6nnen nicht editiert werden.\",\n  editEdge: \"Kante editieren\",\n  editEdgeDescription: \"Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.\",\n  editNode: \"Knoten editieren\"\n}; // Spanish\n\nvar es = {\n  addDescription: \"Haga clic en un lugar vac\\xEDo para colocar un nuevo nodo.\",\n  addEdge: \"A\\xF1adir arista\",\n  addNode: \"A\\xF1adir nodo\",\n  back: \"Atr\\xE1s\",\n  createEdgeError: \"No se puede conectar una arista a un grupo.\",\n  del: \"Eliminar selecci\\xF3n\",\n  deleteClusterError: \"No es posible eliminar grupos.\",\n  edgeDescription: \"Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.\",\n  edit: \"Editar\",\n  editClusterError: \"No es posible editar grupos.\",\n  editEdge: \"Editar arista\",\n  editEdgeDescription: \"Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.\",\n  editNode: \"Editar nodo\"\n}; //Italiano\n\nvar it = {\n  addDescription: \"Clicca per aggiungere un nuovo nodo\",\n  addEdge: \"Aggiungi un vertice\",\n  addNode: \"Aggiungi un nodo\",\n  back: \"Indietro\",\n  createEdgeError: \"Non si possono collegare vertici ad un cluster\",\n  del: \"Cancella la selezione\",\n  deleteClusterError: \"I cluster non possono essere cancellati\",\n  edgeDescription: \"Clicca su un nodo e trascinalo ad un altro nodo per connetterli.\",\n  edit: \"Modifica\",\n  editClusterError: \"I clusters non possono essere modificati.\",\n  editEdge: \"Modifica il vertice\",\n  editEdgeDescription: \"Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.\",\n  editNode: \"Modifica il nodo\"\n}; // Dutch\n\nvar nl = {\n  addDescription: \"Klik op een leeg gebied om een nieuwe node te maken.\",\n  addEdge: \"Link toevoegen\",\n  addNode: \"Node toevoegen\",\n  back: \"Terug\",\n  createEdgeError: \"Kan geen link maken naar een cluster.\",\n  del: \"Selectie verwijderen\",\n  deleteClusterError: \"Clusters kunnen niet worden verwijderd.\",\n  edgeDescription: \"Klik op een node en sleep de link naar een andere node om ze te verbinden.\",\n  edit: \"Wijzigen\",\n  editClusterError: \"Clusters kunnen niet worden aangepast.\",\n  editEdge: \"Link wijzigen\",\n  editEdgeDescription: \"Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.\",\n  editNode: \"Node wijzigen\"\n}; // Portuguese Brazil\n\nvar pt = {\n  addDescription: \"Clique em um espaço em branco para adicionar um novo nó\",\n  addEdge: \"Adicionar aresta\",\n  addNode: \"Adicionar nó\",\n  back: \"Voltar\",\n  createEdgeError: \"Não foi possível linkar arestas a um cluster.\",\n  del: \"Remover selecionado\",\n  deleteClusterError: \"Clusters não puderam ser removidos.\",\n  edgeDescription: \"Clique em um nó e arraste a aresta até outro nó para conectá-los\",\n  edit: \"Editar\",\n  editClusterError: \"Clusters não puderam ser editados.\",\n  editEdge: \"Editar aresta\",\n  editEdgeDescription: \"Clique nos pontos de controle e os arraste para um nó para conectá-los\",\n  editNode: \"Editar nó\"\n}; // Russian\n\nvar ru = {\n  addDescription: \"Кликните в свободное место, чтобы добавить новый узел.\",\n  addEdge: \"Добавить ребро\",\n  addNode: \"Добавить узел\",\n  back: \"Назад\",\n  createEdgeError: \"Невозможно соединить ребра в кластер.\",\n  del: \"Удалить выбранное\",\n  deleteClusterError: \"Кластеры не могут быть удалены\",\n  edgeDescription: \"Кликните на узел и протяните ребро к другому узлу, чтобы соединить их.\",\n  edit: \"Редактировать\",\n  editClusterError: \"Кластеры недоступны для редактирования.\",\n  editEdge: \"Редактировать ребро\",\n  editEdgeDescription: \"Кликните на контрольные точки и перетащите их в узел, чтобы подключиться к нему.\",\n  editNode: \"Редактировать узел\"\n}; // Chinese\n\nvar cn = {\n  addDescription: \"单击空白处放置新节点。\",\n  addEdge: \"添加连接线\",\n  addNode: \"添加节点\",\n  back: \"返回\",\n  createEdgeError: \"无法将连接线连接到群集。\",\n  del: \"删除选定\",\n  deleteClusterError: \"无法删除群集。\",\n  edgeDescription: \"单击某个节点并将该连接线拖动到另一个节点以连接它们。\",\n  edit: \"编辑\",\n  editClusterError: \"无法编辑群集。\",\n  editEdge: \"编辑连接线\",\n  editEdgeDescription: \"单击控制节点并将它们拖到节点上连接。\",\n  editNode: \"编辑节点\"\n}; // Ukrainian\n\nvar uk = {\n  addDescription: \"Kлікніть на вільне місце, щоб додати новий вузол.\",\n  addEdge: \"Додати край\",\n  addNode: \"Додати вузол\",\n  back: \"Назад\",\n  createEdgeError: \"Не можливо об'єднати краї в групу.\",\n  del: \"Видалити обране\",\n  deleteClusterError: \"Групи не можуть бути видалені.\",\n  edgeDescription: \"Клікніть на вузол і перетягніть край до іншого вузла, щоб їх з'єднати.\",\n  edit: \"Редагувати\",\n  editClusterError: \"Групи недоступні для редагування.\",\n  editEdge: \"Редагувати край\",\n  editEdgeDescription: \"Клікніть на контрольні точки і перетягніть їх у вузол, щоб підключитися до нього.\",\n  editNode: \"Редагувати вузол\"\n}; // French\n\nvar fr = {\n  addDescription: \"Cliquez dans un endroit vide pour placer un nœud.\",\n  addEdge: \"Ajouter un lien\",\n  addNode: \"Ajouter un nœud\",\n  back: \"Retour\",\n  createEdgeError: \"Impossible de créer un lien vers un cluster.\",\n  del: \"Effacer la sélection\",\n  deleteClusterError: \"Les clusters ne peuvent pas être effacés.\",\n  edgeDescription: \"Cliquez sur un nœud et glissez le lien vers un autre nœud pour les connecter.\",\n  edit: \"Éditer\",\n  editClusterError: \"Les clusters ne peuvent pas être édités.\",\n  editEdge: \"Éditer le lien\",\n  editEdgeDescription: \"Cliquez sur les points de contrôle et glissez-les pour connecter un nœud.\",\n  editNode: \"Éditer le nœud\"\n}; // Czech\n\nvar cs = {\n  addDescription: \"Kluknutím do prázdného prostoru můžete přidat nový vrchol.\",\n  addEdge: \"Přidat hranu\",\n  addNode: \"Přidat vrchol\",\n  back: \"Zpět\",\n  createEdgeError: \"Nelze připojit hranu ke shluku.\",\n  del: \"Smazat výběr\",\n  deleteClusterError: \"Nelze mazat shluky.\",\n  edgeDescription: \"Přetažením z jednoho vrcholu do druhého můžete spojit tyto vrcholy novou hranou.\",\n  edit: \"Upravit\",\n  editClusterError: \"Nelze upravovat shluky.\",\n  editEdge: \"Upravit hranu\",\n  editEdgeDescription: \"Přetažením kontrolního vrcholu hrany ji můžete připojit k jinému vrcholu.\",\n  editNode: \"Upravit vrchol\"\n};\nvar locales = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  en: en,\n  de: de,\n  es: es,\n  it: it,\n  nl: nl,\n  pt: pt,\n  ru: ru,\n  cn: cn,\n  uk: uk,\n  fr: fr,\n  cs: cs\n});\n/**\r\n * Normalizes language code into the format used internally.\r\n *\r\n * @param locales - All the available locales.\r\n * @param rawCode - The original code as supplied by the user.\r\n *\r\n * @returns Language code in the format language-COUNTRY or language, eventually\r\n * fallbacks to en.\r\n */\n\nfunction normalizeLanguageCode(locales, rawCode) {\n  try {\n    var _rawCode$split = rawCode.split(/[-_ /]/, 2),\n        _rawCode$split2 = slicedToArray(_rawCode$split, 2),\n        rawLanguage = _rawCode$split2[0],\n        rawCountry = _rawCode$split2[1];\n\n    var language = rawLanguage != null ? rawLanguage.toLowerCase() : null;\n    var country = rawCountry != null ? rawCountry.toUpperCase() : null;\n\n    if (language && country) {\n      var code = language + \"-\" + country;\n\n      if (Object.prototype.hasOwnProperty.call(locales, code)) {\n        return code;\n      } else {\n        var _context;\n\n        console.warn(concat$2(_context = \"Unknown variant \".concat(country, \" of language \")).call(_context, language, \".\"));\n      }\n    }\n\n    if (language) {\n      var _code = language;\n\n      if (Object.prototype.hasOwnProperty.call(locales, _code)) {\n        return _code;\n      } else {\n        console.warn(\"Unknown language \".concat(language));\n      }\n    }\n\n    console.warn(\"Unknown locale \".concat(rawCode, \", falling back to English.\"));\n    return \"en\";\n  } catch (error) {\n    console.error(error);\n    console.warn(\"Unexpected error while normalizing locale \".concat(rawCode, \", falling back to English.\"));\n    return \"en\";\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar classCallCheck = _classCallCheck;\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    defineProperty$6(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar createClass = _createClass;\n/**\n * Associates a canvas to a given image, containing a number of renderings\n * of the image at various sizes.\n *\n * This technique is known as 'mipmapping'.\n *\n * NOTE: Images can also be of type 'data:svg+xml`. This code also works\n *       for svg, but the mipmapping may not be necessary.\n *\n * @param {Image} image\n */\n\nvar CachedImage = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function CachedImage() {\n    classCallCheck(this, CachedImage);\n    this.NUM_ITERATIONS = 4; // Number of items in the coordinates array\n\n    this.image = new Image();\n    this.canvas = document.createElement(\"canvas\");\n  }\n  /**\n   * Called when the image has been successfully loaded.\n   */\n\n\n  createClass(CachedImage, [{\n    key: \"init\",\n    value: function init() {\n      if (this.initialized()) return;\n      this.src = this.image.src; // For same interface with Image\n\n      var w = this.image.width;\n      var h = this.image.height; // Ease external access\n\n      this.width = w;\n      this.height = h;\n      var h2 = Math.floor(h / 2);\n      var h4 = Math.floor(h / 4);\n      var h8 = Math.floor(h / 8);\n      var h16 = Math.floor(h / 16);\n      var w2 = Math.floor(w / 2);\n      var w4 = Math.floor(w / 4);\n      var w8 = Math.floor(w / 8);\n      var w16 = Math.floor(w / 16); // Make canvas as small as possible\n\n      this.canvas.width = 3 * w4;\n      this.canvas.height = h2; // Coordinates and sizes of images contained in the canvas\n      // Values per row:  [top x, left y, width, height]\n\n      this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];\n\n      this._fillMipMap();\n    }\n    /**\n     * @returns {boolean} true if init() has been called, false otherwise.\n     */\n\n  }, {\n    key: \"initialized\",\n    value: function initialized() {\n      return this.coordinates !== undefined;\n    }\n    /**\n     * Redraw main image in various sizes to the context.\n     *\n     * The rationale behind this is to reduce artefacts due to interpolation\n     * at differing zoom levels.\n     *\n     * Source: http://stackoverflow.com/q/18761404/1223531\n     *\n     * This methods takes the resizing out of the drawing loop, in order to\n     * reduce performance overhead.\n     *\n     * TODO: The code assumes that a 2D context can always be gotten. This is\n     *       not necessarily true! OTOH, if not true then usage of this class\n     *       is senseless.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_fillMipMap\",\n    value: function _fillMipMap() {\n      var ctx = this.canvas.getContext(\"2d\"); // First zoom-level comes from the image\n\n      var to = this.coordinates[0];\n      ctx.drawImage(this.image, to[0], to[1], to[2], to[3]); // The rest are copy actions internal to the canvas/context\n\n      for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {\n        var from = this.coordinates[iterations - 1];\n        var _to = this.coordinates[iterations];\n        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], _to[0], _to[1], _to[2], _to[3]);\n      }\n    }\n    /**\n     * Draw the image, using the mipmap if necessary.\n     *\n     * MipMap is only used if param factor > 2; otherwise, original bitmap\n     * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1\n     *\n     * Credits to 'Alex de Mulder' for original implementation.\n     *\n     * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image\n     * @param {Float} factor scale factor at which to draw\n     * @param {number} left\n     * @param {number} top\n     * @param {number} width\n     * @param {number} height\n     */\n\n  }, {\n    key: \"drawImageAtPosition\",\n    value: function drawImageAtPosition(ctx, factor, left, top, width, height) {\n      if (!this.initialized()) return; //can't draw image yet not intialized\n\n      if (factor > 2) {\n        // Determine which zoomed image to use\n        factor *= 0.5;\n        var iterations = 0;\n\n        while (factor > 2 && iterations < this.NUM_ITERATIONS) {\n          factor *= 0.5;\n          iterations += 1;\n        }\n\n        if (iterations >= this.NUM_ITERATIONS) {\n          iterations = this.NUM_ITERATIONS - 1;\n        } //console.log(\"iterations: \" + iterations);\n\n\n        var from = this.coordinates[iterations];\n        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], left, top, width, height);\n      } else {\n        // Draw image directly\n        ctx.drawImage(this.image, left, top, width, height);\n      }\n    }\n  }]);\n  return CachedImage;\n}();\n/**\n * This callback is a callback that accepts an Image.\n *\n * @callback ImageCallback\n * @param {Image} image\n */\n\n/**\n * This class loads images and keeps them stored.\n *\n * @param {ImageCallback} callback\n */\n\n\nvar Images = /*#__PURE__*/function () {\n  /**\n   * @param {ImageCallback} callback\n   */\n  function Images(callback) {\n    classCallCheck(this, Images);\n    this.images = {};\n    this.imageBroken = {};\n    this.callback = callback;\n  }\n  /**\n   * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image\n   * @param {string} brokenUrl                Url the broken image to try and load\n   * @param {Image} imageToLoadBrokenUrlOn   The image object\n   */\n\n\n  createClass(Images, [{\n    key: \"_tryloadBrokenUrl\",\n    value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {\n      //If these parameters aren't specified then exit the function because nothing constructive can be done\n      if (url === undefined || imageToLoadBrokenUrlOn === undefined) return;\n\n      if (brokenUrl === undefined) {\n        console.warn(\"No broken url image defined\");\n        return;\n      } //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl\n\n\n      imageToLoadBrokenUrlOn.image.onerror = function () {\n        console.error(\"Could not load brokenImage:\", brokenUrl); // cache item will contain empty image, this should be OK for default\n      }; //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image\n\n\n      imageToLoadBrokenUrlOn.image.src = brokenUrl;\n    }\n    /**\n     *\n     * @param {vis.Image} imageToRedrawWith\n     * @private\n     */\n\n  }, {\n    key: \"_redrawWithImage\",\n    value: function _redrawWithImage(imageToRedrawWith) {\n      if (this.callback) {\n        this.callback(imageToRedrawWith);\n      }\n    }\n    /**\n     * @param {string} url          Url of the image\n     * @param {string} brokenUrl    Url of an image to use if the url image is not found\n     * @returns {Image} img          The image object\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(url, brokenUrl) {\n      var _this = this; //Try and get the image from the cache, if successful then return the cached image\n\n\n      var cachedImage = this.images[url];\n      if (cachedImage) return cachedImage; //Create a new image\n\n      var img = new CachedImage(); // Need to add to cache here, otherwise final return will spawn different copies of the same image,\n      // Also, there will be multiple loads of the same image.\n\n      this.images[url] = img; //Subscribe to the event that is raised if the image loads successfully\n\n      img.image.onload = function () {\n        // Properly init the cached item and then request a redraw\n        _this._fixImageCoordinates(img.image);\n\n        img.init();\n\n        _this._redrawWithImage(img);\n      }; //Subscribe to the event that is raised if the image fails to load\n\n\n      img.image.onerror = function () {\n        console.error(\"Could not load image:\", url); //Try and load the image specified by the brokenUrl using\n\n        _this._tryloadBrokenUrl(url, brokenUrl, img);\n      }; //Set the source of the image to the url, this is what actually kicks off the loading of the image\n\n\n      img.image.src = url; //Return the new image\n\n      return img;\n    }\n    /**\n     * IE11 fix -- thanks dponch!\n     *\n     * Local helper function\n     *\n     * @param {vis.Image} imageToCache\n     * @private\n     */\n\n  }, {\n    key: \"_fixImageCoordinates\",\n    value: function _fixImageCoordinates(imageToCache) {\n      if (imageToCache.width === 0) {\n        document.body.appendChild(imageToCache);\n        imageToCache.width = imageToCache.offsetWidth;\n        imageToCache.height = imageToCache.offsetHeight;\n        document.body.removeChild(imageToCache);\n      }\n    }\n  }]);\n  return Images;\n}();\n\nvar freezing = !fails(function () {\n  return Object.isExtensible(Object.preventExtensions({}));\n});\nvar internalMetadata = createCommonjsModule(function (module) {\n  var defineProperty = objectDefineProperty.f;\n  var METADATA = uid('meta');\n  var id = 0;\n\n  var isExtensible = Object.isExtensible || function () {\n    return true;\n  };\n\n  var setMetadata = function (it) {\n    defineProperty(it, METADATA, {\n      value: {\n        objectID: 'O' + ++id,\n        // object ID\n        weakData: {} // weak collections IDs\n\n      }\n    });\n  };\n\n  var fastKey = function (it, create) {\n    // return a primitive with prefix\n    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\n    if (!has(it, METADATA)) {\n      // can't set metadata to uncaught frozen object\n      if (!isExtensible(it)) return 'F'; // not necessary to add metadata\n\n      if (!create) return 'E'; // add missing metadata\n\n      setMetadata(it); // return object ID\n    }\n\n    return it[METADATA].objectID;\n  };\n\n  var getWeakData = function (it, create) {\n    if (!has(it, METADATA)) {\n      // can't set metadata to uncaught frozen object\n      if (!isExtensible(it)) return true; // not necessary to add metadata\n\n      if (!create) return false; // add missing metadata\n\n      setMetadata(it); // return the store of weak collections IDs\n    }\n\n    return it[METADATA].weakData;\n  }; // add metadata on freeze-family methods calling\n\n\n  var onFreeze = function (it) {\n    if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);\n    return it;\n  };\n\n  var meta = module.exports = {\n    REQUIRED: false,\n    fastKey: fastKey,\n    getWeakData: getWeakData,\n    onFreeze: onFreeze\n  };\n  hiddenKeys[METADATA] = true;\n});\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar iterate = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = functionBindContext(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    }\n\n    return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators\n\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = toLength(iterable.length); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && result instanceof Result) return result;\n      }\n\n      return new Result(false);\n    }\n\n    iterator = iterFn.call(iterable);\n  }\n\n  next = iterator.next;\n\n  while (!(step = next.call(iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator);\n      throw error;\n    }\n\n    if (typeof result == 'object' && result && result instanceof Result) return result;\n  }\n\n  return new Result(false);\n};\n\nvar anInstance = function (it, Constructor, name) {\n  if (!(it instanceof Constructor)) {\n    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\n  }\n\n  return it;\n};\n\nvar defineProperty$9 = objectDefineProperty.f;\nvar forEach$4 = arrayIteration.forEach;\nvar setInternalState$3 = internalState.set;\nvar internalStateGetterFor = internalState.getterFor;\n\nvar collection = function (CONSTRUCTOR_NAME, wrapper, common) {\n  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;\n  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var NativeConstructor = global_1[CONSTRUCTOR_NAME];\n  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n  var exported = {};\n  var Constructor;\n\n  if (!descriptors || typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n    new NativeConstructor().entries().next();\n  }))) {\n    // create collection constructor\n    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n    internalMetadata.REQUIRED = true;\n  } else {\n    Constructor = wrapper(function (target, iterable) {\n      setInternalState$3(anInstance(target, Constructor, CONSTRUCTOR_NAME), {\n        type: CONSTRUCTOR_NAME,\n        collection: new NativeConstructor()\n      });\n      if (iterable != undefined) iterate(iterable, target[ADDER], {\n        that: target,\n        AS_ENTRIES: IS_MAP\n      });\n    });\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n    forEach$4(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {\n      var IS_ADDER = KEY == 'add' || KEY == 'set';\n\n      if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {\n        createNonEnumerableProperty(Constructor.prototype, KEY, function (a, b) {\n          var collection = getInternalState(this).collection;\n          if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;\n          var result = collection[KEY](a === 0 ? 0 : a, b);\n          return IS_ADDER ? this : result;\n        });\n      }\n    });\n    IS_WEAK || defineProperty$9(Constructor.prototype, 'size', {\n      configurable: true,\n      get: function () {\n        return getInternalState(this).collection.size;\n      }\n    });\n  }\n\n  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);\n  exported[CONSTRUCTOR_NAME] = Constructor;\n\n  _export({\n    global: true,\n    forced: true\n  }, exported);\n\n  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n  return Constructor;\n};\n\nvar redefineAll = function (target, src, options) {\n  for (var key in src) {\n    if (options && options.unsafe && target[key]) target[key] = src[key];else redefine(target, key, src[key], options);\n  }\n\n  return target;\n};\n\nvar SPECIES$3 = wellKnownSymbol('species');\n\nvar setSpecies = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n  var defineProperty = objectDefineProperty.f;\n\n  if (descriptors && Constructor && !Constructor[SPECIES$3]) {\n    defineProperty(Constructor, SPECIES$3, {\n      configurable: true,\n      get: function () {\n        return this;\n      }\n    });\n  }\n};\n\nvar defineProperty$a = objectDefineProperty.f;\nvar fastKey = internalMetadata.fastKey;\nvar setInternalState$4 = internalState.set;\nvar internalStateGetterFor$1 = internalState.getterFor;\nvar collectionStrong = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, CONSTRUCTOR_NAME);\n      setInternalState$4(that, {\n        type: CONSTRUCTOR_NAME,\n        index: objectCreate(null),\n        first: undefined,\n        last: undefined,\n        size: 0\n      });\n      if (!descriptors) that.size = 0;\n      if (iterable != undefined) iterate(iterable, that[ADDER], {\n        that: that,\n        AS_ENTRIES: IS_MAP\n      });\n    });\n    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var entry = getEntry(that, key);\n      var previous, index; // change existing entry\n\n      if (entry) {\n        entry.value = value; // create new entry\n      } else {\n        state.last = entry = {\n          index: index = fastKey(key, true),\n          key: key,\n          value: value,\n          previous: previous = state.last,\n          next: undefined,\n          removed: false\n        };\n        if (!state.first) state.first = entry;\n        if (previous) previous.next = entry;\n        if (descriptors) state.size++;else that.size++; // add to index\n\n        if (index !== 'F') state.index[index] = entry;\n      }\n\n      return that;\n    };\n\n    var getEntry = function (that, key) {\n      var state = getInternalState(that); // fast case\n\n      var index = fastKey(key);\n      var entry;\n      if (index !== 'F') return state.index[index]; // frozen object case\n\n      for (entry = state.first; entry; entry = entry.next) {\n        if (entry.key == key) return entry;\n      }\n    };\n\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        var that = this;\n        var state = getInternalState(that);\n        var data = state.index;\n        var entry = state.first;\n\n        while (entry) {\n          entry.removed = true;\n          if (entry.previous) entry.previous = entry.previous.next = undefined;\n          delete data[entry.index];\n          entry = entry.next;\n        }\n\n        state.first = state.last = undefined;\n        if (descriptors) state.size = 0;else that.size = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = this;\n        var state = getInternalState(that);\n        var entry = getEntry(that, key);\n\n        if (entry) {\n          var next = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev) prev.next = next;\n          if (next) next.previous = prev;\n          if (state.first == entry) state.first = next;\n          if (state.last == entry) state.last = prev;\n          if (descriptors) state.size--;else that.size--;\n        }\n\n        return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn\n      /* , that = undefined */\n      ) {\n        var state = getInternalState(this);\n        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n\n        while (entry = entry ? entry.next : state.first) {\n          boundFunction(entry.value, entry.key, this); // revert to the last existing entry\n\n          while (entry && entry.removed) entry = entry.previous;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(this, key);\n      }\n    });\n    redefineAll(C.prototype, IS_MAP ? {\n      // 23.1.3.6 Map.prototype.get(key)\n      get: function get(key) {\n        var entry = getEntry(this, key);\n        return entry && entry.value;\n      },\n      // 23.1.3.9 Map.prototype.set(key, value)\n      set: function set(key, value) {\n        return define(this, key === 0 ? 0 : key, value);\n      }\n    } : {\n      // 23.2.3.1 Set.prototype.add(value)\n      add: function add(value) {\n        return define(this, value = value === 0 ? 0 : value, value);\n      }\n    });\n    if (descriptors) defineProperty$a(C.prototype, 'size', {\n      get: function () {\n        return getInternalState(this).size;\n      }\n    });\n    return C;\n  },\n  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {\n    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';\n    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);\n    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME); // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n\n    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {\n      setInternalState$4(this, {\n        type: ITERATOR_NAME,\n        target: iterated,\n        state: getInternalCollectionState(iterated),\n        kind: kind,\n        last: undefined\n      });\n    }, function () {\n      var state = getInternalIteratorState(this);\n      var kind = state.kind;\n      var entry = state.last; // revert to the last existing entry\n\n      while (entry && entry.removed) entry = entry.previous; // get next entry\n\n\n      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n        // or finish the iteration\n        state.target = undefined;\n        return {\n          value: undefined,\n          done: true\n        };\n      } // return step by kind\n\n\n      if (kind == 'keys') return {\n        value: entry.key,\n        done: false\n      };\n      if (kind == 'values') return {\n        value: entry.value,\n        done: false\n      };\n      return {\n        value: [entry.key, entry.value],\n        done: false\n      };\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2\n\n    setSpecies(CONSTRUCTOR_NAME);\n  }\n}; // https://tc39.github.io/ecma262/#sec-map-objects\n\nvar es_map = collection('Map', function (init) {\n  return function Map() {\n    return init(this, arguments.length ? arguments[0] : undefined);\n  };\n}, collectionStrong);\nvar map$3 = path.Map;\nvar map$4 = map$3;\nvar map$5 = map$4;\n/**\n * This class can store groups and options specific for groups.\n */\n\nvar Groups = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function Groups() {\n    classCallCheck(this, Groups);\n    this.clear();\n    this._defaultIndex = 0;\n    this._groupIndex = 0;\n    this._defaultGroups = [{\n      border: \"#2B7CE9\",\n      background: \"#97C2FC\",\n      highlight: {\n        border: \"#2B7CE9\",\n        background: \"#D2E5FF\"\n      },\n      hover: {\n        border: \"#2B7CE9\",\n        background: \"#D2E5FF\"\n      }\n    }, // 0: blue\n    {\n      border: \"#FFA500\",\n      background: \"#FFFF00\",\n      highlight: {\n        border: \"#FFA500\",\n        background: \"#FFFFA3\"\n      },\n      hover: {\n        border: \"#FFA500\",\n        background: \"#FFFFA3\"\n      }\n    }, // 1: yellow\n    {\n      border: \"#FA0A10\",\n      background: \"#FB7E81\",\n      highlight: {\n        border: \"#FA0A10\",\n        background: \"#FFAFB1\"\n      },\n      hover: {\n        border: \"#FA0A10\",\n        background: \"#FFAFB1\"\n      }\n    }, // 2: red\n    {\n      border: \"#41A906\",\n      background: \"#7BE141\",\n      highlight: {\n        border: \"#41A906\",\n        background: \"#A1EC76\"\n      },\n      hover: {\n        border: \"#41A906\",\n        background: \"#A1EC76\"\n      }\n    }, // 3: green\n    {\n      border: \"#E129F0\",\n      background: \"#EB7DF4\",\n      highlight: {\n        border: \"#E129F0\",\n        background: \"#F0B3F5\"\n      },\n      hover: {\n        border: \"#E129F0\",\n        background: \"#F0B3F5\"\n      }\n    }, // 4: magenta\n    {\n      border: \"#7C29F0\",\n      background: \"#AD85E4\",\n      highlight: {\n        border: \"#7C29F0\",\n        background: \"#D3BDF0\"\n      },\n      hover: {\n        border: \"#7C29F0\",\n        background: \"#D3BDF0\"\n      }\n    }, // 5: purple\n    {\n      border: \"#C37F00\",\n      background: \"#FFA807\",\n      highlight: {\n        border: \"#C37F00\",\n        background: \"#FFCA66\"\n      },\n      hover: {\n        border: \"#C37F00\",\n        background: \"#FFCA66\"\n      }\n    }, // 6: orange\n    {\n      border: \"#4220FB\",\n      background: \"#6E6EFD\",\n      highlight: {\n        border: \"#4220FB\",\n        background: \"#9B9BFD\"\n      },\n      hover: {\n        border: \"#4220FB\",\n        background: \"#9B9BFD\"\n      }\n    }, // 7: darkblue\n    {\n      border: \"#FD5A77\",\n      background: \"#FFC0CB\",\n      highlight: {\n        border: \"#FD5A77\",\n        background: \"#FFD1D9\"\n      },\n      hover: {\n        border: \"#FD5A77\",\n        background: \"#FFD1D9\"\n      }\n    }, // 8: pink\n    {\n      border: \"#4AD63A\",\n      background: \"#C2FABC\",\n      highlight: {\n        border: \"#4AD63A\",\n        background: \"#E6FFE3\"\n      },\n      hover: {\n        border: \"#4AD63A\",\n        background: \"#E6FFE3\"\n      }\n    }, // 9: mint\n    {\n      border: \"#990000\",\n      background: \"#EE0000\",\n      highlight: {\n        border: \"#BB0000\",\n        background: \"#FF3333\"\n      },\n      hover: {\n        border: \"#BB0000\",\n        background: \"#FF3333\"\n      }\n    }, // 10:bright red\n    {\n      border: \"#FF6000\",\n      background: \"#FF6000\",\n      highlight: {\n        border: \"#FF6000\",\n        background: \"#FF6000\"\n      },\n      hover: {\n        border: \"#FF6000\",\n        background: \"#FF6000\"\n      }\n    }, // 12: real orange\n    {\n      border: \"#97C2FC\",\n      background: \"#2B7CE9\",\n      highlight: {\n        border: \"#D2E5FF\",\n        background: \"#2B7CE9\"\n      },\n      hover: {\n        border: \"#D2E5FF\",\n        background: \"#2B7CE9\"\n      }\n    }, // 13: blue\n    {\n      border: \"#399605\",\n      background: \"#255C03\",\n      highlight: {\n        border: \"#399605\",\n        background: \"#255C03\"\n      },\n      hover: {\n        border: \"#399605\",\n        background: \"#255C03\"\n      }\n    }, // 14: green\n    {\n      border: \"#B70054\",\n      background: \"#FF007E\",\n      highlight: {\n        border: \"#B70054\",\n        background: \"#FF007E\"\n      },\n      hover: {\n        border: \"#B70054\",\n        background: \"#FF007E\"\n      }\n    }, // 15: magenta\n    {\n      border: \"#AD85E4\",\n      background: \"#7C29F0\",\n      highlight: {\n        border: \"#D3BDF0\",\n        background: \"#7C29F0\"\n      },\n      hover: {\n        border: \"#D3BDF0\",\n        background: \"#7C29F0\"\n      }\n    }, // 16: purple\n    {\n      border: \"#4557FA\",\n      background: \"#000EA1\",\n      highlight: {\n        border: \"#6E6EFD\",\n        background: \"#000EA1\"\n      },\n      hover: {\n        border: \"#6E6EFD\",\n        background: \"#000EA1\"\n      }\n    }, // 17: darkblue\n    {\n      border: \"#FFC0CB\",\n      background: \"#FD5A77\",\n      highlight: {\n        border: \"#FFD1D9\",\n        background: \"#FD5A77\"\n      },\n      hover: {\n        border: \"#FFD1D9\",\n        background: \"#FD5A77\"\n      }\n    }, // 18: pink\n    {\n      border: \"#C2FABC\",\n      background: \"#74D66A\",\n      highlight: {\n        border: \"#E6FFE3\",\n        background: \"#74D66A\"\n      },\n      hover: {\n        border: \"#E6FFE3\",\n        background: \"#74D66A\"\n      }\n    }, // 19: mint\n    {\n      border: \"#EE0000\",\n      background: \"#990000\",\n      highlight: {\n        border: \"#FF3333\",\n        background: \"#BB0000\"\n      },\n      hover: {\n        border: \"#FF3333\",\n        background: \"#BB0000\"\n      }\n    } // 20:bright red\n    ];\n    this.options = {};\n    this.defaultOptions = {\n      useDefaultGroups: true\n    };\n    assign$2(this.options, this.defaultOptions);\n  }\n  /**\n   *\n   * @param {object} options\n   */\n\n\n  createClass(Groups, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var optionFields = [\"useDefaultGroups\"];\n\n      if (options !== undefined) {\n        for (var groupName in options) {\n          if (Object.prototype.hasOwnProperty.call(options, groupName)) {\n            if (indexOf$3(optionFields).call(optionFields, groupName) === -1) {\n              var group = options[groupName];\n              this.add(groupName, group);\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Clear all groups\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._groups = new map$5();\n      this._groupNames = [];\n    }\n    /**\n     * Get group options of a groupname.\n     * If groupname is not found, a new group may be created.\n     *\n     * @param {*}       groupname     Can be a number, string, Date, etc.\n     * @param {boolean} [shouldCreate=true] If true, create a new group\n     * @returns {object} The found or created group\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(groupname) {\n      var shouldCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var group = this._groups.get(groupname);\n\n      if (group === undefined && shouldCreate) {\n        if (this.options.useDefaultGroups === false && this._groupNames.length > 0) {\n          // create new group\n          var index = this._groupIndex % this._groupNames.length;\n          ++this._groupIndex;\n          group = {};\n          group.color = this._groups.get(this._groupNames[index]);\n\n          this._groups.set(groupname, group);\n        } else {\n          // create new group\n          var _index = this._defaultIndex % this._defaultGroups.length;\n\n          this._defaultIndex++;\n          group = {};\n          group.color = this._defaultGroups[_index];\n\n          this._groups.set(groupname, group);\n        }\n      }\n\n      return group;\n    }\n    /**\n     * Add custom group style.\n     *\n     * @param {string} groupName - The name of the group, a new group will be\n     * created if a group with the same name doesn't exist, otherwise the old\n     * groups style will be overwritten.\n     * @param {object} style - An object containing borderColor, backgroundColor,\n     * etc.\n     * @returns {object} The created group object.\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(groupName, style) {\n      // Only push group name once to prevent duplicates which would consume more\n      // RAM and also skew the distribution towards more often updated groups,\n      // neither of which is desirable.\n      if (!this._groups.has(groupName)) {\n        this._groupNames.push(groupName);\n      }\n\n      this._groups.set(groupName, style);\n\n      return style;\n    }\n  }]);\n  return Groups;\n}();\n\nvar slice$6 = [].slice;\nvar MSIE = /MSIE .\\./.test(engineUserAgent); // <- dirty ie9- check\n\nvar wrap$1 = function (scheduler) {\n  return function (handler, timeout\n  /* , ...arguments */\n  ) {\n    var boundArgs = arguments.length > 2;\n    var args = boundArgs ? slice$6.call(arguments, 2) : undefined;\n    return scheduler(boundArgs ? function () {\n      // eslint-disable-next-line no-new-func\n      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);\n    } : handler, timeout);\n  };\n}; // ie9- setTimeout & setInterval additional parameters fix\n// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers\n\n\n_export({\n  global: true,\n  bind: true,\n  forced: MSIE\n}, {\n  // `setTimeout` method\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout\n  setTimeout: wrap$1(global_1.setTimeout),\n  // `setInterval` method\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval\n  setInterval: wrap$1(global_1.setInterval)\n});\n\nvar setTimeout$1 = path.setTimeout;\nvar setTimeout$2 = setTimeout$1;\nvar $some = arrayIteration.some;\nvar STRICT_METHOD$2 = arrayMethodIsStrict('some');\nvar USES_TO_LENGTH$7 = arrayMethodUsesToLength('some'); // `Array.prototype.some` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.some\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !STRICT_METHOD$2 || !USES_TO_LENGTH$7\n}, {\n  some: function some(callbackfn\n  /* , thisArg */\n  ) {\n    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar some = entryVirtual('Array').some;\nvar ArrayPrototype$9 = Array.prototype;\n\nvar some_1 = function (it) {\n  var own = it.some;\n  return it === ArrayPrototype$9 || it instanceof Array && own === ArrayPrototype$9.some ? some : own;\n};\n\nvar some$1 = some_1;\nvar some$2 = some$1;\nvar globalIsFinite = global_1.isFinite; // `Number.isFinite` method\n// https://tc39.github.io/ecma262/#sec-number.isfinite\n\nvar numberIsFinite = Number.isFinite || function isFinite(it) {\n  return typeof it == 'number' && globalIsFinite(it);\n}; // https://tc39.github.io/ecma262/#sec-number.isfinite\n\n\n_export({\n  target: 'Number',\n  stat: true\n}, {\n  isFinite: numberIsFinite\n});\n\nvar _isFinite = path.Number.isFinite;\nvar _isFinite$1 = _isFinite;\nvar _isFinite$2 = _isFinite$1; // https://tc39.github.io/ecma262/#sec-number.isnan\n\n_export({\n  target: 'Number',\n  stat: true\n}, {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare\n    return number != number;\n  }\n});\n\nvar isNan = path.Number.isNaN;\nvar isNan$1 = isNan;\nvar isNan$2 = isNan$1;\nvar nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;\nvar FAILS_ON_PRIMITIVES$3 = fails(function () {\n  return !Object.getOwnPropertyNames(1);\n}); // `Object.getOwnPropertyNames` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n\n_export({\n  target: 'Object',\n  stat: true,\n  forced: FAILS_ON_PRIMITIVES$3\n}, {\n  getOwnPropertyNames: nativeGetOwnPropertyNames$2\n});\n\nvar Object$2 = path.Object;\n\nvar getOwnPropertyNames = function getOwnPropertyNames(it) {\n  return Object$2.getOwnPropertyNames(it);\n};\n\nvar getOwnPropertyNames$1 = getOwnPropertyNames;\nvar getOwnPropertyNames$2 = getOwnPropertyNames$1;\nvar trim$2 = stringTrim.trim;\nvar $parseFloat = global_1.parseFloat;\nvar FORCED$3 = 1 / $parseFloat(whitespaces + '-0') !== -Infinity; // `parseFloat` method\n// https://tc39.github.io/ecma262/#sec-parsefloat-string\n\nvar numberParseFloat = FORCED$3 ? function parseFloat(string) {\n  var trimmedString = trim$2(String(string));\n  var result = $parseFloat(trimmedString);\n  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;\n} : $parseFloat; // https://tc39.github.io/ecma262/#sec-parsefloat-string\n\n_export({\n  global: true,\n  forced: parseFloat != numberParseFloat\n}, {\n  parseFloat: numberParseFloat\n});\n\nvar _parseFloat = path.parseFloat;\nvar _parseFloat$1 = _parseFloat;\nvar _parseFloat$2 = _parseFloat$1;\n/**\n * Helper functions for components\n */\n\n/**\n * Determine values to use for (sub)options of 'chosen'.\n *\n * This option is either a boolean or an object whose values should be examined further.\n * The relevant structures are:\n *\n * - chosen: <boolean value>\n * - chosen: { subOption: <boolean or function> }\n *\n * Where subOption is 'node', 'edge' or 'label'.\n *\n * The intention of this method appears to be to set a specific priority to the options;\n * Since most properties are either bridged or merged into the local options objects, there\n * is not much point in handling them separately.\n * TODO: examine if 'most' in previous sentence can be replaced with 'all'. In that case, we\n *       should be able to get rid of this method.\n *\n * @param {string}  subOption  option within object 'chosen' to consider; either 'node', 'edge' or 'label'\n * @param {object}  pile       array of options objects to consider\n *\n * @returns {boolean | Function}  value for passed subOption of 'chosen' to use\n */\n\nfunction choosify(subOption, pile) {\n  // allowed values for subOption\n  var allowed = [\"node\", \"edge\", \"label\"];\n  var value = true;\n  var chosen = topMost(pile, \"chosen\");\n\n  if (typeof chosen === \"boolean\") {\n    value = chosen;\n  } else if (_typeof_1(chosen) === \"object\") {\n    if (indexOf$3(allowed).call(allowed, subOption) === -1) {\n      throw new Error(\"choosify: subOption '\" + subOption + \"' should be one of \" + \"'\" + allowed.join(\"', '\") + \"'\");\n    }\n\n    var chosenEdge = topMost(pile, [\"chosen\", subOption]);\n\n    if (typeof chosenEdge === \"boolean\" || typeof chosenEdge === \"function\") {\n      value = chosenEdge;\n    }\n  }\n\n  return value;\n}\n/**\n * Check if the point falls within the given rectangle.\n *\n * @param {rect} rect\n * @param {point} point\n * @param {rotationPoint} [rotationPoint] if specified, the rotation that applies to the rectangle.\n * @returns {boolean}  true if point within rectangle, false otherwise\n */\n\n\nfunction pointInRect(rect, point, rotationPoint) {\n  if (rect.width <= 0 || rect.height <= 0) {\n    return false; // early out\n  }\n\n  if (rotationPoint !== undefined) {\n    // Rotate the point the same amount as the rectangle\n    var tmp = {\n      x: point.x - rotationPoint.x,\n      y: point.y - rotationPoint.y\n    };\n\n    if (rotationPoint.angle !== 0) {\n      // In order to get the coordinates the same, you need to\n      // rotate in the reverse direction\n      var angle = -rotationPoint.angle;\n      var tmp2 = {\n        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,\n        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y\n      };\n      point = tmp2;\n    } else {\n      point = tmp;\n    } // Note that if a rotation is specified, the rectangle coordinates\n    // are **not* the full canvas coordinates. They are relative to the\n    // rotationPoint. Hence, the point coordinates need not be translated\n    // back in this case.\n\n  }\n\n  var right = rect.x + rect.width;\n  var bottom = rect.y + rect.width;\n  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;\n}\n/**\n * Check if given value is acceptable as a label text.\n *\n * @param {*} text value to check; can be anything at this point\n * @returns {boolean} true if valid label value, false otherwise\n */\n\n\nfunction isValidLabel(text) {\n  // Note that this is quite strict: types that *might* be converted to string are disallowed\n  return typeof text === \"string\" && text !== \"\";\n}\n/**\n * Returns x, y of self reference circle based on provided angle\n *\n * @param {object} ctx\n * @param {number} angle\n * @param {number} radius\n * @param {VisNode} node\n *\n * @returns {object} x and y coordinates\n */\n\n\nfunction getSelfRefCoordinates(ctx, angle, radius, node) {\n  var x = node.x;\n  var y = node.y;\n\n  if (typeof node.distanceToBorder === \"function\") {\n    //calculating opposite and adjacent\n    //distaneToBorder becomes Hypotenuse.\n    //Formulas sin(a) = Opposite / Hypotenuse and cos(a) = Adjacent / Hypotenuse\n    var toBorderDist = node.distanceToBorder(ctx, angle);\n    var yFromNodeCenter = Math.sin(angle) * toBorderDist;\n    var xFromNodeCenter = Math.cos(angle) * toBorderDist; //xFromNodeCenter is basically x and if xFromNodeCenter equals to the distance to border then it means\n    //that y does not need calculation because it is equal node.height / 2 or node.y\n    //same thing with yFromNodeCenter and if yFromNodeCenter equals to the distance to border then it means\n    //that x is equal node.width / 2 or node.x\n\n    if (xFromNodeCenter === toBorderDist) {\n      x += toBorderDist;\n      y = node.y;\n    } else if (yFromNodeCenter === toBorderDist) {\n      x = node.x;\n      y -= toBorderDist;\n    } else {\n      x += xFromNodeCenter;\n      y -= yFromNodeCenter;\n    }\n  } else if (node.shape.width > node.shape.height) {\n    x = node.x + node.shape.width * 0.5;\n    y = node.y - radius;\n  } else {\n    x = node.x + radius;\n    y = node.y - node.shape.height * 0.5;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nvar values$1 = entryVirtual('Array').values;\nvar values$2 = values$1;\nvar ArrayPrototype$a = Array.prototype;\nvar DOMIterables$1 = {\n  DOMTokenList: true,\n  NodeList: true\n};\n\nvar values_1 = function (it) {\n  var own = it.values;\n  return it === ArrayPrototype$a || it instanceof Array && own === ArrayPrototype$a.values // eslint-disable-next-line no-prototype-builtins\n  || DOMIterables$1.hasOwnProperty(classof(it)) ? values$2 : own;\n};\n\nvar values$3 = values_1;\n/**\n * Callback to determine text dimensions, using the parent label settings.\n *\n * @callback MeasureText\n * @param {text} text\n * @param {text} mod\n * @returns {object} { width, values} width in pixels and font attributes\n */\n\n/**\n * Helper class for Label which collects results of splitting labels into lines and blocks.\n *\n * @private\n */\n\nvar LabelAccumulator = /*#__PURE__*/function () {\n  /**\n   * @param {MeasureText} measureText\n   */\n  function LabelAccumulator(measureText) {\n    classCallCheck(this, LabelAccumulator);\n    this.measureText = measureText;\n    this.current = 0;\n    this.width = 0;\n    this.height = 0;\n    this.lines = [];\n  }\n  /**\n   * Append given text to the given line.\n   *\n   * @param {number}  l    index of line to add to\n   * @param {string}  text string to append to line\n   * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n   * @private\n   */\n\n\n  createClass(LabelAccumulator, [{\n    key: \"_add\",\n    value: function _add(l, text) {\n      var mod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"normal\";\n\n      if (this.lines[l] === undefined) {\n        this.lines[l] = {\n          width: 0,\n          height: 0,\n          blocks: []\n        };\n      } // We still need to set a block for undefined and empty texts, hence return at this point\n      // This is necessary because we don't know at this point if we're at the\n      // start of an empty line or not.\n      // To compensate, empty blocks are removed in `finalize()`.\n      //\n      // Empty strings should still have a height\n\n\n      var tmpText = text;\n      if (text === undefined || text === \"\") tmpText = \" \"; // Determine width and get the font properties\n\n      var result = this.measureText(tmpText, mod);\n      var block = assign$2({}, values$3(result));\n      block.text = text;\n      block.width = result.width;\n      block.mod = mod;\n\n      if (text === undefined || text === \"\") {\n        block.width = 0;\n      }\n\n      this.lines[l].blocks.push(block); // Update the line width. We need this for determining if a string goes over max width\n\n      this.lines[l].width += block.width;\n    }\n    /**\n     * Returns the width in pixels of the current line.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"curWidth\",\n    value: function curWidth() {\n      var line = this.lines[this.current];\n      if (line === undefined) return 0;\n      return line.width;\n    }\n    /**\n     * Add text in block to current line\n     *\n     * @param {string} text\n     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n     */\n\n  }, {\n    key: \"append\",\n    value: function append(text) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"normal\";\n\n      this._add(this.current, text, mod);\n    }\n    /**\n     * Add text in block to current line and start a new line\n     *\n     * @param {string} text\n     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n     */\n\n  }, {\n    key: \"newLine\",\n    value: function newLine(text) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"normal\";\n\n      this._add(this.current, text, mod);\n\n      this.current++;\n    }\n    /**\n     * Determine and set the heights of all the lines currently contained in this instance\n     *\n     * Note that width has already been set.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"determineLineHeights\",\n    value: function determineLineHeights() {\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k]; // Looking for max height of blocks in line\n\n        var height = 0;\n\n        if (line.blocks !== undefined) {\n          // Can happen if text contains e.g. '\\n '\n          for (var l = 0; l < line.blocks.length; l++) {\n            var block = line.blocks[l];\n\n            if (height < block.height) {\n              height = block.height;\n            }\n          }\n        }\n\n        line.height = height;\n      }\n    }\n    /**\n     * Determine the full size of the label text, as determined by current lines and blocks\n     *\n     * @private\n     */\n\n  }, {\n    key: \"determineLabelSize\",\n    value: function determineLabelSize() {\n      var width = 0;\n      var height = 0;\n\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k];\n\n        if (line.width > width) {\n          width = line.width;\n        }\n\n        height += line.height;\n      }\n\n      this.width = width;\n      this.height = height;\n    }\n    /**\n     * Remove all empty blocks and empty lines we don't need\n     *\n     * This must be done after the width/height determination,\n     * so that these are set properly for processing here.\n     *\n     * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed\n     * @private\n     */\n\n  }, {\n    key: \"removeEmptyBlocks\",\n    value: function removeEmptyBlocks() {\n      var tmpLines = [];\n\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k]; // Note: an empty line in between text has width zero but is still relevant to layout.\n        // So we can't use width for testing empty line here\n\n        if (line.blocks.length === 0) continue; // Discard final empty line always\n\n        if (k === this.lines.length - 1) {\n          if (line.width === 0) continue;\n        }\n\n        var tmpLine = {};\n        assign$2(tmpLine, line);\n        tmpLine.blocks = [];\n        var firstEmptyBlock = void 0;\n        var tmpBlocks = [];\n\n        for (var l = 0; l < line.blocks.length; l++) {\n          var block = line.blocks[l];\n\n          if (block.width !== 0) {\n            tmpBlocks.push(block);\n          } else {\n            if (firstEmptyBlock === undefined) {\n              firstEmptyBlock = block;\n            }\n          }\n        } // Ensure that there is *some* text present\n\n\n        if (tmpBlocks.length === 0 && firstEmptyBlock !== undefined) {\n          tmpBlocks.push(firstEmptyBlock);\n        }\n\n        tmpLine.blocks = tmpBlocks;\n        tmpLines.push(tmpLine);\n      }\n\n      return tmpLines;\n    }\n    /**\n     * Set the sizes for all lines and the whole thing.\n     *\n     * @returns {{width: (number|*), height: (number|*), lines: Array}}\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      //console.log(JSON.stringify(this.lines, null, 2));\n      this.determineLineHeights();\n      this.determineLabelSize();\n      var tmpLines = this.removeEmptyBlocks(); // Return a simple hash object for further processing.\n\n      return {\n        width: this.width,\n        height: this.height,\n        lines: tmpLines\n      };\n    }\n  }]);\n  return LabelAccumulator;\n}();\n\nvar tagPattern = {\n  // HTML\n  \"<b>\": /<b>/,\n  \"<i>\": /<i>/,\n  \"<code>\": /<code>/,\n  \"</b>\": /<\\/b>/,\n  \"</i>\": /<\\/i>/,\n  \"</code>\": /<\\/code>/,\n  // Markdown\n  \"*\": /\\*/,\n  // bold\n  _: /_/,\n  // ital\n  \"`\": /`/,\n  // mono\n  afterBold: /[^*]/,\n  afterItal: /[^_]/,\n  afterMono: /[^`]/\n};\n/**\n * Internal helper class for parsing the markup tags for HTML and Markdown.\n *\n * NOTE: Sequences of tabs and spaces are reduced to single space.\n *       Scan usage of `this.spacing` within method\n */\n\nvar MarkupAccumulator = /*#__PURE__*/function () {\n  /**\n   * Create an instance\n   *\n   * @param {string} text  text to parse for markup\n   */\n  function MarkupAccumulator(text) {\n    classCallCheck(this, MarkupAccumulator);\n    this.text = text;\n    this.bold = false;\n    this.ital = false;\n    this.mono = false;\n    this.spacing = false;\n    this.position = 0;\n    this.buffer = \"\";\n    this.modStack = [];\n    this.blocks = [];\n  }\n  /**\n   * Return the mod label currently on the top of the stack\n   *\n   * @returns {string}  label of topmost mod\n   * @private\n   */\n\n\n  createClass(MarkupAccumulator, [{\n    key: \"mod\",\n    value: function mod() {\n      return this.modStack.length === 0 ? \"normal\" : this.modStack[0];\n    }\n    /**\n     * Return the mod label currently active\n     *\n     * @returns {string}  label of active mod\n     * @private\n     */\n\n  }, {\n    key: \"modName\",\n    value: function modName() {\n      if (this.modStack.length === 0) return \"normal\";else if (this.modStack[0] === \"mono\") return \"mono\";else {\n        if (this.bold && this.ital) {\n          return \"boldital\";\n        } else if (this.bold) {\n          return \"bold\";\n        } else if (this.ital) {\n          return \"ital\";\n        }\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"emitBlock\",\n    value: function emitBlock() {\n      if (this.spacing) {\n        this.add(\" \");\n        this.spacing = false;\n      }\n\n      if (this.buffer.length > 0) {\n        this.blocks.push({\n          text: this.buffer,\n          mod: this.modName()\n        });\n        this.buffer = \"\";\n      }\n    }\n    /**\n     * Output text to buffer\n     *\n     * @param {string} text  text to add\n     * @private\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(text) {\n      if (text === \" \") {\n        this.spacing = true;\n      }\n\n      if (this.spacing) {\n        this.buffer += \" \";\n        this.spacing = false;\n      }\n\n      if (text != \" \") {\n        this.buffer += text;\n      }\n    }\n    /**\n     * Handle parsing of whitespace\n     *\n     * @param {string} ch  the character to check\n     * @returns {boolean} true if the character was processed as whitespace, false otherwise\n     */\n\n  }, {\n    key: \"parseWS\",\n    value: function parseWS(ch) {\n      if (/[ \\t]/.test(ch)) {\n        if (!this.mono) {\n          this.spacing = true;\n        } else {\n          this.add(ch);\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {string} tagName  label for block type to set\n     * @private\n     */\n\n  }, {\n    key: \"setTag\",\n    value: function setTag(tagName) {\n      this.emitBlock();\n      this[tagName] = true;\n      this.modStack.unshift(tagName);\n    }\n    /**\n     * @param {string} tagName  label for block type to unset\n     * @private\n     */\n\n  }, {\n    key: \"unsetTag\",\n    value: function unsetTag(tagName) {\n      this.emitBlock();\n      this[tagName] = false;\n      this.modStack.shift();\n    }\n    /**\n     * @param {string} tagName label for block type we are currently processing\n     * @param {string|RegExp} tag string to match in text\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n\n  }, {\n    key: \"parseStartTag\",\n    value: function parseStartTag(tagName, tag) {\n      // Note: if 'mono' passed as tagName, there is a double check here. This is OK\n      if (!this.mono && !this[tagName] && this.match(tag)) {\n        this.setTag(tagName);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {string|RegExp} tag\n     * @param {number} [advance=true] if set, advance current position in text\n     * @returns {boolean} true if match at given position, false otherwise\n     * @private\n     */\n\n  }, {\n    key: \"match\",\n    value: function match(tag) {\n      var advance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var _this$prepareRegExp = this.prepareRegExp(tag),\n          _this$prepareRegExp2 = slicedToArray(_this$prepareRegExp, 2),\n          regExp = _this$prepareRegExp2[0],\n          length = _this$prepareRegExp2[1];\n\n      var matched = regExp.test(this.text.substr(this.position, length));\n\n      if (matched && advance) {\n        this.position += length - 1;\n      }\n\n      return matched;\n    }\n    /**\n     * @param {string} tagName label for block type we are currently processing\n     * @param {string|RegExp} tag string to match in text\n     * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n\n  }, {\n    key: \"parseEndTag\",\n    value: function parseEndTag(tagName, tag, nextTag) {\n      var checkTag = this.mod() === tagName;\n\n      if (tagName === \"mono\") {\n        // special handling for 'mono'\n        checkTag = checkTag && this.mono;\n      } else {\n        checkTag = checkTag && !this.mono;\n      }\n\n      if (checkTag && this.match(tag)) {\n        if (nextTag !== undefined) {\n          // Purpose of the following match is to prevent a direct unset/set of a given tag\n          // E.g. '*bold **still bold*' => '*bold still bold*'\n          if (this.position === this.text.length - 1 || this.match(nextTag, false)) {\n            this.unsetTag(tagName);\n          }\n        } else {\n          this.unsetTag(tagName);\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {string|RegExp} tag  string to match in text\n     * @param {value} value  string to replace tag with, if found at current position\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(tag, value) {\n      if (this.match(tag)) {\n        this.add(value);\n        this.position += length - 1;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Create a regular expression for the tag if it isn't already one.\n     *\n     * The return value is an array `[RegExp, number]`, with exactly two value, where:\n     *  - RegExp is the regular expression to use\n     *  - number is the lenth of the input string to match\n     *\n     * @param {string|RegExp} tag  string to match in text\n     * @returns {Array}  regular expression to use and length of input string to match\n     * @private\n     */\n\n  }, {\n    key: \"prepareRegExp\",\n    value: function prepareRegExp(tag) {\n      var length;\n      var regExp;\n\n      if (tag instanceof RegExp) {\n        regExp = tag;\n        length = 1; // ASSUMPTION: regexp only tests one character\n      } else {\n        // use prepared regexp if present\n        var prepared = tagPattern[tag];\n\n        if (prepared !== undefined) {\n          regExp = prepared;\n        } else {\n          regExp = new RegExp(tag);\n        }\n\n        length = tag.length;\n      }\n\n      return [regExp, length];\n    }\n  }]);\n  return MarkupAccumulator;\n}();\n/**\n * Helper class for Label which explodes the label text into lines and blocks within lines\n *\n * @private\n */\n\n\nvar LabelSplitter = /*#__PURE__*/function () {\n  /**\n   * @param {CanvasRenderingContext2D} ctx Canvas rendering context\n   * @param {Label} parent reference to the Label instance using current instance\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n  function LabelSplitter(ctx, parent, selected, hover) {\n    var _this = this;\n\n    classCallCheck(this, LabelSplitter);\n    this.ctx = ctx;\n    this.parent = parent;\n    this.selected = selected;\n    this.hover = hover;\n    /**\n     * Callback to determine text width; passed to LabelAccumulator instance\n     *\n     * @param  {string} text string to determine width of\n     * @param  {string} mod  font type to use for this text\n     * @returns {object} { width, values} width in pixels and font attributes\n     */\n\n    var textWidth = function textWidth(text, mod) {\n      if (text === undefined) return 0; // TODO: This can be done more efficiently with caching\n      // This will set the ctx.font correctly, depending on selected/hover and mod - so that ctx.measureText() will be accurate.\n\n      var values = _this.parent.getFormattingValues(ctx, selected, hover, mod);\n\n      var width = 0;\n\n      if (text !== \"\") {\n        var measure = _this.ctx.measureText(text);\n\n        width = measure.width;\n      }\n\n      return {\n        width: width,\n        values: values\n      };\n    };\n\n    this.lines = new LabelAccumulator(textWidth);\n  }\n  /**\n   * Split passed text of a label into lines and blocks.\n   *\n   * # NOTE\n   *\n   * The handling of spacing is option dependent:\n   *\n   * - if `font.multi : false`, all spaces are retained\n   * - if `font.multi : true`, every sequence of spaces is compressed to a single space\n   *\n   * This might not be the best way to do it, but this is as it has been working till now.\n   * In order not to break existing functionality, for the time being this behaviour will\n   * be retained in any code changes.\n   *\n   * @param {string} text  text to split\n   * @returns {Array<line>}\n   */\n\n\n  createClass(LabelSplitter, [{\n    key: \"process\",\n    value: function process(text) {\n      if (!isValidLabel(text)) {\n        return this.lines.finalize();\n      }\n\n      var font = this.parent.fontOptions; // Normalize the end-of-line's to a single representation - order important\n\n      text = text.replace(/\\r\\n/g, \"\\n\"); // Dos EOL's\n\n      text = text.replace(/\\r/g, \"\\n\"); // Mac EOL's\n      // Note that at this point, there can be no \\r's in the text.\n      // This is used later on splitStringIntoLines() to split multifont texts.\n\n      var nlLines = String(text).split(\"\\n\");\n      var lineCount = nlLines.length;\n\n      if (font.multi) {\n        // Multi-font case: styling tags active\n        for (var i = 0; i < lineCount; i++) {\n          var blocks = this.splitBlocks(nlLines[i], font.multi); // Post: Sequences of tabs and spaces are reduced to single space\n\n          if (blocks === undefined) continue;\n\n          if (blocks.length === 0) {\n            this.lines.newLine(\"\");\n            continue;\n          }\n\n          if (font.maxWdt > 0) {\n            // widthConstraint.maximum defined\n            //console.log('Running widthConstraint multi, max: ' + this.fontOptions.maxWdt);\n            for (var j = 0; j < blocks.length; j++) {\n              var mod = blocks[j].mod;\n              var _text = blocks[j].text;\n              this.splitStringIntoLines(_text, mod, true);\n            }\n          } else {\n            // widthConstraint.maximum NOT defined\n            for (var _j = 0; _j < blocks.length; _j++) {\n              var _mod = blocks[_j].mod;\n              var _text2 = blocks[_j].text;\n              this.lines.append(_text2, _mod);\n            }\n          }\n\n          this.lines.newLine();\n        }\n      } else {\n        // Single-font case\n        if (font.maxWdt > 0) {\n          // widthConstraint.maximum defined\n          // console.log('Running widthConstraint normal, max: ' + this.fontOptions.maxWdt);\n          for (var _i = 0; _i < lineCount; _i++) {\n            this.splitStringIntoLines(nlLines[_i]);\n          }\n        } else {\n          // widthConstraint.maximum NOT defined\n          for (var _i2 = 0; _i2 < lineCount; _i2++) {\n            this.lines.newLine(nlLines[_i2]);\n          }\n        }\n      }\n\n      return this.lines.finalize();\n    }\n    /**\n     * normalize the markup system\n     *\n     * @param {boolean|'md'|'markdown'|'html'} markupSystem\n     * @returns {string}\n     */\n\n  }, {\n    key: \"decodeMarkupSystem\",\n    value: function decodeMarkupSystem(markupSystem) {\n      var system = \"none\";\n\n      if (markupSystem === \"markdown\" || markupSystem === \"md\") {\n        system = \"markdown\";\n      } else if (markupSystem === true || markupSystem === \"html\") {\n        system = \"html\";\n      }\n\n      return system;\n    }\n    /**\n     *\n     * @param {string} text\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"splitHtmlBlocks\",\n    value: function splitHtmlBlocks(text) {\n      var s = new MarkupAccumulator(text);\n\n      var parseEntities = function parseEntities(ch) {\n        if (/&/.test(ch)) {\n          var parsed = s.replace(s.text, \"&lt;\", \"<\") || s.replace(s.text, \"&amp;\", \"&\");\n\n          if (!parsed) {\n            s.add(\"&\");\n          }\n\n          return true;\n        }\n\n        return false;\n      };\n\n      while (s.position < s.text.length) {\n        var ch = s.text.charAt(s.position);\n        var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag(\"bold\", \"<b>\") || s.parseStartTag(\"ital\", \"<i>\") || s.parseStartTag(\"mono\", \"<code>\") || s.parseEndTag(\"bold\", \"</b>\") || s.parseEndTag(\"ital\", \"</i>\") || s.parseEndTag(\"mono\", \"</code>\")) || parseEntities(ch);\n\n        if (!parsed) {\n          s.add(ch);\n        }\n\n        s.position++;\n      }\n\n      s.emitBlock();\n      return s.blocks;\n    }\n    /**\n     *\n     * @param {string} text\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"splitMarkdownBlocks\",\n    value: function splitMarkdownBlocks(text) {\n      var _this2 = this;\n\n      var s = new MarkupAccumulator(text);\n      var beginable = true;\n\n      var parseOverride = function parseOverride(ch) {\n        if (/\\\\/.test(ch)) {\n          if (s.position < _this2.text.length + 1) {\n            s.position++;\n            ch = _this2.text.charAt(s.position);\n\n            if (/ \\t/.test(ch)) {\n              s.spacing = true;\n            } else {\n              s.add(ch);\n              beginable = false;\n            }\n          }\n\n          return true;\n        }\n\n        return false;\n      };\n\n      while (s.position < s.text.length) {\n        var ch = s.text.charAt(s.position);\n        var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag(\"bold\", \"*\") || s.parseStartTag(\"ital\", \"_\") || s.parseStartTag(\"mono\", \"`\")) || s.parseEndTag(\"bold\", \"*\", \"afterBold\") || s.parseEndTag(\"ital\", \"_\", \"afterItal\") || s.parseEndTag(\"mono\", \"`\", \"afterMono\");\n\n        if (!parsed) {\n          s.add(ch);\n          beginable = false;\n        }\n\n        s.position++;\n      }\n\n      s.emitBlock();\n      return s.blocks;\n    }\n    /**\n     * Explodes a piece of text into single-font blocks using a given markup\n     *\n     * @param {string} text\n     * @param {boolean|'md'|'markdown'|'html'} markupSystem\n     * @returns {Array.<{text: string, mod: string}>}\n     * @private\n     */\n\n  }, {\n    key: \"splitBlocks\",\n    value: function splitBlocks(text, markupSystem) {\n      var system = this.decodeMarkupSystem(markupSystem);\n\n      if (system === \"none\") {\n        return [{\n          text: text,\n          mod: \"normal\"\n        }];\n      } else if (system === \"markdown\") {\n        return this.splitMarkdownBlocks(text);\n      } else if (system === \"html\") {\n        return this.splitHtmlBlocks(text);\n      }\n    }\n    /**\n     * @param {string} text\n     * @returns {boolean} true if text length over the current max with\n     * @private\n     */\n\n  }, {\n    key: \"overMaxWidth\",\n    value: function overMaxWidth(text) {\n      var width = this.ctx.measureText(text).width;\n      return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;\n    }\n    /**\n     * Determine the longest part of the sentence which still fits in the\n     * current max width.\n     *\n     * @param {Array} words  Array of strings signifying a text lines\n     * @returns {number}      index of first item in string making string go over max\n     * @private\n     */\n\n  }, {\n    key: \"getLongestFit\",\n    value: function getLongestFit(words) {\n      var text = \"\";\n      var w = 0;\n\n      while (w < words.length) {\n        var pre = text === \"\" ? \"\" : \" \";\n        var newText = text + pre + words[w];\n        if (this.overMaxWidth(newText)) break;\n        text = newText;\n        w++;\n      }\n\n      return w;\n    }\n    /**\n     * Determine the longest part of the string which still fits in the\n     * current max width.\n     *\n     * @param {Array} words Array of strings signifying a text lines\n     * @returns {number} index of first item in string making string go over max\n     */\n\n  }, {\n    key: \"getLongestFitWord\",\n    value: function getLongestFitWord(words) {\n      var w = 0;\n\n      while (w < words.length) {\n        if (this.overMaxWidth(slice$5(words).call(words, 0, w))) break;\n        w++;\n      }\n\n      return w;\n    }\n    /**\n     * Split the passed text into lines, according to width constraint (if any).\n     *\n     * The method assumes that the input string is a single line, i.e. without lines break.\n     *\n     * This method retains spaces, if still present (case `font.multi: false`).\n     * A space which falls on an internal line break, will be replaced by a newline.\n     * There is no special handling of tabs; these go along with the flow.\n     *\n     * @param {string} str\n     * @param {string} [mod='normal']\n     * @param {boolean} [appendLast=false]\n     * @private\n     */\n\n  }, {\n    key: \"splitStringIntoLines\",\n    value: function splitStringIntoLines(str) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"normal\";\n      var appendLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // Set the canvas context font, based upon the current selected/hover state\n      // and the provided mod, so the text measurement performed by getLongestFit\n      // will be accurate - and not just use the font of whoever last used the canvas.\n\n      this.parent.getFormattingValues(this.ctx, this.selected, this.hover, mod); // Still-present spaces are relevant, retain them\n\n      str = str.replace(/^( +)/g, \"$1\\r\");\n      str = str.replace(/([^\\r][^ ]*)( +)/g, \"$1\\r$2\\r\");\n      var words = str.split(\"\\r\");\n\n      while (words.length > 0) {\n        var w = this.getLongestFit(words);\n\n        if (w === 0) {\n          // Special case: the first word is already larger than the max width.\n          var word = words[0]; // Break the word to the largest part that fits the line\n\n          var x = this.getLongestFitWord(word);\n          this.lines.newLine(slice$5(word).call(word, 0, x), mod); // Adjust the word, so that the rest will be done next iteration\n\n          words[0] = slice$5(word).call(word, x);\n        } else {\n          // skip any space that is replaced by a newline\n          var newW = w;\n\n          if (words[w - 1] === \" \") {\n            w--;\n          } else if (words[newW] === \" \") {\n            newW++;\n          }\n\n          var text = slice$5(words).call(words, 0, w).join(\"\");\n\n          if (w == words.length && appendLast) {\n            this.lines.append(text, mod);\n          } else {\n            this.lines.newLine(text, mod);\n          } // Adjust the word, so that the rest will be done next iteration\n\n\n          words = slice$5(words).call(words, newW);\n        }\n      }\n    }\n  }]);\n  return LabelSplitter;\n}();\n/**\n * List of special styles for multi-fonts\n *\n * @private\n */\n\n\nvar multiFontStyle = [\"bold\", \"ital\", \"boldital\", \"mono\"];\n/**\n * A Label to be used for Nodes or Edges.\n */\n\nvar Label = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {object} options\n   * @param {boolean} [edgelabel=false]\n   */\n  function Label(body, options) {\n    var edgelabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    classCallCheck(this, Label);\n    this.body = body;\n    this.pointToSelf = false;\n    this.baseSize = undefined;\n    this.fontOptions = {}; // instance variable containing the *instance-local* font options\n\n    this.setOptions(options);\n    this.size = {\n      top: 0,\n      left: 0,\n      width: 0,\n      height: 0,\n      yLine: 0\n    };\n    this.isEdgeLabel = edgelabel;\n  }\n  /**\n   * @param {object} options the options of the parent Node-instance\n   */\n\n\n  createClass(Label, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.elementOptions = options; // Reference to the options of the parent Node-instance\n\n      this.initFontOptions(options.font);\n\n      if (isValidLabel(options.label)) {\n        this.labelDirty = true;\n      } else {\n        // Bad label! Change the option value to prevent bad stuff happening\n        options.label = undefined;\n      }\n\n      if (options.font !== undefined && options.font !== null) {\n        // font options can be deleted at various levels\n        if (typeof options.font === \"string\") {\n          this.baseSize = this.fontOptions.size;\n        } else if (_typeof_1(options.font) === \"object\") {\n          var size = options.font.size;\n\n          if (size !== undefined) {\n            this.baseSize = size;\n          }\n        }\n      }\n    }\n    /**\n     * Init the font Options structure.\n     *\n     * Member fontOptions serves as an accumulator for the current font options.\n     * As such, it needs to be completely separated from the node options.\n     *\n     * @param {object} newFontOptions the new font options to process\n     * @private\n     */\n\n  }, {\n    key: \"initFontOptions\",\n    value: function initFontOptions(newFontOptions) {\n      var _this = this; // Prepare the multi-font option objects.\n      // These will be filled in propagateFonts(), if required\n\n\n      forEach$3(multiFontStyle, function (style) {\n        _this.fontOptions[style] = {};\n      }); // Handle shorthand option, if present\n\n      if (Label.parseFontString(this.fontOptions, newFontOptions)) {\n        this.fontOptions.vadjust = 0;\n        return;\n      } // Copy over the non-multifont options, if specified\n\n\n      forEach$3(newFontOptions, function (prop, n) {\n        if (prop !== undefined && prop !== null && _typeof_1(prop) !== \"object\") {\n          _this.fontOptions[n] = prop;\n        }\n      });\n    }\n    /**\n     * If in-variable is a string, parse it as a font specifier.\n     *\n     * Note that following is not done here and have to be done after the call:\n     * - Not all font options are set (vadjust, mod)\n     *\n     * @param {object} outOptions  out-parameter, object in which to store the parse results (if any)\n     * @param {object} inOptions  font options to parse\n     * @returns {boolean} true if font parsed as string, false otherwise\n     * @static\n     */\n\n  }, {\n    key: \"constrain\",\n\n    /**\n     * Set the width and height constraints based on 'nearest' value\n     *\n     * @param {Array} pile array of option objects to consider\n     * @returns {object} the actual constraint values to use\n     * @private\n     */\n    value: function constrain(pile) {\n      // NOTE: constrainWidth and  constrainHeight never set!\n      // NOTE: for edge labels, only 'maxWdt' set\n      // Node labels can set all the fields\n      var fontOptions = {\n        constrainWidth: false,\n        maxWdt: -1,\n        minWdt: -1,\n        constrainHeight: false,\n        minHgt: -1,\n        valign: \"middle\"\n      };\n      var widthConstraint = topMost(pile, \"widthConstraint\");\n\n      if (typeof widthConstraint === \"number\") {\n        fontOptions.maxWdt = Number(widthConstraint);\n        fontOptions.minWdt = Number(widthConstraint);\n      } else if (_typeof_1(widthConstraint) === \"object\") {\n        var widthConstraintMaximum = topMost(pile, [\"widthConstraint\", \"maximum\"]);\n\n        if (typeof widthConstraintMaximum === \"number\") {\n          fontOptions.maxWdt = Number(widthConstraintMaximum);\n        }\n\n        var widthConstraintMinimum = topMost(pile, [\"widthConstraint\", \"minimum\"]);\n\n        if (typeof widthConstraintMinimum === \"number\") {\n          fontOptions.minWdt = Number(widthConstraintMinimum);\n        }\n      }\n\n      var heightConstraint = topMost(pile, \"heightConstraint\");\n\n      if (typeof heightConstraint === \"number\") {\n        fontOptions.minHgt = Number(heightConstraint);\n      } else if (_typeof_1(heightConstraint) === \"object\") {\n        var heightConstraintMinimum = topMost(pile, [\"heightConstraint\", \"minimum\"]);\n\n        if (typeof heightConstraintMinimum === \"number\") {\n          fontOptions.minHgt = Number(heightConstraintMinimum);\n        }\n\n        var heightConstraintValign = topMost(pile, [\"heightConstraint\", \"valign\"]);\n\n        if (typeof heightConstraintValign === \"string\") {\n          if (heightConstraintValign === \"top\" || heightConstraintValign === \"bottom\") {\n            fontOptions.valign = heightConstraintValign;\n          }\n        }\n      }\n\n      return fontOptions;\n    }\n    /**\n     * Set options and update internal state\n     *\n     * @param {object} options  options to set\n     * @param {Array}  pile     array of option objects to consider for option 'chosen'\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(options, pile) {\n      this.setOptions(options, true);\n      this.propagateFonts(pile);\n      deepExtend(this.fontOptions, this.constrain(pile));\n      this.fontOptions.chooser = choosify(\"label\", pile);\n    }\n    /**\n     * When margins are set in an element, adjust sizes is called to remove them\n     * from the width/height constraints. This must be done prior to label sizing.\n     *\n     * @param {{top: number, right: number, bottom: number, left: number}} margins\n     */\n\n  }, {\n    key: \"adjustSizes\",\n    value: function adjustSizes(margins) {\n      var widthBias = margins ? margins.right + margins.left : 0;\n\n      if (this.fontOptions.constrainWidth) {\n        this.fontOptions.maxWdt -= widthBias;\n        this.fontOptions.minWdt -= widthBias;\n      }\n\n      var heightBias = margins ? margins.top + margins.bottom : 0;\n\n      if (this.fontOptions.constrainHeight) {\n        this.fontOptions.minHgt -= heightBias;\n      }\n    } /////////////////////////////////////////////////////////\n    // Methods for handling options piles\n    // Eventually, these will be moved to a separate class\n    /////////////////////////////////////////////////////////\n\n    /**\n     * Add the font members of the passed list of option objects to the pile.\n     *\n     * @param {Pile} dstPile  pile of option objects add to\n     * @param {Pile} srcPile  pile of option objects to take font options from\n     * @private\n     */\n\n  }, {\n    key: \"addFontOptionsToPile\",\n    value: function addFontOptionsToPile(dstPile, srcPile) {\n      for (var i = 0; i < srcPile.length; ++i) {\n        this.addFontToPile(dstPile, srcPile[i]);\n      }\n    }\n    /**\n     * Add given font option object to the list of objects (the 'pile') to consider for determining\n     * multi-font option values.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {object} options  instance to add to pile\n     * @private\n     */\n\n  }, {\n    key: \"addFontToPile\",\n    value: function addFontToPile(pile, options) {\n      if (options === undefined) return;\n      if (options.font === undefined || options.font === null) return;\n      var item = options.font;\n      pile.push(item);\n    }\n    /**\n     * Collect all own-property values from the font pile that aren't multi-font option objectss.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @returns {object} object with all current own basic font properties\n     * @private\n     */\n\n  }, {\n    key: \"getBasicOptions\",\n    value: function getBasicOptions(pile) {\n      var ret = {}; // Scans the whole pile to get all options present\n\n      for (var n = 0; n < pile.length; ++n) {\n        var fontOptions = pile[n]; // Convert shorthand if necessary\n\n        var tmpShorthand = {};\n\n        if (Label.parseFontString(tmpShorthand, fontOptions)) {\n          fontOptions = tmpShorthand;\n        }\n\n        forEach$3(fontOptions, function (opt, name) {\n          if (opt === undefined) return; // multi-font option need not be present\n\n          if (Object.prototype.hasOwnProperty.call(ret, name)) return; // Keep first value we encounter\n\n          if (indexOf$3(multiFontStyle).call(multiFontStyle, name) !== -1) {\n            // Skip multi-font properties but we do need the structure\n            ret[name] = {};\n          } else {\n            ret[name] = opt;\n          }\n        });\n      }\n\n      return ret;\n    }\n    /**\n     * Return the value for given option for the given multi-font.\n     *\n     * All available option objects are trawled in the set order to construct the option values.\n     *\n     * ---------------------------------------------------------------------\n     * ## Traversal of pile for multi-fonts\n     *\n     * The determination of multi-font option values is a special case, because any values not\n     * present in the multi-font options should by definition be taken from the main font options,\n     * i.e. from the current 'parent' object of the multi-font option.\n     *\n     * ### Search order for multi-fonts\n     *\n     * 'bold' used as example:\n     *\n     *   - search in option group 'bold' in local properties\n     *   - search in main font option group in local properties\n     *\n     * ---------------------------------------------------------------------\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {MultiFontStyle} multiName sub path for the multi-font\n     * @param {string} option  the option to search for, for the given multi-font\n     * @returns {string|number} the value for the given option\n     * @private\n     */\n\n  }, {\n    key: \"getFontOption\",\n    value: function getFontOption(pile, multiName, option) {\n      var multiFont; // Search multi font in local properties\n\n      for (var n = 0; n < pile.length; ++n) {\n        var fontOptions = pile[n];\n\n        if (Object.prototype.hasOwnProperty.call(fontOptions, multiName)) {\n          multiFont = fontOptions[multiName];\n          if (multiFont === undefined || multiFont === null) continue; // Convert shorthand if necessary\n          // TODO: inefficient to do this conversion every time; find a better way.\n\n          var tmpShorthand = {};\n\n          if (Label.parseFontString(tmpShorthand, multiFont)) {\n            multiFont = tmpShorthand;\n          }\n\n          if (Object.prototype.hasOwnProperty.call(multiFont, option)) {\n            return multiFont[option];\n          }\n        }\n      } // Option is not mentioned in the multi font options; take it from the parent font options.\n      // These have already been converted with getBasicOptions(), so use the converted values.\n\n\n      if (Object.prototype.hasOwnProperty.call(this.fontOptions, option)) {\n        return this.fontOptions[option];\n      } // A value **must** be found; you should never get here.\n\n\n      throw new Error(\"Did not find value for multi-font for property: '\" + option + \"'\");\n    }\n    /**\n     * Return all options values for the given multi-font.\n     *\n     * All available option objects are trawled in the set order to construct the option values.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {MultiFontStyle} multiName sub path for the mod-font\n     * @returns {MultiFontOptions}\n     * @private\n     */\n\n  }, {\n    key: \"getFontOptions\",\n    value: function getFontOptions(pile, multiName) {\n      var result = {};\n      var optionNames = [\"color\", \"size\", \"face\", \"mod\", \"vadjust\"]; // List of allowed options per multi-font\n\n      for (var i = 0; i < optionNames.length; ++i) {\n        var mod = optionNames[i];\n        result[mod] = this.getFontOption(pile, multiName, mod);\n      }\n\n      return result;\n    } /////////////////////////////////////////////////////////\n    // End methods for handling options piles\n    /////////////////////////////////////////////////////////\n\n    /**\n     * Collapse the font options for the multi-font to single objects, from\n     * the chain of option objects passed (the 'pile').\n     *\n     * @param {Pile} pile  sequence of option objects to consider.\n     *                     First item in list assumed to be the newly set options.\n     */\n\n  }, {\n    key: \"propagateFonts\",\n    value: function propagateFonts(pile) {\n      var _this2 = this;\n\n      var fontPile = []; // sequence of font objects to consider, order important\n      // Note that this.elementOptions is not used here.\n\n      this.addFontOptionsToPile(fontPile, pile);\n      this.fontOptions = this.getBasicOptions(fontPile); // We set multifont values even if multi === false, for consistency (things break otherwise)\n\n      var _loop = function _loop(i) {\n        var mod = multiFontStyle[i];\n        var modOptions = _this2.fontOptions[mod];\n\n        var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod); // Copy over found values\n\n\n        forEach$3(tmpMultiFontOptions, function (option, n) {\n          modOptions[n] = option;\n        });\n        modOptions.size = Number(modOptions.size);\n        modOptions.vadjust = Number(modOptions.vadjust);\n      };\n\n      for (var i = 0; i < multiFontStyle.length; ++i) {\n        _loop(i);\n      }\n    }\n    /**\n     * Main function. This is called from anything that wants to draw a label.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} [baseline='middle']\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover) {\n      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"middle\"; // if no label, return\n\n      if (this.elementOptions.label === undefined) return; // check if we have to render the label\n\n      var viewFontSize = this.fontOptions.size * this.body.view.scale;\n      if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) return; // This ensures that there will not be HUGE letters on screen\n      // by setting an upper limit on the visible text size (regardless of zoomLevel)\n\n      if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {\n        viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;\n      } // update the size cache if required\n\n\n      this.calculateLabelSize(ctx, selected, hover, x, y, baseline);\n\n      this._drawBackground(ctx);\n\n      this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);\n    }\n    /**\n     * Draws the label background\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @private\n     */\n\n  }, {\n    key: \"_drawBackground\",\n    value: function _drawBackground(ctx) {\n      if (this.fontOptions.background !== undefined && this.fontOptions.background !== \"none\") {\n        ctx.fillStyle = this.fontOptions.background;\n        var size = this.getSize();\n        ctx.fillRect(size.left, size.top, size.width, size.height);\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {string} [baseline='middle']\n     * @param {number} viewFontSize\n     * @private\n     */\n\n  }, {\n    key: \"_drawText\",\n    value: function _drawText(ctx, x, y) {\n      var baseline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"middle\";\n      var viewFontSize = arguments.length > 4 ? arguments[4] : undefined;\n\n      var _this$_setAlignment = this._setAlignment(ctx, x, y, baseline);\n\n      var _this$_setAlignment2 = slicedToArray(_this$_setAlignment, 2);\n\n      x = _this$_setAlignment2[0];\n      y = _this$_setAlignment2[1];\n      ctx.textAlign = \"left\";\n      x = x - this.size.width / 2; // Shift label 1/2-distance to the left\n\n      if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {\n        if (this.fontOptions.valign === \"top\") {\n          y -= (this.size.height - this.size.labelHeight) / 2;\n        }\n\n        if (this.fontOptions.valign === \"bottom\") {\n          y += (this.size.height - this.size.labelHeight) / 2;\n        }\n      } // draw the text\n\n\n      for (var i = 0; i < this.lineCount; i++) {\n        var line = this.lines[i];\n\n        if (line && line.blocks) {\n          var width = 0;\n\n          if (this.isEdgeLabel || this.fontOptions.align === \"center\") {\n            width += (this.size.width - line.width) / 2;\n          } else if (this.fontOptions.align === \"right\") {\n            width += this.size.width - line.width;\n          }\n\n          for (var j = 0; j < line.blocks.length; j++) {\n            var block = line.blocks[j];\n            ctx.font = block.font;\n\n            var _this$_getColor = this._getColor(block.color, viewFontSize, block.strokeColor),\n                _this$_getColor2 = slicedToArray(_this$_getColor, 2),\n                fontColor = _this$_getColor2[0],\n                strokeColor = _this$_getColor2[1];\n\n            if (block.strokeWidth > 0) {\n              ctx.lineWidth = block.strokeWidth;\n              ctx.strokeStyle = strokeColor;\n              ctx.lineJoin = \"round\";\n            }\n\n            ctx.fillStyle = fontColor;\n\n            if (block.strokeWidth > 0) {\n              ctx.strokeText(block.text, x + width, y + block.vadjust);\n            }\n\n            ctx.fillText(block.text, x + width, y + block.vadjust);\n            width += block.width;\n          }\n\n          y += line.height;\n        }\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {string} baseline\n     * @returns {Array.<number>}\n     * @private\n     */\n\n  }, {\n    key: \"_setAlignment\",\n    value: function _setAlignment(ctx, x, y, baseline) {\n      // check for label alignment (for edges)\n      // TODO: make alignment for nodes\n      if (this.isEdgeLabel && this.fontOptions.align !== \"horizontal\" && this.pointToSelf === false) {\n        x = 0;\n        y = 0;\n        var lineMargin = 2;\n\n        if (this.fontOptions.align === \"top\") {\n          ctx.textBaseline = \"alphabetic\";\n          y -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers\n        } else if (this.fontOptions.align === \"bottom\") {\n          ctx.textBaseline = \"hanging\";\n          y += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers\n        } else {\n          ctx.textBaseline = \"middle\";\n        }\n      } else {\n        ctx.textBaseline = baseline;\n      }\n\n      return [x, y];\n    }\n    /**\n     * fade in when relative scale is between threshold and threshold - 1.\n     * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.\n     *\n     * @param {string} color  The font color to use\n     * @param {number} viewFontSize\n     * @param {string} initialStrokeColor\n     * @returns {Array.<string>} An array containing the font color and stroke color\n     * @private\n     */\n\n  }, {\n    key: \"_getColor\",\n    value: function _getColor(color, viewFontSize, initialStrokeColor) {\n      var fontColor = color || \"#000000\";\n      var strokeColor = initialStrokeColor || \"#ffffff\";\n\n      if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {\n        var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));\n        fontColor = overrideOpacity(fontColor, opacity);\n        strokeColor = overrideOpacity(strokeColor, opacity);\n      }\n\n      return [fontColor, strokeColor];\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {{width: number, height: number}}\n     */\n\n  }, {\n    key: \"getTextSize\",\n    value: function getTextSize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      this._processLabel(ctx, selected, hover);\n\n      return {\n        width: this.size.width,\n        height: this.size.height,\n        lineCount: this.lineCount\n      };\n    }\n    /**\n     * Get the current dimensions of the label\n     *\n     * @returns {rect}\n     */\n\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      var lineMargin = 2;\n      var x = this.size.left; // default values which might be overridden below\n\n      var y = this.size.top - 0.5 * lineMargin; // idem\n\n      if (this.isEdgeLabel) {\n        var x2 = -this.size.width * 0.5;\n\n        switch (this.fontOptions.align) {\n          case \"middle\":\n            x = x2;\n            y = -this.size.height * 0.5;\n            break;\n\n          case \"top\":\n            x = x2;\n            y = -(this.size.height + lineMargin);\n            break;\n\n          case \"bottom\":\n            x = x2;\n            y = lineMargin;\n            break;\n        }\n      }\n\n      var ret = {\n        left: x,\n        top: y,\n        width: this.size.width,\n        height: this.size.height\n      };\n      return ret;\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {'middle'|'hanging'} [baseline='middle']\n     */\n\n  }, {\n    key: \"calculateLabelSize\",\n    value: function calculateLabelSize(ctx, selected, hover) {\n      var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"middle\";\n\n      this._processLabel(ctx, selected, hover);\n\n      this.size.left = x - this.size.width * 0.5;\n      this.size.top = y - this.size.height * 0.5;\n      this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;\n\n      if (baseline === \"hanging\") {\n        this.size.top += 0.5 * this.fontOptions.size;\n        this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers\n\n        this.size.yLine += 4; // distance from node\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} mod\n     * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}\n     */\n\n  }, {\n    key: \"getFormattingValues\",\n    value: function getFormattingValues(ctx, selected, hover, mod) {\n      var getValue = function getValue(fontOptions, mod, option) {\n        if (mod === \"normal\") {\n          if (option === \"mod\") return \"\";\n          return fontOptions[option];\n        }\n\n        if (fontOptions[mod][option] !== undefined) {\n          // Grumbl leaving out test on undefined equals false for \"\"\n          return fontOptions[mod][option];\n        } else {\n          // Take from parent font option\n          return fontOptions[option];\n        }\n      };\n\n      var values = {\n        color: getValue(this.fontOptions, mod, \"color\"),\n        size: getValue(this.fontOptions, mod, \"size\"),\n        face: getValue(this.fontOptions, mod, \"face\"),\n        mod: getValue(this.fontOptions, mod, \"mod\"),\n        vadjust: getValue(this.fontOptions, mod, \"vadjust\"),\n        strokeWidth: this.fontOptions.strokeWidth,\n        strokeColor: this.fontOptions.strokeColor\n      };\n\n      if (selected || hover) {\n        if (mod === \"normal\" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {\n          values.mod = \"bold\";\n        } else {\n          if (typeof this.fontOptions.chooser === \"function\") {\n            this.fontOptions.chooser(values, this.elementOptions.id, selected, hover);\n          }\n        }\n      }\n\n      var fontString = \"\";\n\n      if (values.mod !== undefined && values.mod !== \"\") {\n        // safeguard for undefined - this happened\n        fontString += values.mod + \" \";\n      }\n\n      fontString += values.size + \"px \" + values.face;\n      ctx.font = fontString.replace(/\"/g, \"\");\n      values.font = ctx.font;\n      values.height = values.size;\n      return values;\n    }\n    /**\n     *\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"differentState\",\n    value: function differentState(selected, hover) {\n      return selected !== this.selectedState || hover !== this.hoverState;\n    }\n    /**\n     * This explodes the passed text into lines and determines the width, height and number of lines.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} inText  the text to explode\n     * @returns {{width, height, lines}|*}\n     * @private\n     */\n\n  }, {\n    key: \"_processLabelText\",\n    value: function _processLabelText(ctx, selected, hover, inText) {\n      var splitter = new LabelSplitter(ctx, this, selected, hover);\n      return splitter.process(inText);\n    }\n    /**\n     * This explodes the label string into lines and sets the width, height and number of lines.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n\n  }, {\n    key: \"_processLabel\",\n    value: function _processLabel(ctx, selected, hover) {\n      if (this.labelDirty === false && !this.differentState(selected, hover)) return;\n\n      var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);\n\n      if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {\n        state.width = this.fontOptions.minWdt;\n      }\n\n      this.size.labelHeight = state.height;\n\n      if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {\n        state.height = this.fontOptions.minHgt;\n      }\n\n      this.lines = state.lines;\n      this.lineCount = state.lines.length;\n      this.size.width = state.width;\n      this.size.height = state.height;\n      this.selectedState = selected;\n      this.hoverState = hover;\n      this.labelDirty = false;\n    }\n    /**\n     * Check if this label is visible\n     *\n     * @returns {boolean} true if this label will be show, false otherwise\n     */\n\n  }, {\n    key: \"visible\",\n    value: function visible() {\n      if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === undefined) {\n        return false; // nothing to display\n      }\n\n      var viewFontSize = this.fontOptions.size * this.body.view.scale;\n\n      if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {\n        return false; // Too small or too far away to show\n      }\n\n      return true;\n    }\n  }], [{\n    key: \"parseFontString\",\n    value: function parseFontString(outOptions, inOptions) {\n      if (!inOptions || typeof inOptions !== \"string\") return false;\n      var newOptionsArray = inOptions.split(\" \");\n      outOptions.size = +newOptionsArray[0].replace(\"px\", \"\");\n      outOptions.face = newOptionsArray[1];\n      outOptions.color = newOptionsArray[2];\n      return true;\n    }\n  }]);\n  return Label;\n}();\n\nvar nativeConstruct = getBuiltIn('Reflect', 'construct'); // `Reflect.construct` method\n// https://tc39.github.io/ecma262/#sec-reflect.construct\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\n\nvar NEW_TARGET_BUG = fails(function () {\n  function F() {\n    /* empty */\n  }\n\n  return !(nativeConstruct(function () {\n    /* empty */\n  }, [], F) instanceof F);\n});\nvar ARGS_BUG = !fails(function () {\n  nativeConstruct(function () {\n    /* empty */\n  });\n});\nvar FORCED$4 = NEW_TARGET_BUG || ARGS_BUG;\n\n_export({\n  target: 'Reflect',\n  stat: true,\n  forced: FORCED$4,\n  sham: FORCED$4\n}, {\n  construct: function construct(Target, args\n  /* , newTarget */\n  ) {\n    aFunction(Target);\n    anObject(args);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);\n\n    if (Target == newTarget) {\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch (args.length) {\n        case 0:\n          return new Target();\n\n        case 1:\n          return new Target(args[0]);\n\n        case 2:\n          return new Target(args[0], args[1]);\n\n        case 3:\n          return new Target(args[0], args[1], args[2]);\n\n        case 4:\n          return new Target(args[0], args[1], args[2], args[3]);\n      } // w/o altered newTarget, lot of arguments case\n\n\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (functionBind.apply(Target, $args))();\n    } // with altered newTarget, not support built-in constructors\n\n\n    var proto = newTarget.prototype;\n    var instance = objectCreate(isObject(proto) ? proto : Object.prototype);\n    var result = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});\n\nvar construct$1 = path.Reflect.construct;\nvar construct$2 = construct$1;\nvar construct$3 = construct$2;\nvar create$3 = create;\nvar create$4 = create$3; // https://tc39.github.io/ecma262/#sec-object.setprototypeof\n\n_export({\n  target: 'Object',\n  stat: true\n}, {\n  setPrototypeOf: objectSetPrototypeOf\n});\n\nvar setPrototypeOf = path.Object.setPrototypeOf;\nvar setPrototypeOf$1 = setPrototypeOf;\nvar setPrototypeOf$2 = setPrototypeOf$1;\nvar setPrototypeOf$3 = createCommonjsModule(function (module) {\n  function _setPrototypeOf(o, p) {\n    module.exports = _setPrototypeOf = setPrototypeOf$2 || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  module.exports = _setPrototypeOf;\n});\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = create$4(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf$3(subClass, superClass);\n}\n\nvar inherits = _inherits;\n\nfunction _assertThisInitialized$1(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar assertThisInitialized = _assertThisInitialized$1;\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof_1(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nvar possibleConstructorReturn = _possibleConstructorReturn;\nvar getPrototypeOf$3 = getPrototypeOf;\nvar getPrototypeOf$4 = getPrototypeOf$3;\nvar getPrototypeOf$5 = createCommonjsModule(function (module) {\n  function _getPrototypeOf(o) {\n    module.exports = _getPrototypeOf = setPrototypeOf$2 ? getPrototypeOf$4 : function _getPrototypeOf(o) {\n      return o.__proto__ || getPrototypeOf$4(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  module.exports = _getPrototypeOf;\n}); // https://tc39.github.io/ecma262/#sec-array.prototype.fill\n\nvar arrayFill = function fill(value\n/* , start = 0, end = @length */\n) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var argumentsLength = arguments.length;\n  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n\n  while (endPos > index) O[index++] = value;\n\n  return O;\n}; // https://tc39.github.io/ecma262/#sec-array.prototype.fill\n\n\n_export({\n  target: 'Array',\n  proto: true\n}, {\n  fill: arrayFill\n}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\n\nvar fill = entryVirtual('Array').fill;\nvar ArrayPrototype$b = Array.prototype;\n\nvar fill_1 = function (it) {\n  var own = it.fill;\n  return it === ArrayPrototype$b || it instanceof Array && own === ArrayPrototype$b.fill ? fill : own;\n};\n\nvar fill$1 = fill_1;\nvar fill$2 = fill$1;\n/**\n * The Base class for all Nodes.\n */\n\nvar NodeBase = /*#__PURE__*/function () {\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function NodeBase(options, body, labelModule) {\n    classCallCheck(this, NodeBase);\n    this.body = body;\n    this.labelModule = labelModule;\n    this.setOptions(options);\n    this.top = undefined;\n    this.left = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.radius = undefined;\n    this.margin = undefined;\n    this.refreshNeeded = true;\n    this.boundingBox = {\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n  /**\n   *\n   * @param {object} options\n   */\n\n\n  createClass(NodeBase, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n    /**\n     *\n     * @param {Label} labelModule\n     * @private\n     */\n\n  }, {\n    key: \"_setMargins\",\n    value: function _setMargins(labelModule) {\n      this.margin = {};\n\n      if (this.options.margin) {\n        if (_typeof_1(this.options.margin) == \"object\") {\n          this.margin.top = this.options.margin.top;\n          this.margin.right = this.options.margin.right;\n          this.margin.bottom = this.options.margin.bottom;\n          this.margin.left = this.options.margin.left;\n        } else {\n          this.margin.top = this.options.margin;\n          this.margin.right = this.options.margin;\n          this.margin.bottom = this.options.margin;\n          this.margin.left = this.options.margin;\n        }\n      }\n\n      labelModule.adjustSizes(this.margin);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"_distanceToBorder\",\n    value: function _distanceToBorder(ctx, angle) {\n      var borderWidth = this.options.borderWidth;\n\n      if (ctx) {\n        this.resize(ctx);\n      }\n\n      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"enableShadow\",\n    value: function enableShadow(ctx, values) {\n      if (values.shadow) {\n        ctx.shadowColor = values.shadowColor;\n        ctx.shadowBlur = values.shadowSize;\n        ctx.shadowOffsetX = values.shadowX;\n        ctx.shadowOffsetY = values.shadowY;\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"disableShadow\",\n    value: function disableShadow(ctx, values) {\n      if (values.shadow) {\n        ctx.shadowColor = \"rgba(0,0,0,0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"enableBorderDashes\",\n    value: function enableBorderDashes(ctx, values) {\n      if (values.borderDashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          var dashes = values.borderDashes;\n\n          if (dashes === true) {\n            dashes = [5, 15];\n          }\n\n          ctx.setLineDash(dashes);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\");\n          this.options.shapeProperties.borderDashes = false;\n          values.borderDashes = false;\n        }\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"disableBorderDashes\",\n    value: function disableBorderDashes(ctx, values) {\n      if (values.borderDashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          ctx.setLineDash([0]);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\");\n          this.options.shapeProperties.borderDashes = false;\n          values.borderDashes = false;\n        }\n      }\n    }\n    /**\n     * Determine if the shape of a node needs to be recalculated.\n     *\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {boolean}\n     * @protected\n     */\n\n  }, {\n    key: \"needsRefresh\",\n    value: function needsRefresh(selected, hover) {\n      if (this.refreshNeeded === true) {\n        // This is probably not the best location to reset this member.\n        // However, in the current logic, it is the most convenient one.\n        this.refreshNeeded = false;\n        return true;\n      }\n\n      return this.width === undefined || this.labelModule.differentState(selected, hover);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"initContextForDraw\",\n    value: function initContextForDraw(ctx, values) {\n      var borderWidth = values.borderWidth / this.body.view.scale;\n      ctx.lineWidth = Math.min(this.width, borderWidth);\n      ctx.strokeStyle = values.borderColor;\n      ctx.fillStyle = values.color;\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"performStroke\",\n    value: function performStroke(ctx, values) {\n      var borderWidth = values.borderWidth / this.body.view.scale; //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.\n\n      ctx.save(); // if borders are zero width, they will be drawn with width 1 by default. This prevents that\n\n      if (borderWidth > 0) {\n        this.enableBorderDashes(ctx, values); //draw the border\n\n        ctx.stroke(); //disable dashed border for other elements\n\n        this.disableBorderDashes(ctx, values);\n      }\n\n      ctx.restore();\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"performFill\",\n    value: function performFill(ctx, values) {\n      ctx.save();\n      ctx.fillStyle = values.color; // draw shadow if enabled\n\n      this.enableShadow(ctx, values); // draw the background\n\n      fill$2(ctx).call(ctx); // disable shadows for other elements.\n\n      this.disableShadow(ctx, values);\n      ctx.restore();\n      this.performStroke(ctx, values);\n    }\n    /**\n     *\n     * @param {number} margin\n     * @private\n     */\n\n  }, {\n    key: \"_addBoundingBoxMargin\",\n    value: function _addBoundingBoxMargin(margin) {\n      this.boundingBox.left -= margin;\n      this.boundingBox.top -= margin;\n      this.boundingBox.bottom += margin;\n      this.boundingBox.right += margin;\n    }\n    /**\n     * Actual implementation of this method call.\n     *\n     * Doing it like this makes it easier to override\n     * in the child classes.\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n\n  }, {\n    key: \"_updateBoundingBox\",\n    value: function _updateBoundingBox(x, y, ctx, selected, hover) {\n      if (ctx !== undefined) {\n        this.resize(ctx, selected, hover);\n      }\n\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.boundingBox.left = this.left;\n      this.boundingBox.top = this.top;\n      this.boundingBox.bottom = this.top + this.height;\n      this.boundingBox.right = this.left + this.width;\n    }\n    /**\n     * Default implementation of this method call.\n     * This acts as a stub which can be overridden.\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     */\n\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y, ctx, selected, hover) {\n      this._updateBoundingBox(x, y, ctx, selected, hover);\n    }\n    /**\n     * Determine the dimensions to use for nodes with an internal label\n     *\n     * Currently, these are: Circle, Ellipse, Database, Box\n     * The other nodes have external labels, and will not call this method\n     *\n     * If there is no label, decent default values are supplied.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} [selected]\n     * @param {boolean} [hover]\n     * @returns {{width:number, height:number}}\n     */\n\n  }, {\n    key: \"getDimensionsFromLabel\",\n    value: function getDimensionsFromLabel(ctx, selected, hover) {\n      // NOTE: previously 'textSize' was not put in 'this' for Ellipse\n      // TODO: examine the consequences.\n      this.textSize = this.labelModule.getTextSize(ctx, selected, hover);\n      var width = this.textSize.width;\n      var height = this.textSize.height;\n      var DEFAULT_SIZE = 14;\n\n      if (width === 0) {\n        // This happens when there is no label text set\n        width = DEFAULT_SIZE; // use a decent default\n\n        height = DEFAULT_SIZE; // if width zero, then height also always zero\n      }\n\n      return {\n        width: width,\n        height: height\n      };\n    }\n  }]);\n  return NodeBase;\n}();\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A Box Node/Cluster shape.\n *\n * @augments NodeBase\n */\n\n\nvar Box = /*#__PURE__*/function (_NodeBase) {\n  inherits(Box, _NodeBase);\n\n  var _super = _createSuper(Box);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Box(options, body, labelModule) {\n    var _this;\n\n    classCallCheck(this, Box);\n    _this = _super.call(this, options, body, labelModule);\n\n    _this._setMargins(labelModule);\n\n    return _this;\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  createClass(Box, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        this.width = dimensions.width + this.margin.right + this.margin.left;\n        this.height = dimensions.height + this.margin.top + this.margin.bottom;\n        this.radius = this.width / 2;\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values);\n      drawRoundRect(ctx, this.left, this.top, this.width, this.height, values.borderRadius);\n      this.performFill(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n    }\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     */\n\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y, ctx, selected, hover) {\n      this._updateBoundingBox(x, y, ctx, selected, hover);\n\n      var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box\n\n      this._addBoundingBoxMargin(borderRadius);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n\n      var borderWidth = this.options.borderWidth;\n      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;\n    }\n  }]);\n  return Box;\n}(NodeBase);\n\nfunction _createSuper$1(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * NOTE: This is a bad base class\n *\n * Child classes are:\n *\n *   Image       - uses *only* image methods\n *   Circle      - uses *only* _drawRawCircle\n *   CircleImage - uses all\n *\n * TODO: Refactor, move _drawRawCircle to different module, derive Circle from NodeBase\n *       Rename this to ImageBase\n *       Consolidate common code in Image and CircleImage to base class\n *\n * @augments NodeBase\n */\n\n\nvar CircleImageBase = /*#__PURE__*/function (_NodeBase) {\n  inherits(CircleImageBase, _NodeBase);\n\n  var _super = _createSuper$1(CircleImageBase);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function CircleImageBase(options, body, labelModule) {\n    var _this;\n\n    classCallCheck(this, CircleImageBase);\n    _this = _super.call(this, options, body, labelModule);\n    _this.labelOffset = 0;\n    _this.selected = false;\n    return _this;\n  }\n  /**\n   *\n   * @param {object} options\n   * @param {object} [imageObj]\n   * @param {object} [imageObjAlt]\n   */\n\n\n  createClass(CircleImageBase, [{\n    key: \"setOptions\",\n    value: function setOptions(options, imageObj, imageObjAlt) {\n      this.options = options;\n\n      if (!(imageObj === undefined && imageObjAlt === undefined)) {\n        this.setImages(imageObj, imageObjAlt);\n      }\n    }\n    /**\n     * Set the images for this node.\n     *\n     * The images can be updated after the initial setting of options;\n     * therefore, this method needs to be reentrant.\n     *\n     * For correct working in error cases, it is necessary to properly set\n     * field 'nodes.brokenImage' in the options.\n     *\n     * @param {Image} imageObj  required; main image to show for this node\n     * @param {Image|undefined} imageObjAlt optional; image to show when node is selected\n     */\n\n  }, {\n    key: \"setImages\",\n    value: function setImages(imageObj, imageObjAlt) {\n      if (imageObjAlt && this.selected) {\n        this.imageObj = imageObjAlt;\n        this.imageObjAlt = imageObj;\n      } else {\n        this.imageObj = imageObj;\n        this.imageObjAlt = imageObjAlt;\n      }\n    }\n    /**\n     * Set selection and switch between the base and the selected image.\n     *\n     * Do the switch only if imageObjAlt exists.\n     *\n     * @param {boolean} selected value of new selected state for current node\n     */\n\n  }, {\n    key: \"switchImages\",\n    value: function switchImages(selected) {\n      var selection_changed = selected && !this.selected || !selected && this.selected;\n      this.selected = selected; // Remember new selection\n\n      if (this.imageObjAlt !== undefined && selection_changed) {\n        var imageTmp = this.imageObj;\n        this.imageObj = this.imageObjAlt;\n        this.imageObjAlt = imageTmp;\n      }\n    }\n    /**\n     * Returns Image Padding from node options\n     *\n     * @returns {{top: number,left: number,bottom: number,right: number}} image padding inside this shape\n     * @private\n     */\n\n  }, {\n    key: \"_getImagePadding\",\n    value: function _getImagePadding() {\n      var imgPadding = {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n\n      if (this.options.imagePadding) {\n        var optImgPadding = this.options.imagePadding;\n\n        if (_typeof_1(optImgPadding) == \"object\") {\n          imgPadding.top = optImgPadding.top;\n          imgPadding.right = optImgPadding.right;\n          imgPadding.bottom = optImgPadding.bottom;\n          imgPadding.left = optImgPadding.left;\n        } else {\n          imgPadding.top = optImgPadding;\n          imgPadding.right = optImgPadding;\n          imgPadding.bottom = optImgPadding;\n          imgPadding.left = optImgPadding;\n        }\n      }\n\n      return imgPadding;\n    }\n    /**\n     * Adjust the node dimensions for a loaded image.\n     *\n     * Pre: this.imageObj is valid\n     */\n\n  }, {\n    key: \"_resizeImage\",\n    value: function _resizeImage() {\n      var width, height;\n\n      if (this.options.shapeProperties.useImageSize === false) {\n        // Use the size property\n        var ratio_width = 1;\n        var ratio_height = 1; // Only calculate the proper ratio if both width and height not zero\n\n        if (this.imageObj.width && this.imageObj.height) {\n          if (this.imageObj.width > this.imageObj.height) {\n            ratio_width = this.imageObj.width / this.imageObj.height;\n          } else {\n            ratio_height = this.imageObj.height / this.imageObj.width;\n          }\n        }\n\n        width = this.options.size * 2 * ratio_width;\n        height = this.options.size * 2 * ratio_height;\n      } else {\n        // Use the image size with image padding\n        var imgPadding = this._getImagePadding();\n\n        width = this.imageObj.width + imgPadding.left + imgPadding.right;\n        height = this.imageObj.height + imgPadding.top + imgPadding.bottom;\n      }\n\n      this.width = width;\n      this.height = height;\n      this.radius = 0.5 * this.width;\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {ArrowOptions} values\n     * @private\n     */\n\n  }, {\n    key: \"_drawRawCircle\",\n    value: function _drawRawCircle(ctx, x, y, values) {\n      this.initContextForDraw(ctx, values);\n      drawCircle(ctx, x, y, values.size);\n      this.performFill(ctx, values);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     * @private\n     */\n\n  }, {\n    key: \"_drawImageAtPosition\",\n    value: function _drawImageAtPosition(ctx, values) {\n      if (this.imageObj.width != 0) {\n        // draw the image\n        ctx.globalAlpha = values.opacity !== undefined ? values.opacity : 1; // draw shadow if enabled\n\n        this.enableShadow(ctx, values);\n        var factor = 1;\n\n        if (this.options.shapeProperties.interpolation === true) {\n          factor = this.imageObj.width / this.width / this.body.view.scale;\n        }\n\n        var imgPadding = this._getImagePadding();\n\n        var imgPosLeft = this.left + imgPadding.left;\n        var imgPosTop = this.top + imgPadding.top;\n        var imgWidth = this.width - imgPadding.left - imgPadding.right;\n        var imgHeight = this.height - imgPadding.top - imgPadding.bottom;\n        this.imageObj.drawImageAtPosition(ctx, factor, imgPosLeft, imgPosTop, imgWidth, imgHeight); // disable shadows for other elements.\n\n        this.disableShadow(ctx, values);\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n\n  }, {\n    key: \"_drawImageLabel\",\n    value: function _drawImageLabel(ctx, x, y, selected, hover) {\n      var offset = 0;\n\n      if (this.height !== undefined) {\n        offset = this.height * 0.5;\n        var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);\n\n        if (labelDimensions.lineCount >= 1) {\n          offset += labelDimensions.height / 2;\n        }\n      }\n\n      var yLabel = y + offset;\n\n      if (this.options.label) {\n        this.labelOffset = offset;\n      }\n\n      this.labelModule.draw(ctx, x, yLabel, selected, hover, \"hanging\");\n    }\n  }]);\n  return CircleImageBase;\n}(NodeBase);\n\nfunction _createSuper$2(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$2() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A Circle Node/Cluster shape.\n *\n * @augments CircleImageBase\n */\n\n\nvar Circle = /*#__PURE__*/function (_CircleImageBase) {\n  inherits(Circle, _CircleImageBase);\n\n  var _super = _createSuper$2(Circle);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Circle(options, body, labelModule) {\n    var _this;\n\n    classCallCheck(this, Circle);\n    _this = _super.call(this, options, body, labelModule);\n\n    _this._setMargins(labelModule);\n\n    return _this;\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  createClass(Circle, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);\n        this.options.size = diameter / 2; // NOTE: this size field only set here, not in Ellipse, Database, Box\n\n        this.width = diameter;\n        this.height = diameter;\n        this.radius = this.width / 2;\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      this._drawRawCircle(ctx, x, y, values);\n\n      this.updateBoundingBox(x, y);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);\n    }\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     */\n\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n\n      return this.width * 0.5;\n    }\n  }]);\n  return Circle;\n}(CircleImageBase);\n\nfunction _createSuper$3(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$3() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A CircularImage Node/Cluster shape.\n *\n * @augments CircleImageBase\n */\n\n\nvar CircularImage = /*#__PURE__*/function (_CircleImageBase) {\n  inherits(CircularImage, _CircleImageBase);\n\n  var _super = _createSuper$3(CircularImage);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   * @param {Image} imageObj\n   * @param {Image} imageObjAlt\n   */\n\n\n  function CircularImage(options, body, labelModule, imageObj, imageObjAlt) {\n    var _this;\n\n    classCallCheck(this, CircularImage);\n    _this = _super.call(this, options, body, labelModule);\n\n    _this.setImages(imageObj, imageObjAlt);\n\n    return _this;\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  createClass(CircularImage, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;\n\n      if (imageAbsent) {\n        var diameter = this.options.size * 2;\n        this.width = diameter;\n        this.height = diameter;\n        this.radius = 0.5 * this.width;\n        return;\n      } // At this point, an image is present, i.e. this.imageObj is valid.\n\n\n      if (this.needsRefresh(selected, hover)) {\n        this._resizeImage();\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.switchImages(selected);\n      this.resize();\n      var labelX = x,\n          labelY = y;\n\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n        labelX += this.width / 2;\n        labelY += this.height / 2;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      } // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.\n\n\n      this._drawRawCircle(ctx, labelX, labelY, values); // now we draw in the circle, we save so we can revert the clip operation after drawing.\n\n\n      ctx.save(); // clip is used to use the stroke in drawRawCircle as an area that we can draw in.\n\n      ctx.clip(); // draw the image\n\n      this._drawImageAtPosition(ctx, values); // restore so we can again draw on the full canvas\n\n\n      ctx.restore();\n\n      this._drawImageLabel(ctx, labelX, labelY, selected, hover);\n\n      this.updateBoundingBox(x, y);\n    } // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here\n\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     */\n\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.boundingBox.top = y;\n        this.boundingBox.left = x;\n        this.boundingBox.right = x + this.options.size * 2;\n        this.boundingBox.bottom = y + this.options.size * 2;\n      } else {\n        this.boundingBox.top = y - this.options.size;\n        this.boundingBox.left = x - this.options.size;\n        this.boundingBox.right = x + this.options.size;\n        this.boundingBox.bottom = y + this.options.size;\n      } // TODO: compare with Image.updateBoundingBox(), consolidate?\n\n\n      this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n      this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n      this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n\n      return this.width * 0.5;\n    }\n  }]);\n  return CircularImage;\n}(CircleImageBase);\n\nfunction _createSuper$4(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$4() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Base class for constructing Node/Cluster Shapes.\n *\n * @augments NodeBase\n */\n\n\nvar ShapeBase = /*#__PURE__*/function (_NodeBase) {\n  inherits(ShapeBase, _NodeBase);\n\n  var _super = _createSuper$4(ShapeBase);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function ShapeBase(options, body, labelModule) {\n    classCallCheck(this, ShapeBase);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   * @param {object} [values={size: this.options.size}]\n   */\n\n\n  createClass(ShapeBase, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      var values = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        size: this.options.size\n      };\n\n      if (this.needsRefresh(selected, hover)) {\n        var _this$customSizeWidth, _this$customSizeHeigh;\n\n        this.labelModule.getTextSize(ctx, selected, hover);\n        var size = 2 * values.size;\n        this.width = (_this$customSizeWidth = this.customSizeWidth) !== null && _this$customSizeWidth !== void 0 ? _this$customSizeWidth : size;\n        this.height = (_this$customSizeHeigh = this.customSizeHeight) !== null && _this$customSizeHeigh !== void 0 ? _this$customSizeHeigh : size;\n        this.radius = 0.5 * this.width;\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} shape\n     * @param {number} sizeMultiplier - Unused! TODO: Remove next major release\n     * @param {number} x\n     * @param {number} y\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     * @private\n     *\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n\n  }, {\n    key: \"_drawShape\",\n    value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values) {\n      var _this = this;\n\n      this.resize(ctx, selected, hover, values);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values);\n      getShape(shape)(ctx, x, y, values.size);\n      this.performFill(ctx, values);\n\n      if (this.options.icon !== undefined) {\n        if (this.options.icon.code !== undefined) {\n          ctx.font = (selected ? \"bold \" : \"\") + this.height / 2 + \"px \" + (this.options.icon.face || \"FontAwesome\");\n          ctx.fillStyle = this.options.icon.color || \"black\";\n          ctx.textAlign = \"center\";\n          ctx.textBaseline = \"middle\";\n          ctx.fillText(this.options.icon.code, x, y);\n        }\n      }\n\n      return {\n        drawExternalLabel: function drawExternalLabel() {\n          if (_this.options.label !== undefined) {\n            // Need to call following here in order to ensure value for\n            // `this.labelModule.size.height`.\n            _this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, \"hanging\");\n\n            var yLabel = y + 0.5 * _this.height + 0.5 * _this.labelModule.size.height;\n\n            _this.labelModule.draw(ctx, x, yLabel, selected, hover, \"hanging\");\n          }\n\n          _this.updateBoundingBox(x, y);\n        }\n      };\n    }\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);\n      }\n    }\n  }]);\n  return ShapeBase;\n}(NodeBase);\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = keys$3(object);\n\n  if (getOwnPropertySymbols$2) {\n    var symbols = getOwnPropertySymbols$2(object);\n    if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) {\n      return getOwnPropertyDescriptor$3(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      var _context;\n\n      forEach$2(_context = ownKeys$2(Object(source), true)).call(_context, function (key) {\n        defineProperty$7(target, key, source[key]);\n      });\n    } else if (getOwnPropertyDescriptors$2) {\n      defineProperties$1(target, getOwnPropertyDescriptors$2(source));\n    } else {\n      var _context2;\n\n      forEach$2(_context2 = ownKeys$2(Object(source))).call(_context2, function (key) {\n        defineProperty$2(target, key, getOwnPropertyDescriptor$3(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper$5(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$5() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A CustomShape Node/Cluster shape.\n *\n * @augments ShapeBase\n */\n\n\nvar CustomShape = /*#__PURE__*/function (_ShapeBase) {\n  inherits(CustomShape, _ShapeBase);\n\n  var _super = _createSuper$5(CustomShape);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   * @param {Function} ctxRenderer\n   \n   */\n\n\n  function CustomShape(options, body, labelModule, ctxRenderer) {\n    var _this;\n\n    classCallCheck(this, CustomShape);\n    _this = _super.call(this, options, body, labelModule, ctxRenderer);\n    _this.ctxRenderer = ctxRenderer;\n    return _this;\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   *\n   * @returns {object} Callbacks to draw later on different layers.\n   */\n\n\n  createClass(CustomShape, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover, values);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2; // Guard right away because someone may just draw in the function itself.\n\n      ctx.save();\n      var drawLater = this.ctxRenderer({\n        ctx: ctx,\n        id: this.options.id,\n        x: x,\n        y: y,\n        state: {\n          selected: selected,\n          hover: hover\n        },\n        style: _objectSpread({}, values),\n        label: this.options.label\n      }); // Render the node shape bellow arrows.\n\n      if (drawLater.drawNode != null) {\n        drawLater.drawNode();\n      }\n\n      ctx.restore();\n\n      if (drawLater.drawExternalLabel) {\n        // Guard the external label (above arrows) drawing function.\n        var drawExternalLabel = drawLater.drawExternalLabel;\n\n        drawLater.drawExternalLabel = function () {\n          ctx.save();\n          drawExternalLabel();\n          ctx.restore();\n        };\n      }\n\n      if (drawLater.nodeDimensions) {\n        this.customSizeWidth = drawLater.nodeDimensions.width;\n        this.customSizeHeight = drawLater.nodeDimensions.height;\n      }\n\n      return drawLater;\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return CustomShape;\n}(ShapeBase);\n\nfunction _createSuper$6(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$6() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A Database Node/Cluster shape.\n *\n * @augments NodeBase\n */\n\n\nvar Database = /*#__PURE__*/function (_NodeBase) {\n  inherits(Database, _NodeBase);\n\n  var _super = _createSuper$6(Database);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Database(options, body, labelModule) {\n    var _this;\n\n    classCallCheck(this, Database);\n    _this = _super.call(this, options, body, labelModule);\n\n    _this._setMargins(labelModule);\n\n    return _this;\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n\n\n  createClass(Database, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        var size = dimensions.width + this.margin.right + this.margin.left;\n        this.width = size;\n        this.height = size;\n        this.radius = this.width / 2;\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values);\n      drawDatabase(ctx, x - this.width / 2, y - this.height / 2, this.width, this.height);\n      this.performFill(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Database;\n}(NodeBase);\n\nfunction _createSuper$7(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$7() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A Diamond Node/Cluster shape.\n *\n * @augments ShapeBase\n */\n\n\nvar Diamond = /*#__PURE__*/function (_ShapeBase) {\n  inherits(Diamond, _ShapeBase);\n\n  var _super = _createSuper$7(Diamond);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Diamond(options, body, labelModule) {\n    classCallCheck(this, Diamond);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   *\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n\n\n  createClass(Diamond, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"diamond\", 4, x, y, selected, hover, values);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Diamond;\n}(ShapeBase);\n\nfunction _createSuper$8(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$8() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A Dot Node/Cluster shape.\n *\n * @augments ShapeBase\n */\n\n\nvar Dot = /*#__PURE__*/function (_ShapeBase) {\n  inherits(Dot, _ShapeBase);\n\n  var _super = _createSuper$8(Dot);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Dot(options, body, labelModule) {\n    classCallCheck(this, Dot);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   *\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n\n\n  createClass(Dot, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"circle\", 2, x, y, selected, hover, values);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n\n      return this.options.size;\n    }\n  }]);\n  return Dot;\n}(ShapeBase);\n\nfunction _createSuper$9(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$9() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Am Ellipse Node/Cluster shape.\n *\n * @augments NodeBase\n */\n\n\nvar Ellipse = /*#__PURE__*/function (_NodeBase) {\n  inherits(Ellipse, _NodeBase);\n\n  var _super = _createSuper$9(Ellipse);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Ellipse(options, body, labelModule) {\n    classCallCheck(this, Ellipse);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  createClass(Ellipse, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        this.height = dimensions.height * 2;\n        this.width = dimensions.width + dimensions.height;\n        this.radius = 0.5 * this.width;\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width * 0.5;\n      this.top = y - this.height * 0.5;\n      this.initContextForDraw(ctx, values);\n      drawEllipse(ctx, this.left, this.top, this.width, this.height);\n      this.performFill(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, x, y, selected, hover);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n\n      var a = this.width * 0.5;\n      var b = this.height * 0.5;\n      var w = Math.sin(angle) * a;\n      var h = Math.cos(angle) * b;\n      return a * b / Math.sqrt(w * w + h * h);\n    }\n  }]);\n  return Ellipse;\n}(NodeBase);\n\nfunction _createSuper$a(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$a() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * An icon replacement for the default Node shape.\n *\n * @augments NodeBase\n */\n\n\nvar Icon = /*#__PURE__*/function (_NodeBase) {\n  inherits(Icon, _NodeBase);\n\n  var _super = _createSuper$a(Icon);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Icon(options, body, labelModule) {\n    var _this;\n\n    classCallCheck(this, Icon);\n    _this = _super.call(this, options, body, labelModule);\n\n    _this._setMargins(labelModule);\n\n    return _this;\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx - Unused.\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  createClass(Icon, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        this.iconSize = {\n          width: Number(this.options.icon.size),\n          height: Number(this.options.icon.size)\n        };\n        this.width = this.iconSize.width + this.margin.right + this.margin.left;\n        this.height = this.iconSize.height + this.margin.top + this.margin.bottom;\n        this.radius = 0.5 * this.width;\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     *\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      var _this2 = this;\n\n      this.resize(ctx, selected, hover);\n      this.options.icon.size = this.options.icon.size || 50;\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      this._icon(ctx, x, y, selected, hover, values);\n\n      return {\n        drawExternalLabel: function drawExternalLabel() {\n          if (_this2.options.label !== undefined) {\n            var iconTextSpacing = 5;\n\n            _this2.labelModule.draw(ctx, _this2.left + _this2.iconSize.width / 2 + _this2.margin.left, y + _this2.height / 2 + iconTextSpacing, selected);\n          }\n\n          _this2.updateBoundingBox(x, y);\n        }\n      };\n    }\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.icon.size * 0.5;\n      this.boundingBox.left = x - this.options.icon.size * 0.5;\n      this.boundingBox.right = x + this.options.icon.size * 0.5;\n      this.boundingBox.bottom = y + this.options.icon.size * 0.5;\n\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        var iconTextSpacing = 5;\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover - Unused\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"_icon\",\n    value: function _icon(ctx, x, y, selected, hover, values) {\n      var iconSize = Number(this.options.icon.size);\n\n      if (this.options.icon.code !== undefined) {\n        ctx.font = [this.options.icon.weight != null ? this.options.icon.weight : selected ? \"bold\" : \"\", // If the weight is forced (for example to make Font Awesome 5 work\n        // properly) substitute slightly bigger size for bold font face.\n        (this.options.icon.weight != null && selected ? 5 : 0) + iconSize + \"px\", this.options.icon.face].join(\" \"); // draw icon\n\n        ctx.fillStyle = this.options.icon.color || \"black\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\"; // draw shadow if enabled\n\n        this.enableShadow(ctx, values);\n        ctx.fillText(this.options.icon.code, x, y); // disable shadows for other elements.\n\n        this.disableShadow(ctx, values);\n      } else {\n        console.error(\"When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.\");\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Icon;\n}(NodeBase);\n\nfunction _createSuper$b(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$b() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * An image-based replacement for the default Node shape.\n *\n * @augments CircleImageBase\n */\n\n\nvar Image$1 = /*#__PURE__*/function (_CircleImageBase) {\n  inherits(Image, _CircleImageBase);\n\n  var _super = _createSuper$b(Image);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   * @param {Image} imageObj\n   * @param {Image} imageObjAlt\n   */\n\n\n  function Image(options, body, labelModule, imageObj, imageObjAlt) {\n    var _this;\n\n    classCallCheck(this, Image);\n    _this = _super.call(this, options, body, labelModule);\n\n    _this.setImages(imageObj, imageObjAlt);\n\n    return _this;\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx - Unused.\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n\n\n  createClass(Image, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;\n\n      if (imageAbsent) {\n        var side = this.options.size * 2;\n        this.width = side;\n        this.height = side;\n        return;\n      }\n\n      if (this.needsRefresh(selected, hover)) {\n        this._resizeImage();\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      ctx.save();\n      this.switchImages(selected);\n      this.resize();\n      var labelX = x,\n          labelY = y;\n\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n        labelX += this.width / 2;\n        labelY += this.height / 2;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n\n      if (this.options.shapeProperties.useBorderWithImage === true) {\n        var neutralborderWidth = this.options.borderWidth;\n        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;\n        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;\n        ctx.lineWidth = Math.min(this.width, borderWidth);\n        ctx.beginPath();\n        var strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;\n        var fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;\n\n        if (values.opacity !== undefined) {\n          strokeStyle = overrideOpacity(strokeStyle, values.opacity);\n          fillStyle = overrideOpacity(fillStyle, values.opacity);\n        } // setup the line properties.\n\n\n        ctx.strokeStyle = strokeStyle; // set a fillstyle\n\n        ctx.fillStyle = fillStyle; // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image\n\n        ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);\n        fill$2(ctx).call(ctx);\n        this.performStroke(ctx, values);\n        ctx.closePath();\n      }\n\n      this._drawImageAtPosition(ctx, values);\n\n      this._drawImageLabel(ctx, labelX, labelY, selected, hover);\n\n      this.updateBoundingBox(x, y);\n      ctx.restore();\n    }\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.resize();\n\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n\n      this.boundingBox.left = this.left;\n      this.boundingBox.top = this.top;\n      this.boundingBox.bottom = this.top + this.height;\n      this.boundingBox.right = this.left + this.width;\n\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Image;\n}(CircleImageBase);\n\nfunction _createSuper$c(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$c() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A Square Node/Cluster shape.\n *\n * @augments ShapeBase\n */\n\n\nvar Square = /*#__PURE__*/function (_ShapeBase) {\n  inherits(Square, _ShapeBase);\n\n  var _super = _createSuper$c(Square);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Square(options, body, labelModule) {\n    classCallCheck(this, Square);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   *\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n\n\n  createClass(Square, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"square\", 2, x, y, selected, hover, values);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Square;\n}(ShapeBase);\n\nfunction _createSuper$d(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$d() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A Hexagon Node/Cluster shape.\n *\n * @augments ShapeBase\n */\n\n\nvar Hexagon = /*#__PURE__*/function (_ShapeBase) {\n  inherits(Hexagon, _ShapeBase);\n\n  var _super = _createSuper$d(Hexagon);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Hexagon(options, body, labelModule) {\n    classCallCheck(this, Hexagon);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   *\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n\n\n  createClass(Hexagon, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"hexagon\", 4, x, y, selected, hover, values);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Hexagon;\n}(ShapeBase);\n\nfunction _createSuper$e(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$e() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A Star Node/Cluster shape.\n *\n * @augments ShapeBase\n */\n\n\nvar Star = /*#__PURE__*/function (_ShapeBase) {\n  inherits(Star, _ShapeBase);\n\n  var _super = _createSuper$e(Star);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Star(options, body, labelModule) {\n    classCallCheck(this, Star);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   *\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n\n\n  createClass(Star, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"star\", 4, x, y, selected, hover, values);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Star;\n}(ShapeBase);\n\nfunction _createSuper$f(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$f() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A text-based replacement for the default Node shape.\n *\n * @augments NodeBase\n */\n\n\nvar Text = /*#__PURE__*/function (_NodeBase) {\n  inherits(Text, _NodeBase);\n\n  var _super = _createSuper$f(Text);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Text(options, body, labelModule) {\n    var _this;\n\n    classCallCheck(this, Text);\n    _this = _super.call(this, options, body, labelModule);\n\n    _this._setMargins(labelModule);\n\n    return _this;\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n\n\n  createClass(Text, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        this.textSize = this.labelModule.getTextSize(ctx, selected, hover);\n        this.width = this.textSize.width + this.margin.right + this.margin.left;\n        this.height = this.textSize.height + this.margin.top + this.margin.bottom;\n        this.radius = 0.5 * this.width;\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2; // draw shadow if enabled\n\n      this.enableShadow(ctx, values);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover); // disable shadows for other elements.\n\n      this.disableShadow(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Text;\n}(NodeBase);\n\nfunction _createSuper$g(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$g() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A Triangle Node/Cluster shape.\n *\n * @augments ShapeBase\n */\n\n\nvar Triangle = /*#__PURE__*/function (_ShapeBase) {\n  inherits(Triangle, _ShapeBase);\n\n  var _super = _createSuper$g(Triangle);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function Triangle(options, body, labelModule) {\n    classCallCheck(this, Triangle);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x\n   * @param {number} y\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   *\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n\n\n  createClass(Triangle, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"triangle\", 3, x, y, selected, hover, values);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Triangle;\n}(ShapeBase);\n\nfunction _createSuper$h(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$h() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A downward facing Triangle Node/Cluster shape.\n *\n * @augments ShapeBase\n */\n\n\nvar TriangleDown = /*#__PURE__*/function (_ShapeBase) {\n  inherits(TriangleDown, _ShapeBase);\n\n  var _super = _createSuper$h(TriangleDown);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n\n\n  function TriangleDown(options, body, labelModule) {\n    classCallCheck(this, TriangleDown);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x\n   * @param {number} y\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   *\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n\n\n  createClass(TriangleDown, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"triangleDown\", 3, x, y, selected, hover, values);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return TriangleDown;\n}(ShapeBase);\n\nvar $stringify$1 = getBuiltIn('JSON', 'stringify');\nvar re = /[\\uD800-\\uDFFF]/g;\nvar low = /^[\\uD800-\\uDBFF]$/;\nvar hi = /^[\\uDC00-\\uDFFF]$/;\n\nvar fix = function (match, offset, string) {\n  var prev = string.charAt(offset - 1);\n  var next = string.charAt(offset + 1);\n\n  if (low.test(match) && !hi.test(next) || hi.test(match) && !low.test(prev)) {\n    return '\\\\u' + match.charCodeAt(0).toString(16);\n  }\n\n  return match;\n};\n\nvar FORCED$5 = fails(function () {\n  return $stringify$1('\\uDF06\\uD834') !== '\"\\\\udf06\\\\ud834\"' || $stringify$1('\\uDEAD') !== '\"\\\\udead\"';\n});\n\nif ($stringify$1) {\n  // https://github.com/tc39/proposal-well-formed-stringify\n  _export({\n    target: 'JSON',\n    stat: true,\n    forced: FORCED$5\n  }, {\n    // eslint-disable-next-line no-unused-vars\n    stringify: function stringify(it, replacer, space) {\n      var result = $stringify$1.apply(null, arguments);\n      return typeof result == 'string' ? result.replace(re, fix) : result;\n    }\n  });\n}\n\nif (!path.JSON) path.JSON = {\n  stringify: JSON.stringify\n}; // eslint-disable-next-line no-unused-vars\n\nvar stringify = function stringify(it, replacer, space) {\n  return path.JSON.stringify.apply(null, arguments);\n};\n\nvar stringify$1 = stringify;\nvar stringify$2 = stringify$1;\nvar errorFound = false;\nvar allOptions;\nvar printStyle = \"background: #FFeeee; color: #dd0000\";\n/**\n *  Used to validate options.\n */\n\nvar Validator = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function Validator() {\n    classCallCheck(this, Validator);\n  }\n  /**\n   * Main function to be called\n   *\n   * @param {object} options\n   * @param {object} referenceOptions\n   * @param {object} subObject\n   * @returns {boolean}\n   * @static\n   */\n\n\n  createClass(Validator, null, [{\n    key: \"validate\",\n    value: function validate(options, referenceOptions, subObject) {\n      errorFound = false;\n      allOptions = referenceOptions;\n      var usedOptions = referenceOptions;\n\n      if (subObject !== undefined) {\n        usedOptions = referenceOptions[subObject];\n      }\n\n      Validator.parse(options, usedOptions, []);\n      return errorFound;\n    }\n    /**\n     * Will traverse an object recursively and check every value\n     *\n     * @param {object} options\n     * @param {object} referenceOptions\n     * @param {Array} path    | where to look for the actual option\n     * @static\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(options, referenceOptions, path) {\n      for (var option in options) {\n        if (Object.prototype.hasOwnProperty.call(options, option)) {\n          Validator.check(option, options, referenceOptions, path);\n        }\n      }\n    }\n    /**\n     * Check every value. If the value is an object, call the parse function on that object.\n     *\n     * @param {string} option\n     * @param {object} options\n     * @param {object} referenceOptions\n     * @param {Array} path    | where to look for the actual option\n     * @static\n     */\n\n  }, {\n    key: \"check\",\n    value: function check(option, options, referenceOptions, path) {\n      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {\n        Validator.getSuggestion(option, referenceOptions, path);\n        return;\n      }\n\n      var referenceOption = option;\n      var is_object = true;\n\n      if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {\n        // NOTE: This only triggers if the __any__ is in the top level of the options object.\n        //       THAT'S A REALLY BAD PLACE TO ALLOW IT!!!!\n        // TODO: Examine if needed, remove if possible\n        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.\n        referenceOption = \"__any__\"; // if the any-subgroup is not a predefined object in the configurator,\n        // we do not look deeper into the object.\n\n        is_object = Validator.getType(options[option]) === \"object\";\n      }\n\n      var refOptionObj = referenceOptions[referenceOption];\n\n      if (is_object && refOptionObj.__type__ !== undefined) {\n        refOptionObj = refOptionObj.__type__;\n      }\n\n      Validator.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);\n    }\n    /**\n     *\n     * @param {string}  option           | the option property\n     * @param {object}  options          | The supplied options object\n     * @param {object}  referenceOptions | The reference options containing all options and their allowed formats\n     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.\n     * @param {string}  refOptionObj     | This is the type object from the reference options\n     * @param {Array}   path             | where in the object is the option\n     * @static\n     */\n\n  }, {\n    key: \"checkFields\",\n    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {\n      var log = function log(message) {\n        console.error(\"%c\" + message + Validator.printLocation(path, option), printStyle);\n      };\n\n      var optionType = Validator.getType(options[option]);\n      var refOptionType = refOptionObj[optionType];\n\n      if (refOptionType !== undefined) {\n        // if the type is correct, we check if it is supposed to be one of a few select values\n        if (Validator.getType(refOptionType) === \"array\" && indexOf$3(refOptionType).call(refOptionType, options[option]) === -1) {\n          log('Invalid option detected in \"' + option + '\".' + \" Allowed values are:\" + Validator.print(refOptionType) + ' not \"' + options[option] + '\". ');\n          errorFound = true;\n        } else if (optionType === \"object\" && referenceOption !== \"__any__\") {\n          path = copyAndExtendArray(path, option);\n          Validator.parse(options[option], referenceOptions[referenceOption], path);\n        }\n      } else if (refOptionObj[\"any\"] === undefined) {\n        // type of the field is incorrect and the field cannot be any\n        log('Invalid type received for \"' + option + '\". Expected: ' + Validator.print(keys$3(refOptionObj)) + \". Received [\" + optionType + '] \"' + options[option] + '\"');\n        errorFound = true;\n      }\n    }\n    /**\n     *\n     * @param {object | boolean | number | string | Array.<number> | Date | Node | Moment | undefined | null} object\n     * @returns {string}\n     * @static\n     */\n\n  }, {\n    key: \"getType\",\n    value: function getType(object) {\n      var type = _typeof_1(object);\n\n      if (type === \"object\") {\n        if (object === null) {\n          return \"null\";\n        }\n\n        if (object instanceof Boolean) {\n          return \"boolean\";\n        }\n\n        if (object instanceof Number) {\n          return \"number\";\n        }\n\n        if (object instanceof String) {\n          return \"string\";\n        }\n\n        if (isArray$5(object)) {\n          return \"array\";\n        }\n\n        if (object instanceof Date) {\n          return \"date\";\n        }\n\n        if (object.nodeType !== undefined) {\n          return \"dom\";\n        }\n\n        if (object._isAMomentObject === true) {\n          return \"moment\";\n        }\n\n        return \"object\";\n      } else if (type === \"number\") {\n        return \"number\";\n      } else if (type === \"boolean\") {\n        return \"boolean\";\n      } else if (type === \"string\") {\n        return \"string\";\n      } else if (type === undefined) {\n        return \"undefined\";\n      }\n\n      return type;\n    }\n    /**\n     * @param {string} option\n     * @param {object} options\n     * @param {Array.<string>} path\n     * @static\n     */\n\n  }, {\n    key: \"getSuggestion\",\n    value: function getSuggestion(option, options, path) {\n      var localSearch = Validator.findInOptions(option, options, path, false);\n      var globalSearch = Validator.findInOptions(option, allOptions, [], true);\n      var localSearchThreshold = 8;\n      var globalSearchThreshold = 4;\n      var msg;\n\n      if (localSearch.indexMatch !== undefined) {\n        msg = \" in \" + Validator.printLocation(localSearch.path, option, \"\") + 'Perhaps it was incomplete? Did you mean: \"' + localSearch.indexMatch + '\"?\\n\\n';\n      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {\n        msg = \" in \" + Validator.printLocation(localSearch.path, option, \"\") + \"Perhaps it was misplaced? Matching option found at: \" + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, \"\");\n      } else if (localSearch.distance <= localSearchThreshold) {\n        msg = '. Did you mean \"' + localSearch.closestMatch + '\"?' + Validator.printLocation(localSearch.path, option);\n      } else {\n        msg = \". Did you mean one of these: \" + Validator.print(keys$3(options)) + Validator.printLocation(path, option);\n      }\n\n      console.error('%cUnknown option detected: \"' + option + '\"' + msg, printStyle);\n      errorFound = true;\n    }\n    /**\n     * traverse the options in search for a match.\n     *\n     * @param {string} option\n     * @param {object} options\n     * @param {Array} path    | where to look for the actual option\n     * @param {boolean} [recursive=false]\n     * @returns {{closestMatch: string, path: Array, distance: number}}\n     * @static\n     */\n\n  }, {\n    key: \"findInOptions\",\n    value: function findInOptions(option, options, path) {\n      var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var min = 1e9;\n      var closestMatch = \"\";\n      var closestMatchPath = [];\n      var lowerCaseOption = option.toLowerCase();\n      var indexMatch = undefined;\n\n      for (var op in options) {\n        var distance = void 0;\n\n        if (options[op].__type__ !== undefined && recursive === true) {\n          var result = Validator.findInOptions(option, options[op], copyAndExtendArray(path, op));\n\n          if (min > result.distance) {\n            closestMatch = result.closestMatch;\n            closestMatchPath = result.path;\n            min = result.distance;\n            indexMatch = result.indexMatch;\n          }\n        } else {\n          var _context;\n\n          if (indexOf$3(_context = op.toLowerCase()).call(_context, lowerCaseOption) !== -1) {\n            indexMatch = op;\n          }\n\n          distance = Validator.levenshteinDistance(option, op);\n\n          if (min > distance) {\n            closestMatch = op;\n            closestMatchPath = copyArray(path);\n            min = distance;\n          }\n        }\n      }\n\n      return {\n        closestMatch: closestMatch,\n        path: closestMatchPath,\n        distance: min,\n        indexMatch: indexMatch\n      };\n    }\n    /**\n     * @param {Array.<string>} path\n     * @param {object} option\n     * @param {string} prefix\n     * @returns {string}\n     * @static\n     */\n\n  }, {\n    key: \"printLocation\",\n    value: function printLocation(path, option) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Problem value found at: \\n\";\n      var str = \"\\n\\n\" + prefix + \"options = {\\n\";\n\n      for (var i = 0; i < path.length; i++) {\n        for (var j = 0; j < i + 1; j++) {\n          str += \"  \";\n        }\n\n        str += path[i] + \": {\\n\";\n      }\n\n      for (var _j = 0; _j < path.length + 1; _j++) {\n        str += \"  \";\n      }\n\n      str += option + \"\\n\";\n\n      for (var _i = 0; _i < path.length + 1; _i++) {\n        for (var _j2 = 0; _j2 < path.length - _i; _j2++) {\n          str += \"  \";\n        }\n\n        str += \"}\\n\";\n      }\n\n      return str + \"\\n\\n\";\n    }\n    /**\n     * @param {object} options\n     * @returns {string}\n     * @static\n     */\n\n  }, {\n    key: \"print\",\n    value: function print(options) {\n      return stringify$2(options).replace(/(\")|(\\[)|(\\])|(,\"__type__\")/g, \"\").replace(/(,)/g, \", \");\n    }\n    /**\n     *  Compute the edit distance between the two given strings\n     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript\n     *\n     * Copyright (c) 2011 Andrei Mackenzie\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n     *\n     * @param {string} a\n     * @param {string} b\n     * @returns {Array.<Array.<number>>}}\n     * @static\n     */\n\n  }, {\n    key: \"levenshteinDistance\",\n    value: function levenshteinDistance(a, b) {\n      if (a.length === 0) return b.length;\n      if (b.length === 0) return a.length;\n      var matrix = []; // increment along the first column of each row\n\n      var i;\n\n      for (i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n      } // increment each column in the first row\n\n\n      var j;\n\n      for (j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n      } // Fill in the rest of the matrix\n\n\n      for (i = 1; i <= b.length; i++) {\n        for (j = 1; j <= a.length; j++) {\n          if (b.charAt(i - 1) == a.charAt(j - 1)) {\n            matrix[i][j] = matrix[i - 1][j - 1];\n          } else {\n            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution\n            Math.min(matrix[i][j - 1] + 1, // insertion\n            matrix[i - 1][j] + 1)); // deletion\n          }\n        }\n      }\n\n      return matrix[b.length][a.length];\n    }\n  }]);\n  return Validator;\n}();\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = keys$3(object);\n\n  if (getOwnPropertySymbols$2) {\n    var symbols = getOwnPropertySymbols$2(object);\n    if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) {\n      return getOwnPropertyDescriptor$3(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      var _context5;\n\n      forEach$2(_context5 = ownKeys$3(Object(source), true)).call(_context5, function (key) {\n        defineProperty$7(target, key, source[key]);\n      });\n    } else if (getOwnPropertyDescriptors$2) {\n      defineProperties$1(target, getOwnPropertyDescriptors$2(source));\n    } else {\n      var _context6;\n\n      forEach$2(_context6 = ownKeys$3(Object(source))).call(_context6, function (key) {\n        defineProperty$2(target, key, getOwnPropertyDescriptor$3(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * A node. A node can be connected to other nodes via one or multiple edges.\n */\n\n\nvar Node = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {object} options An object containing options for the node. All\n   *                            options are optional, except for the id.\n   *                              {number} id     Id of the node. Required\n   *                              {string} label  Text label for the node\n   *                              {number} x      Horizontal position of the node\n   *                              {number} y      Vertical position of the node\n   *                              {string} shape  Node shape\n   *                              {string} image  An image url\n   *                              {string} title  A title text, can be HTML\n   *                              {anytype} group A group name or number\n   *\n   * @param {object} body               Shared state of current network instance\n   * @param {Network.Images} imagelist  A list with images. Only needed when the node has an image\n   * @param {Groups} grouplist          A list with groups. Needed for retrieving group options\n   * @param {object} globalOptions      Current global node options; these serve as defaults for the node instance\n   * @param {object} defaultOptions     Global default options for nodes; note that this is also the prototype\n   *                                    for parameter `globalOptions`.\n   */\n  function Node(options, body, imagelist, grouplist, globalOptions, defaultOptions) {\n    classCallCheck(this, Node);\n    this.options = bridgeObject(globalOptions);\n    this.globalOptions = globalOptions;\n    this.defaultOptions = defaultOptions;\n    this.body = body;\n    this.edges = []; // all edges connected to this node\n    // set defaults for the options\n\n    this.id = undefined;\n    this.imagelist = imagelist;\n    this.grouplist = grouplist; // state options\n\n    this.x = undefined;\n    this.y = undefined;\n    this.baseSize = this.options.size;\n    this.baseFontSize = this.options.font.size;\n    this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate\n\n    this.selected = false;\n    this.hover = false;\n    this.labelModule = new Label(this.body, this.options, false\n    /* Not edge label */\n    );\n    this.setOptions(options);\n  }\n  /**\n   * Attach a edge to the node\n   *\n   * @param {Edge} edge\n   */\n\n\n  createClass(Node, [{\n    key: \"attachEdge\",\n    value: function attachEdge(edge) {\n      var _context;\n\n      if (indexOf$3(_context = this.edges).call(_context, edge) === -1) {\n        this.edges.push(edge);\n      }\n    }\n    /**\n     * Detach a edge from the node\n     *\n     * @param {Edge} edge\n     */\n\n  }, {\n    key: \"detachEdge\",\n    value: function detachEdge(edge) {\n      var _context2;\n\n      var index = indexOf$3(_context2 = this.edges).call(_context2, edge);\n\n      if (index != -1) {\n        var _context3;\n\n        splice$2(_context3 = this.edges).call(_context3, index, 1);\n      }\n    }\n    /**\n     * Set or overwrite options for the node\n     *\n     * @param {object} options an object with options\n     * @returns {null|boolean}\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var currentShape = this.options.shape;\n\n      if (!options) {\n        return; // Note that the return value will be 'undefined'! This is OK.\n      } // Save the color for later.\n      // This is necessary in order to prevent local color from being overwritten by group color.\n      // TODO: To prevent such workarounds the way options are handled should be rewritten from scratch.\n      // This is not the only problem with current options handling.\n\n\n      if (typeof options.color !== \"undefined\") {\n        this._localColor = options.color;\n      } // basic options\n\n\n      if (options.id !== undefined) {\n        this.id = options.id;\n      }\n\n      if (this.id === undefined) {\n        throw new Error(\"Node must have an id\");\n      }\n\n      Node.checkMass(options, this.id); // set these options locally\n      // clear x and y positions\n\n      if (options.x !== undefined) {\n        if (options.x === null) {\n          this.x = undefined;\n          this.predefinedPosition = false;\n        } else {\n          this.x = _parseInt$2(options.x);\n          this.predefinedPosition = true;\n        }\n      }\n\n      if (options.y !== undefined) {\n        if (options.y === null) {\n          this.y = undefined;\n          this.predefinedPosition = false;\n        } else {\n          this.y = _parseInt$2(options.y);\n          this.predefinedPosition = true;\n        }\n      }\n\n      if (options.size !== undefined) {\n        this.baseSize = options.size;\n      }\n\n      if (options.value !== undefined) {\n        options.value = _parseFloat$2(options.value);\n      } // this transforms all shorthands into fully defined options\n\n\n      Node.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);\n      var pile = [options, this.options, this.defaultOptions];\n      this.chooser = choosify(\"node\", pile);\n\n      this._load_images();\n\n      this.updateLabelModule(options); // Need to set local opacity after `this.updateLabelModule(options);` because `this.updateLabelModule(options);` overrites local opacity with group opacity\n\n      if (options.opacity !== undefined && Node.checkOpacity(options.opacity)) {\n        this.options.opacity = options.opacity;\n      }\n\n      this.updateShape(currentShape);\n      return options.hidden !== undefined || options.physics !== undefined;\n    }\n    /**\n     * Load the images from the options, for the nodes that need them.\n     *\n     * Images are always loaded, even if they are not used in the current shape.\n     * The user may switch to an image shape later on.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_load_images\",\n    value: function _load_images() {\n      if (this.options.shape === \"circularImage\" || this.options.shape === \"image\") {\n        if (this.options.image === undefined) {\n          throw new Error(\"Option image must be defined for node type '\" + this.options.shape + \"'\");\n        }\n      }\n\n      if (this.options.image === undefined) {\n        return;\n      }\n\n      if (this.imagelist === undefined) {\n        throw new Error(\"Internal Error: No images provided\");\n      }\n\n      if (typeof this.options.image === \"string\") {\n        this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);\n      } else {\n        if (this.options.image.unselected === undefined) {\n          throw new Error(\"No unselected image provided\");\n        }\n\n        this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);\n\n        if (this.options.image.selected !== undefined) {\n          this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);\n        } else {\n          this.imageObjAlt = undefined;\n        }\n      }\n    }\n    /**\n     * Check that opacity is only between 0 and 1\n     *\n     * @param {number} opacity\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getFormattingValues\",\n\n    /**\n     *\n     * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}\n     */\n    value: function getFormattingValues() {\n      var values = {\n        color: this.options.color.background,\n        opacity: this.options.opacity,\n        borderWidth: this.options.borderWidth,\n        borderColor: this.options.color.border,\n        size: this.options.size,\n        borderDashes: this.options.shapeProperties.borderDashes,\n        borderRadius: this.options.shapeProperties.borderRadius,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y\n      };\n\n      if (this.selected || this.hover) {\n        if (this.chooser === true) {\n          if (this.selected) {\n            if (this.options.borderWidthSelected != null) {\n              values.borderWidth = this.options.borderWidthSelected;\n            } else {\n              values.borderWidth *= 2;\n            }\n\n            values.color = this.options.color.highlight.background;\n            values.borderColor = this.options.color.highlight.border;\n            values.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            values.color = this.options.color.hover.background;\n            values.borderColor = this.options.color.hover.border;\n            values.shadow = this.options.shadow.enabled;\n          }\n        } else if (typeof this.chooser === \"function\") {\n          this.chooser(values, this.options.id, this.selected, this.hover);\n\n          if (values.shadow === false) {\n            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {\n              values.shadow = true;\n            }\n          }\n        }\n      } else {\n        values.shadow = this.options.shadow.enabled;\n      }\n\n      if (this.options.opacity !== undefined) {\n        var opacity = this.options.opacity;\n        values.borderColor = overrideOpacity(values.borderColor, opacity);\n        values.color = overrideOpacity(values.color, opacity);\n        values.shadowColor = overrideOpacity(values.shadowColor, opacity);\n      }\n\n      return values;\n    }\n    /**\n     *\n     * @param {object} options\n     */\n\n  }, {\n    key: \"updateLabelModule\",\n    value: function updateLabelModule(options) {\n      if (this.options.label === undefined || this.options.label === null) {\n        this.options.label = \"\";\n      }\n\n      Node.updateGroupOptions(this.options, _objectSpread$1(_objectSpread$1({}, options), {}, {\n        color: options && options.color || this._localColor || undefined\n      }), this.grouplist); //\n      // Note:The prototype chain for this.options is:\n      //\n      // this.options ->    NodesHandler.options    -> NodesHandler.defaultOptions\n      //                 (also: this.globalOptions)\n      //\n      // Note that the prototypes are mentioned explicitly in the pile list below;\n      // WE DON'T WANT THE ORDER OF THE PROTOTYPES!!!! At least, not for font handling of labels.\n      // This is a good indication that the prototype usage of options is deficient.\n      //\n\n      var currentGroup = this.grouplist.get(this.options.group, false);\n      var pile = [options, // new options\n      this.options, // current node options, see comment above for prototype\n      currentGroup, // group options, if any\n      this.globalOptions, // Currently set global node options\n      this.defaultOptions // Default global node options\n      ];\n      this.labelModule.update(this.options, pile);\n\n      if (this.labelModule.baseSize !== undefined) {\n        this.baseFontSize = this.labelModule.baseSize;\n      }\n    }\n    /**\n     *\n     * @param {string} currentShape\n     */\n\n  }, {\n    key: \"updateShape\",\n    value: function updateShape(currentShape) {\n      if (currentShape === this.options.shape && this.shape) {\n        this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);\n      } else {\n        // choose draw method depending on the shape\n        switch (this.options.shape) {\n          case \"box\":\n            this.shape = new Box(this.options, this.body, this.labelModule);\n            break;\n\n          case \"circle\":\n            this.shape = new Circle(this.options, this.body, this.labelModule);\n            break;\n\n          case \"circularImage\":\n            this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n\n          case \"custom\":\n            this.shape = new CustomShape(this.options, this.body, this.labelModule, this.options.ctxRenderer);\n            break;\n\n          case \"database\":\n            this.shape = new Database(this.options, this.body, this.labelModule);\n            break;\n\n          case \"diamond\":\n            this.shape = new Diamond(this.options, this.body, this.labelModule);\n            break;\n\n          case \"dot\":\n            this.shape = new Dot(this.options, this.body, this.labelModule);\n            break;\n\n          case \"ellipse\":\n            this.shape = new Ellipse(this.options, this.body, this.labelModule);\n            break;\n\n          case \"icon\":\n            this.shape = new Icon(this.options, this.body, this.labelModule);\n            break;\n\n          case \"image\":\n            this.shape = new Image$1(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n\n          case \"square\":\n            this.shape = new Square(this.options, this.body, this.labelModule);\n            break;\n\n          case \"hexagon\":\n            this.shape = new Hexagon(this.options, this.body, this.labelModule);\n            break;\n\n          case \"star\":\n            this.shape = new Star(this.options, this.body, this.labelModule);\n            break;\n\n          case \"text\":\n            this.shape = new Text(this.options, this.body, this.labelModule);\n            break;\n\n          case \"triangle\":\n            this.shape = new Triangle(this.options, this.body, this.labelModule);\n            break;\n\n          case \"triangleDown\":\n            this.shape = new TriangleDown(this.options, this.body, this.labelModule);\n            break;\n\n          default:\n            this.shape = new Ellipse(this.options, this.body, this.labelModule);\n            break;\n        }\n      }\n\n      this.needsRefresh();\n    }\n    /**\n     * select this node\n     */\n\n  }, {\n    key: \"select\",\n    value: function select() {\n      this.selected = true;\n      this.needsRefresh();\n    }\n    /**\n     * unselect this node\n     */\n\n  }, {\n    key: \"unselect\",\n    value: function unselect() {\n      this.selected = false;\n      this.needsRefresh();\n    }\n    /**\n     * Reset the calculated size of the node, forces it to recalculate its size\n     */\n\n  }, {\n    key: \"needsRefresh\",\n    value: function needsRefresh() {\n      this.shape.refreshNeeded = true;\n    }\n    /**\n     * get the title of this node.\n     *\n     * @returns {string} title    The title of the node, or undefined when no title\n     *                           has been set.\n     */\n\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      return this.options.title;\n    }\n    /**\n     * Calculate the distance to the border of the Node\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @param {number} angle        Angle in radians\n     * @returns {number} distance   Distance to the border in pixels\n     */\n\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this.shape.distanceToBorder(ctx, angle);\n    }\n    /**\n     * Check if this node has a fixed x and y position\n     *\n     * @returns {boolean}      true if fixed, false if not\n     */\n\n  }, {\n    key: \"isFixed\",\n    value: function isFixed() {\n      return this.options.fixed.x && this.options.fixed.y;\n    }\n    /**\n     * check if this node is selecte\n     *\n     * @returns {boolean} selected   True if node is selected, else false\n     */\n\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return this.selected;\n    }\n    /**\n     * Retrieve the value of the node. Can be undefined\n     *\n     * @returns {number} value\n     */\n\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.options.value;\n    }\n    /**\n     * Get the current dimensions of the label\n     *\n     * @returns {rect}\n     */\n\n  }, {\n    key: \"getLabelSize\",\n    value: function getLabelSize() {\n      return this.labelModule.size();\n    }\n    /**\n     * Adjust the value range of the node. The node will adjust it's size\n     * based on its value.\n     *\n     * @param {number} min\n     * @param {number} max\n     * @param {number} total\n     */\n\n  }, {\n    key: \"setValueRange\",\n    value: function setValueRange(min, max, total) {\n      if (this.options.value !== undefined) {\n        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);\n        var sizeDiff = this.options.scaling.max - this.options.scaling.min;\n\n        if (this.options.scaling.label.enabled === true) {\n          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;\n        }\n\n        this.options.size = this.options.scaling.min + scale * sizeDiff;\n      } else {\n        this.options.size = this.baseSize;\n        this.options.font.size = this.baseFontSize;\n      }\n\n      this.updateLabelModule();\n    }\n    /**\n     * Draw this node in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     *\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var values = this.getFormattingValues();\n      return this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values) || {};\n    }\n    /**\n     * Update the bounding box of the shape\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(ctx) {\n      this.shape.updateBoundingBox(this.x, this.y, ctx);\n    }\n    /**\n     * Recalculate the size of this node in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n\n  }, {\n    key: \"resize\",\n    value: function resize(ctx) {\n      var values = this.getFormattingValues();\n      this.shape.resize(ctx, this.selected, this.hover, values);\n    }\n    /**\n     * Determine all visual elements of this node instance, in which the given\n     * point falls within the bounding shape.\n     *\n     * @param {point} point\n     * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point\n     */\n\n  }, {\n    key: \"getItemsOnPoint\",\n    value: function getItemsOnPoint(point) {\n      var ret = [];\n\n      if (this.labelModule.visible()) {\n        if (pointInRect(this.labelModule.getSize(), point)) {\n          ret.push({\n            nodeId: this.id,\n            labelId: 0\n          });\n        }\n      }\n\n      if (pointInRect(this.shape.boundingBox, point)) {\n        ret.push({\n          nodeId: this.id\n        });\n      }\n\n      return ret;\n    }\n    /**\n     * Check if this object is overlapping with the provided object\n     *\n     * @param {object} obj   an object with parameters left, top, right, bottom\n     * @returns {boolean}     True if location is located on node\n     */\n\n  }, {\n    key: \"isOverlappingWith\",\n    value: function isOverlappingWith(obj) {\n      return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;\n    }\n    /**\n     * Check if this object is overlapping with the provided object\n     *\n     * @param {object} obj   an object with parameters left, top, right, bottom\n     * @returns {boolean}     True if location is located on node\n     */\n\n  }, {\n    key: \"isBoundingBoxOverlappingWith\",\n    value: function isBoundingBoxOverlappingWith(obj) {\n      return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;\n    }\n    /**\n     * Check valid values for mass\n     *\n     * The mass may not be negative or zero. If it is, reset to 1\n     *\n     * @param {object} options\n     * @param {Node.id} id\n     * @static\n     */\n\n  }], [{\n    key: \"checkOpacity\",\n    value: function checkOpacity(opacity) {\n      return 0 <= opacity && opacity <= 1;\n    }\n    /**\n     * Check that origin is 'center' or 'top-left'\n     *\n     * @param {string} origin\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"checkCoordinateOrigin\",\n    value: function checkCoordinateOrigin(origin) {\n      return origin === undefined || origin === \"center\" || origin === \"top-left\";\n    }\n    /**\n     * Copy group option values into the node options.\n     *\n     * The group options override the global node options, so the copy of group options\n     *  must happen *after* the global node options have been set.\n     *\n     * This method must also be called also if the global node options have changed and the group options did not.\n     *\n     * @param {object} parentOptions\n     * @param {object} newOptions  new values for the options, currently only passed in for check\n     * @param {object} groupList\n     */\n\n  }, {\n    key: \"updateGroupOptions\",\n    value: function updateGroupOptions(parentOptions, newOptions, groupList) {\n      var _context4;\n\n      if (groupList === undefined) return; // No groups, nothing to do\n\n      var group = parentOptions.group; // paranoia: the selected group is already merged into node options, check.\n\n      if (newOptions !== undefined && newOptions.group !== undefined && group !== newOptions.group) {\n        throw new Error(\"updateGroupOptions: group values in options don't match.\");\n      }\n\n      var hasGroup = typeof group === \"number\" || typeof group === \"string\" && group != \"\";\n      if (!hasGroup) return; // current node has no group, no need to merge\n\n      var groupObj = groupList.get(group);\n\n      if (groupObj.opacity !== undefined && newOptions.opacity === undefined) {\n        if (!Node.checkOpacity(groupObj.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + groupObj.opacity);\n          groupObj.opacity = undefined;\n        }\n      } // Skip any new option to avoid them being overridden by the group options.\n\n\n      var skipProperties = filter$2(_context4 = getOwnPropertyNames$2(newOptions)).call(_context4, function (p) {\n        return newOptions[p] != null;\n      }); // Always skip merging group font options into parent; these are required to be distinct for labels\n\n      skipProperties.push(\"font\");\n      selectiveNotDeepExtend(skipProperties, parentOptions, groupObj); // the color object needs to be completely defined.\n      // Since groups can partially overwrite the colors, we parse it again, just in case.\n\n      parentOptions.color = parseColor(parentOptions.color);\n    }\n    /**\n     * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.\n     * Static so it can also be used by the handler.\n     *\n     * @param {object} parentOptions\n     * @param {object} newOptions\n     * @param {boolean} [allowDeletion=false]\n     * @param {object} [globalOptions={}]\n     * @param {object} [groupList]\n     * @static\n     */\n\n  }, {\n    key: \"parseOptions\",\n    value: function parseOptions(parentOptions, newOptions) {\n      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var groupList = arguments.length > 4 ? arguments[4] : undefined;\n      var fields = [\"color\", \"fixed\", \"shadow\"];\n      selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);\n      Node.checkMass(newOptions);\n\n      if (parentOptions.opacity !== undefined) {\n        if (!Node.checkOpacity(parentOptions.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + parentOptions.opacity);\n          parentOptions.opacity = undefined;\n        }\n      }\n\n      if (newOptions.opacity !== undefined) {\n        if (!Node.checkOpacity(newOptions.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + newOptions.opacity);\n          newOptions.opacity = undefined;\n        }\n      }\n\n      if (newOptions.shapeProperties && !Node.checkCoordinateOrigin(newOptions.shapeProperties.coordinateOrigin)) {\n        console.error(\"Invalid option for node coordinateOrigin, found: \" + newOptions.shapeProperties.coordinateOrigin);\n      } // merge the shadow options into the parent.\n\n\n      mergeOptions(parentOptions, newOptions, \"shadow\", globalOptions); // individual shape newOptions\n\n      if (newOptions.color !== undefined && newOptions.color !== null) {\n        var parsedColor = parseColor(newOptions.color);\n        fillIfDefined(parentOptions.color, parsedColor);\n      } else if (allowDeletion === true && newOptions.color === null) {\n        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options\n      } // handle the fixed options\n\n\n      if (newOptions.fixed !== undefined && newOptions.fixed !== null) {\n        if (typeof newOptions.fixed === \"boolean\") {\n          parentOptions.fixed.x = newOptions.fixed;\n          parentOptions.fixed.y = newOptions.fixed;\n        } else {\n          if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === \"boolean\") {\n            parentOptions.fixed.x = newOptions.fixed.x;\n          }\n\n          if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === \"boolean\") {\n            parentOptions.fixed.y = newOptions.fixed.y;\n          }\n        }\n      }\n\n      if (allowDeletion === true && newOptions.font === null) {\n        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options\n      }\n\n      Node.updateGroupOptions(parentOptions, newOptions, groupList); // handle the scaling options, specifically the label part\n\n      if (newOptions.scaling !== undefined) {\n        mergeOptions(parentOptions.scaling, newOptions.scaling, \"label\", globalOptions.scaling);\n      }\n    }\n  }, {\n    key: \"checkMass\",\n    value: function checkMass(options, id) {\n      if (options.mass !== undefined && options.mass <= 0) {\n        var strId = \"\";\n\n        if (id !== undefined) {\n          strId = \" in node id: \" + id;\n        }\n\n        console.error(\"%cNegative or zero mass disallowed\" + strId + \", setting mass to 1.\", printStyle);\n        options.mass = 1;\n      }\n    }\n  }]);\n  return Node;\n}();\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$2(o, minLen) {\n  var _context4;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen);\n  var n = slice$5(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from_1$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);\n}\n\nfunction _arrayLikeToArray$2(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * Handler for Nodes\n */\n\n\nvar NodesHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Images} images\n   * @param {Array.<Group>} groups\n   * @param {LayoutEngine} layoutEngine\n   */\n  function NodesHandler(body, images, groups, layoutEngine) {\n    var _context,\n        _this = this;\n\n    classCallCheck(this, NodesHandler);\n    this.body = body;\n    this.images = images;\n    this.groups = groups;\n    this.layoutEngine = layoutEngine; // create the node API in the body container\n\n    this.body.functions.createNode = bind$2(_context = this.create).call(_context, this);\n    this.nodesListeners = {\n      add: function add(event, params) {\n        _this.add(params.items);\n      },\n      update: function update(event, params) {\n        _this.update(params.items, params.data, params.oldData);\n      },\n      remove: function remove(event, params) {\n        _this.remove(params.items);\n      }\n    };\n    this.defaultOptions = {\n      borderWidth: 1,\n      borderWidthSelected: undefined,\n      brokenImage: undefined,\n      color: {\n        border: \"#2B7CE9\",\n        background: \"#97C2FC\",\n        highlight: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        },\n        hover: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        }\n      },\n      opacity: undefined,\n      // number between 0 and 1\n      fixed: {\n        x: false,\n        y: false\n      },\n      font: {\n        color: \"#343434\",\n        size: 14,\n        // px\n        face: \"arial\",\n        background: \"none\",\n        strokeWidth: 0,\n        // px\n        strokeColor: \"#ffffff\",\n        align: \"center\",\n        vadjust: 0,\n        multi: false,\n        bold: {\n          mod: \"bold\"\n        },\n        boldital: {\n          mod: \"bold italic\"\n        },\n        ital: {\n          mod: \"italic\"\n        },\n        mono: {\n          mod: \"\",\n          size: 15,\n          // px\n          face: \"monospace\",\n          vadjust: 2\n        }\n      },\n      group: undefined,\n      hidden: false,\n      icon: {\n        face: \"FontAwesome\",\n        //'FontAwesome',\n        code: undefined,\n        //'\\uf007',\n        size: 50,\n        //50,\n        color: \"#2B7CE9\" //'#aa00ff'\n\n      },\n      image: undefined,\n      // --> URL\n      imagePadding: {\n        // only for image shape\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      label: undefined,\n      labelHighlightBold: true,\n      level: undefined,\n      margin: {\n        top: 5,\n        right: 5,\n        bottom: 5,\n        left: 5\n      },\n      mass: 1,\n      physics: true,\n      scaling: {\n        min: 10,\n        max: 30,\n        label: {\n          enabled: false,\n          min: 14,\n          max: 30,\n          maxVisible: 30,\n          drawThreshold: 5\n        },\n        customScalingFunction: function customScalingFunction(min, max, total, value) {\n          if (max === min) {\n            return 0.5;\n          } else {\n            var scale = 1 / (max - min);\n            return Math.max(0, (value - min) * scale);\n          }\n        }\n      },\n      shadow: {\n        enabled: false,\n        color: \"rgba(0,0,0,0.5)\",\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      shape: \"ellipse\",\n      shapeProperties: {\n        borderDashes: false,\n        // only for borders\n        borderRadius: 6,\n        // only for box shape\n        interpolation: true,\n        // only for image and circularImage shapes\n        useImageSize: false,\n        // only for image and circularImage shapes\n        useBorderWithImage: false,\n        // only for image shape\n        coordinateOrigin: \"center\" // only for image and circularImage shapes\n\n      },\n      size: 25,\n      title: undefined,\n      value: undefined,\n      x: undefined,\n      y: undefined\n    }; // Protect from idiocy\n\n    if (this.defaultOptions.mass <= 0) {\n      throw \"Internal error: mass in defaultOptions of NodesHandler may not be zero or negative\";\n    }\n\n    this.options = bridgeObject(this.defaultOptions);\n    this.bindEventListeners();\n  }\n  /**\n   * Binds event listeners\n   */\n\n\n  createClass(NodesHandler, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _context2,\n          _context3,\n          _this2 = this; // refresh the nodes. Used when reverting from hierarchical layout\n\n\n      this.body.emitter.on(\"refreshNodes\", bind$2(_context2 = this.refresh).call(_context2, this));\n      this.body.emitter.on(\"refresh\", bind$2(_context3 = this.refresh).call(_context3, this));\n      this.body.emitter.on(\"destroy\", function () {\n        forEach$3(_this2.nodesListeners, function (callback, event) {\n          if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);\n        });\n        delete _this2.body.functions.createNode;\n        delete _this2.nodesListeners.add;\n        delete _this2.nodesListeners.update;\n        delete _this2.nodesListeners.remove;\n        delete _this2.nodesListeners;\n      });\n    }\n    /**\n     *\n     * @param {object} options\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        Node.parseOptions(this.options, options); // Need to set opacity here because Node.parseOptions is also used for groups,\n        // if you set opacity in Node.parseOptions it overwrites group opacity.\n\n        if (options.opacity !== undefined) {\n          if (isNan$2(options.opacity) || !_isFinite$2(options.opacity) || options.opacity < 0 || options.opacity > 1) {\n            console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + options.opacity);\n          } else {\n            this.options.opacity = options.opacity;\n          }\n        } // update the shape in all nodes\n\n\n        if (options.shape !== undefined) {\n          for (var nodeId in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n              this.body.nodes[nodeId].updateShape();\n            }\n          }\n        } // Update the labels of nodes if any relevant options changed.\n\n\n        if (typeof options.font !== \"undefined\" || typeof options.widthConstraint !== \"undefined\" || typeof options.heightConstraint !== \"undefined\") {\n          for (var _i = 0, _Object$keys = keys$3(this.body.nodes); _i < _Object$keys.length; _i++) {\n            var _nodeId = _Object$keys[_i];\n\n            this.body.nodes[_nodeId].updateLabelModule();\n\n            this.body.nodes[_nodeId].needsRefresh();\n          }\n        } // update the shape size in all nodes\n\n\n        if (options.size !== undefined) {\n          for (var _nodeId2 in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {\n              this.body.nodes[_nodeId2].needsRefresh();\n            }\n          }\n        } // update the state of the variables if needed\n\n\n        if (options.hidden !== undefined || options.physics !== undefined) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n    /**\n     * Set a data set with nodes for the network\n     *\n     * @param {Array | DataSet | DataView} nodes         The data containing the nodes.\n     * @param {boolean} [doNotEmit=false] - Suppress data changed event.\n     * @private\n     */\n\n  }, {\n    key: \"setData\",\n    value: function setData(nodes) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var oldNodesData = this.body.data.nodes;\n\n      if ((0,vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.isDataViewLike)(\"id\", nodes)) {\n        this.body.data.nodes = nodes;\n      } else if (isArray$5(nodes)) {\n        this.body.data.nodes = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n        this.body.data.nodes.add(nodes);\n      } else if (!nodes) {\n        this.body.data.nodes = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n      } else {\n        throw new TypeError(\"Array or DataSet expected\");\n      }\n\n      if (oldNodesData) {\n        // unsubscribe from old dataset\n        forEach$3(this.nodesListeners, function (callback, event) {\n          oldNodesData.off(event, callback);\n        });\n      } // remove drawn nodes\n\n\n      this.body.nodes = {};\n\n      if (this.body.data.nodes) {\n        // subscribe to new dataset\n        var me = this;\n        forEach$3(this.nodesListeners, function (callback, event) {\n          me.body.data.nodes.on(event, callback);\n        }); // draw all new nodes\n\n        var ids = this.body.data.nodes.getIds();\n        this.add(ids, true);\n      }\n\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    /**\n     * Add nodes\n     *\n     * @param {number[] | string[]} ids\n     * @param {boolean} [doNotEmit=false]\n     * @private\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(ids) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var id;\n      var newNodes = [];\n\n      for (var i = 0; i < ids.length; i++) {\n        id = ids[i];\n        var properties = this.body.data.nodes.get(id);\n        var node = this.create(properties);\n        newNodes.push(node);\n        this.body.nodes[id] = node; // note: this may replace an existing node\n      }\n\n      this.layoutEngine.positionInitially(newNodes);\n\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    /**\n     * Update existing nodes, or create them when not yet existing\n     *\n     * @param {number[] | string[]} ids id's of changed nodes\n     * @param {Array} changedData array with changed data\n     * @param {Array|undefined} oldData optional; array with previous data\n     * @private\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(ids, changedData, oldData) {\n      var nodes = this.body.nodes;\n      var dataChanged = false;\n\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var node = nodes[id];\n        var data = changedData[i];\n\n        if (node !== undefined) {\n          // update node\n          if (node.setOptions(data)) {\n            dataChanged = true;\n          }\n        } else {\n          dataChanged = true; // create node\n\n          node = this.create(data);\n          nodes[id] = node;\n        }\n      }\n\n      if (!dataChanged && oldData !== undefined) {\n        // Check for any changes which should trigger a layout recalculation\n        // For now, this is just 'level' for hierarchical layout\n        // Assumption: old and new data arranged in same order; at time of writing, this holds.\n        dataChanged = some$2(changedData).call(changedData, function (newValue, index) {\n          var oldValue = oldData[index];\n          return oldValue && oldValue.level !== newValue.level;\n        });\n      }\n\n      if (dataChanged === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      } else {\n        this.body.emitter.emit(\"_dataUpdated\");\n      }\n    }\n    /**\n     * Remove existing nodes. If nodes do not exist, the method will just ignore it.\n     *\n     * @param {number[] | string[]} ids\n     * @private\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(ids) {\n      var nodes = this.body.nodes;\n\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        delete nodes[id];\n      }\n\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n    /**\n     * create a node\n     *\n     * @param {object} properties\n     * @param {class} [constructorClass=Node.default]\n     * @returns {*}\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(properties) {\n      var constructorClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Node;\n      return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);\n    }\n    /**\n     *\n     * @param {boolean} [clearPositions=false]\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this3 = this;\n\n      var clearPositions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      forEach$3(this.body.nodes, function (node, nodeId) {\n        var data = _this3.body.data.nodes.get(nodeId);\n\n        if (data !== undefined) {\n          if (clearPositions === true) {\n            node.setOptions({\n              x: null,\n              y: null\n            });\n          }\n\n          node.setOptions({\n            fixed: false\n          });\n          node.setOptions(data);\n        }\n      });\n    }\n    /**\n     * Returns the positions of the nodes.\n     *\n     * @param {Array.<Node.id> | string} [ids]  --> optional, can be array of nodeIds, can be string\n     * @returns {{}}\n     */\n\n  }, {\n    key: \"getPositions\",\n    value: function getPositions(ids) {\n      var dataArray = {};\n\n      if (ids !== undefined) {\n        if (isArray$5(ids) === true) {\n          for (var i = 0; i < ids.length; i++) {\n            if (this.body.nodes[ids[i]] !== undefined) {\n              var node = this.body.nodes[ids[i]];\n              dataArray[ids[i]] = {\n                x: Math.round(node.x),\n                y: Math.round(node.y)\n              };\n            }\n          }\n        } else {\n          if (this.body.nodes[ids] !== undefined) {\n            var _node = this.body.nodes[ids];\n            dataArray[ids] = {\n              x: Math.round(_node.x),\n              y: Math.round(_node.y)\n            };\n          }\n        }\n      } else {\n        for (var _i2 = 0; _i2 < this.body.nodeIndices.length; _i2++) {\n          var _node2 = this.body.nodes[this.body.nodeIndices[_i2]];\n          dataArray[this.body.nodeIndices[_i2]] = {\n            x: Math.round(_node2.x),\n            y: Math.round(_node2.y)\n          };\n        }\n      }\n\n      return dataArray;\n    }\n    /**\n     * Retrieves the x y position of a specific id.\n     *\n     * @param {string} id The id to retrieve.\n     *\n     * @throws {TypeError} If no id is included.\n     * @throws {ReferenceError} If an invalid id is provided.\n     *\n     * @returns {{ x: number, y: number }} Returns X, Y canvas position of the node with given id.\n     */\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(id) {\n      if (id == undefined) {\n        throw new TypeError(\"No id was specified for getPosition method.\");\n      } else if (this.body.nodes[id] == undefined) {\n        throw new ReferenceError(\"NodeId provided for getPosition does not exist. Provided: \".concat(id));\n      } else {\n        return {\n          x: Math.round(this.body.nodes[id].x),\n          y: Math.round(this.body.nodes[id].y)\n        };\n      }\n    }\n    /**\n     * Load the XY positions of the nodes into the dataset.\n     */\n\n  }, {\n    key: \"storePositions\",\n    value: function storePositions() {\n      // todo: add support for clusters and hierarchical.\n      var dataArray = [];\n      var dataset = this.body.data.nodes.getDataSet();\n\n      var _iterator = _createForOfIteratorHelper$1(dataset.get()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dsNode = _step.value;\n          var id = dsNode.id;\n          var bodyNode = this.body.nodes[id];\n          var x = Math.round(bodyNode.x);\n          var y = Math.round(bodyNode.y);\n\n          if (dsNode.x !== x || dsNode.y !== y) {\n            dataArray.push({\n              id: id,\n              x: x,\n              y: y\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      dataset.update(dataArray);\n    }\n    /**\n     * get the bounding box of a node.\n     *\n     * @param {Node.id} nodeId\n     * @returns {j|*}\n     */\n\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(nodeId) {\n      if (this.body.nodes[nodeId] !== undefined) {\n        return this.body.nodes[nodeId].shape.boundingBox;\n      }\n    }\n    /**\n     * Get the Ids of nodes connected to this node.\n     *\n     * @param {Node.id} nodeId\n     * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.\n     *                                          Any other value returns both parent and child nodes.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getConnectedNodes\",\n    value: function getConnectedNodes(nodeId, direction) {\n      var nodeList = [];\n\n      if (this.body.nodes[nodeId] !== undefined) {\n        var node = this.body.nodes[nodeId];\n        var nodeObj = {}; // used to quickly check if node already exists\n\n        for (var i = 0; i < node.edges.length; i++) {\n          var edge = node.edges[i];\n\n          if (direction !== \"to\" && edge.toId == node.id) {\n            // these are double equals since ids can be numeric or string\n            if (nodeObj[edge.fromId] === undefined) {\n              nodeList.push(edge.fromId);\n              nodeObj[edge.fromId] = true;\n            }\n          } else if (direction !== \"from\" && edge.fromId == node.id) {\n            // these are double equals since ids can be numeric or string\n            if (nodeObj[edge.toId] === undefined) {\n              nodeList.push(edge.toId);\n              nodeObj[edge.toId] = true;\n            }\n          }\n        }\n      }\n\n      return nodeList;\n    }\n    /**\n     * Get the ids of the edges connected to this node.\n     *\n     * @param {Node.id} nodeId\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getConnectedEdges\",\n    value: function getConnectedEdges(nodeId) {\n      var edgeList = [];\n\n      if (this.body.nodes[nodeId] !== undefined) {\n        var node = this.body.nodes[nodeId];\n\n        for (var i = 0; i < node.edges.length; i++) {\n          edgeList.push(node.edges[i].id);\n        }\n      } else {\n        console.error(\"NodeId provided for getConnectedEdges does not exist. Provided: \", nodeId);\n      }\n\n      return edgeList;\n    }\n    /**\n     * Move a node.\n     *\n     * @param {Node.id} nodeId\n     * @param {number} x\n     * @param {number} y\n     */\n\n  }, {\n    key: \"moveNode\",\n    value: function moveNode(nodeId, x, y) {\n      var _this4 = this;\n\n      if (this.body.nodes[nodeId] !== undefined) {\n        this.body.nodes[nodeId].x = Number(x);\n        this.body.nodes[nodeId].y = Number(y);\n        setTimeout$2(function () {\n          _this4.body.emitter.emit(\"startSimulation\");\n        }, 0);\n      } else {\n        console.error(\"Node id supplied to moveNode does not exist. Provided: \", nodeId);\n      }\n    }\n  }]);\n  return NodesHandler;\n}();\n\nvar getOwnPropertyDescriptor$4 = getOwnPropertyDescriptor_1;\nvar getOwnPropertyDescriptor$5 = getOwnPropertyDescriptor$4; // https://tc39.github.io/ecma262/#sec-reflect.get\n\nfunction get$1(target, propertyKey\n/* , receiver */\n) {\n  var receiver = arguments.length < 3 ? target : arguments[2];\n  var descriptor, prototype;\n  if (anObject(target) === receiver) return target[propertyKey];\n  if (descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey)) return has(descriptor, 'value') ? descriptor.value : descriptor.get === undefined ? undefined : descriptor.get.call(receiver);\n  if (isObject(prototype = objectGetPrototypeOf(target))) return get$1(prototype, propertyKey, receiver);\n}\n\n_export({\n  target: 'Reflect',\n  stat: true\n}, {\n  get: get$1\n});\n\nvar get$2 = path.Reflect.get;\nvar get$3 = get$2;\nvar get$4 = get$3;\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf$5(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nvar superPropBase = _superPropBase;\nvar get$5 = createCommonjsModule(function (module) {\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && get$4) {\n      module.exports = _get = get$4;\n    } else {\n      module.exports = _get = function _get(target, property, receiver) {\n        var base = superPropBase(target, property);\n        if (!base) return;\n        var desc = getOwnPropertyDescriptor$5(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  module.exports = _get;\n});\nvar $hypot = Math.hypot;\nvar abs$1 = Math.abs;\nvar sqrt = Math.sqrt; // Chrome 77 bug\n// https://bugs.chromium.org/p/v8/issues/detail?id=9546\n\nvar BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity; // `Math.hypot` method\n// https://tc39.github.io/ecma262/#sec-math.hypot\n\n_export({\n  target: 'Math',\n  stat: true,\n  forced: BUGGY\n}, {\n  hypot: function hypot(value1, value2) {\n    // eslint-disable-line no-unused-vars\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n\n    while (i < aLen) {\n      arg = abs$1(arguments[i++]);\n\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n\n    return larg === Infinity ? Infinity : larg * sqrt(sum);\n  }\n});\n\nvar hypot = path.Math.hypot;\nvar hypot$1 = hypot;\nvar hypot$2 = hypot$1;\n\nfunction _createSuper$i(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$i() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * Common methods for endpoints\r\n *\r\n * @class\r\n */\n\n\nvar EndPoint = /*#__PURE__*/function () {\n  function EndPoint() {\n    classCallCheck(this, EndPoint);\n  }\n\n  createClass(EndPoint, null, [{\n    key: \"transform\",\n\n    /**\r\n     * Apply transformation on points for display.\r\n     *\r\n     * The following is done:\r\n     * - rotate by the specified angle\r\n     * - multiply the (normalized) coordinates by the passed length\r\n     * - offset by the target coordinates\r\n     *\r\n     * @param points - The point(s) to be transformed.\r\n     * @param arrowData - The data determining the result of the transformation.\r\n     */\n    value: function transform(points, arrowData) {\n      if (!isArray$5(points)) {\n        points = [points];\n      }\n\n      var x = arrowData.point.x;\n      var y = arrowData.point.y;\n      var angle = arrowData.angle;\n      var length = arrowData.length;\n\n      for (var i = 0; i < points.length; ++i) {\n        var p = points[i];\n        var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);\n        var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);\n        p.x = x + length * xt;\n        p.y = y + length * yt;\n      }\n    }\n    /**\r\n     * Draw a closed path using the given real coordinates.\r\n     *\r\n     * @param ctx - The path will be rendered into this context.\r\n     * @param points - The points of the path.\r\n     */\n\n  }, {\n    key: \"drawPath\",\n    value: function drawPath(ctx, points) {\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n\n      for (var i = 1; i < points.length; ++i) {\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n\n      ctx.closePath();\n    }\n  }]);\n  return EndPoint;\n}();\n/**\r\n * Drawing methods for the arrow endpoint.\r\n */\n\n\nvar Image$2 = /*#__PURE__*/function (_EndPoint) {\n  inherits(Image, _EndPoint);\n\n  var _super = _createSuper$i(Image);\n\n  function Image() {\n    classCallCheck(this, Image);\n    return _super.apply(this, arguments);\n  }\n\n  createClass(Image, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns False as there is no way to fill an image.\r\n     */\n    value: function draw(ctx, arrowData) {\n      if (arrowData.image) {\n        ctx.save();\n        ctx.translate(arrowData.point.x, arrowData.point.y);\n        ctx.rotate(Math.PI / 2 + arrowData.angle);\n        var width = arrowData.imageWidth != null ? arrowData.imageWidth : arrowData.image.width;\n        var height = arrowData.imageHeight != null ? arrowData.imageHeight : arrowData.image.height;\n        arrowData.image.drawImageAtPosition(ctx, 1, // scale\n        -width / 2, // x\n        0, // y\n        width, height);\n        ctx.restore();\n      }\n\n      return false;\n    }\n  }]);\n  return Image;\n}(EndPoint);\n/**\r\n * Drawing methods for the arrow endpoint.\r\n */\n\n\nvar Arrow = /*#__PURE__*/function (_EndPoint2) {\n  inherits(Arrow, _EndPoint2);\n\n  var _super2 = _createSuper$i(Arrow);\n\n  function Arrow() {\n    classCallCheck(this, Arrow);\n    return _super2.apply(this, arguments);\n  }\n\n  createClass(Arrow, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -1,\n        y: 0.3\n      }, {\n        x: -0.9,\n        y: 0\n      }, {\n        x: -1,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Arrow;\n}(EndPoint);\n/**\r\n * Drawing methods for the crow endpoint.\r\n */\n\n\nvar Crow = /*#__PURE__*/function () {\n  function Crow() {\n    classCallCheck(this, Crow);\n  }\n\n  createClass(Crow, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: -1,\n        y: 0\n      }, {\n        x: 0,\n        y: 0.3\n      }, {\n        x: -0.4,\n        y: 0\n      }, {\n        x: 0,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Crow;\n}();\n/**\r\n * Drawing methods for the curve endpoint.\r\n */\n\n\nvar Curve = /*#__PURE__*/function () {\n  function Curve() {\n    classCallCheck(this, Curve);\n  }\n\n  createClass(Curve, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var point = {\n        x: -0.4,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData); // Update endpoint style for drawing transparent arc.\n\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0)\"; // Define curve endpoint as semicircle.\n\n      var pi = Math.PI;\n      var startAngle = arrowData.angle - pi / 2;\n      var endAngle = arrowData.angle + pi / 2;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);\n      ctx.stroke();\n      return true;\n    }\n  }]);\n  return Curve;\n}();\n/**\r\n * Drawing methods for the inverted curve endpoint.\r\n */\n\n\nvar InvertedCurve = /*#__PURE__*/function () {\n  function InvertedCurve() {\n    classCallCheck(this, InvertedCurve);\n  }\n\n  createClass(InvertedCurve, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var point = {\n        x: -0.3,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData); // Update endpoint style for drawing transparent arc.\n\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0)\"; // Define inverted curve endpoint as semicircle.\n\n      var pi = Math.PI;\n      var startAngle = arrowData.angle + pi / 2;\n      var endAngle = arrowData.angle + 3 * pi / 2;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);\n      ctx.stroke();\n      return true;\n    }\n  }]);\n  return InvertedCurve;\n}();\n/**\r\n * Drawing methods for the trinagle endpoint.\r\n */\n\n\nvar Triangle$1 = /*#__PURE__*/function () {\n  function Triangle() {\n    classCallCheck(this, Triangle);\n  }\n\n  createClass(Triangle, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: 0.02,\n        y: 0\n      }, {\n        x: -1,\n        y: 0.3\n      }, {\n        x: -1,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Triangle;\n}();\n/**\r\n * Drawing methods for the inverted trinagle endpoint.\r\n */\n\n\nvar InvertedTriangle = /*#__PURE__*/function () {\n  function InvertedTriangle() {\n    classCallCheck(this, InvertedTriangle);\n  }\n\n  createClass(InvertedTriangle, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: 0,\n        y: 0.3\n      }, {\n        x: 0,\n        y: -0.3\n      }, {\n        x: -1,\n        y: 0\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return InvertedTriangle;\n}();\n/**\r\n * Drawing methods for the circle endpoint.\r\n */\n\n\nvar Circle$1 = /*#__PURE__*/function () {\n  function Circle() {\n    classCallCheck(this, Circle);\n  }\n\n  createClass(Circle, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      var point = {\n        x: -0.4,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData);\n      drawCircle(ctx, point.x, point.y, arrowData.length * 0.4);\n      return true;\n    }\n  }]);\n  return Circle;\n}();\n/**\r\n * Drawing methods for the bar endpoint.\r\n */\n\n\nvar Bar = /*#__PURE__*/function () {\n  function Bar() {\n    classCallCheck(this, Bar);\n  }\n\n  createClass(Bar, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      /*\r\n      var points = [\r\n        {x:0, y:0.5},\r\n        {x:0, y:-0.5}\r\n      ];\r\n           EndPoint.transform(points, arrowData);\r\n      ctx.beginPath();\r\n      ctx.moveTo(points[0].x, points[0].y);\r\n      ctx.lineTo(points[1].x, points[1].y);\r\n      ctx.stroke();\r\n      */\n      var points = [{\n        x: 0,\n        y: 0.5\n      }, {\n        x: 0,\n        y: -0.5\n      }, {\n        x: -0.15,\n        y: -0.5\n      }, {\n        x: -0.15,\n        y: 0.5\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Bar;\n}();\n/**\r\n * Drawing methods for the box endpoint.\r\n */\n\n\nvar Box$1 = /*#__PURE__*/function () {\n  function Box() {\n    classCallCheck(this, Box);\n  }\n\n  createClass(Box, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0.3\n      }, {\n        x: 0,\n        y: -0.3\n      }, {\n        x: -0.6,\n        y: -0.3\n      }, {\n        x: -0.6,\n        y: 0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Box;\n}();\n/**\r\n * Drawing methods for the diamond endpoint.\r\n */\n\n\nvar Diamond$1 = /*#__PURE__*/function () {\n  function Diamond() {\n    classCallCheck(this, Diamond);\n  }\n\n  createClass(Diamond, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -0.5,\n        y: -0.3\n      }, {\n        x: -1,\n        y: 0\n      }, {\n        x: -0.5,\n        y: 0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Diamond;\n}();\n/**\r\n * Drawing methods for the vee endpoint.\r\n */\n\n\nvar Vee = /*#__PURE__*/function () {\n  function Vee() {\n    classCallCheck(this, Vee);\n  }\n\n  createClass(Vee, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    value: function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: -1,\n        y: 0.3\n      }, {\n        x: -0.5,\n        y: 0\n      }, {\n        x: -1,\n        y: -0.3\n      }, {\n        x: 0,\n        y: 0\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Vee;\n}();\n/**\r\n * Drawing methods for the endpoints.\r\n */\n\n\nvar EndPoints = /*#__PURE__*/function () {\n  function EndPoints() {\n    classCallCheck(this, EndPoints);\n  }\n\n  createClass(EndPoints, null, [{\n    key: \"draw\",\n\n    /**\r\n     * Draw an endpoint.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     *\r\n     * @returns True if ctx.fill() can be used to fill the arrow, false otherwise.\r\n     */\n    value: function draw(ctx, arrowData) {\n      var type;\n\n      if (arrowData.type) {\n        type = arrowData.type.toLowerCase();\n      }\n\n      switch (type) {\n        case \"image\":\n          return Image$2.draw(ctx, arrowData);\n\n        case \"circle\":\n          return Circle$1.draw(ctx, arrowData);\n\n        case \"box\":\n          return Box$1.draw(ctx, arrowData);\n\n        case \"crow\":\n          return Crow.draw(ctx, arrowData);\n\n        case \"curve\":\n          return Curve.draw(ctx, arrowData);\n\n        case \"diamond\":\n          return Diamond$1.draw(ctx, arrowData);\n\n        case \"inv_curve\":\n          return InvertedCurve.draw(ctx, arrowData);\n\n        case \"triangle\":\n          return Triangle$1.draw(ctx, arrowData);\n\n        case \"inv_triangle\":\n          return InvertedTriangle.draw(ctx, arrowData);\n\n        case \"bar\":\n          return Bar.draw(ctx, arrowData);\n\n        case \"vee\":\n          return Vee.draw(ctx, arrowData);\n\n        case \"arrow\": // fall-through\n\n        default:\n          return Arrow.draw(ctx, arrowData);\n      }\n    }\n  }]);\n  return EndPoints;\n}();\n\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = keys$3(object);\n\n  if (getOwnPropertySymbols$2) {\n    var symbols = getOwnPropertySymbols$2(object);\n    if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) {\n      return getOwnPropertyDescriptor$3(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      var _context2;\n\n      forEach$2(_context2 = ownKeys$4(Object(source), true)).call(_context2, function (key) {\n        defineProperty$7(target, key, source[key]);\n      });\n    } else if (getOwnPropertyDescriptors$2) {\n      defineProperties$1(target, getOwnPropertyDescriptors$2(source));\n    } else {\n      var _context3;\n\n      forEach$2(_context3 = ownKeys$4(Object(source))).call(_context3, function (key) {\n        defineProperty$2(target, key, getOwnPropertyDescriptor$3(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\r\n * The Base Class for all edges.\r\n */\n\n\nvar EdgeBase = /*#__PURE__*/function () {\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param _body - The body of the network.\r\n   * @param _labelModule - Label module.\r\n   */\n  function EdgeBase(options, _body, _labelModule) {\n    classCallCheck(this, EdgeBase);\n    this._body = _body;\n    this._labelModule = _labelModule;\n    this.color = {};\n    this.colorDirty = true;\n    this.hoverWidth = 1.5;\n    this.selectionWidth = 2;\n    this.setOptions(options);\n    this.fromPoint = this.from;\n    this.toPoint = this.to;\n  }\n  /** @inheritDoc */\n\n\n  createClass(EdgeBase, [{\n    key: \"connect\",\n    value: function connect() {\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      return false;\n    }\n    /**\r\n     * Set new edge options.\r\n     *\r\n     * @param options - The new edge options object.\r\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n      this.id = this.options.id;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(ctx, values, _selected, _hover) {\n      var viaNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.getViaNode(); // set style\n\n      ctx.strokeStyle = this.getColor(ctx, values);\n      ctx.lineWidth = values.width;\n\n      if (values.dashes !== false) {\n        this._drawDashedLine(ctx, values, viaNode);\n      } else {\n        this._drawLine(ctx, values, viaNode);\n      }\n    }\n    /**\r\n     * Draw a line with given style between two nodes through supplied node(s).\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param viaNode - Additional control point(s) for the edge.\r\n     * @param fromPoint - TODO: Seems ignored, remove?\r\n     * @param toPoint - TODO: Seems ignored, remove?\r\n     */\n\n  }, {\n    key: \"_drawLine\",\n    value: function _drawLine(ctx, values, viaNode, fromPoint, toPoint) {\n      if (this.from != this.to) {\n        // draw line\n        this._line(ctx, values, viaNode, fromPoint, toPoint);\n      } else {\n        var _this$_getCircleData = this._getCircleData(ctx),\n            _this$_getCircleData2 = slicedToArray(_this$_getCircleData, 3),\n            x = _this$_getCircleData2[0],\n            y = _this$_getCircleData2[1],\n            radius = _this$_getCircleData2[2];\n\n        this._circle(ctx, values, x, y, radius);\n      }\n    }\n    /**\r\n     * Draw a dashed line with given style between two nodes through supplied node(s).\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param viaNode - Additional control point(s) for the edge.\r\n     * @param _fromPoint - Ignored (TODO: remove in the future).\r\n     * @param _toPoint - Ignored (TODO: remove in the future).\r\n     */\n\n  }, {\n    key: \"_drawDashedLine\",\n    value: function _drawDashedLine(ctx, values, viaNode, _fromPoint, _toPoint) {\n      ctx.lineCap = \"round\";\n      var pattern = isArray$5(values.dashes) ? values.dashes : [5, 5]; // only firefox and chrome support this method, else we use the legacy one.\n\n      if (ctx.setLineDash !== undefined) {\n        ctx.save(); // set dash settings for chrome or firefox\n\n        ctx.setLineDash(pattern);\n        ctx.lineDashOffset = 0; // draw the line\n\n        if (this.from != this.to) {\n          // draw line\n          this._line(ctx, values, viaNode);\n        } else {\n          var _this$_getCircleData3 = this._getCircleData(ctx),\n              _this$_getCircleData4 = slicedToArray(_this$_getCircleData3, 3),\n              x = _this$_getCircleData4[0],\n              y = _this$_getCircleData4[1],\n              radius = _this$_getCircleData4[2];\n\n          this._circle(ctx, values, x, y, radius);\n        } // restore the dash settings.\n\n\n        ctx.setLineDash([0]);\n        ctx.lineDashOffset = 0;\n        ctx.restore();\n      } else {\n        // unsupporting smooth lines\n        if (this.from != this.to) {\n          // draw line\n          drawDashedLine(ctx, this.from.x, this.from.y, this.to.x, this.to.y, pattern);\n        } else {\n          var _this$_getCircleData5 = this._getCircleData(ctx),\n              _this$_getCircleData6 = slicedToArray(_this$_getCircleData5, 3),\n              _x = _this$_getCircleData6[0],\n              _y = _this$_getCircleData6[1],\n              _radius = _this$_getCircleData6[2];\n\n          this._circle(ctx, values, _x, _y, _radius);\n        } // draw shadow if enabled\n\n\n        this.enableShadow(ctx, values);\n        ctx.stroke(); // disable shadows for other elements.\n\n        this.disableShadow(ctx, values);\n      }\n    }\n    /**\r\n     * Find the intersection between the border of the node and the edge.\r\n     *\r\n     * @param node - The node (either from or to node of the edge).\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param options - Additional options.\r\n     *\r\n     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.\r\n     */\n\n  }, {\n    key: \"findBorderPosition\",\n    value: function findBorderPosition(node, ctx, options) {\n      if (this.from != this.to) {\n        return this._findBorderPosition(node, ctx, options);\n      } else {\n        return this._findBorderPositionCircle(node, ctx, options);\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"findBorderPositions\",\n    value: function findBorderPositions(ctx) {\n      if (this.from != this.to) {\n        return {\n          from: this._findBorderPosition(this.from, ctx),\n          to: this._findBorderPosition(this.to, ctx)\n        };\n      } else {\n        var _context;\n\n        var _this$_getCircleData$ = slice$5(_context = this._getCircleData(ctx)).call(_context, 0, 2),\n            _this$_getCircleData$2 = slicedToArray(_this$_getCircleData$, 2),\n            x = _this$_getCircleData$2[0],\n            y = _this$_getCircleData$2[1];\n\n        return {\n          from: this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: 0.25,\n            high: 0.6,\n            direction: -1\n          }),\n          to: this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: 0.6,\n            high: 0.8,\n            direction: 1\n          })\n        };\n      }\n    }\n    /**\r\n     * Compute the center point and radius of an edge connected to the same node at both ends.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     *\r\n     * @returns `[x, y, radius]`\r\n     */\n\n  }, {\n    key: \"_getCircleData\",\n    value: function _getCircleData(ctx) {\n      var radius = this.options.selfReference.size;\n\n      if (ctx !== undefined) {\n        if (this.from.shape.width === undefined) {\n          this.from.shape.resize(ctx);\n        }\n      } // get circle coordinates\n\n\n      var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, radius, this.from);\n      return [coordinates.x, coordinates.y, radius];\n    }\n    /**\r\n     * Get a point on a circle.\r\n     *\r\n     * @param x - Center of the circle on the x axis.\r\n     * @param y - Center of the circle on the y axis.\r\n     * @param radius - Radius of the circle.\r\n     * @param position - Value between 0 (line start) and 1 (line end).\r\n     *\r\n     * @returns Cartesian coordinates of requested point on the circle.\r\n     */\n\n  }, {\n    key: \"_pointOnCircle\",\n    value: function _pointOnCircle(x, y, radius, position) {\n      var angle = position * 2 * Math.PI;\n      return {\n        x: x + radius * Math.cos(angle),\n        y: y - radius * Math.sin(angle)\n      };\n    }\n    /**\r\n     * Find the intersection between the border of the node and the edge.\r\n     *\r\n     * @remarks\r\n     * This function uses binary search to look for the point where the circle crosses the border of the node.\r\n     *\r\n     * @param nearNode - The node (either from or to node of the edge).\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param options - Additional options.\r\n     *\r\n     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.\r\n     */\n\n  }, {\n    key: \"_findBorderPositionCircle\",\n    value: function _findBorderPositionCircle(nearNode, ctx, options) {\n      var x = options.x;\n      var y = options.y;\n      var low = options.low;\n      var high = options.high;\n      var direction = options.direction;\n      var maxIterations = 10;\n      var radius = this.options.selfReference.size;\n      var threshold = 0.05;\n      var pos;\n      var middle = (low + high) * 0.5;\n      var endPointOffset = 0;\n\n      if (this.options.arrowStrikethrough === true) {\n        if (direction === -1) {\n          endPointOffset = this.options.endPointOffset.from;\n        } else if (direction === 1) {\n          endPointOffset = this.options.endPointOffset.to;\n        }\n      }\n\n      var iteration = 0;\n\n      do {\n        middle = (low + high) * 0.5;\n        pos = this._pointOnCircle(x, y, radius, middle);\n        var angle = Math.atan2(nearNode.y - pos.y, nearNode.x - pos.x);\n        var distanceToBorder = nearNode.distanceToBorder(ctx, angle) + endPointOffset;\n        var distanceToPoint = Math.sqrt(Math.pow(pos.x - nearNode.x, 2) + Math.pow(pos.y - nearNode.y, 2));\n        var difference = distanceToBorder - distanceToPoint;\n\n        if (Math.abs(difference) < threshold) {\n          break; // found\n        } else if (difference > 0) {\n          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.\n          if (direction > 0) {\n            low = middle;\n          } else {\n            high = middle;\n          }\n        } else {\n          if (direction > 0) {\n            high = middle;\n          } else {\n            low = middle;\n          }\n        }\n\n        ++iteration;\n      } while (low <= high && iteration < maxIterations);\n\n      return _objectSpread$2(_objectSpread$2({}, pos), {}, {\n        t: middle\n      });\n    }\n    /**\r\n     * Get the line width of the edge. Depends on width and whether one of the connected nodes is selected.\r\n     *\r\n     * @param selected - Determines wheter the line is selected.\r\n     * @param hover - Determines wheter the line is being hovered, only applies if selected is false.\r\n     *\r\n     * @returns The width of the line.\r\n     */\n\n  }, {\n    key: \"getLineWidth\",\n    value: function getLineWidth(selected, hover) {\n      if (selected === true) {\n        return Math.max(this.selectionWidth, 0.3 / this._body.view.scale);\n      } else if (hover === true) {\n        return Math.max(this.hoverWidth, 0.3 / this._body.view.scale);\n      } else {\n        return Math.max(this.options.width, 0.3 / this._body.view.scale);\n      }\n    }\n    /**\r\n     * Compute the color or gradient for given edge.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param _selected - Ignored (TODO: remove in the future).\r\n     * @param _hover - Ignored (TODO: remove in the future).\r\n     *\r\n     * @returns Color string if single color is inherited or gradient if two.\r\n     */\n\n  }, {\n    key: \"getColor\",\n    value: function getColor(ctx, values) {\n      if (values.inheritsColor !== false) {\n        // when this is a loop edge, just use the 'from' method\n        if (values.inheritsColor === \"both\" && this.from.id !== this.to.id) {\n          var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);\n          var fromColor = this.from.options.color.highlight.border;\n          var toColor = this.to.options.color.highlight.border;\n\n          if (this.from.selected === false && this.to.selected === false) {\n            fromColor = overrideOpacity(this.from.options.color.border, values.opacity);\n            toColor = overrideOpacity(this.to.options.color.border, values.opacity);\n          } else if (this.from.selected === true && this.to.selected === false) {\n            toColor = this.to.options.color.border;\n          } else if (this.from.selected === false && this.to.selected === true) {\n            fromColor = this.from.options.color.border;\n          }\n\n          grd.addColorStop(0, fromColor);\n          grd.addColorStop(1, toColor); // -------------------- this returns -------------------- //\n\n          return grd;\n        }\n\n        if (values.inheritsColor === \"to\") {\n          return overrideOpacity(this.to.options.color.border, values.opacity);\n        } else {\n          // \"from\"\n          return overrideOpacity(this.from.options.color.border, values.opacity);\n        }\n      } else {\n        return overrideOpacity(values.color, values.opacity);\n      }\n    }\n    /**\r\n     * Draw a line from a node to itself, a circle.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param x - Center of the circle on the x axis.\r\n     * @param y - Center of the circle on the y axis.\r\n     * @param radius - Radius of the circle.\r\n     */\n\n  }, {\n    key: \"_circle\",\n    value: function _circle(ctx, values, x, y, radius) {\n      // draw shadow if enabled\n      this.enableShadow(ctx, values); //full circle\n\n      var angleFrom = 0;\n      var angleTo = Math.PI * 2;\n\n      if (!this.options.selfReference.renderBehindTheNode) {\n        //render only parts which are not overlaping with parent node\n        //need to find x,y of from point and x,y to point\n        //calculating radians\n        var low = this.options.selfReference.angle;\n        var high = this.options.selfReference.angle + Math.PI;\n\n        var pointTFrom = this._findBorderPositionCircle(this.from, ctx, {\n          x: x,\n          y: y,\n          low: low,\n          high: high,\n          direction: -1\n        });\n\n        var pointTTo = this._findBorderPositionCircle(this.from, ctx, {\n          x: x,\n          y: y,\n          low: low,\n          high: high,\n          direction: 1\n        });\n\n        angleFrom = Math.atan2(pointTFrom.y - y, pointTFrom.x - x);\n        angleTo = Math.atan2(pointTTo.y - y, pointTTo.x - x);\n      } // draw a circle\n\n\n      ctx.beginPath();\n      ctx.arc(x, y, radius, angleFrom, angleTo, false);\n      ctx.stroke(); // disable shadows for other elements.\n\n      this.disableShadow(ctx, values);\n    }\n    /**\r\n     * @inheritDoc\r\n     *\r\n     * @remarks\r\n     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\r\n     */\n\n  }, {\n    key: \"getDistanceToEdge\",\n    value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      if (this.from != this.to) {\n        return this._getDistanceToEdge(x1, y1, x2, y2, x3, y3);\n      } else {\n        var _this$_getCircleData7 = this._getCircleData(undefined),\n            _this$_getCircleData8 = slicedToArray(_this$_getCircleData7, 3),\n            x = _this$_getCircleData8[0],\n            y = _this$_getCircleData8[1],\n            radius = _this$_getCircleData8[2];\n\n        var dx = x - x3;\n        var dy = y - y3;\n        return Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);\n      }\n    }\n    /**\r\n     * Calculate the distance between a point (x3, y3) and a line segment from (x1, y1) to (x2, y2).\r\n     *\r\n     * @param x1 - First end of the line segment on the x axis.\r\n     * @param y1 - First end of the line segment on the y axis.\r\n     * @param x2 - Second end of the line segment on the x axis.\r\n     * @param y2 - Second end of the line segment on the y axis.\r\n     * @param x3 - Position of the point on the x axis.\r\n     * @param y3 - Position of the point on the y axis.\r\n     *\r\n     * @returns The distance between the line segment and the point.\r\n     */\n\n  }, {\n    key: \"_getDistanceToLine\",\n    value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {\n      var px = x2 - x1;\n      var py = y2 - y1;\n      var something = px * px + py * py;\n      var u = ((x3 - x1) * px + (y3 - y1) * py) / something;\n\n      if (u > 1) {\n        u = 1;\n      } else if (u < 0) {\n        u = 0;\n      }\n\n      var x = x1 + u * px;\n      var y = y1 + u * py;\n      var dx = x - x3;\n      var dy = y - y3; //# Note: If the actual distance does not matter,\n      //# if you only want to compare what this function\n      //# returns to other results of this function, you\n      //# can just return the squared distance instead\n      //# (i.e. remove the sqrt) to gain a little performance\n\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getArrowData\",\n    value: function getArrowData(ctx, position, viaNode, _selected, _hover, values) {\n      // set lets\n      var angle;\n      var arrowPoint;\n      var node1;\n      var node2;\n      var reversed;\n      var scaleFactor;\n      var type;\n      var lineWidth = values.width;\n\n      if (position === \"from\") {\n        node1 = this.from;\n        node2 = this.to;\n        reversed = values.fromArrowScale < 0;\n        scaleFactor = Math.abs(values.fromArrowScale);\n        type = values.fromArrowType;\n      } else if (position === \"to\") {\n        node1 = this.to;\n        node2 = this.from;\n        reversed = values.toArrowScale < 0;\n        scaleFactor = Math.abs(values.toArrowScale);\n        type = values.toArrowType;\n      } else {\n        node1 = this.to;\n        node2 = this.from;\n        reversed = values.middleArrowScale < 0;\n        scaleFactor = Math.abs(values.middleArrowScale);\n        type = values.middleArrowType;\n      }\n\n      var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.\n      // if not connected to itself\n\n      if (node1 != node2) {\n        var approximateEdgeLength = hypot$2(node1.x - node2.x, node1.y - node2.y);\n        var relativeLength = length / approximateEdgeLength;\n\n        if (position !== \"middle\") {\n          // draw arrow head\n          if (this.options.smooth.enabled === true) {\n            var pointT = this._findBorderPosition(node1, ctx, {\n              via: viaNode\n            });\n\n            var guidePos = this.getPoint(pointT.t + relativeLength * (position === \"from\" ? 1 : -1), viaNode);\n            angle = Math.atan2(pointT.y - guidePos.y, pointT.x - guidePos.x);\n            arrowPoint = pointT;\n          } else {\n            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n            arrowPoint = this._findBorderPosition(node1, ctx);\n          }\n        } else {\n          // Negative half length reverses arrow direction.\n          var halfLength = (reversed ? -relativeLength : relativeLength) / 2;\n          var guidePos1 = this.getPoint(0.5 + halfLength, viaNode);\n          var guidePos2 = this.getPoint(0.5 - halfLength, viaNode);\n          angle = Math.atan2(guidePos1.y - guidePos2.y, guidePos1.x - guidePos2.x);\n          arrowPoint = this.getPoint(0.5, viaNode);\n        }\n      } else {\n        // draw circle\n        var _this$_getCircleData9 = this._getCircleData(ctx),\n            _this$_getCircleData10 = slicedToArray(_this$_getCircleData9, 3),\n            x = _this$_getCircleData10[0],\n            y = _this$_getCircleData10[1],\n            radius = _this$_getCircleData10[2];\n\n        if (position === \"from\") {\n          var low = this.options.selfReference.angle;\n          var high = this.options.selfReference.angle + Math.PI;\n\n          var _pointT = this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: low,\n            high: high,\n            direction: -1\n          });\n\n          angle = _pointT.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;\n          arrowPoint = _pointT;\n        } else if (position === \"to\") {\n          var _low = this.options.selfReference.angle;\n\n          var _high = this.options.selfReference.angle + Math.PI;\n\n          var _pointT2 = this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: _low,\n            high: _high,\n            direction: 1\n          });\n\n          angle = _pointT2.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;\n          arrowPoint = _pointT2;\n        } else {\n          var pos = this.options.selfReference.angle / (2 * Math.PI);\n          arrowPoint = this._pointOnCircle(x, y, radius, pos);\n          angle = pos * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;\n        }\n      }\n\n      var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);\n      var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);\n      var arrowCore = {\n        x: xi,\n        y: yi\n      };\n      return {\n        point: arrowPoint,\n        core: arrowCore,\n        angle: angle,\n        length: length,\n        type: type\n      };\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"drawArrowHead\",\n    value: function drawArrowHead(ctx, values, _selected, _hover, arrowData) {\n      // set style\n      ctx.strokeStyle = this.getColor(ctx, values);\n      ctx.fillStyle = ctx.strokeStyle;\n      ctx.lineWidth = values.width;\n      var canFill = EndPoints.draw(ctx, arrowData);\n\n      if (canFill) {\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n        fill$2(ctx).call(ctx); // disable shadows for other elements.\n\n        this.disableShadow(ctx, values);\n      }\n    }\n    /**\r\n     * Set the shadow formatting values in the context if enabled, do nothing otherwise.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values for the shadow.\r\n     */\n\n  }, {\n    key: \"enableShadow\",\n    value: function enableShadow(ctx, values) {\n      if (values.shadow === true) {\n        ctx.shadowColor = values.shadowColor;\n        ctx.shadowBlur = values.shadowSize;\n        ctx.shadowOffsetX = values.shadowX;\n        ctx.shadowOffsetY = values.shadowY;\n      }\n    }\n    /**\r\n     * Reset the shadow formatting values in the context if enabled, do nothing otherwise.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values for the shadow.\r\n     */\n\n  }, {\n    key: \"disableShadow\",\n    value: function disableShadow(ctx, values) {\n      if (values.shadow === true) {\n        ctx.shadowColor = \"rgba(0,0,0,0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n    }\n    /**\r\n     * Render the background according to the formatting values.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values for the background.\r\n     */\n\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground(ctx, values) {\n      if (values.background !== false) {\n        // save original line attrs\n        var origCtxAttr = {\n          strokeStyle: ctx.strokeStyle,\n          lineWidth: ctx.lineWidth,\n          dashes: ctx.dashes\n        };\n        ctx.strokeStyle = values.backgroundColor;\n        ctx.lineWidth = values.backgroundSize;\n        this.setStrokeDashed(ctx, values.backgroundDashes);\n        ctx.stroke(); // restore original line attrs\n\n        ctx.strokeStyle = origCtxAttr.strokeStyle;\n        ctx.lineWidth = origCtxAttr.lineWidth;\n        ctx.dashes = origCtxAttr.dashes;\n        this.setStrokeDashed(ctx, values.dashes);\n      }\n    }\n    /**\r\n     * Set the line dash pattern if supported. Logs a warning to the console if it isn't supported.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param dashes - The pattern [line, space, line…], true for default dashed line or false for normal line.\r\n     */\n\n  }, {\n    key: \"setStrokeDashed\",\n    value: function setStrokeDashed(ctx, dashes) {\n      if (dashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          var pattern = isArray$5(dashes) ? dashes : [5, 5];\n          ctx.setLineDash(pattern);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n        }\n      } else {\n        if (ctx.setLineDash !== undefined) {\n          ctx.setLineDash([]);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n        }\n      }\n    }\n  }]);\n  return EdgeBase;\n}();\n\nfunction ownKeys$5(object, enumerableOnly) {\n  var keys = keys$3(object);\n\n  if (getOwnPropertySymbols$2) {\n    var symbols = getOwnPropertySymbols$2(object);\n    if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) {\n      return getOwnPropertyDescriptor$3(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      var _context;\n\n      forEach$2(_context = ownKeys$5(Object(source), true)).call(_context, function (key) {\n        defineProperty$7(target, key, source[key]);\n      });\n    } else if (getOwnPropertyDescriptors$2) {\n      defineProperties$1(target, getOwnPropertyDescriptors$2(source));\n    } else {\n      var _context2;\n\n      forEach$2(_context2 = ownKeys$5(Object(source))).call(_context2, function (key) {\n        defineProperty$2(target, key, getOwnPropertyDescriptor$3(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper$j(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$j() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * The Base Class for all Bezier edges.\r\n * Bezier curves are used to model smooth gradual curves in paths between nodes.\r\n */\n\n\nvar BezierEdgeBase = /*#__PURE__*/function (_EdgeBase) {\n  inherits(BezierEdgeBase, _EdgeBase);\n\n  var _super = _createSuper$j(BezierEdgeBase);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n\n\n  function BezierEdgeBase(options, body, labelModule) {\n    classCallCheck(this, BezierEdgeBase);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\r\n   * Find the intersection between the border of the node and the edge.\r\n   *\r\n   * @remarks\r\n   * This function uses binary search to look for the point where the bezier curve crosses the border of the node.\r\n   *\r\n   * @param nearNode - The node (either from or to node of the edge).\r\n   * @param ctx - The context that will be used for rendering.\r\n   * @param viaNode - Additional node(s) the edge passes through.\r\n   *\r\n   * @returns Cartesian coordinates of the intersection between the border of the node and the edge.\r\n   */\n\n\n  createClass(BezierEdgeBase, [{\n    key: \"_findBorderPositionBezier\",\n    value: function _findBorderPositionBezier(nearNode, ctx) {\n      var viaNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._getViaCoordinates();\n      var maxIterations = 10;\n      var threshold = 0.2;\n      var from = false;\n      var high = 1;\n      var low = 0;\n      var node = this.to;\n      var pos;\n      var middle;\n      var endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.to : 0;\n\n      if (nearNode.id === this.from.id) {\n        node = this.from;\n        from = true;\n        endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.from : 0;\n      }\n\n      if (this.options.arrowStrikethrough === false) {\n        endPointOffset = 0;\n      }\n\n      var iteration = 0;\n\n      do {\n        middle = (low + high) * 0.5;\n        pos = this.getPoint(middle, viaNode);\n        var angle = Math.atan2(node.y - pos.y, node.x - pos.x);\n        var distanceToBorder = node.distanceToBorder(ctx, angle) + endPointOffset;\n        var distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));\n        var difference = distanceToBorder - distanceToPoint;\n\n        if (Math.abs(difference) < threshold) {\n          break; // found\n        } else if (difference < 0) {\n          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.\n          if (from === false) {\n            low = middle;\n          } else {\n            high = middle;\n          }\n        } else {\n          if (from === false) {\n            high = middle;\n          } else {\n            low = middle;\n          }\n        }\n\n        ++iteration;\n      } while (low <= high && iteration < maxIterations);\n\n      return _objectSpread$3(_objectSpread$3({}, pos), {}, {\n        t: middle\n      });\n    }\n    /**\r\n     * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).\r\n     *\r\n     * @remarks\r\n     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\r\n     *\r\n     * @param x1 - First end of the line segment on the x axis.\r\n     * @param y1 - First end of the line segment on the y axis.\r\n     * @param x2 - Second end of the line segment on the x axis.\r\n     * @param y2 - Second end of the line segment on the y axis.\r\n     * @param x3 - Position of the point on the x axis.\r\n     * @param y3 - Position of the point on the y axis.\r\n     * @param via - The control point for the edge.\r\n     *\r\n     * @returns The distance between the line segment and the point.\r\n     */\n\n  }, {\n    key: \"_getDistanceToBezierEdge\",\n    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {\n      // x3,y3 is the point\n      var minDistance = 1e9;\n      var distance;\n      var i, t, x, y;\n      var lastX = x1;\n      var lastY = y1;\n\n      for (i = 1; i < 10; i++) {\n        t = 0.1 * i;\n        x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;\n        y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;\n\n        if (i > 0) {\n          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);\n          minDistance = distance < minDistance ? distance : minDistance;\n        }\n\n        lastX = x;\n        lastY = y;\n      }\n\n      return minDistance;\n    }\n    /**\r\n     * Render a bezier curve between two nodes.\r\n     *\r\n     * @remarks\r\n     * The method accepts zero, one or two control points.\r\n     * Passing zero control points just draws a straight line.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Style options for edge drawing.\r\n     * @param viaNode1 - First control point for curve drawing.\r\n     * @param viaNode2 - Second control point for curve drawing.\r\n     */\n\n  }, {\n    key: \"_bezierCurve\",\n    value: function _bezierCurve(ctx, values, viaNode1, viaNode2) {\n      ctx.beginPath();\n      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);\n\n      if (viaNode1 != null && viaNode1.x != null) {\n        if (viaNode2 != null && viaNode2.x != null) {\n          ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);\n        } else {\n          ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);\n        }\n      } else {\n        // fallback to normal straight edge\n        ctx.lineTo(this.toPoint.x, this.toPoint.y);\n      } // draw a background\n\n\n      this.drawBackground(ctx, values); // draw shadow if enabled\n\n      this.enableShadow(ctx, values);\n      ctx.stroke();\n      this.disableShadow(ctx, values);\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n  }]);\n  return BezierEdgeBase;\n}(EdgeBase);\n\nfunction _createSuper$k(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$k() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * A Dynamic Bezier Edge. Bezier curves are used to model smooth gradual\r\n * curves in paths between nodes. The Dynamic piece refers to how the curve\r\n * reacts to physics changes.\r\n *\r\n * @augments BezierEdgeBase\r\n */\n\n\nvar BezierEdgeDynamic = /*#__PURE__*/function (_BezierEdgeBase) {\n  inherits(BezierEdgeDynamic, _BezierEdgeBase);\n\n  var _super = _createSuper$k(BezierEdgeDynamic);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n\n\n  function BezierEdgeDynamic(options, body, labelModule) {\n    var _this;\n\n    classCallCheck(this, BezierEdgeDynamic); //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.\n\n    _this = _super.call(this, options, body, labelModule); // --> this calls the setOptions below\n\n    _this.via = _this.via; // constructor → super → super → setOptions → setupSupportNode\n\n    _this._boundFunction = function () {\n      _this.positionBezierNode();\n    };\n\n    _this._body.emitter.on(\"_repositionBezierNodes\", _this._boundFunction);\n\n    return _this;\n  }\n  /** @inheritDoc */\n\n\n  createClass(BezierEdgeDynamic, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      get$5(getPrototypeOf$5(BezierEdgeDynamic.prototype), \"setOptions\", this).call(this, options); // check if the physics has changed.\n\n      var physicsChange = false;\n\n      if (this.options.physics !== options.physics) {\n        physicsChange = true;\n      } // set the options and the to and from nodes\n\n\n      this.options = options;\n      this.id = this.options.id;\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to]; // setup the support node and connect\n\n      this.setupSupportNode();\n      this.connect(); // when we change the physics state of the edge, we reposition the support node.\n\n      if (physicsChange === true) {\n        this.via.setOptions({\n          physics: this.options.physics\n        });\n        this.positionBezierNode();\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n\n      if (this.from === undefined || this.to === undefined || this.options.physics === false) {\n        this.via.setOptions({\n          physics: false\n        });\n      } else {\n        // fix weird behaviour where a self referencing node has physics enabled\n        if (this.from.id === this.to.id) {\n          this.via.setOptions({\n            physics: false\n          });\n        } else {\n          this.via.setOptions({\n            physics: true\n          });\n        }\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this._body.emitter.off(\"_repositionBezierNodes\", this._boundFunction);\n\n      if (this.via !== undefined) {\n        delete this._body.nodes[this.via.id];\n        this.via = undefined;\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * Create and add a support node if not already present.\r\n     *\r\n     * @remarks\r\n     * Bezier curves require an anchor point to calculate the smooth flow.\r\n     * These points are nodes.\r\n     * These nodes are invisible but are used for the force calculation.\r\n     *\r\n     * The changed data is not called, if needed, it is returned by the main edge constructor.\r\n     */\n\n  }, {\n    key: \"setupSupportNode\",\n    value: function setupSupportNode() {\n      if (this.via === undefined) {\n        var nodeId = \"edgeId:\" + this.id;\n\n        var node = this._body.functions.createNode({\n          id: nodeId,\n          shape: \"circle\",\n          physics: true,\n          hidden: true\n        });\n\n        this._body.nodes[nodeId] = node;\n        this.via = node;\n        this.via.parentEdgeId = this.id;\n        this.positionBezierNode();\n      }\n    }\n    /**\r\n     * Position bezier node.\r\n     */\n\n  }, {\n    key: \"positionBezierNode\",\n    value: function positionBezierNode() {\n      if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {\n        this.via.x = 0.5 * (this.from.x + this.to.x);\n        this.via.y = 0.5 * (this.from.y + this.to.y);\n      } else if (this.via !== undefined) {\n        this.via.x = 0;\n        this.via.y = 0;\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"_line\",\n    value: function _line(ctx, values, viaNode) {\n      this._bezierCurve(ctx, values, viaNode);\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      return this.via;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this.via;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.via;\n\n      if (this.from === this.to) {\n        var _this$_getCircleData = this._getCircleData(),\n            _this$_getCircleData2 = slicedToArray(_this$_getCircleData, 3),\n            cx = _this$_getCircleData2[0],\n            cy = _this$_getCircleData2[1],\n            cr = _this$_getCircleData2[2];\n\n        var a = 2 * Math.PI * (1 - position);\n        return {\n          x: cx + cr * Math.sin(a),\n          y: cy + cr - cr * (1 - Math.cos(a))\n        };\n      } else {\n        return {\n          x: Math.pow(1 - position, 2) * this.fromPoint.x + 2 * position * (1 - position) * viaNode.x + Math.pow(position, 2) * this.toPoint.x,\n          y: Math.pow(1 - position, 2) * this.fromPoint.y + 2 * position * (1 - position) * viaNode.y + Math.pow(position, 2) * this.toPoint.y\n        };\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      return this._findBorderPositionBezier(nearNode, ctx, this.via);\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      // x3,y3 is the point\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);\n    }\n  }]);\n  return BezierEdgeDynamic;\n}(BezierEdgeBase);\n\nfunction _createSuper$l(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$l() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * A Static Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.\r\n */\n\n\nvar BezierEdgeStatic = /*#__PURE__*/function (_BezierEdgeBase) {\n  inherits(BezierEdgeStatic, _BezierEdgeBase);\n\n  var _super = _createSuper$l(BezierEdgeStatic);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n\n\n  function BezierEdgeStatic(options, body, labelModule) {\n    classCallCheck(this, BezierEdgeStatic);\n    return _super.call(this, options, body, labelModule);\n  }\n  /** @inheritDoc */\n\n\n  createClass(BezierEdgeStatic, [{\n    key: \"_line\",\n    value: function _line(ctx, values, viaNode) {\n      this._bezierCurve(ctx, values, viaNode);\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n    /**\r\n     * Compute the coordinates of the via node.\r\n     *\r\n     * @remarks\r\n     * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.\r\n     *\r\n     * @returns Cartesian coordinates of the via node.\r\n     */\n\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      // Assumption: x/y coordinates in from/to always defined\n      var factor = this.options.smooth.roundness;\n      var type = this.options.smooth.type;\n      var dx = Math.abs(this.from.x - this.to.x);\n      var dy = Math.abs(this.from.y - this.to.y);\n\n      if (type === \"discrete\" || type === \"diagonalCross\") {\n        var stepX;\n        var stepY;\n\n        if (dx <= dy) {\n          stepX = stepY = factor * dy;\n        } else {\n          stepX = stepY = factor * dx;\n        }\n\n        if (this.from.x > this.to.x) {\n          stepX = -stepX;\n        }\n\n        if (this.from.y >= this.to.y) {\n          stepY = -stepY;\n        }\n\n        var xVia = this.from.x + stepX;\n        var yVia = this.from.y + stepY;\n\n        if (type === \"discrete\") {\n          if (dx <= dy) {\n            xVia = dx < factor * dy ? this.from.x : xVia;\n          } else {\n            yVia = dy < factor * dx ? this.from.y : yVia;\n          }\n        }\n\n        return {\n          x: xVia,\n          y: yVia\n        };\n      } else if (type === \"straightCross\") {\n        var _stepX = (1 - factor) * dx;\n\n        var _stepY = (1 - factor) * dy;\n\n        if (dx <= dy) {\n          // up - down\n          _stepX = 0;\n\n          if (this.from.y < this.to.y) {\n            _stepY = -_stepY;\n          }\n        } else {\n          // left - right\n          if (this.from.x < this.to.x) {\n            _stepX = -_stepX;\n          }\n\n          _stepY = 0;\n        }\n\n        return {\n          x: this.to.x + _stepX,\n          y: this.to.y + _stepY\n        };\n      } else if (type === \"horizontal\") {\n        var _stepX2 = (1 - factor) * dx;\n\n        if (this.from.x < this.to.x) {\n          _stepX2 = -_stepX2;\n        }\n\n        return {\n          x: this.to.x + _stepX2,\n          y: this.from.y\n        };\n      } else if (type === \"vertical\") {\n        var _stepY2 = (1 - factor) * dy;\n\n        if (this.from.y < this.to.y) {\n          _stepY2 = -_stepY2;\n        }\n\n        return {\n          x: this.from.x,\n          y: this.to.y + _stepY2\n        };\n      } else if (type === \"curvedCW\") {\n        dx = this.to.x - this.from.x;\n        dy = this.from.y - this.to.y;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        var pi = Math.PI;\n        var originalAngle = Math.atan2(dy, dx);\n        var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);\n        return {\n          x: this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle),\n          y: this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle)\n        };\n      } else if (type === \"curvedCCW\") {\n        dx = this.to.x - this.from.x;\n        dy = this.from.y - this.to.y;\n\n        var _radius = Math.sqrt(dx * dx + dy * dy);\n\n        var _pi = Math.PI;\n\n        var _originalAngle = Math.atan2(dy, dx);\n\n        var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);\n\n        return {\n          x: this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle),\n          y: this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle)\n        };\n      } else {\n        // continuous\n        var _stepX3;\n\n        var _stepY3;\n\n        if (dx <= dy) {\n          _stepX3 = _stepY3 = factor * dy;\n        } else {\n          _stepX3 = _stepY3 = factor * dx;\n        }\n\n        if (this.from.x > this.to.x) {\n          _stepX3 = -_stepX3;\n        }\n\n        if (this.from.y >= this.to.y) {\n          _stepY3 = -_stepY3;\n        }\n\n        var _xVia = this.from.x + _stepX3;\n\n        var _yVia = this.from.y + _stepY3;\n\n        if (dx <= dy) {\n          if (this.from.x <= this.to.x) {\n            _xVia = this.to.x < _xVia ? this.to.x : _xVia;\n          } else {\n            _xVia = this.to.x > _xVia ? this.to.x : _xVia;\n          }\n        } else {\n          if (this.from.y >= this.to.y) {\n            _yVia = this.to.y > _yVia ? this.to.y : _yVia;\n          } else {\n            _yVia = this.to.y < _yVia ? this.to.y : _yVia;\n          }\n        }\n\n        return {\n          x: _xVia,\n          y: _yVia\n        };\n      }\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this._findBorderPositionBezier(nearNode, ctx, options.via);\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      var viaNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates(); // x3,y3 is the point\n\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates();\n      var t = position;\n      var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;\n      var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }]);\n  return BezierEdgeStatic;\n}(BezierEdgeBase);\n\nfunction _createSuper$m(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$m() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * A Base Class for all Cubic Bezier Edges. Bezier curves are used to model\r\n * smooth gradual curves in paths between nodes.\r\n *\r\n * @augments BezierEdgeBase\r\n */\n\n\nvar CubicBezierEdgeBase = /*#__PURE__*/function (_BezierEdgeBase) {\n  inherits(CubicBezierEdgeBase, _BezierEdgeBase);\n\n  var _super = _createSuper$m(CubicBezierEdgeBase);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n\n\n  function CubicBezierEdgeBase(options, body, labelModule) {\n    classCallCheck(this, CubicBezierEdgeBase);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\r\n   * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).\r\n   *\r\n   * @remarks\r\n   * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\r\n   * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n   *\r\n   * @param x1 - First end of the line segment on the x axis.\r\n   * @param y1 - First end of the line segment on the y axis.\r\n   * @param x2 - Second end of the line segment on the x axis.\r\n   * @param y2 - Second end of the line segment on the y axis.\r\n   * @param x3 - Position of the point on the x axis.\r\n   * @param y3 - Position of the point on the y axis.\r\n   * @param via1 - The first point this edge passes through.\r\n   * @param via2 - The second point this edge passes through.\r\n   *\r\n   * @returns The distance between the line segment and the point.\r\n   */\n\n\n  createClass(CubicBezierEdgeBase, [{\n    key: \"_getDistanceToBezierEdge2\",\n    value: function _getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2) {\n      // x3,y3 is the point\n      var minDistance = 1e9;\n      var lastX = x1;\n      var lastY = y1;\n      var vec = [0, 0, 0, 0];\n\n      for (var i = 1; i < 10; i++) {\n        var t = 0.1 * i;\n        vec[0] = Math.pow(1 - t, 3);\n        vec[1] = 3 * t * Math.pow(1 - t, 2);\n        vec[2] = 3 * Math.pow(t, 2) * (1 - t);\n        vec[3] = Math.pow(t, 3);\n        var x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;\n        var y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;\n\n        if (i > 0) {\n          var distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);\n\n          minDistance = distance < minDistance ? distance : minDistance;\n        }\n\n        lastX = x;\n        lastY = y;\n      }\n\n      return minDistance;\n    }\n  }]);\n  return CubicBezierEdgeBase;\n}(BezierEdgeBase);\n\nfunction _createSuper$n(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$n() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * A Cubic Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.\r\n */\n\n\nvar CubicBezierEdge = /*#__PURE__*/function (_CubicBezierEdgeBase) {\n  inherits(CubicBezierEdge, _CubicBezierEdgeBase);\n\n  var _super = _createSuper$n(CubicBezierEdge);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n\n\n  function CubicBezierEdge(options, body, labelModule) {\n    classCallCheck(this, CubicBezierEdge);\n    return _super.call(this, options, body, labelModule);\n  }\n  /** @inheritDoc */\n\n\n  createClass(CubicBezierEdge, [{\n    key: \"_line\",\n    value: function _line(ctx, values, viaNodes) {\n      // get the coordinates of the support points.\n      var via1 = viaNodes[0];\n      var via2 = viaNodes[1];\n\n      this._bezierCurve(ctx, values, via1, via2);\n    }\n    /**\r\n     * Compute the additional points the edge passes through.\r\n     *\r\n     * @returns Cartesian coordinates of the points the edge passes through.\r\n     */\n\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      var dx = this.from.x - this.to.x;\n      var dy = this.from.y - this.to.y;\n      var x1;\n      var y1;\n      var x2;\n      var y2;\n      var roundness = this.options.smooth.roundness; // horizontal if x > y or if direction is forced or if direction is horizontal\n\n      if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === \"horizontal\") && this.options.smooth.forceDirection !== \"vertical\") {\n        y1 = this.from.y;\n        y2 = this.to.y;\n        x1 = this.from.x - roundness * dx;\n        x2 = this.to.x + roundness * dx;\n      } else {\n        y1 = this.from.y - roundness * dy;\n        y2 = this.to.y + roundness * dy;\n        x1 = this.from.x;\n        x2 = this.to.x;\n      }\n\n      return [{\n        x: x1,\n        y: y1\n      }, {\n        x: x2,\n        y: y2\n      }];\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      return this._findBorderPositionBezier(nearNode, ctx);\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      var _ref = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates(),\n          _ref2 = slicedToArray(_ref, 2),\n          via1 = _ref2[0],\n          via2 = _ref2[1]; // x3,y3 is the point\n\n\n      return this._getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2);\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates(),\n          _ref4 = slicedToArray(_ref3, 2),\n          via1 = _ref4[0],\n          via2 = _ref4[1];\n\n      var t = position;\n      var vec = [Math.pow(1 - t, 3), 3 * t * Math.pow(1 - t, 2), 3 * Math.pow(t, 2) * (1 - t), Math.pow(t, 3)];\n      var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;\n      var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }]);\n  return CubicBezierEdge;\n}(CubicBezierEdgeBase);\n\nfunction _createSuper$o(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$o() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * A Straight Edge.\r\n */\n\n\nvar StraightEdge = /*#__PURE__*/function (_EdgeBase) {\n  inherits(StraightEdge, _EdgeBase);\n\n  var _super = _createSuper$o(StraightEdge);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n\n\n  function StraightEdge(options, body, labelModule) {\n    classCallCheck(this, StraightEdge);\n    return _super.call(this, options, body, labelModule);\n  }\n  /** @inheritDoc */\n\n\n  createClass(StraightEdge, [{\n    key: \"_line\",\n    value: function _line(ctx, values) {\n      // draw a straight line\n      ctx.beginPath();\n      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);\n      ctx.lineTo(this.toPoint.x, this.toPoint.y); // draw shadow if enabled\n\n      this.enableShadow(ctx, values);\n      ctx.stroke();\n      this.disableShadow(ctx, values);\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return undefined;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      return {\n        x: (1 - position) * this.fromPoint.x + position * this.toPoint.x,\n        y: (1 - position) * this.fromPoint.y + position * this.toPoint.y\n      };\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      var node1 = this.to;\n      var node2 = this.from;\n\n      if (nearNode.id === this.from.id) {\n        node1 = this.from;\n        node2 = this.to;\n      }\n\n      var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n      var dx = node1.x - node2.x;\n      var dy = node1.y - node2.y;\n      var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);\n      var toBorderDist = nearNode.distanceToBorder(ctx, angle);\n      var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;\n      return {\n        x: (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x,\n        y: (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y,\n        t: 0\n      };\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      // x3,y3 is the point\n      return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);\n    }\n  }]);\n  return StraightEdge;\n}(EdgeBase);\n/**\n * An edge connects two nodes and has a specific direction.\n */\n\n\nvar Edge = /*#__PURE__*/function () {\n  /**\n   * @param {object} options        values specific to this edge, must contain at least 'from' and 'to'\n   * @param {object} body           shared state from Network instance\n   * @param {Network.Images} imagelist  A list with images. Only needed when the edge has image arrows.\n   * @param {object} globalOptions  options from the EdgesHandler instance\n   * @param {object} defaultOptions default options from the EdgeHandler instance. Value and reference are constant\n   */\n  function Edge(options, body, imagelist, globalOptions, defaultOptions) {\n    classCallCheck(this, Edge);\n\n    if (body === undefined) {\n      throw new Error(\"No body provided\");\n    } // Since globalOptions is constant in values as well as reference,\n    // Following needs to be done only once.\n\n\n    this.options = bridgeObject(globalOptions);\n    this.globalOptions = globalOptions;\n    this.defaultOptions = defaultOptions;\n    this.body = body;\n    this.imagelist = imagelist; // initialize variables\n\n    this.id = undefined;\n    this.fromId = undefined;\n    this.toId = undefined;\n    this.selected = false;\n    this.hover = false;\n    this.labelDirty = true;\n    this.baseWidth = this.options.width;\n    this.baseFontSize = this.options.font.size;\n    this.from = undefined; // a node\n\n    this.to = undefined; // a node\n\n    this.edgeType = undefined;\n    this.connected = false;\n    this.labelModule = new Label(this.body, this.options, true\n    /* It's an edge label */\n    );\n    this.setOptions(options);\n  }\n  /**\n   * Set or overwrite options for the edge\n   *\n   * @param {object} options  an object with options\n   * @returns {undefined|boolean} undefined if no options, true if layout affecting data changed, false otherwise.\n   */\n\n\n  createClass(Edge, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (!options) {\n        return;\n      } // Following options if changed affect the layout.\n\n\n      var affectsLayout = typeof options.physics !== \"undefined\" && this.options.physics !== options.physics || typeof options.hidden !== \"undefined\" && (this.options.hidden || false) !== (options.hidden || false) || typeof options.from !== \"undefined\" && this.options.from !== options.from || typeof options.to !== \"undefined\" && this.options.to !== options.to;\n      Edge.parseOptions(this.options, options, true, this.globalOptions);\n\n      if (options.id !== undefined) {\n        this.id = options.id;\n      }\n\n      if (options.from !== undefined) {\n        this.fromId = options.from;\n      }\n\n      if (options.to !== undefined) {\n        this.toId = options.to;\n      }\n\n      if (options.title !== undefined) {\n        this.title = options.title;\n      }\n\n      if (options.value !== undefined) {\n        options.value = _parseFloat$2(options.value);\n      }\n\n      var pile = [options, this.options, this.defaultOptions];\n      this.chooser = choosify(\"edge\", pile); // update label Module\n\n      this.updateLabelModule(options); // Update edge type, this if changed affects the layout.\n\n      affectsLayout = this.updateEdgeType() || affectsLayout; // if anything has been updates, reset the selection width and the hover width\n\n      this._setInteractionWidths(); // A node is connected when it has a from and to node that both exist in the network.body.nodes.\n\n\n      this.connect();\n      return affectsLayout;\n    }\n    /**\n     *\n     * @param {object} parentOptions\n     * @param {object} newOptions\n     * @param {boolean} [allowDeletion=false]\n     * @param {object} [globalOptions={}]\n     * @param {boolean} [copyFromGlobals=false]\n     */\n\n  }, {\n    key: \"getFormattingValues\",\n\n    /**\n     *\n     * @returns {ArrowOptions}\n     */\n    value: function getFormattingValues() {\n      var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;\n      var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;\n      var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;\n      var inheritsColor = this.options.color.inherit;\n      var values = {\n        toArrow: toArrow,\n        toArrowScale: this.options.arrows.to.scaleFactor,\n        toArrowType: this.options.arrows.to.type,\n        toArrowSrc: this.options.arrows.to.src,\n        toArrowImageWidth: this.options.arrows.to.imageWidth,\n        toArrowImageHeight: this.options.arrows.to.imageHeight,\n        middleArrow: middleArrow,\n        middleArrowScale: this.options.arrows.middle.scaleFactor,\n        middleArrowType: this.options.arrows.middle.type,\n        middleArrowSrc: this.options.arrows.middle.src,\n        middleArrowImageWidth: this.options.arrows.middle.imageWidth,\n        middleArrowImageHeight: this.options.arrows.middle.imageHeight,\n        fromArrow: fromArrow,\n        fromArrowScale: this.options.arrows.from.scaleFactor,\n        fromArrowType: this.options.arrows.from.type,\n        fromArrowSrc: this.options.arrows.from.src,\n        fromArrowImageWidth: this.options.arrows.from.imageWidth,\n        fromArrowImageHeight: this.options.arrows.from.imageHeight,\n        arrowStrikethrough: this.options.arrowStrikethrough,\n        color: inheritsColor ? undefined : this.options.color.color,\n        inheritsColor: inheritsColor,\n        opacity: this.options.color.opacity,\n        hidden: this.options.hidden,\n        length: this.options.length,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y,\n        dashes: this.options.dashes,\n        width: this.options.width,\n        background: this.options.background.enabled,\n        backgroundColor: this.options.background.color,\n        backgroundSize: this.options.background.size,\n        backgroundDashes: this.options.background.dashes\n      };\n\n      if (this.selected || this.hover) {\n        if (this.chooser === true) {\n          if (this.selected) {\n            var selectedWidth = this.options.selectionWidth;\n\n            if (typeof selectedWidth === \"function\") {\n              values.width = selectedWidth(values.width);\n            } else if (typeof selectedWidth === \"number\") {\n              values.width += selectedWidth;\n            }\n\n            values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n            values.color = this.options.color.highlight;\n            values.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            var hoverWidth = this.options.hoverWidth;\n\n            if (typeof hoverWidth === \"function\") {\n              values.width = hoverWidth(values.width);\n            } else if (typeof hoverWidth === \"number\") {\n              values.width += hoverWidth;\n            }\n\n            values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n            values.color = this.options.color.hover;\n            values.shadow = this.options.shadow.enabled;\n          }\n        } else if (typeof this.chooser === \"function\") {\n          this.chooser(values, this.options.id, this.selected, this.hover);\n\n          if (values.color !== undefined) {\n            values.inheritsColor = false;\n          }\n\n          if (values.shadow === false) {\n            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {\n              values.shadow = true;\n            }\n          }\n        }\n      } else {\n        values.shadow = this.options.shadow.enabled;\n        values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n      }\n\n      return values;\n    }\n    /**\n     * update the options in the label module\n     *\n     * @param {object} options\n     */\n\n  }, {\n    key: \"updateLabelModule\",\n    value: function updateLabelModule(options) {\n      var pile = [options, this.options, this.globalOptions, // Currently set global edge options\n      this.defaultOptions];\n      this.labelModule.update(this.options, pile);\n\n      if (this.labelModule.baseSize !== undefined) {\n        this.baseFontSize = this.labelModule.baseSize;\n      }\n    }\n    /**\n     * update the edge type, set the options\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"updateEdgeType\",\n    value: function updateEdgeType() {\n      var smooth = this.options.smooth;\n      var dataChanged = false;\n      var changeInType = true;\n\n      if (this.edgeType !== undefined) {\n        if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === \"dynamic\" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === \"cubicBezier\" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== \"dynamic\" && smooth.type !== \"cubicBezier\" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {\n          changeInType = false;\n        }\n\n        if (changeInType === true) {\n          dataChanged = this.cleanup();\n        }\n      }\n\n      if (changeInType === true) {\n        if (smooth.enabled === true) {\n          if (smooth.type === \"dynamic\") {\n            dataChanged = true;\n            this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);\n          } else if (smooth.type === \"cubicBezier\") {\n            this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);\n          } else {\n            this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);\n          }\n        } else {\n          this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);\n        }\n      } else {\n        // if nothing changes, we just set the options.\n        this.edgeType.setOptions(this.options);\n      }\n\n      return dataChanged;\n    }\n    /**\n     * Connect an edge to its nodes\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      this.disconnect();\n      this.from = this.body.nodes[this.fromId] || undefined;\n      this.to = this.body.nodes[this.toId] || undefined;\n      this.connected = this.from !== undefined && this.to !== undefined;\n\n      if (this.connected === true) {\n        this.from.attachEdge(this);\n        this.to.attachEdge(this);\n      } else {\n        if (this.from) {\n          this.from.detachEdge(this);\n        }\n\n        if (this.to) {\n          this.to.detachEdge(this);\n        }\n      }\n\n      this.edgeType.connect();\n    }\n    /**\n     * Disconnect an edge from its nodes\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this.from) {\n        this.from.detachEdge(this);\n        this.from = undefined;\n      }\n\n      if (this.to) {\n        this.to.detachEdge(this);\n        this.to = undefined;\n      }\n\n      this.connected = false;\n    }\n    /**\n     * get the title of this edge.\n     *\n     * @returns {string} title    The title of the edge, or undefined when no title\n     *                           has been set.\n     */\n\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      return this.title;\n    }\n    /**\n     * check if this node is selecte\n     *\n     * @returns {boolean} selected   True if node is selected, else false\n     */\n\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return this.selected;\n    }\n    /**\n     * Retrieve the value of the edge. Can be undefined\n     *\n     * @returns {number} value\n     */\n\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.options.value;\n    }\n    /**\n     * Adjust the value range of the edge. The edge will adjust it's width\n     * based on its value.\n     *\n     * @param {number} min\n     * @param {number} max\n     * @param {number} total\n     */\n\n  }, {\n    key: \"setValueRange\",\n    value: function setValueRange(min, max, total) {\n      if (this.options.value !== undefined) {\n        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);\n        var widthDiff = this.options.scaling.max - this.options.scaling.min;\n\n        if (this.options.scaling.label.enabled === true) {\n          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;\n        }\n\n        this.options.width = this.options.scaling.min + scale * widthDiff;\n      } else {\n        this.options.width = this.baseWidth;\n        this.options.font.size = this.baseFontSize;\n      }\n\n      this._setInteractionWidths();\n\n      this.updateLabelModule();\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setInteractionWidths\",\n    value: function _setInteractionWidths() {\n      if (typeof this.options.hoverWidth === \"function\") {\n        this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);\n      } else {\n        this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;\n      }\n\n      if (typeof this.options.selectionWidth === \"function\") {\n        this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);\n      } else {\n        this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;\n      }\n    }\n    /**\n     * Redraw a edge\n     * Draw this edge in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var values = this.getFormattingValues();\n\n      if (values.hidden) {\n        return;\n      } // get the via node from the edge type\n\n\n      var viaNode = this.edgeType.getViaNode(); // draw line and label\n\n      this.edgeType.drawLine(ctx, values, this.selected, this.hover, viaNode);\n      this.drawLabel(ctx, viaNode);\n    }\n    /**\n     * Redraw arrows\n     * Draw this arrows in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n\n  }, {\n    key: \"drawArrows\",\n    value: function drawArrows(ctx) {\n      var values = this.getFormattingValues();\n\n      if (values.hidden) {\n        return;\n      } // get the via node from the edge type\n\n\n      var viaNode = this.edgeType.getViaNode();\n      var arrowData = {}; // restore edge targets to defaults\n\n      this.edgeType.fromPoint = this.edgeType.from;\n      this.edgeType.toPoint = this.edgeType.to; // from and to arrows give a different end point for edges. we set them here\n\n      if (values.fromArrow) {\n        arrowData.from = this.edgeType.getArrowData(ctx, \"from\", viaNode, this.selected, this.hover, values);\n        if (values.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;\n\n        if (values.fromArrowSrc) {\n          arrowData.from.image = this.imagelist.load(values.fromArrowSrc);\n        }\n\n        if (values.fromArrowImageWidth) {\n          arrowData.from.imageWidth = values.fromArrowImageWidth;\n        }\n\n        if (values.fromArrowImageHeight) {\n          arrowData.from.imageHeight = values.fromArrowImageHeight;\n        }\n      }\n\n      if (values.toArrow) {\n        arrowData.to = this.edgeType.getArrowData(ctx, \"to\", viaNode, this.selected, this.hover, values);\n        if (values.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;\n\n        if (values.toArrowSrc) {\n          arrowData.to.image = this.imagelist.load(values.toArrowSrc);\n        }\n\n        if (values.toArrowImageWidth) {\n          arrowData.to.imageWidth = values.toArrowImageWidth;\n        }\n\n        if (values.toArrowImageHeight) {\n          arrowData.to.imageHeight = values.toArrowImageHeight;\n        }\n      } // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.\n\n\n      if (values.middleArrow) {\n        arrowData.middle = this.edgeType.getArrowData(ctx, \"middle\", viaNode, this.selected, this.hover, values);\n\n        if (values.middleArrowSrc) {\n          arrowData.middle.image = this.imagelist.load(values.middleArrowSrc);\n        }\n\n        if (values.middleArrowImageWidth) {\n          arrowData.middle.imageWidth = values.middleArrowImageWidth;\n        }\n\n        if (values.middleArrowImageHeight) {\n          arrowData.middle.imageHeight = values.middleArrowImageHeight;\n        }\n      }\n\n      if (values.fromArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.from);\n      }\n\n      if (values.middleArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.middle);\n      }\n\n      if (values.toArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.to);\n      }\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Node} viaNode\n     */\n\n  }, {\n    key: \"drawLabel\",\n    value: function drawLabel(ctx, viaNode) {\n      if (this.options.label !== undefined) {\n        // set style\n        var node1 = this.from;\n        var node2 = this.to;\n\n        if (this.labelModule.differentState(this.selected, this.hover)) {\n          this.labelModule.getTextSize(ctx, this.selected, this.hover);\n        }\n\n        var point;\n\n        if (node1.id != node2.id) {\n          this.labelModule.pointToSelf = false;\n          point = this.edgeType.getPoint(0.5, viaNode);\n          ctx.save();\n\n          var rotationPoint = this._getRotation(ctx);\n\n          if (rotationPoint.angle != 0) {\n            ctx.translate(rotationPoint.x, rotationPoint.y);\n            ctx.rotate(rotationPoint.angle);\n          } // draw the label\n\n\n          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);\n          /*\n          // Useful debug code: draw a border around the label\n          // This should **not** be enabled in production!\n          var size = this.labelModule.getSize();; // ;; intentional so lint catches it\n          ctx.strokeStyle = \"#ff0000\";\n          ctx.strokeRect(size.left, size.top, size.width, size.height);\n          // End  debug code\n          */\n\n          ctx.restore();\n        } else {\n          // Ignore the orientations.\n          this.labelModule.pointToSelf = true; // get circle coordinates\n\n          var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, this.options.selfReference.size, node1);\n          point = this._pointOnCircle(coordinates.x, coordinates.y, this.options.selfReference.size, this.options.selfReference.angle);\n          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);\n        }\n      }\n    }\n    /**\n     * Determine all visual elements of this edge instance, in which the given\n     * point falls within the bounding shape.\n     *\n     * @param {point} point\n     * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point\n     */\n\n  }, {\n    key: \"getItemsOnPoint\",\n    value: function getItemsOnPoint(point) {\n      var ret = [];\n\n      if (this.labelModule.visible()) {\n        var rotationPoint = this._getRotation();\n\n        if (pointInRect(this.labelModule.getSize(), point, rotationPoint)) {\n          ret.push({\n            edgeId: this.id,\n            labelId: 0\n          });\n        }\n      }\n\n      var obj = {\n        left: point.x,\n        top: point.y\n      };\n\n      if (this.isOverlappingWith(obj)) {\n        ret.push({\n          edgeId: this.id\n        });\n      }\n\n      return ret;\n    }\n    /**\n     * Check if this object is overlapping with the provided object\n     *\n     * @param {object} obj   an object with parameters left, top\n     * @returns {boolean}     True if location is located on the edge\n     */\n\n  }, {\n    key: \"isOverlappingWith\",\n    value: function isOverlappingWith(obj) {\n      if (this.connected) {\n        var distMax = 10;\n        var xFrom = this.from.x;\n        var yFrom = this.from.y;\n        var xTo = this.to.x;\n        var yTo = this.to.y;\n        var xObj = obj.left;\n        var yObj = obj.top;\n        var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);\n        return dist < distMax;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Determine the rotation point, if any.\n     *\n     * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size\n     * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate\n     * @private\n     */\n\n  }, {\n    key: \"_getRotation\",\n    value: function _getRotation(ctx) {\n      var viaNode = this.edgeType.getViaNode();\n      var point = this.edgeType.getPoint(0.5, viaNode);\n\n      if (ctx !== undefined) {\n        this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);\n      }\n\n      var ret = {\n        x: point.x,\n        y: this.labelModule.size.yLine,\n        angle: 0\n      };\n\n      if (!this.labelModule.visible()) {\n        return ret; // Don't even bother doing the atan2, there's nothing to draw\n      }\n\n      if (this.options.font.align === \"horizontal\") {\n        return ret; // No need to calculate angle\n      }\n\n      var dy = this.from.y - this.to.y;\n      var dx = this.from.x - this.to.x;\n      var angle = Math.atan2(dy, dx); // radians\n      // rotate so that label is readable\n\n      if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {\n        angle += Math.PI;\n      }\n\n      ret.angle = angle;\n      return ret;\n    }\n    /**\n     * Get a point on a circle\n     *\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {number} angle\n     * @returns {object} point\n     * @private\n     */\n\n  }, {\n    key: \"_pointOnCircle\",\n    value: function _pointOnCircle(x, y, radius, angle) {\n      return {\n        x: x + radius * Math.cos(angle),\n        y: y - radius * Math.sin(angle)\n      };\n    }\n    /**\n     * Sets selected state to true\n     */\n\n  }, {\n    key: \"select\",\n    value: function select() {\n      this.selected = true;\n    }\n    /**\n     * Sets selected state to false\n     */\n\n  }, {\n    key: \"unselect\",\n    value: function unselect() {\n      this.selected = false;\n    }\n    /**\n     * cleans all required things on delete\n     *\n     * @returns {*}\n     */\n\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      return this.edgeType.cleanup();\n    }\n    /**\n     * Remove edge from the list and perform necessary cleanup.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      this.cleanup();\n      this.disconnect();\n      delete this.body.edges[this.id];\n    }\n    /**\n     * Check if both connecting nodes exist\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"endPointsValid\",\n    value: function endPointsValid() {\n      return this.body.nodes[this.fromId] !== undefined && this.body.nodes[this.toId] !== undefined;\n    }\n  }], [{\n    key: \"parseOptions\",\n    value: function parseOptions(parentOptions, newOptions) {\n      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var copyFromGlobals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var fields = [\"endPointOffset\", \"arrowStrikethrough\", \"id\", \"from\", \"hidden\", \"hoverWidth\", \"labelHighlightBold\", \"length\", \"line\", \"opacity\", \"physics\", \"scaling\", \"selectionWidth\", \"selfReferenceSize\", \"selfReference\", \"to\", \"title\", \"value\", \"width\", \"font\", \"chosen\", \"widthConstraint\"]; // only deep extend the items in the field array. These do not have shorthand.\n\n      selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion); // Only use endPointOffset values (from and to) if it's valid values\n\n      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.from !== undefined) {\n        if (_isFinite$2(newOptions.endPointOffset.from)) {\n          parentOptions.endPointOffset.from = newOptions.endPointOffset.from;\n        } else {\n          parentOptions.endPointOffset.from = globalOptions.endPointOffset.from !== undefined ? globalOptions.endPointOffset.from : 0;\n          console.error(\"endPointOffset.from is not a valid number\");\n        }\n      }\n\n      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.to !== undefined) {\n        if (_isFinite$2(newOptions.endPointOffset.to)) {\n          parentOptions.endPointOffset.to = newOptions.endPointOffset.to;\n        } else {\n          parentOptions.endPointOffset.to = globalOptions.endPointOffset.to !== undefined ? globalOptions.endPointOffset.to : 0;\n          console.error(\"endPointOffset.to is not a valid number\");\n        }\n      } // Only copy label if it's a legal value.\n\n\n      if (isValidLabel(newOptions.label)) {\n        parentOptions.label = newOptions.label;\n      } else if (!isValidLabel(parentOptions.label)) {\n        parentOptions.label = undefined;\n      }\n\n      mergeOptions(parentOptions, newOptions, \"smooth\", globalOptions);\n      mergeOptions(parentOptions, newOptions, \"shadow\", globalOptions);\n      mergeOptions(parentOptions, newOptions, \"background\", globalOptions);\n\n      if (newOptions.dashes !== undefined && newOptions.dashes !== null) {\n        parentOptions.dashes = newOptions.dashes;\n      } else if (allowDeletion === true && newOptions.dashes === null) {\n        parentOptions.dashes = create$2(globalOptions.dashes); // this sets the pointer of the option back to the global option.\n      } // set the scaling newOptions\n\n\n      if (newOptions.scaling !== undefined && newOptions.scaling !== null) {\n        if (newOptions.scaling.min !== undefined) {\n          parentOptions.scaling.min = newOptions.scaling.min;\n        }\n\n        if (newOptions.scaling.max !== undefined) {\n          parentOptions.scaling.max = newOptions.scaling.max;\n        }\n\n        mergeOptions(parentOptions.scaling, newOptions.scaling, \"label\", globalOptions.scaling);\n      } else if (allowDeletion === true && newOptions.scaling === null) {\n        parentOptions.scaling = create$2(globalOptions.scaling); // this sets the pointer of the option back to the global option.\n      } // handle multiple input cases for arrows\n\n\n      if (newOptions.arrows !== undefined && newOptions.arrows !== null) {\n        if (typeof newOptions.arrows === \"string\") {\n          var arrows = newOptions.arrows.toLowerCase();\n          parentOptions.arrows.to.enabled = indexOf$3(arrows).call(arrows, \"to\") != -1;\n          parentOptions.arrows.middle.enabled = indexOf$3(arrows).call(arrows, \"middle\") != -1;\n          parentOptions.arrows.from.enabled = indexOf$3(arrows).call(arrows, \"from\") != -1;\n        } else if (_typeof_1(newOptions.arrows) === \"object\") {\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"to\", globalOptions.arrows);\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"middle\", globalOptions.arrows);\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"from\", globalOptions.arrows);\n        } else {\n          throw new Error(\"The arrow newOptions can only be an object or a string. Refer to the documentation. You used:\" + stringify$2(newOptions.arrows));\n        }\n      } else if (allowDeletion === true && newOptions.arrows === null) {\n        parentOptions.arrows = create$2(globalOptions.arrows); // this sets the pointer of the option back to the global option.\n      } // handle multiple input cases for color\n\n\n      if (newOptions.color !== undefined && newOptions.color !== null) {\n        var fromColor = isString(newOptions.color) ? {\n          color: newOptions.color,\n          highlight: newOptions.color,\n          hover: newOptions.color,\n          inherit: false,\n          opacity: 1\n        } : newOptions.color;\n        var toColor = parentOptions.color; // If passed, fill in values from default options - required in the case of no prototype bridging\n\n        if (copyFromGlobals) {\n          deepExtend(toColor, globalOptions.color, false, allowDeletion);\n        } else {\n          // Clear local properties - need to do it like this in order to retain prototype bridges\n          for (var i in toColor) {\n            if (Object.prototype.hasOwnProperty.call(toColor, i)) {\n              delete toColor[i];\n            }\n          }\n        }\n\n        if (isString(toColor)) {\n          toColor.color = toColor;\n          toColor.highlight = toColor;\n          toColor.hover = toColor;\n          toColor.inherit = false;\n\n          if (fromColor.opacity === undefined) {\n            toColor.opacity = 1.0; // set default\n          }\n        } else {\n          var colorsDefined = false;\n\n          if (fromColor.color !== undefined) {\n            toColor.color = fromColor.color;\n            colorsDefined = true;\n          }\n\n          if (fromColor.highlight !== undefined) {\n            toColor.highlight = fromColor.highlight;\n            colorsDefined = true;\n          }\n\n          if (fromColor.hover !== undefined) {\n            toColor.hover = fromColor.hover;\n            colorsDefined = true;\n          }\n\n          if (fromColor.inherit !== undefined) {\n            toColor.inherit = fromColor.inherit;\n          }\n\n          if (fromColor.opacity !== undefined) {\n            toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));\n          }\n\n          if (colorsDefined === true) {\n            toColor.inherit = false;\n          } else {\n            if (toColor.inherit === undefined) {\n              toColor.inherit = \"from\"; // Set default\n            }\n          }\n        }\n      } else if (allowDeletion === true && newOptions.color === null) {\n        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options\n      }\n\n      if (allowDeletion === true && newOptions.font === null) {\n        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options\n      }\n\n      if (Object.prototype.hasOwnProperty.call(newOptions, \"selfReferenceSize\")) {\n        console.warn(\"The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}\");\n        parentOptions.selfReference.size = newOptions.selfReferenceSize;\n      }\n    }\n  }]);\n  return Edge;\n}();\n/**\n * Handler for Edges\n */\n\n\nvar EdgesHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Array.<Image>} images\n   * @param {Array.<Group>} groups\n   */\n  function EdgesHandler(body, images, groups) {\n    var _context,\n        _this = this;\n\n    classCallCheck(this, EdgesHandler);\n    this.body = body;\n    this.images = images;\n    this.groups = groups; // create the edge API in the body container\n\n    this.body.functions.createEdge = bind$2(_context = this.create).call(_context, this);\n    this.edgesListeners = {\n      add: function add(event, params) {\n        _this.add(params.items);\n      },\n      update: function update(event, params) {\n        _this.update(params.items);\n      },\n      remove: function remove(event, params) {\n        _this.remove(params.items);\n      }\n    };\n    this.options = {};\n    this.defaultOptions = {\n      arrows: {\n        to: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        },\n        // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}\n        middle: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        },\n        from: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        }\n      },\n      endPointOffset: {\n        from: 0,\n        to: 0\n      },\n      arrowStrikethrough: true,\n      color: {\n        color: \"#848484\",\n        highlight: \"#848484\",\n        hover: \"#848484\",\n        inherit: \"from\",\n        opacity: 1.0\n      },\n      dashes: false,\n      font: {\n        color: \"#343434\",\n        size: 14,\n        // px\n        face: \"arial\",\n        background: \"none\",\n        strokeWidth: 2,\n        // px\n        strokeColor: \"#ffffff\",\n        align: \"horizontal\",\n        multi: false,\n        vadjust: 0,\n        bold: {\n          mod: \"bold\"\n        },\n        boldital: {\n          mod: \"bold italic\"\n        },\n        ital: {\n          mod: \"italic\"\n        },\n        mono: {\n          mod: \"\",\n          size: 15,\n          // px\n          face: \"courier new\",\n          vadjust: 2\n        }\n      },\n      hidden: false,\n      hoverWidth: 1.5,\n      label: undefined,\n      labelHighlightBold: true,\n      length: undefined,\n      physics: true,\n      scaling: {\n        min: 1,\n        max: 15,\n        label: {\n          enabled: true,\n          min: 14,\n          max: 30,\n          maxVisible: 30,\n          drawThreshold: 5\n        },\n        customScalingFunction: function customScalingFunction(min, max, total, value) {\n          if (max === min) {\n            return 0.5;\n          } else {\n            var scale = 1 / (max - min);\n            return Math.max(0, (value - min) * scale);\n          }\n        }\n      },\n      selectionWidth: 1.5,\n      selfReference: {\n        size: 20,\n        angle: Math.PI / 4,\n        renderBehindTheNode: true\n      },\n      shadow: {\n        enabled: false,\n        color: \"rgba(0,0,0,0.5)\",\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      background: {\n        enabled: false,\n        color: \"rgba(111,111,111,1)\",\n        size: 10,\n        dashes: false\n      },\n      smooth: {\n        enabled: true,\n        type: \"dynamic\",\n        forceDirection: \"none\",\n        roundness: 0.5\n      },\n      title: undefined,\n      width: 1,\n      value: undefined\n    };\n    deepExtend(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n  /**\n   * Binds event listeners\n   */\n\n\n  createClass(EdgesHandler, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this2 = this,\n          _context2,\n          _context3; // this allows external modules to force all dynamic curves to turn static.\n\n\n      this.body.emitter.on(\"_forceDisableDynamicCurves\", function (type) {\n        var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (type === \"dynamic\") {\n          type = \"continuous\";\n        }\n\n        var dataChanged = false;\n\n        for (var edgeId in _this2.body.edges) {\n          if (Object.prototype.hasOwnProperty.call(_this2.body.edges, edgeId)) {\n            var edge = _this2.body.edges[edgeId];\n\n            var edgeData = _this2.body.data.edges.get(edgeId); // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.\n            // this is because a change in the global would not affect these curves.\n\n\n            if (edgeData != null) {\n              var smoothOptions = edgeData.smooth;\n\n              if (smoothOptions !== undefined) {\n                if (smoothOptions.enabled === true && smoothOptions.type === \"dynamic\") {\n                  if (type === undefined) {\n                    edge.setOptions({\n                      smooth: false\n                    });\n                  } else {\n                    edge.setOptions({\n                      smooth: {\n                        type: type\n                      }\n                    });\n                  }\n\n                  dataChanged = true;\n                }\n              }\n            }\n          }\n        }\n\n        if (emit === true && dataChanged === true) {\n          _this2.body.emitter.emit(\"_dataChanged\");\n        }\n      }); // this is called when options of EXISTING nodes or edges have changed.\n      //\n      // NOTE: Not true, called when options have NOT changed, for both existing as well as new nodes.\n      //       See update() for logic.\n      // TODO: Verify and examine the consequences of this. It might still trigger when\n      //       non-option fields have changed, but then reconnecting edges is still useless.\n      //       Alternatively, it might also be called when edges are removed.\n      //\n\n      this.body.emitter.on(\"_dataUpdated\", function () {\n        _this2.reconnectEdges();\n      }); // refresh the edges. Used when reverting from hierarchical layout\n\n      this.body.emitter.on(\"refreshEdges\", bind$2(_context2 = this.refresh).call(_context2, this));\n      this.body.emitter.on(\"refresh\", bind$2(_context3 = this.refresh).call(_context3, this));\n      this.body.emitter.on(\"destroy\", function () {\n        forEach$3(_this2.edgesListeners, function (callback, event) {\n          if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);\n        });\n        delete _this2.body.functions.createEdge;\n        delete _this2.edgesListeners.add;\n        delete _this2.edgesListeners.update;\n        delete _this2.edgesListeners.remove;\n        delete _this2.edgesListeners;\n      });\n    }\n    /**\n     *\n     * @param {object} options\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // use the parser from the Edge class to fill in all shorthand notations\n        Edge.parseOptions(this.options, options, true, this.defaultOptions, true); // update smooth settings in all edges\n\n        var dataChanged = false;\n\n        if (options.smooth !== undefined) {\n          for (var edgeId in this.body.edges) {\n            if (Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) {\n              dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;\n            }\n          }\n        } // update fonts in all edges\n\n\n        if (options.font !== undefined) {\n          for (var _edgeId in this.body.edges) {\n            if (Object.prototype.hasOwnProperty.call(this.body.edges, _edgeId)) {\n              this.body.edges[_edgeId].updateLabelModule();\n            }\n          }\n        } // update the state of the variables if needed\n\n\n        if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n    /**\n     * Load edges by reading the data table\n     *\n     * @param {Array | DataSet | DataView} edges    The data containing the edges.\n     * @param {boolean} [doNotEmit=false] - Suppress data changed event.\n     * @private\n     */\n\n  }, {\n    key: \"setData\",\n    value: function setData(edges) {\n      var _this3 = this;\n\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var oldEdgesData = this.body.data.edges;\n\n      if ((0,vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.isDataViewLike)(\"id\", edges)) {\n        this.body.data.edges = edges;\n      } else if (isArray$5(edges)) {\n        this.body.data.edges = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n        this.body.data.edges.add(edges);\n      } else if (!edges) {\n        this.body.data.edges = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n      } else {\n        throw new TypeError(\"Array or DataSet expected\");\n      } // TODO: is this null or undefined or false?\n\n\n      if (oldEdgesData) {\n        // unsubscribe from old dataset\n        forEach$3(this.edgesListeners, function (callback, event) {\n          oldEdgesData.off(event, callback);\n        });\n      } // remove drawn edges\n\n\n      this.body.edges = {}; // TODO: is this null or undefined or false?\n\n      if (this.body.data.edges) {\n        // subscribe to new dataset\n        forEach$3(this.edgesListeners, function (callback, event) {\n          _this3.body.data.edges.on(event, callback);\n        }); // draw all new nodes\n\n        var ids = this.body.data.edges.getIds();\n        this.add(ids, true);\n      }\n\n      this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    /**\n     * Add edges\n     *\n     * @param {number[] | string[]} ids\n     * @param {boolean} [doNotEmit=false]\n     * @private\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(ids) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var edges = this.body.edges;\n      var edgesData = this.body.data.edges;\n\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var oldEdge = edges[id];\n\n        if (oldEdge) {\n          oldEdge.disconnect();\n        }\n\n        var data = edgesData.get(id, {\n          showInternalIds: true\n        });\n        edges[id] = this.create(data);\n      }\n\n      this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    /**\n     * Update existing edges, or create them when not yet existing\n     *\n     * @param {number[] | string[]} ids\n     * @private\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(ids) {\n      var edges = this.body.edges;\n      var edgesData = this.body.data.edges;\n      var dataChanged = false;\n\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var data = edgesData.get(id);\n        var edge = edges[id];\n\n        if (edge !== undefined) {\n          // update edge\n          edge.disconnect();\n          dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.\n\n          edge.connect();\n        } else {\n          // create edge\n          this.body.edges[id] = this.create(data);\n          dataChanged = true;\n        }\n      }\n\n      if (dataChanged === true) {\n        this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n        this.body.emitter.emit(\"_dataChanged\");\n      } else {\n        this.body.emitter.emit(\"_dataUpdated\");\n      }\n    }\n    /**\n     * Remove existing edges. Non existing ids will be ignored\n     *\n     * @param {number[] | string[]} ids\n     * @param {boolean} [emit=true]\n     * @private\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(ids) {\n      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (ids.length === 0) return; // early out\n\n      var edges = this.body.edges;\n      forEach$3(ids, function (id) {\n        var edge = edges[id];\n\n        if (edge !== undefined) {\n          edge.remove();\n        }\n      });\n\n      if (emit) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    /**\n     * Refreshes Edge Handler\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this4 = this;\n\n      forEach$3(this.body.edges, function (edge, edgeId) {\n        var data = _this4.body.data.edges.get(edgeId);\n\n        if (data !== undefined) {\n          edge.setOptions(data);\n        }\n      });\n    }\n    /**\n     *\n     * @param {object} properties\n     * @returns {Edge}\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(properties) {\n      return new Edge(properties, this.body, this.images, this.options, this.defaultOptions);\n    }\n    /**\n     * Reconnect all edges\n     *\n     * @private\n     */\n\n  }, {\n    key: \"reconnectEdges\",\n    value: function reconnectEdges() {\n      var id;\n      var nodes = this.body.nodes;\n      var edges = this.body.edges;\n\n      for (id in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n          nodes[id].edges = [];\n        }\n      }\n\n      for (id in edges) {\n        if (Object.prototype.hasOwnProperty.call(edges, id)) {\n          var edge = edges[id];\n          edge.from = null;\n          edge.to = null;\n          edge.connect();\n        }\n      }\n    }\n    /**\n     *\n     * @param {Edge.id} edgeId\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getConnectedNodes\",\n    value: function getConnectedNodes(edgeId) {\n      var nodeList = [];\n\n      if (this.body.edges[edgeId] !== undefined) {\n        var edge = this.body.edges[edgeId];\n\n        if (edge.fromId !== undefined) {\n          nodeList.push(edge.fromId);\n        }\n\n        if (edge.toId !== undefined) {\n          nodeList.push(edge.toId);\n        }\n      }\n\n      return nodeList;\n    }\n    /**\n     * There is no direct relation between the nodes and the edges DataSet,\n     * so the right place to do call this is in the handler for event `_dataUpdated`.\n     */\n\n  }, {\n    key: \"_updateState\",\n    value: function _updateState() {\n      this._addMissingEdges();\n\n      this._removeInvalidEdges();\n    }\n    /**\n     * Scan for missing nodes and remove corresponding edges, if any.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_removeInvalidEdges\",\n    value: function _removeInvalidEdges() {\n      var _this5 = this;\n\n      var edgesToDelete = [];\n      forEach$3(this.body.edges, function (edge, id) {\n        var toNode = _this5.body.nodes[edge.toId];\n        var fromNode = _this5.body.nodes[edge.fromId]; // Skip clustering edges here, let the Clustering module handle those\n\n        if (toNode !== undefined && toNode.isCluster === true || fromNode !== undefined && fromNode.isCluster === true) {\n          return;\n        }\n\n        if (toNode === undefined || fromNode === undefined) {\n          edgesToDelete.push(id);\n        }\n      });\n      this.remove(edgesToDelete, false);\n    }\n    /**\n     * add all edges from dataset that are not in the cached state\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_addMissingEdges\",\n    value: function _addMissingEdges() {\n      var edgesData = this.body.data.edges;\n\n      if (edgesData === undefined || edgesData === null) {\n        return; // No edges DataSet yet; can happen on startup\n      }\n\n      var edges = this.body.edges;\n      var addIds = [];\n      forEach$2(edgesData).call(edgesData, function (edgeData, edgeId) {\n        var edge = edges[edgeId];\n\n        if (edge === undefined) {\n          addIds.push(edgeId);\n        }\n      });\n      this.add(addIds, true);\n    }\n  }]);\n  return EdgesHandler;\n}();\n/**\n * Barnes Hut Solver\n */\n\n\nvar BarnesHutSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function BarnesHutSolver(body, physicsBody, options) {\n    classCallCheck(this, BarnesHutSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.barnesHutTree;\n    this.setOptions(options);\n    this._rng = Alea(\"BARNES HUT SOLVER\"); // debug: show grid\n    // this.body.emitter.on(\"afterDrawing\", (ctx) => {this._debug(ctx,'#ff0000')})\n  }\n  /**\n   *\n   * @param {object} options\n   */\n\n\n  createClass(BarnesHutSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      this.thetaInversed = 1 / this.options.theta; // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius\n\n      this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));\n    }\n    /**\n     * This function calculates the forces the nodes apply on each other based on a gravitational model.\n     * The Barnes Hut method is used to speed up this N-body simulation.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {\n        var node;\n        var nodes = this.body.nodes;\n        var nodeIndices = this.physicsBody.physicsNodeIndices;\n        var nodeCount = nodeIndices.length; // create the tree\n\n        var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices); // for debugging\n\n\n        this.barnesHutTree = barnesHutTree; // place the nodes one by one recursively\n\n        for (var i = 0; i < nodeCount; i++) {\n          node = nodes[nodeIndices[i]];\n\n          if (node.options.mass > 0) {\n            // starting with root is irrelevant, it never passes the BarnesHutSolver condition\n            this._getForceContributions(barnesHutTree.root, node);\n          }\n        }\n      }\n    }\n    /**\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: \"_getForceContributions\",\n    value: function _getForceContributions(parentBranch, node) {\n      this._getForceContribution(parentBranch.children.NW, node);\n\n      this._getForceContribution(parentBranch.children.NE, node);\n\n      this._getForceContribution(parentBranch.children.SW, node);\n\n      this._getForceContribution(parentBranch.children.SE, node);\n    }\n    /**\n     * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.\n     * If a region contains a single node, we check if it is not itself, then we apply the force.\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: \"_getForceContribution\",\n    value: function _getForceContribution(parentBranch, node) {\n      // we get no force contribution from an empty region\n      if (parentBranch.childrenCount > 0) {\n        // get the distance from the center of mass to the node.\n        var dx = parentBranch.centerOfMass.x - node.x;\n        var dy = parentBranch.centerOfMass.y - node.y;\n        var distance = Math.sqrt(dx * dx + dy * dy); // BarnesHutSolver condition\n        // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed\n        // calcSize = 1/s --> d * 1/s > 1/theta = passed\n\n        if (distance * parentBranch.calcSize > this.thetaInversed) {\n          this._calculateForces(distance, dx, dy, node, parentBranch);\n        } else {\n          // Did not pass the condition, go into children if available\n          if (parentBranch.childrenCount === 4) {\n            this._getForceContributions(parentBranch, node);\n          } else {\n            // parentBranch must have only one node, if it was empty we wouldnt be here\n            if (parentBranch.children.data.id != node.id) {\n              // if it is not self\n              this._calculateForces(distance, dx, dy, node, parentBranch);\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Calculate the forces based on the distance.\n     *\n     * @param {number} distance\n     * @param {number} dx\n     * @param {number} dy\n     * @param {Node} node\n     * @param {object} parentBranch\n     * @private\n     */\n\n  }, {\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, node, parentBranch) {\n      if (distance === 0) {\n        distance = 0.1;\n        dx = distance;\n      }\n\n      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {\n        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);\n      } // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines\n      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce\n\n\n      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);\n      var fx = dx * gravityForce;\n      var fy = dy * gravityForce;\n      this.physicsBody.forces[node.id].x += fx;\n      this.physicsBody.forces[node.id].y += fy;\n    }\n    /**\n     * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.\n     *\n     * @param {Array.<Node>} nodes\n     * @param {Array.<number>} nodeIndices\n     * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree\n     * @private\n     */\n\n  }, {\n    key: \"_formBarnesHutTree\",\n    value: function _formBarnesHutTree(nodes, nodeIndices) {\n      var node;\n      var nodeCount = nodeIndices.length;\n      var minX = nodes[nodeIndices[0]].x;\n      var minY = nodes[nodeIndices[0]].y;\n      var maxX = nodes[nodeIndices[0]].x;\n      var maxY = nodes[nodeIndices[0]].y; // get the range of the nodes\n\n      for (var i = 1; i < nodeCount; i++) {\n        var _node = nodes[nodeIndices[i]];\n        var x = _node.x;\n        var y = _node.y;\n\n        if (_node.options.mass > 0) {\n          if (x < minX) {\n            minX = x;\n          }\n\n          if (x > maxX) {\n            maxX = x;\n          }\n\n          if (y < minY) {\n            minY = y;\n          }\n\n          if (y > maxY) {\n            maxY = y;\n          }\n        }\n      } // make the range a square\n\n\n      var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y\n\n      if (sizeDiff > 0) {\n        minY -= 0.5 * sizeDiff;\n        maxY += 0.5 * sizeDiff;\n      } // xSize > ySize\n      else {\n        minX += 0.5 * sizeDiff;\n        maxX -= 0.5 * sizeDiff;\n      } // xSize < ySize\n\n\n      var minimumTreeSize = 1e-5;\n      var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));\n      var halfRootSize = 0.5 * rootSize;\n      var centerX = 0.5 * (minX + maxX),\n          centerY = 0.5 * (minY + maxY); // construct the barnesHutTree\n\n      var barnesHutTree = {\n        root: {\n          centerOfMass: {\n            x: 0,\n            y: 0\n          },\n          mass: 0,\n          range: {\n            minX: centerX - halfRootSize,\n            maxX: centerX + halfRootSize,\n            minY: centerY - halfRootSize,\n            maxY: centerY + halfRootSize\n          },\n          size: rootSize,\n          calcSize: 1 / rootSize,\n          children: {\n            data: null\n          },\n          maxWidth: 0,\n          level: 0,\n          childrenCount: 4\n        }\n      };\n\n      this._splitBranch(barnesHutTree.root); // place the nodes one by one recursively\n\n\n      for (var _i = 0; _i < nodeCount; _i++) {\n        node = nodes[nodeIndices[_i]];\n\n        if (node.options.mass > 0) {\n          this._placeInTree(barnesHutTree.root, node);\n        }\n      } // make global\n\n\n      return barnesHutTree;\n    }\n    /**\n     * this updates the mass of a branch. this is increased by adding a node.\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: \"_updateBranchMass\",\n    value: function _updateBranchMass(parentBranch, node) {\n      var centerOfMass = parentBranch.centerOfMass;\n      var totalMass = parentBranch.mass + node.options.mass;\n      var totalMassInv = 1 / totalMass;\n      centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;\n      centerOfMass.x *= totalMassInv;\n      centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;\n      centerOfMass.y *= totalMassInv;\n      parentBranch.mass = totalMass;\n      var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);\n      parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;\n    }\n    /**\n     * determine in which branch the node will be placed.\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @param {boolean} skipMassUpdate\n     * @private\n     */\n\n  }, {\n    key: \"_placeInTree\",\n    value: function _placeInTree(parentBranch, node, skipMassUpdate) {\n      if (skipMassUpdate != true || skipMassUpdate === undefined) {\n        // update the mass of the branch.\n        this._updateBranchMass(parentBranch, node);\n      }\n\n      var range = parentBranch.children.NW.range;\n      var region;\n\n      if (range.maxX > node.x) {\n        // in NW or SW\n        if (range.maxY > node.y) {\n          region = \"NW\";\n        } else {\n          region = \"SW\";\n        }\n      } else {\n        // in NE or SE\n        if (range.maxY > node.y) {\n          region = \"NE\";\n        } else {\n          region = \"SE\";\n        }\n      }\n\n      this._placeInRegion(parentBranch, node, region);\n    }\n    /**\n     * actually place the node in a region (or branch)\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @param {'NW'| 'NE' | 'SW' | 'SE'} region\n     * @private\n     */\n\n  }, {\n    key: \"_placeInRegion\",\n    value: function _placeInRegion(parentBranch, node, region) {\n      var children = parentBranch.children[region];\n\n      switch (children.childrenCount) {\n        case 0:\n          // place node here\n          children.children.data = node;\n          children.childrenCount = 1;\n\n          this._updateBranchMass(children, node);\n\n          break;\n\n        case 1:\n          // convert into children\n          // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)\n          // we move one node a little bit and we do not put it in the tree.\n          if (children.children.data.x === node.x && children.children.data.y === node.y) {\n            node.x += this._rng();\n            node.y += this._rng();\n          } else {\n            this._splitBranch(children);\n\n            this._placeInTree(children, node);\n          }\n\n          break;\n\n        case 4:\n          // place in branch\n          this._placeInTree(children, node);\n\n          break;\n      }\n    }\n    /**\n     * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch\n     * after the split is complete.\n     *\n     * @param {object} parentBranch\n     * @private\n     */\n\n  }, {\n    key: \"_splitBranch\",\n    value: function _splitBranch(parentBranch) {\n      // if the branch is shaded with a node, replace the node in the new subset.\n      var containedNode = null;\n\n      if (parentBranch.childrenCount === 1) {\n        containedNode = parentBranch.children.data;\n        parentBranch.mass = 0;\n        parentBranch.centerOfMass.x = 0;\n        parentBranch.centerOfMass.y = 0;\n      }\n\n      parentBranch.childrenCount = 4;\n      parentBranch.children.data = null;\n\n      this._insertRegion(parentBranch, \"NW\");\n\n      this._insertRegion(parentBranch, \"NE\");\n\n      this._insertRegion(parentBranch, \"SW\");\n\n      this._insertRegion(parentBranch, \"SE\");\n\n      if (containedNode != null) {\n        this._placeInTree(parentBranch, containedNode);\n      }\n    }\n    /**\n     * This function subdivides the region into four new segments.\n     * Specifically, this inserts a single new segment.\n     * It fills the children section of the parentBranch\n     *\n     * @param {object} parentBranch\n     * @param {'NW'| 'NE' | 'SW' | 'SE'} region\n     * @private\n     */\n\n  }, {\n    key: \"_insertRegion\",\n    value: function _insertRegion(parentBranch, region) {\n      var minX, maxX, minY, maxY;\n      var childSize = 0.5 * parentBranch.size;\n\n      switch (region) {\n        case \"NW\":\n          minX = parentBranch.range.minX;\n          maxX = parentBranch.range.minX + childSize;\n          minY = parentBranch.range.minY;\n          maxY = parentBranch.range.minY + childSize;\n          break;\n\n        case \"NE\":\n          minX = parentBranch.range.minX + childSize;\n          maxX = parentBranch.range.maxX;\n          minY = parentBranch.range.minY;\n          maxY = parentBranch.range.minY + childSize;\n          break;\n\n        case \"SW\":\n          minX = parentBranch.range.minX;\n          maxX = parentBranch.range.minX + childSize;\n          minY = parentBranch.range.minY + childSize;\n          maxY = parentBranch.range.maxY;\n          break;\n\n        case \"SE\":\n          minX = parentBranch.range.minX + childSize;\n          maxX = parentBranch.range.maxX;\n          minY = parentBranch.range.minY + childSize;\n          maxY = parentBranch.range.maxY;\n          break;\n      }\n\n      parentBranch.children[region] = {\n        centerOfMass: {\n          x: 0,\n          y: 0\n        },\n        mass: 0,\n        range: {\n          minX: minX,\n          maxX: maxX,\n          minY: minY,\n          maxY: maxY\n        },\n        size: 0.5 * parentBranch.size,\n        calcSize: 2 * parentBranch.calcSize,\n        children: {\n          data: null\n        },\n        maxWidth: 0,\n        level: parentBranch.level + 1,\n        childrenCount: 0\n      };\n    } //---------------------------  DEBUGGING BELOW  ---------------------------//\n\n    /**\n     * This function is for debugging purposed, it draws the tree.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} color\n     * @private\n     */\n\n  }, {\n    key: \"_debug\",\n    value: function _debug(ctx, color) {\n      if (this.barnesHutTree !== undefined) {\n        ctx.lineWidth = 1;\n\n        this._drawBranch(this.barnesHutTree.root, ctx, color);\n      }\n    }\n    /**\n     * This function is for debugging purposes. It draws the branches recursively.\n     *\n     * @param {object} branch\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} color\n     * @private\n     */\n\n  }, {\n    key: \"_drawBranch\",\n    value: function _drawBranch(branch, ctx, color) {\n      if (color === undefined) {\n        color = \"#FF0000\";\n      }\n\n      if (branch.childrenCount === 4) {\n        this._drawBranch(branch.children.NW, ctx);\n\n        this._drawBranch(branch.children.NE, ctx);\n\n        this._drawBranch(branch.children.SE, ctx);\n\n        this._drawBranch(branch.children.SW, ctx);\n      }\n\n      ctx.strokeStyle = color;\n      ctx.beginPath();\n      ctx.moveTo(branch.range.minX, branch.range.minY);\n      ctx.lineTo(branch.range.maxX, branch.range.minY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.maxX, branch.range.minY);\n      ctx.lineTo(branch.range.maxX, branch.range.maxY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.maxX, branch.range.maxY);\n      ctx.lineTo(branch.range.minX, branch.range.maxY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.minX, branch.range.maxY);\n      ctx.lineTo(branch.range.minX, branch.range.minY);\n      ctx.stroke();\n      /*\n       if (branch.mass > 0) {\n       ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);\n       ctx.stroke();\n       }\n       */\n    }\n  }]);\n  return BarnesHutSolver;\n}();\n/**\n * Repulsion Solver\n */\n\n\nvar RepulsionSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function RepulsionSolver(body, physicsBody, options) {\n    classCallCheck(this, RepulsionSolver);\n    this._rng = Alea(\"REPULSION SOLVER\");\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n  /**\n   *\n   * @param {object} options\n   */\n\n\n  createClass(RepulsionSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n    /**\n     * Calculate the forces the nodes apply on each other based on a repulsion field.\n     * This field is linearly approximated.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx, dy, distance, fx, fy, repulsingForce, node1, node2;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces; // repulsing forces between nodes\n\n      var nodeDistance = this.options.nodeDistance; // approximation constants\n\n      var a = -2 / 3 / nodeDistance;\n      var b = 4 / 3; // we loop from i over all but the last entree in the array\n      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j\n\n      for (var i = 0; i < nodeIndices.length - 1; i++) {\n        node1 = nodes[nodeIndices[i]];\n\n        for (var j = i + 1; j < nodeIndices.length; j++) {\n          node2 = nodes[nodeIndices[j]];\n          dx = node2.x - node1.x;\n          dy = node2.y - node1.y;\n          distance = Math.sqrt(dx * dx + dy * dy); // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.\n\n          if (distance === 0) {\n            distance = 0.1 * this._rng();\n            dx = distance;\n          }\n\n          if (distance < 2 * nodeDistance) {\n            if (distance < 0.5 * nodeDistance) {\n              repulsingForce = 1.0;\n            } else {\n              repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))\n            }\n\n            repulsingForce = repulsingForce / distance;\n            fx = dx * repulsingForce;\n            fy = dy * repulsingForce;\n            forces[node1.id].x -= fx;\n            forces[node1.id].y -= fy;\n            forces[node2.id].x += fx;\n            forces[node2.id].y += fy;\n          }\n        }\n      }\n    }\n  }]);\n  return RepulsionSolver;\n}();\n/**\n * Hierarchical Repulsion Solver\n */\n\n\nvar HierarchicalRepulsionSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function HierarchicalRepulsionSolver(body, physicsBody, options) {\n    classCallCheck(this, HierarchicalRepulsionSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n  /**\n   *\n   * @param {object} options\n   */\n\n\n  createClass(HierarchicalRepulsionSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));\n    }\n    /**\n     * Calculate the forces the nodes apply on each other based on a repulsion field.\n     * This field is linearly approximated.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces; // repulsing forces between nodes\n\n      var nodeDistance = this.options.nodeDistance; // we loop from i over all but the last entree in the array\n      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j\n\n      for (var i = 0; i < nodeIndices.length - 1; i++) {\n        var node1 = nodes[nodeIndices[i]];\n\n        for (var j = i + 1; j < nodeIndices.length; j++) {\n          var node2 = nodes[nodeIndices[j]]; // nodes only affect nodes on their level\n\n          if (node1.level === node2.level) {\n            var theseNodesDistance = nodeDistance + this.overlapAvoidanceFactor * ((node1.shape.radius || 0) / 2 + (node2.shape.radius || 0) / 2);\n            var dx = node2.x - node1.x;\n            var dy = node2.y - node1.y;\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            var steepness = 0.05;\n            var repulsingForce = void 0;\n\n            if (distance < theseNodesDistance) {\n              repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * theseNodesDistance, 2);\n            } else {\n              repulsingForce = 0;\n            } // normalize force with\n\n\n            if (distance !== 0) {\n              repulsingForce = repulsingForce / distance;\n            }\n\n            var fx = dx * repulsingForce;\n            var fy = dy * repulsingForce;\n            forces[node1.id].x -= fx;\n            forces[node1.id].y -= fy;\n            forces[node2.id].x += fx;\n            forces[node2.id].y += fy;\n          }\n        }\n      }\n    }\n  }]);\n  return HierarchicalRepulsionSolver;\n}();\n/**\n * Spring Solver\n */\n\n\nvar SpringSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function SpringSolver(body, physicsBody, options) {\n    classCallCheck(this, SpringSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n  /**\n   *\n   * @param {object} options\n   */\n\n\n  createClass(SpringSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n    /**\n     * This function calculates the springforces on the nodes, accounting for the support nodes.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var edgeLength, edge;\n      var edgeIndices = this.physicsBody.physicsEdgeIndices;\n      var edges = this.body.edges;\n      var node1, node2, node3; // forces caused by the edges, modelled as springs\n\n      for (var i = 0; i < edgeIndices.length; i++) {\n        edge = edges[edgeIndices[i]];\n\n        if (edge.connected === true && edge.toId !== edge.fromId) {\n          // only calculate forces if nodes are in the same sector\n          if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {\n            if (edge.edgeType.via !== undefined) {\n              edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;\n              node1 = edge.to;\n              node2 = edge.edgeType.via;\n              node3 = edge.from;\n\n              this._calculateSpringForce(node1, node2, 0.5 * edgeLength);\n\n              this._calculateSpringForce(node2, node3, 0.5 * edgeLength);\n            } else {\n              // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use\n              // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.\n              edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;\n\n              this._calculateSpringForce(edge.from, edge.to, edgeLength);\n            }\n          }\n        }\n      }\n    }\n    /**\n     * This is the code actually performing the calculation for the function above.\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @param {number} edgeLength\n     * @private\n     */\n\n  }, {\n    key: \"_calculateSpringForce\",\n    value: function _calculateSpringForce(node1, node2, edgeLength) {\n      var dx = node1.x - node2.x;\n      var dy = node1.y - node2.y;\n      var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01); // the 1/distance is so the fx and fy can be calculated without sine or cosine.\n\n      var springForce = this.options.springConstant * (edgeLength - distance) / distance;\n      var fx = dx * springForce;\n      var fy = dy * springForce; // handle the case where one node is not part of the physcis\n\n      if (this.physicsBody.forces[node1.id] !== undefined) {\n        this.physicsBody.forces[node1.id].x += fx;\n        this.physicsBody.forces[node1.id].y += fy;\n      }\n\n      if (this.physicsBody.forces[node2.id] !== undefined) {\n        this.physicsBody.forces[node2.id].x -= fx;\n        this.physicsBody.forces[node2.id].y -= fy;\n      }\n    }\n  }]);\n  return SpringSolver;\n}();\n/**\n * Hierarchical Spring Solver\n */\n\n\nvar HierarchicalSpringSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function HierarchicalSpringSolver(body, physicsBody, options) {\n    classCallCheck(this, HierarchicalSpringSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n  /**\n   *\n   * @param {object} options\n   */\n\n\n  createClass(HierarchicalSpringSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n    /**\n     * This function calculates the springforces on the nodes, accounting for the support nodes.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var edgeLength, edge;\n      var dx, dy, fx, fy, springForce, distance;\n      var edges = this.body.edges;\n      var factor = 0.5;\n      var edgeIndices = this.physicsBody.physicsEdgeIndices;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces; // initialize the spring force counters\n\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        forces[nodeId].springFx = 0;\n        forces[nodeId].springFy = 0;\n      } // forces caused by the edges, modelled as springs\n\n\n      for (var _i = 0; _i < edgeIndices.length; _i++) {\n        edge = edges[edgeIndices[_i]];\n\n        if (edge.connected === true) {\n          edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;\n          dx = edge.from.x - edge.to.x;\n          dy = edge.from.y - edge.to.y;\n          distance = Math.sqrt(dx * dx + dy * dy);\n          distance = distance === 0 ? 0.01 : distance; // the 1/distance is so the fx and fy can be calculated without sine or cosine.\n\n          springForce = this.options.springConstant * (edgeLength - distance) / distance;\n          fx = dx * springForce;\n          fy = dy * springForce;\n\n          if (edge.to.level != edge.from.level) {\n            if (forces[edge.toId] !== undefined) {\n              forces[edge.toId].springFx -= fx;\n              forces[edge.toId].springFy -= fy;\n            }\n\n            if (forces[edge.fromId] !== undefined) {\n              forces[edge.fromId].springFx += fx;\n              forces[edge.fromId].springFy += fy;\n            }\n          } else {\n            if (forces[edge.toId] !== undefined) {\n              forces[edge.toId].x -= factor * fx;\n              forces[edge.toId].y -= factor * fy;\n            }\n\n            if (forces[edge.fromId] !== undefined) {\n              forces[edge.fromId].x += factor * fx;\n              forces[edge.fromId].y += factor * fy;\n            }\n          }\n        }\n      } // normalize spring forces\n\n\n      springForce = 1;\n      var springFx, springFy;\n\n      for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {\n        var _nodeId = nodeIndices[_i2];\n        springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));\n        springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));\n        forces[_nodeId].x += springFx;\n        forces[_nodeId].y += springFy;\n      } // retain energy balance\n\n\n      var totalFx = 0;\n      var totalFy = 0;\n\n      for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {\n        var _nodeId2 = nodeIndices[_i3];\n        totalFx += forces[_nodeId2].x;\n        totalFy += forces[_nodeId2].y;\n      }\n\n      var correctionFx = totalFx / nodeIndices.length;\n      var correctionFy = totalFy / nodeIndices.length;\n\n      for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {\n        var _nodeId3 = nodeIndices[_i4];\n        forces[_nodeId3].x -= correctionFx;\n        forces[_nodeId3].y -= correctionFy;\n      }\n    }\n  }]);\n  return HierarchicalSpringSolver;\n}();\n/**\n * Central Gravity Solver\n */\n\n\nvar CentralGravitySolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function CentralGravitySolver(body, physicsBody, options) {\n    classCallCheck(this, CentralGravitySolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n  /**\n   *\n   * @param {object} options\n   */\n\n\n  createClass(CentralGravitySolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n    /**\n     * Calculates forces for each node\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx, dy, distance, node;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        node = nodes[nodeId];\n        dx = -node.x;\n        dy = -node.y;\n        distance = Math.sqrt(dx * dx + dy * dy);\n\n        this._calculateForces(distance, dx, dy, forces, node);\n      }\n    }\n    /**\n     * Calculate the forces based on the distance.\n     *\n     * @param {number} distance\n     * @param {number} dx\n     * @param {number} dy\n     * @param {object<Node.id, vis.Node>} forces\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, forces, node) {\n      var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;\n      forces[node.id].x = dx * gravityForce;\n      forces[node.id].y = dy * gravityForce;\n    }\n  }]);\n  return CentralGravitySolver;\n}();\n\nfunction _createSuper$p(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$p() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @augments BarnesHutSolver\n */\n\n\nvar ForceAtlas2BasedRepulsionSolver = /*#__PURE__*/function (_BarnesHutSolver) {\n  inherits(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);\n\n  var _super = _createSuper$p(ForceAtlas2BasedRepulsionSolver);\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n\n\n  function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {\n    var _this;\n\n    classCallCheck(this, ForceAtlas2BasedRepulsionSolver);\n    _this = _super.call(this, body, physicsBody, options);\n    _this._rng = Alea(\"FORCE ATLAS 2 BASED REPULSION SOLVER\");\n    return _this;\n  }\n  /**\n   * Calculate the forces based on the distance.\n   *\n   * @param {number} distance\n   * @param {number} dx\n   * @param {number} dy\n   * @param {Node} node\n   * @param {object} parentBranch\n   * @private\n   */\n\n\n  createClass(ForceAtlas2BasedRepulsionSolver, [{\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, node, parentBranch) {\n      if (distance === 0) {\n        distance = 0.1 * this._rng();\n        dx = distance;\n      }\n\n      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {\n        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);\n      }\n\n      var degree = node.edges.length + 1; // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines\n      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce\n\n      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);\n      var fx = dx * gravityForce;\n      var fy = dy * gravityForce;\n      this.physicsBody.forces[node.id].x += fx;\n      this.physicsBody.forces[node.id].y += fy;\n    }\n  }]);\n  return ForceAtlas2BasedRepulsionSolver;\n}(BarnesHutSolver);\n\nfunction _createSuper$q(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$q() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @augments CentralGravitySolver\n */\n\n\nvar ForceAtlas2BasedCentralGravitySolver = /*#__PURE__*/function (_CentralGravitySolver) {\n  inherits(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);\n\n  var _super = _createSuper$q(ForceAtlas2BasedCentralGravitySolver);\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n\n\n  function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {\n    classCallCheck(this, ForceAtlas2BasedCentralGravitySolver);\n    return _super.call(this, body, physicsBody, options);\n  }\n  /**\n   * Calculate the forces based on the distance.\n   *\n   * @param {number} distance\n   * @param {number} dx\n   * @param {number} dy\n   * @param {object<Node.id, Node>} forces\n   * @param {Node} node\n   * @private\n   */\n\n\n  createClass(ForceAtlas2BasedCentralGravitySolver, [{\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, forces, node) {\n      if (distance > 0) {\n        var degree = node.edges.length + 1;\n        var gravityForce = this.options.centralGravity * degree * node.options.mass;\n        forces[node.id].x = dx * gravityForce;\n        forces[node.id].y = dy * gravityForce;\n      }\n    }\n  }]);\n  return ForceAtlas2BasedCentralGravitySolver;\n}(CentralGravitySolver);\n/**\n * The physics engine\n */\n\n\nvar PhysicsEngine = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function PhysicsEngine(body) {\n    classCallCheck(this, PhysicsEngine);\n    this.body = body;\n    this.physicsBody = {\n      physicsNodeIndices: [],\n      physicsEdgeIndices: [],\n      forces: {},\n      velocities: {}\n    };\n    this.physicsEnabled = true;\n    this.simulationInterval = 1000 / 60;\n    this.requiresTimeout = true;\n    this.previousStates = {};\n    this.referenceState = {};\n    this.freezeCache = {};\n    this.renderTimer = undefined; // parameters for the adaptive timestep\n\n    this.adaptiveTimestep = false;\n    this.adaptiveTimestepEnabled = false;\n    this.adaptiveCounter = 0;\n    this.adaptiveInterval = 3;\n    this.stabilized = false;\n    this.startedStabilization = false;\n    this.stabilizationIterations = 0;\n    this.ready = false; // will be set to true if the stabilize\n    // default options\n\n    this.options = {};\n    this.defaultOptions = {\n      enabled: true,\n      barnesHut: {\n        theta: 0.5,\n        gravitationalConstant: -2000,\n        centralGravity: 0.3,\n        springLength: 95,\n        springConstant: 0.04,\n        damping: 0.09,\n        avoidOverlap: 0\n      },\n      forceAtlas2Based: {\n        theta: 0.5,\n        gravitationalConstant: -50,\n        centralGravity: 0.01,\n        springConstant: 0.08,\n        springLength: 100,\n        damping: 0.4,\n        avoidOverlap: 0\n      },\n      repulsion: {\n        centralGravity: 0.2,\n        springLength: 200,\n        springConstant: 0.05,\n        nodeDistance: 100,\n        damping: 0.09,\n        avoidOverlap: 0\n      },\n      hierarchicalRepulsion: {\n        centralGravity: 0.0,\n        springLength: 100,\n        springConstant: 0.01,\n        nodeDistance: 120,\n        damping: 0.09\n      },\n      maxVelocity: 50,\n      minVelocity: 0.75,\n      // px/s\n      solver: \"barnesHut\",\n      stabilization: {\n        enabled: true,\n        iterations: 1000,\n        // maximum number of iteration to stabilize\n        updateInterval: 50,\n        onlyDynamicEdges: false,\n        fit: true\n      },\n      timestep: 0.5,\n      adaptiveTimestep: true,\n      wind: {\n        x: 0,\n        y: 0\n      }\n    };\n    assign$2(this.options, this.defaultOptions);\n    this.timestep = 0.5;\n    this.layoutFailed = false;\n    this.bindEventListeners();\n  }\n  /**\n   * Binds event listeners\n   */\n\n\n  createClass(PhysicsEngine, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this;\n\n      this.body.emitter.on(\"initPhysics\", function () {\n        _this.initPhysics();\n      });\n      this.body.emitter.on(\"_layoutFailed\", function () {\n        _this.layoutFailed = true;\n      });\n      this.body.emitter.on(\"resetPhysics\", function () {\n        _this.stopSimulation();\n\n        _this.ready = false;\n      });\n      this.body.emitter.on(\"disablePhysics\", function () {\n        _this.physicsEnabled = false;\n\n        _this.stopSimulation();\n      });\n      this.body.emitter.on(\"restorePhysics\", function () {\n        _this.setOptions(_this.options);\n\n        if (_this.ready === true) {\n          _this.startSimulation();\n        }\n      });\n      this.body.emitter.on(\"startSimulation\", function () {\n        if (_this.ready === true) {\n          _this.startSimulation();\n        }\n      });\n      this.body.emitter.on(\"stopSimulation\", function () {\n        _this.stopSimulation();\n      });\n      this.body.emitter.on(\"destroy\", function () {\n        _this.stopSimulation(false);\n\n        _this.body.emitter.off();\n      });\n      this.body.emitter.on(\"_dataChanged\", function () {\n        // Nodes and/or edges have been added or removed, update shortcut lists.\n        _this.updatePhysicsData();\n      }); // debug: show forces\n      // this.body.emitter.on(\"afterDrawing\", (ctx) => {this._drawForces(ctx);});\n    }\n    /**\n     * set the physics options\n     *\n     * @param {object} options\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        if (options === false) {\n          this.options.enabled = false;\n          this.physicsEnabled = false;\n          this.stopSimulation();\n        } else if (options === true) {\n          this.options.enabled = true;\n          this.physicsEnabled = true;\n          this.startSimulation();\n        } else {\n          this.physicsEnabled = true;\n          selectiveNotDeepExtend([\"stabilization\"], this.options, options);\n          mergeOptions(this.options, options, \"stabilization\");\n\n          if (options.enabled === undefined) {\n            this.options.enabled = true;\n          }\n\n          if (this.options.enabled === false) {\n            this.physicsEnabled = false;\n            this.stopSimulation();\n          }\n\n          var wind = this.options.wind;\n\n          if (wind) {\n            if (typeof wind.x !== \"number\" || isNan$2(wind.x)) {\n              wind.x = 0;\n            }\n\n            if (typeof wind.y !== \"number\" || isNan$2(wind.y)) {\n              wind.y = 0;\n            }\n          } // set the timestep\n\n\n          this.timestep = this.options.timestep;\n        }\n      }\n\n      this.init();\n    }\n    /**\n     * configure the engine.\n     */\n\n  }, {\n    key: \"init\",\n    value: function init() {\n      var options;\n\n      if (this.options.solver === \"forceAtlas2Based\") {\n        options = this.options.forceAtlas2Based;\n        this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);\n      } else if (this.options.solver === \"repulsion\") {\n        options = this.options.repulsion;\n        this.nodesSolver = new RepulsionSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      } else if (this.options.solver === \"hierarchicalRepulsion\") {\n        options = this.options.hierarchicalRepulsion;\n        this.nodesSolver = new HierarchicalRepulsionSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      } else {\n        // barnesHut\n        options = this.options.barnesHut;\n        this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      }\n\n      this.modelOptions = options;\n    }\n    /**\n     * initialize the engine\n     */\n\n  }, {\n    key: \"initPhysics\",\n    value: function initPhysics() {\n      if (this.physicsEnabled === true && this.options.enabled === true) {\n        if (this.options.stabilization.enabled === true) {\n          this.stabilize();\n        } else {\n          this.stabilized = false;\n          this.ready = true;\n          this.body.emitter.emit(\"fit\", {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom\n\n          this.startSimulation();\n        }\n      } else {\n        this.ready = true;\n        this.body.emitter.emit(\"fit\");\n      }\n    }\n    /**\n     * Start the simulation\n     */\n\n  }, {\n    key: \"startSimulation\",\n    value: function startSimulation() {\n      if (this.physicsEnabled === true && this.options.enabled === true) {\n        this.stabilized = false; // when visible, adaptivity is disabled.\n\n        this.adaptiveTimestep = false; // this sets the width of all nodes initially which could be required for the avoidOverlap\n\n        this.body.emitter.emit(\"_resizeNodes\");\n\n        if (this.viewFunction === undefined) {\n          var _context;\n\n          this.viewFunction = bind$2(_context = this.simulationStep).call(_context, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n          this.body.emitter.emit(\"_startRendering\");\n        }\n      } else {\n        this.body.emitter.emit(\"_redraw\");\n      }\n    }\n    /**\n     * Stop the simulation, force stabilization.\n     *\n     * @param {boolean} [emit=true]\n     */\n\n  }, {\n    key: \"stopSimulation\",\n    value: function stopSimulation() {\n      var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.stabilized = true;\n\n      if (emit === true) {\n        this._emitStabilized();\n      }\n\n      if (this.viewFunction !== undefined) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.viewFunction = undefined;\n\n        if (emit === true) {\n          this.body.emitter.emit(\"_stopRendering\");\n        }\n      }\n    }\n    /**\n     * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.\n     *\n     */\n\n  }, {\n    key: \"simulationStep\",\n    value: function simulationStep() {\n      // check if the physics have settled\n      var startTime = now$2();\n      this.physicsTick();\n      var physicsTime = now$2() - startTime; // run double speed if it is a little graph\n\n      if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {\n        this.physicsTick(); // this makes sure there is no jitter. The decision is taken once to run it at double speed.\n\n        this.runDoubleSpeed = true;\n      }\n\n      if (this.stabilized === true) {\n        this.stopSimulation();\n      }\n    }\n    /**\n     * trigger the stabilized event.\n     *\n     * @param {number} [amountOfIterations=this.stabilizationIterations]\n     * @private\n     */\n\n  }, {\n    key: \"_emitStabilized\",\n    value: function _emitStabilized() {\n      var _this2 = this;\n\n      var amountOfIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.stabilizationIterations;\n\n      if (this.stabilizationIterations > 1 || this.startedStabilization === true) {\n        setTimeout$2(function () {\n          _this2.body.emitter.emit(\"stabilized\", {\n            iterations: amountOfIterations\n          });\n\n          _this2.startedStabilization = false;\n          _this2.stabilizationIterations = 0;\n        }, 0);\n      }\n    }\n    /**\n     * Calculate the forces for one physics iteration and move the nodes.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"physicsStep\",\n    value: function physicsStep() {\n      this.gravitySolver.solve();\n      this.nodesSolver.solve();\n      this.edgesSolver.solve();\n      this.moveNodes();\n    }\n    /**\n     * Make dynamic adjustments to the timestep, based on current state.\n     *\n     * Helper function for physicsTick().\n     *\n     * @private\n     */\n\n  }, {\n    key: \"adjustTimeStep\",\n    value: function adjustTimeStep() {\n      var factor = 1.2; // Factor for increasing the timestep on success.\n      // we compare the two steps. if it is acceptable we double the step.\n\n      if (this._evaluateStepQuality() === true) {\n        this.timestep = factor * this.timestep;\n      } else {\n        // if not, we decrease the step to a minimum of the options timestep.\n        // if the decreased timestep is smaller than the options step, we do not reset the counter\n        // we assume that the options timestep is stable enough.\n        if (this.timestep / factor < this.options.timestep) {\n          this.timestep = this.options.timestep;\n        } else {\n          // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure\n          // that large instabilities do not form.\n          this.adaptiveCounter = -1; // check again next iteration\n\n          this.timestep = Math.max(this.options.timestep, this.timestep / factor);\n        }\n      }\n    }\n    /**\n     * A single simulation step (or 'tick') in the physics simulation\n     *\n     * @private\n     */\n\n  }, {\n    key: \"physicsTick\",\n    value: function physicsTick() {\n      this._startStabilizing(); // this ensures that there is no start event when the network is already stable.\n\n\n      if (this.stabilized === true) return; // adaptivity means the timestep adapts to the situation, only applicable for stabilization\n\n      if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {\n        // timestep remains stable for \"interval\" iterations.\n        var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;\n\n        if (doAdaptive) {\n          // first the big step and revert.\n          this.timestep = 2 * this.timestep;\n          this.physicsStep();\n          this.revert(); // saves the reference state\n          // now the normal step. Since this is the last step, it is the more stable one and we will take this.\n\n          this.timestep = 0.5 * this.timestep; // since it's half the step, we do it twice.\n\n          this.physicsStep();\n          this.physicsStep();\n          this.adjustTimeStep();\n        } else {\n          this.physicsStep(); // normal step, keeping timestep constant\n        }\n\n        this.adaptiveCounter += 1;\n      } else {\n        // case for the static timestep, we reset it to the one in options and take a normal step.\n        this.timestep = this.options.timestep;\n        this.physicsStep();\n      }\n\n      if (this.stabilized === true) this.revert();\n      this.stabilizationIterations++;\n    }\n    /**\n     * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"updatePhysicsData\",\n    value: function updatePhysicsData() {\n      this.physicsBody.forces = {};\n      this.physicsBody.physicsNodeIndices = [];\n      this.physicsBody.physicsEdgeIndices = [];\n      var nodes = this.body.nodes;\n      var edges = this.body.edges; // get node indices for physics\n\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          if (nodes[nodeId].options.physics === true) {\n            this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);\n          }\n        }\n      } // get edge indices for physics\n\n\n      for (var edgeId in edges) {\n        if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {\n          if (edges[edgeId].options.physics === true) {\n            this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);\n          }\n        }\n      } // get the velocity and the forces vector\n\n\n      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {\n        var _nodeId = this.physicsBody.physicsNodeIndices[i];\n        this.physicsBody.forces[_nodeId] = {\n          x: 0,\n          y: 0\n        }; // forces can be reset because they are recalculated. Velocities have to persist.\n\n        if (this.physicsBody.velocities[_nodeId] === undefined) {\n          this.physicsBody.velocities[_nodeId] = {\n            x: 0,\n            y: 0\n          };\n        }\n      } // clean deleted nodes from the velocity vector\n\n\n      for (var _nodeId2 in this.physicsBody.velocities) {\n        if (nodes[_nodeId2] === undefined) {\n          delete this.physicsBody.velocities[_nodeId2];\n        }\n      }\n    }\n    /**\n     * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.\n     */\n\n  }, {\n    key: \"revert\",\n    value: function revert() {\n      var nodeIds = keys$3(this.previousStates);\n      var nodes = this.body.nodes;\n      var velocities = this.physicsBody.velocities;\n      this.referenceState = {};\n\n      for (var i = 0; i < nodeIds.length; i++) {\n        var nodeId = nodeIds[i];\n\n        if (nodes[nodeId] !== undefined) {\n          if (nodes[nodeId].options.physics === true) {\n            this.referenceState[nodeId] = {\n              positions: {\n                x: nodes[nodeId].x,\n                y: nodes[nodeId].y\n              }\n            };\n            velocities[nodeId].x = this.previousStates[nodeId].vx;\n            velocities[nodeId].y = this.previousStates[nodeId].vy;\n            nodes[nodeId].x = this.previousStates[nodeId].x;\n            nodes[nodeId].y = this.previousStates[nodeId].y;\n          }\n        } else {\n          delete this.previousStates[nodeId];\n        }\n      }\n    }\n    /**\n     * This compares the reference state to the current state\n     *\n     * @returns {boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_evaluateStepQuality\",\n    value: function _evaluateStepQuality() {\n      var dx, dy, dpos;\n      var nodes = this.body.nodes;\n      var reference = this.referenceState;\n      var posThreshold = 0.3;\n\n      for (var nodeId in this.referenceState) {\n        if (Object.prototype.hasOwnProperty.call(this.referenceState, nodeId) && nodes[nodeId] !== undefined) {\n          dx = nodes[nodeId].x - reference[nodeId].positions.x;\n          dy = nodes[nodeId].y - reference[nodeId].positions.y;\n          dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n\n          if (dpos > posThreshold) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * move the nodes one timestep and check if they are stabilized\n     */\n\n  }, {\n    key: \"moveNodes\",\n    value: function moveNodes() {\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var maxNodeVelocity = 0;\n      var averageNodeVelocity = 0; // the velocity threshold (energy in the system) for the adaptivity toggle\n\n      var velocityAdaptiveThreshold = 5;\n\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n\n        var nodeVelocity = this._performStep(nodeId); // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized\n\n\n        maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);\n        averageNodeVelocity += nodeVelocity;\n      } // evaluating the stabilized and adaptiveTimestepEnabled conditions\n\n\n      this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;\n      this.stabilized = maxNodeVelocity < this.options.minVelocity;\n    }\n    /**\n     * Calculate new velocity for a coordinate direction\n     *\n     * @param {number} v  velocity for current coordinate\n     * @param {number} f  regular force for current coordinate\n     * @param {number} m  mass of current node\n     * @returns {number} new velocity for current coordinate\n     * @private\n     */\n\n  }, {\n    key: \"calculateComponentVelocity\",\n    value: function calculateComponentVelocity(v, f, m) {\n      var df = this.modelOptions.damping * v; // damping force\n\n      var a = (f - df) / m; // acceleration\n\n      v += a * this.timestep; // Put a limit on the velocities if it is really high\n\n      var maxV = this.options.maxVelocity || 1e9;\n\n      if (Math.abs(v) > maxV) {\n        v = v > 0 ? maxV : -maxV;\n      }\n\n      return v;\n    }\n    /**\n     * Perform the actual step\n     *\n     * @param {Node.id} nodeId\n     * @returns {number} the new velocity of given node\n     * @private\n     */\n\n  }, {\n    key: \"_performStep\",\n    value: function _performStep(nodeId) {\n      var node = this.body.nodes[nodeId];\n      var force = this.physicsBody.forces[nodeId];\n\n      if (this.options.wind) {\n        force.x += this.options.wind.x;\n        force.y += this.options.wind.y;\n      }\n\n      var velocity = this.physicsBody.velocities[nodeId]; // store the state so we can revert\n\n      this.previousStates[nodeId] = {\n        x: node.x,\n        y: node.y,\n        vx: velocity.x,\n        vy: velocity.y\n      };\n\n      if (node.options.fixed.x === false) {\n        velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);\n        node.x += velocity.x * this.timestep;\n      } else {\n        force.x = 0;\n        velocity.x = 0;\n      }\n\n      if (node.options.fixed.y === false) {\n        velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);\n        node.y += velocity.y * this.timestep;\n      } else {\n        force.y = 0;\n        velocity.y = 0;\n      }\n\n      var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));\n      return totalVelocity;\n    }\n    /**\n     * When initializing and stabilizing, we can freeze nodes with a predefined position.\n     * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_freezeNodes\",\n    value: function _freezeNodes() {\n      var nodes = this.body.nodes;\n\n      for (var id in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n          if (nodes[id].x && nodes[id].y) {\n            var fixed = nodes[id].options.fixed;\n            this.freezeCache[id] = {\n              x: fixed.x,\n              y: fixed.y\n            };\n            fixed.x = true;\n            fixed.y = true;\n          }\n        }\n      }\n    }\n    /**\n     * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_restoreFrozenNodes\",\n    value: function _restoreFrozenNodes() {\n      var nodes = this.body.nodes;\n\n      for (var id in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n          if (this.freezeCache[id] !== undefined) {\n            nodes[id].options.fixed.x = this.freezeCache[id].x;\n            nodes[id].options.fixed.y = this.freezeCache[id].y;\n          }\n        }\n      }\n\n      this.freezeCache = {};\n    }\n    /**\n     * Find a stable position for all nodes\n     *\n     * @param {number} [iterations=this.options.stabilization.iterations]\n     */\n\n  }, {\n    key: \"stabilize\",\n    value: function stabilize() {\n      var _this3 = this;\n\n      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.stabilization.iterations;\n\n      if (typeof iterations !== \"number\") {\n        iterations = this.options.stabilization.iterations;\n        console.error(\"The stabilize method needs a numeric amount of iterations. Switching to default: \", iterations);\n      }\n\n      if (this.physicsBody.physicsNodeIndices.length === 0) {\n        this.ready = true;\n        return;\n      } // enable adaptive timesteps\n\n\n      this.adaptiveTimestep = this.options.adaptiveTimestep; // this sets the width of all nodes initially which could be required for the avoidOverlap\n\n      this.body.emitter.emit(\"_resizeNodes\");\n      this.stopSimulation(); // stop the render loop\n\n      this.stabilized = false; // block redraw requests\n\n      this.body.emitter.emit(\"_blockRedraw\");\n      this.targetIterations = iterations; // start the stabilization\n\n      if (this.options.stabilization.onlyDynamicEdges === true) {\n        this._freezeNodes();\n      }\n\n      this.stabilizationIterations = 0;\n      setTimeout$2(function () {\n        return _this3._stabilizationBatch();\n      }, 0);\n    }\n    /**\n     * If not already stabilizing, start it and emit a start event.\n     *\n     * @returns {boolean} true if stabilization started with this call\n     * @private\n     */\n\n  }, {\n    key: \"_startStabilizing\",\n    value: function _startStabilizing() {\n      if (this.startedStabilization === true) return false;\n      this.body.emitter.emit(\"startStabilizing\");\n      this.startedStabilization = true;\n      return true;\n    }\n    /**\n     * One batch of stabilization\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_stabilizationBatch\",\n    value: function _stabilizationBatch() {\n      var _this4 = this;\n\n      var running = function running() {\n        return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;\n      };\n\n      var sendProgress = function sendProgress() {\n        _this4.body.emitter.emit(\"stabilizationProgress\", {\n          iterations: _this4.stabilizationIterations,\n          total: _this4.targetIterations\n        });\n      };\n\n      if (this._startStabilizing()) {\n        sendProgress(); // Ensure that there is at least one start event.\n      }\n\n      var count = 0;\n\n      while (running() && count < this.options.stabilization.updateInterval) {\n        this.physicsTick();\n        count++;\n      }\n\n      sendProgress();\n\n      if (running()) {\n        var _context2;\n\n        setTimeout$2(bind$2(_context2 = this._stabilizationBatch).call(_context2, this), 0);\n      } else {\n        this._finalizeStabilization();\n      }\n    }\n    /**\n     * Wrap up the stabilization, fit and emit the events.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_finalizeStabilization\",\n    value: function _finalizeStabilization() {\n      this.body.emitter.emit(\"_allowRedraw\");\n\n      if (this.options.stabilization.fit === true) {\n        this.body.emitter.emit(\"fit\");\n      }\n\n      if (this.options.stabilization.onlyDynamicEdges === true) {\n        this._restoreFrozenNodes();\n      }\n\n      this.body.emitter.emit(\"stabilizationIterationsDone\");\n      this.body.emitter.emit(\"_requestRedraw\");\n\n      if (this.stabilized === true) {\n        this._emitStabilized();\n      } else {\n        this.startSimulation();\n      }\n\n      this.ready = true;\n    } //---------------------------  DEBUGGING BELOW  ---------------------------//\n\n    /**\n     * Debug function that display arrows for the forces currently active in the network.\n     *\n     * Use this when debugging only.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @private\n     */\n\n  }, {\n    key: \"_drawForces\",\n    value: function _drawForces(ctx) {\n      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {\n        var index = this.physicsBody.physicsNodeIndices[i];\n        var node = this.body.nodes[index];\n        var force = this.physicsBody.forces[index];\n        var factor = 20;\n        var colorFactor = 0.03;\n        var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));\n        var size = Math.min(Math.max(5, forceSize), 15);\n        var arrowSize = 3 * size;\n        var color = HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);\n        var point = {\n          x: node.x + factor * force.x,\n          y: node.y + factor * force.y\n        };\n        ctx.lineWidth = size;\n        ctx.strokeStyle = color;\n        ctx.beginPath();\n        ctx.moveTo(node.x, node.y);\n        ctx.lineTo(point.x, point.y);\n        ctx.stroke();\n        var angle = Math.atan2(force.y, force.x);\n        ctx.fillStyle = color;\n        EndPoints.draw(ctx, {\n          type: \"arrow\",\n          point: point,\n          angle: angle,\n          length: arrowSize\n        });\n        fill$2(ctx).call(ctx);\n      }\n    }\n  }]);\n  return PhysicsEngine;\n}();\n\nvar nativeReverse = [].reverse;\nvar test$1 = [1, 2]; // `Array.prototype.reverse` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.reverse\n// fix for Safari 12.0 bug\n// https://bugs.webkit.org/show_bug.cgi?id=188794\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: String(test$1) === String(test$1.reverse())\n}, {\n  reverse: function reverse() {\n    // eslint-disable-next-line no-self-assign\n    if (isArray(this)) this.length = this.length;\n    return nativeReverse.call(this);\n  }\n});\n\nvar reverse = entryVirtual('Array').reverse;\nvar ArrayPrototype$c = Array.prototype;\n\nvar reverse_1 = function (it) {\n  var own = it.reverse;\n  return it === ArrayPrototype$c || it instanceof Array && own === ArrayPrototype$c.reverse ? reverse : own;\n};\n\nvar reverse$1 = reverse_1;\nvar reverse$2 = reverse$1; // Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\n\nvar getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16);\n\nfunction rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n\n  return getRandomValues(rnds8);\n}\n\nvar REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify$3(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify$3(rnds);\n}\n/**\n * Utility Class\n */\n\n\nvar NetworkUtil = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function NetworkUtil() {\n    classCallCheck(this, NetworkUtil);\n  }\n  /**\n   * Find the center position of the network considering the bounding boxes\n   *\n   * @param {Array.<Node>} allNodes\n   * @param {Array.<Node>} [specificNodes=[]]\n   * @returns {{minX: number, maxX: number, minY: number, maxY: number}}\n   * @static\n   */\n\n\n  createClass(NetworkUtil, null, [{\n    key: \"getRange\",\n    value: function getRange(allNodes) {\n      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var minY = 1e9,\n          maxY = -1e9,\n          minX = 1e9,\n          maxX = -1e9,\n          node;\n\n      if (specificNodes.length > 0) {\n        for (var i = 0; i < specificNodes.length; i++) {\n          node = allNodes[specificNodes[i]];\n\n          if (minX > node.shape.boundingBox.left) {\n            minX = node.shape.boundingBox.left;\n          }\n\n          if (maxX < node.shape.boundingBox.right) {\n            maxX = node.shape.boundingBox.right;\n          }\n\n          if (minY > node.shape.boundingBox.top) {\n            minY = node.shape.boundingBox.top;\n          } // top is negative, bottom is positive\n\n\n          if (maxY < node.shape.boundingBox.bottom) {\n            maxY = node.shape.boundingBox.bottom;\n          } // top is negative, bottom is positive\n\n        }\n      }\n\n      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {\n        minY = 0, maxY = 0, minX = 0, maxX = 0;\n      }\n\n      return {\n        minX: minX,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY\n      };\n    }\n    /**\n     * Find the center position of the network\n     *\n     * @param {Array.<Node>} allNodes\n     * @param {Array.<Node>} [specificNodes=[]]\n     * @returns {{minX: number, maxX: number, minY: number, maxY: number}}\n     * @static\n     */\n\n  }, {\n    key: \"getRangeCore\",\n    value: function getRangeCore(allNodes) {\n      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var minY = 1e9,\n          maxY = -1e9,\n          minX = 1e9,\n          maxX = -1e9,\n          node;\n\n      if (specificNodes.length > 0) {\n        for (var i = 0; i < specificNodes.length; i++) {\n          node = allNodes[specificNodes[i]];\n\n          if (minX > node.x) {\n            minX = node.x;\n          }\n\n          if (maxX < node.x) {\n            maxX = node.x;\n          }\n\n          if (minY > node.y) {\n            minY = node.y;\n          } // top is negative, bottom is positive\n\n\n          if (maxY < node.y) {\n            maxY = node.y;\n          } // top is negative, bottom is positive\n\n        }\n      }\n\n      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {\n        minY = 0, maxY = 0, minX = 0, maxX = 0;\n      }\n\n      return {\n        minX: minX,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY\n      };\n    }\n    /**\n     * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};\n     * @returns {{x: number, y: number}}\n     * @static\n     */\n\n  }, {\n    key: \"findCenter\",\n    value: function findCenter(range) {\n      return {\n        x: 0.5 * (range.maxX + range.minX),\n        y: 0.5 * (range.maxY + range.minY)\n      };\n    }\n    /**\n     * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.\n     *\n     * @param {vis.Item} item\n     * @param {'node'|undefined} type\n     * @returns {{}}\n     * @static\n     */\n\n  }, {\n    key: \"cloneOptions\",\n    value: function cloneOptions(item, type) {\n      var clonedOptions = {};\n\n      if (type === undefined || type === \"node\") {\n        deepExtend(clonedOptions, item.options, true);\n        clonedOptions.x = item.x;\n        clonedOptions.y = item.y;\n        clonedOptions.amountOfConnections = item.edges.length;\n      } else {\n        deepExtend(clonedOptions, item.options, true);\n      }\n\n      return clonedOptions;\n    }\n  }]);\n  return NetworkUtil;\n}();\n\nfunction _createSuper$r(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$r() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * A Cluster is a special Node that allows a group of Nodes positioned closely together\n * to be represented by a single Cluster Node.\n *\n * @augments Node\n */\n\n\nvar Cluster = /*#__PURE__*/function (_Node) {\n  inherits(Cluster, _Node);\n\n  var _super = _createSuper$r(Cluster);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Array.<HTMLImageElement>}imagelist\n   * @param {Array} grouplist\n   * @param {object} globalOptions\n   * @param {object} defaultOptions     Global default options for nodes\n   */\n\n\n  function Cluster(options, body, imagelist, grouplist, globalOptions, defaultOptions) {\n    var _this;\n\n    classCallCheck(this, Cluster);\n    _this = _super.call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions);\n    _this.isCluster = true;\n    _this.containedNodes = {};\n    _this.containedEdges = {};\n    return _this;\n  }\n  /**\n   * Transfer child cluster data to current and disconnect the child cluster.\n   *\n   * Please consult the header comment in 'Clustering.js' for the fields set here.\n   *\n   * @param {string|number} childClusterId  id of child cluster to open\n   */\n\n\n  createClass(Cluster, [{\n    key: \"_openChildCluster\",\n    value: function _openChildCluster(childClusterId) {\n      var _this2 = this;\n\n      var childCluster = this.body.nodes[childClusterId];\n\n      if (this.containedNodes[childClusterId] === undefined) {\n        throw new Error(\"node with id: \" + childClusterId + \" not in current cluster\");\n      }\n\n      if (!childCluster.isCluster) {\n        throw new Error(\"node with id: \" + childClusterId + \" is not a cluster\");\n      } // Disconnect child cluster from current cluster\n\n\n      delete this.containedNodes[childClusterId];\n      forEach$3(childCluster.edges, function (edge) {\n        delete _this2.containedEdges[edge.id];\n      }); // Transfer nodes and edges\n\n      forEach$3(childCluster.containedNodes, function (node, nodeId) {\n        _this2.containedNodes[nodeId] = node;\n      });\n      childCluster.containedNodes = {};\n      forEach$3(childCluster.containedEdges, function (edge, edgeId) {\n        _this2.containedEdges[edgeId] = edge;\n      });\n      childCluster.containedEdges = {}; // Transfer edges within cluster edges which are clustered\n\n      forEach$3(childCluster.edges, function (clusterEdge) {\n        forEach$3(_this2.edges, function (parentClusterEdge) {\n          var _context, _context2; // Assumption: a clustered edge can only be present in a single clustering edge\n          // Not tested here\n\n\n          var index = indexOf$3(_context = parentClusterEdge.clusteringEdgeReplacingIds).call(_context, clusterEdge.id);\n          if (index === -1) return;\n          forEach$3(clusterEdge.clusteringEdgeReplacingIds, function (srcId) {\n            parentClusterEdge.clusteringEdgeReplacingIds.push(srcId); // Maintain correct bookkeeping for transferred edge\n\n            _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;\n          }); // Remove cluster edge from parent cluster edge\n\n          splice$2(_context2 = parentClusterEdge.clusteringEdgeReplacingIds).call(_context2, index, 1);\n        });\n      });\n      childCluster.edges = [];\n    }\n  }]);\n  return Cluster;\n}(Node);\n/**\n * The clustering engine\n */\n\n\nvar ClusterEngine = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function ClusterEngine(body) {\n    var _this = this;\n\n    classCallCheck(this, ClusterEngine);\n    this.body = body;\n    this.clusteredNodes = {}; // key: node id, value: { clusterId: <id of cluster>, node: <node instance>}\n\n    this.clusteredEdges = {}; // key: edge id, value: restore information for given edge\n\n    this.options = {};\n    this.defaultOptions = {};\n    assign$2(this.options, this.defaultOptions);\n    this.body.emitter.on(\"_resetData\", function () {\n      _this.clusteredNodes = {};\n      _this.clusteredEdges = {};\n    });\n  }\n  /**\n   *\n   * @param {number} hubsize\n   * @param {object} options\n   */\n\n\n  createClass(ClusterEngine, [{\n    key: \"clusterByHubsize\",\n    value: function clusterByHubsize(hubsize, options) {\n      if (hubsize === undefined) {\n        hubsize = this._getHubSize();\n      } else if (_typeof_1(hubsize) === \"object\") {\n        options = this._checkOptions(hubsize);\n        hubsize = this._getHubSize();\n      }\n\n      var nodesToCluster = [];\n\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n\n        if (node.edges.length >= hubsize) {\n          nodesToCluster.push(node.id);\n        }\n      }\n\n      for (var _i = 0; _i < nodesToCluster.length; _i++) {\n        this.clusterByConnection(nodesToCluster[_i], options, true);\n      }\n\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n    /**\n     * loop over all nodes, check if they adhere to the condition and cluster if needed.\n     *\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n\n  }, {\n    key: \"cluster\",\n    value: function cluster() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (options.joinCondition === undefined) {\n        throw new Error(\"Cannot call clusterByNodeData without a joinCondition function in the options.\");\n      } // check if the options object is fine, append if needed\n\n\n      options = this._checkOptions(options);\n      var childNodesObj = {};\n      var childEdgesObj = {}; // collect the nodes that will be in the cluster\n\n      forEach$3(this.body.nodes, function (node, nodeId) {\n        if (node.options && options.joinCondition(node.options) === true) {\n          childNodesObj[nodeId] = node; // collect the edges that will be in the cluster\n\n          forEach$3(node.edges, function (edge) {\n            if (_this2.clusteredEdges[edge.id] === undefined) {\n              childEdgesObj[edge.id] = edge;\n            }\n          });\n        }\n      });\n\n      this._cluster(childNodesObj, childEdgesObj, options, refreshData);\n    }\n    /**\n     * Cluster all nodes in the network that have only X edges\n     *\n     * @param {number} edgeCount\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n\n  }, {\n    key: \"clusterByEdgeCount\",\n    value: function clusterByEdgeCount(edgeCount, options) {\n      var _this3 = this;\n\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      options = this._checkOptions(options);\n      var clusters = [];\n      var usedNodes = {};\n      var edge, edges, relevantEdgeCount; // collect the nodes that will be in the cluster\n\n      var _loop = function _loop(i) {\n        var childNodesObj = {};\n        var childEdgesObj = {};\n        var nodeId = _this3.body.nodeIndices[i];\n        var node = _this3.body.nodes[nodeId]; // if this node is already used in another cluster this session, we do not have to re-evaluate it.\n\n        if (usedNodes[nodeId] === undefined) {\n          relevantEdgeCount = 0;\n          edges = [];\n\n          for (var j = 0; j < node.edges.length; j++) {\n            edge = node.edges[j];\n\n            if (_this3.clusteredEdges[edge.id] === undefined) {\n              if (edge.toId !== edge.fromId) {\n                relevantEdgeCount++;\n              }\n\n              edges.push(edge);\n            }\n          } // this node qualifies, we collect its neighbours to start the clustering process.\n\n\n          if (relevantEdgeCount === edgeCount) {\n            var checkJoinCondition = function checkJoinCondition(node) {\n              if (options.joinCondition === undefined || options.joinCondition === null) {\n                return true;\n              }\n\n              var clonedOptions = NetworkUtil.cloneOptions(node);\n              return options.joinCondition(clonedOptions);\n            };\n\n            var gatheringSuccessful = true;\n\n            for (var _j = 0; _j < edges.length; _j++) {\n              edge = edges[_j];\n\n              var childNodeId = _this3._getConnectedId(edge, nodeId); // add the nodes to the list by the join condition.\n\n\n              if (checkJoinCondition(node)) {\n                childEdgesObj[edge.id] = edge;\n                childNodesObj[nodeId] = node;\n                childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];\n                usedNodes[nodeId] = true;\n              } else {\n                // this node does not qualify after all.\n                gatheringSuccessful = false;\n                break;\n              }\n            } // add to the cluster queue\n\n\n            if (keys$3(childNodesObj).length > 0 && keys$3(childEdgesObj).length > 0 && gatheringSuccessful === true) {\n              /**\n               * Search for cluster data that contains any of the node id's\n               *\n               * @returns {boolean} true if no joinCondition, otherwise return value of joinCondition\n               */\n              var findClusterData = function findClusterData() {\n                for (var n = 0; n < clusters.length; ++n) {\n                  // Search for a cluster containing any of the node id's\n                  for (var m in childNodesObj) {\n                    if (clusters[n].nodes[m] !== undefined) {\n                      return clusters[n];\n                    }\n                  }\n                }\n\n                return undefined;\n              }; // If any of the found nodes is part of a cluster found in this method,\n              // add the current values to that cluster\n\n\n              var foundCluster = findClusterData();\n\n              if (foundCluster !== undefined) {\n                // Add nodes to found cluster if not present\n                for (var m in childNodesObj) {\n                  if (foundCluster.nodes[m] === undefined) {\n                    foundCluster.nodes[m] = childNodesObj[m];\n                  }\n                } // Add edges to found cluster, if not present\n\n\n                for (var _m in childEdgesObj) {\n                  if (foundCluster.edges[_m] === undefined) {\n                    foundCluster.edges[_m] = childEdgesObj[_m];\n                  }\n                }\n              } else {\n                // Create a new cluster group\n                clusters.push({\n                  nodes: childNodesObj,\n                  edges: childEdgesObj\n                });\n              }\n            }\n          }\n        }\n      };\n\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        _loop(i);\n      }\n\n      for (var _i2 = 0; _i2 < clusters.length; _i2++) {\n        this._cluster(clusters[_i2].nodes, clusters[_i2].edges, options, false);\n      }\n\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    /**\n     * Cluster all nodes in the network that have only 1 edge\n     *\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n\n  }, {\n    key: \"clusterOutliers\",\n    value: function clusterOutliers(options) {\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.clusterByEdgeCount(1, options, refreshData);\n    }\n    /**\n     * Cluster all nodes in the network that have only 2 edge\n     *\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n\n  }, {\n    key: \"clusterBridges\",\n    value: function clusterBridges(options) {\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.clusterByEdgeCount(2, options, refreshData);\n    }\n    /**\n     * suck all connected nodes of a node into the node.\n     *\n     * @param {Node.id} nodeId\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n\n  }, {\n    key: \"clusterByConnection\",\n    value: function clusterByConnection(nodeId, options) {\n      var _context;\n\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // kill conditions\n\n      if (nodeId === undefined) {\n        throw new Error(\"No nodeId supplied to clusterByConnection!\");\n      }\n\n      if (this.body.nodes[nodeId] === undefined) {\n        throw new Error(\"The nodeId given to clusterByConnection does not exist!\");\n      }\n\n      var node = this.body.nodes[nodeId];\n      options = this._checkOptions(options, node);\n\n      if (options.clusterNodeProperties.x === undefined) {\n        options.clusterNodeProperties.x = node.x;\n      }\n\n      if (options.clusterNodeProperties.y === undefined) {\n        options.clusterNodeProperties.y = node.y;\n      }\n\n      if (options.clusterNodeProperties.fixed === undefined) {\n        options.clusterNodeProperties.fixed = {};\n        options.clusterNodeProperties.fixed.x = node.options.fixed.x;\n        options.clusterNodeProperties.fixed.y = node.options.fixed.y;\n      }\n\n      var childNodesObj = {};\n      var childEdgesObj = {};\n      var parentNodeId = node.id;\n      var parentClonedOptions = NetworkUtil.cloneOptions(node);\n      childNodesObj[parentNodeId] = node; // collect the nodes that will be in the cluster\n\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n\n        if (this.clusteredEdges[edge.id] === undefined) {\n          var childNodeId = this._getConnectedId(edge, parentNodeId); // if the child node is not in a cluster\n\n\n          if (this.clusteredNodes[childNodeId] === undefined) {\n            if (childNodeId !== parentNodeId) {\n              if (options.joinCondition === undefined) {\n                childEdgesObj[edge.id] = edge;\n                childNodesObj[childNodeId] = this.body.nodes[childNodeId];\n              } else {\n                // clone the options and insert some additional parameters that could be interesting.\n                var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);\n\n                if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {\n                  childEdgesObj[edge.id] = edge;\n                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];\n                }\n              }\n            } else {\n              // swallow the edge if it is self-referencing.\n              childEdgesObj[edge.id] = edge;\n            }\n          }\n        }\n      }\n\n      var childNodeIDs = map$2(_context = keys$3(childNodesObj)).call(_context, function (childNode) {\n        return childNodesObj[childNode].id;\n      });\n\n      for (var childNodeKey in childNodesObj) {\n        if (!Object.prototype.hasOwnProperty.call(childNodesObj, childNodeKey)) continue;\n        var childNode = childNodesObj[childNodeKey];\n\n        for (var y = 0; y < childNode.edges.length; y++) {\n          var childEdge = childNode.edges[y];\n\n          if (indexOf$3(childNodeIDs).call(childNodeIDs, this._getConnectedId(childEdge, childNode.id)) > -1) {\n            childEdgesObj[childEdge.id] = childEdge;\n          }\n        }\n      }\n\n      this._cluster(childNodesObj, childEdgesObj, options, refreshData);\n    }\n    /**\n     * This function creates the edges that will be attached to the cluster\n     * It looks for edges that are connected to the nodes from the \"outside' of the cluster.\n     *\n     * @param {{Node.id: vis.Node}} childNodesObj\n     * @param {{vis.Edge.id: vis.Edge}} childEdgesObj\n     * @param {object} clusterNodeProperties\n     * @param {object} clusterEdgeProperties\n     * @private\n     */\n\n  }, {\n    key: \"_createClusterEdges\",\n    value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {\n      var edge, childNodeId, childNode, toId, fromId, otherNodeId; // loop over all child nodes and their edges to find edges going out of the cluster\n      // these edges will be replaced by clusterEdges.\n\n      var childKeys = keys$3(childNodesObj);\n      var createEdges = [];\n\n      for (var i = 0; i < childKeys.length; i++) {\n        childNodeId = childKeys[i];\n        childNode = childNodesObj[childNodeId]; // construct new edges from the cluster to others\n\n        for (var j = 0; j < childNode.edges.length; j++) {\n          edge = childNode.edges[j]; // we only handle edges that are visible to the system, not the disabled ones from the clustering process.\n\n          if (this.clusteredEdges[edge.id] === undefined) {\n            // self-referencing edges will be added to the \"hidden\" list\n            if (edge.toId == edge.fromId) {\n              childEdgesObj[edge.id] = edge;\n            } else {\n              // set up the from and to.\n              if (edge.toId == childNodeId) {\n                // this is a double equals because ints and strings can be interchanged here.\n                toId = clusterNodeProperties.id;\n                fromId = edge.fromId;\n                otherNodeId = fromId;\n              } else {\n                toId = edge.toId;\n                fromId = clusterNodeProperties.id;\n                otherNodeId = toId;\n              }\n            } // Only edges from the cluster outwards are being replaced.\n\n\n            if (childNodesObj[otherNodeId] === undefined) {\n              createEdges.push({\n                edge: edge,\n                fromId: fromId,\n                toId: toId\n              });\n            }\n          }\n        }\n      } //\n      // Here we actually create the replacement edges.\n      //\n      // We could not do this in the loop above as the creation process\n      // would add an edge to the edges array we are iterating over.\n      //\n      // NOTE: a clustered edge can have multiple base edges!\n      //\n\n\n      var newEdges = [];\n      /**\n       * Find a cluster edge which matches the given created edge.\n       *\n       * @param {vis.Edge} createdEdge\n       * @returns {vis.Edge}\n       */\n\n      var getNewEdge = function getNewEdge(createdEdge) {\n        for (var _j2 = 0; _j2 < newEdges.length; _j2++) {\n          var newEdge = newEdges[_j2]; // We replace both to and from edges with a single cluster edge\n\n          var matchToDirection = createdEdge.fromId === newEdge.fromId && createdEdge.toId === newEdge.toId;\n          var matchFromDirection = createdEdge.fromId === newEdge.toId && createdEdge.toId === newEdge.fromId;\n\n          if (matchToDirection || matchFromDirection) {\n            return newEdge;\n          }\n        }\n\n        return null;\n      };\n\n      for (var _j3 = 0; _j3 < createEdges.length; _j3++) {\n        var createdEdge = createEdges[_j3];\n        var _edge = createdEdge.edge;\n        var newEdge = getNewEdge(createdEdge);\n\n        if (newEdge === null) {\n          // Create a clustered edge for this connection\n          newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);\n          newEdges.push(newEdge);\n        } else {\n          newEdge.clusteringEdgeReplacingIds.push(_edge.id);\n        } // also reference the new edge in the old edge\n\n\n        this.body.edges[_edge.id].edgeReplacedById = newEdge.id; // hide the replaced edge\n\n        this._backupEdgeOptions(_edge);\n\n        _edge.setOptions({\n          physics: false\n        });\n      }\n    }\n    /**\n     * This function checks the options that can be supplied to the different cluster functions\n     * for certain fields and inserts defaults if needed\n     *\n     * @param {object} options\n     * @returns {*}\n     * @private\n     */\n\n  }, {\n    key: \"_checkOptions\",\n    value: function _checkOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.clusterEdgeProperties === undefined) {\n        options.clusterEdgeProperties = {};\n      }\n\n      if (options.clusterNodeProperties === undefined) {\n        options.clusterNodeProperties = {};\n      }\n\n      return options;\n    }\n    /**\n     *\n     * @param {object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node\n     * @param {object}    childEdgesObj         | object with edge objects, id as keys\n     * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}\n     * @param {boolean}   refreshData | when true, do not wrap up\n     * @private\n     */\n\n  }, {\n    key: \"_cluster\",\n    value: function _cluster(childNodesObj, childEdgesObj, options) {\n      var refreshData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true; // Remove nodes which are already clustered\n\n      var tmpNodesToRemove = [];\n\n      for (var nodeId in childNodesObj) {\n        if (Object.prototype.hasOwnProperty.call(childNodesObj, nodeId)) {\n          if (this.clusteredNodes[nodeId] !== undefined) {\n            tmpNodesToRemove.push(nodeId);\n          }\n        }\n      }\n\n      for (var n = 0; n < tmpNodesToRemove.length; ++n) {\n        delete childNodesObj[tmpNodesToRemove[n]];\n      } // kill condition: no nodes don't bother\n\n\n      if (keys$3(childNodesObj).length == 0) {\n        return;\n      } // allow clusters of 1 if options allow\n\n\n      if (keys$3(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {\n        return;\n      }\n\n      var clusterNodeProperties = deepExtend({}, options.clusterNodeProperties); // construct the clusterNodeProperties\n\n      if (options.processProperties !== undefined) {\n        // get the childNode options\n        var childNodesOptions = [];\n\n        for (var _nodeId in childNodesObj) {\n          if (Object.prototype.hasOwnProperty.call(childNodesObj, _nodeId)) {\n            var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId]);\n            childNodesOptions.push(clonedOptions);\n          }\n        } // get cluster properties based on childNodes\n\n\n        var childEdgesOptions = [];\n\n        for (var edgeId in childEdgesObj) {\n          if (Object.prototype.hasOwnProperty.call(childEdgesObj, edgeId)) {\n            // these cluster edges will be removed on creation of the cluster.\n            if (edgeId.substr(0, 12) !== \"clusterEdge:\") {\n              var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], \"edge\");\n\n              childEdgesOptions.push(_clonedOptions);\n            }\n          }\n        }\n\n        clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);\n\n        if (!clusterNodeProperties) {\n          throw new Error(\"The processProperties function does not return properties!\");\n        }\n      } // check if we have an unique id;\n\n\n      if (clusterNodeProperties.id === undefined) {\n        clusterNodeProperties.id = \"cluster:\" + v4();\n      }\n\n      var clusterId = clusterNodeProperties.id;\n\n      if (clusterNodeProperties.label === undefined) {\n        clusterNodeProperties.label = \"cluster\";\n      } // give the clusterNode a position if it does not have one.\n\n\n      var pos = undefined;\n\n      if (clusterNodeProperties.x === undefined) {\n        pos = this._getClusterPosition(childNodesObj);\n        clusterNodeProperties.x = pos.x;\n      }\n\n      if (clusterNodeProperties.y === undefined) {\n        if (pos === undefined) {\n          pos = this._getClusterPosition(childNodesObj);\n        }\n\n        clusterNodeProperties.y = pos.y;\n      } // force the ID to remain the same\n\n\n      clusterNodeProperties.id = clusterId; // create the cluster Node\n      // Note that allowSingleNodeCluster, if present, is stored in the options as well\n\n      var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);\n      clusterNode.containedNodes = childNodesObj;\n      clusterNode.containedEdges = childEdgesObj; // cache a copy from the cluster edge properties if we have to reconnect others later on\n\n      clusterNode.clusterEdgeProperties = options.clusterEdgeProperties; // finally put the cluster node into global\n\n      this.body.nodes[clusterNodeProperties.id] = clusterNode;\n\n      this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties); // set ID to undefined so no duplicates arise\n\n\n      clusterNodeProperties.id = undefined; // wrap up\n\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    /**\n     *\n     * @param {Edge} edge\n     * @private\n     */\n\n  }, {\n    key: \"_backupEdgeOptions\",\n    value: function _backupEdgeOptions(edge) {\n      if (this.clusteredEdges[edge.id] === undefined) {\n        this.clusteredEdges[edge.id] = {\n          physics: edge.options.physics\n        };\n      }\n    }\n    /**\n     *\n     * @param {Edge} edge\n     * @private\n     */\n\n  }, {\n    key: \"_restoreEdge\",\n    value: function _restoreEdge(edge) {\n      var originalOptions = this.clusteredEdges[edge.id];\n\n      if (originalOptions !== undefined) {\n        edge.setOptions({\n          physics: originalOptions.physics\n        });\n        delete this.clusteredEdges[edge.id];\n      }\n    }\n    /**\n     * Check if a node is a cluster.\n     *\n     * @param {Node.id} nodeId\n     * @returns {*}\n     */\n\n  }, {\n    key: \"isCluster\",\n    value: function isCluster(nodeId) {\n      if (this.body.nodes[nodeId] !== undefined) {\n        return this.body.nodes[nodeId].isCluster === true;\n      } else {\n        console.error(\"Node does not exist.\");\n        return false;\n      }\n    }\n    /**\n     * get the position of the cluster node based on what's inside\n     *\n     * @param {object} childNodesObj    | object with node objects, id as keys\n     * @returns {{x: number, y: number}}\n     * @private\n     */\n\n  }, {\n    key: \"_getClusterPosition\",\n    value: function _getClusterPosition(childNodesObj) {\n      var childKeys = keys$3(childNodesObj);\n      var minX = childNodesObj[childKeys[0]].x;\n      var maxX = childNodesObj[childKeys[0]].x;\n      var minY = childNodesObj[childKeys[0]].y;\n      var maxY = childNodesObj[childKeys[0]].y;\n      var node;\n\n      for (var i = 1; i < childKeys.length; i++) {\n        node = childNodesObj[childKeys[i]];\n        minX = node.x < minX ? node.x : minX;\n        maxX = node.x > maxX ? node.x : maxX;\n        minY = node.y < minY ? node.y : minY;\n        maxY = node.y > maxY ? node.y : maxY;\n      }\n\n      return {\n        x: 0.5 * (minX + maxX),\n        y: 0.5 * (minY + maxY)\n      };\n    }\n    /**\n     * Open a cluster by calling this function.\n     *\n     * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node\n     * @param {object} options\n     * @param {boolean} refreshData | wrap up afterwards if not true\n     */\n\n  }, {\n    key: \"openCluster\",\n    value: function openCluster(clusterNodeId, options) {\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // kill conditions\n\n      if (clusterNodeId === undefined) {\n        throw new Error(\"No clusterNodeId supplied to openCluster.\");\n      }\n\n      var clusterNode = this.body.nodes[clusterNodeId];\n\n      if (clusterNode === undefined) {\n        throw new Error(\"The clusterNodeId supplied to openCluster does not exist.\");\n      }\n\n      if (clusterNode.isCluster !== true || clusterNode.containedNodes === undefined || clusterNode.containedEdges === undefined) {\n        throw new Error(\"The node:\" + clusterNodeId + \" is not a valid cluster.\");\n      } // Check if current cluster is clustered itself\n\n\n      var stack = this.findNode(clusterNodeId);\n      var parentIndex = indexOf$3(stack).call(stack, clusterNodeId) - 1;\n\n      if (parentIndex >= 0) {\n        // Current cluster is clustered; transfer contained nodes and edges to parent\n        var parentClusterNodeId = stack[parentIndex];\n        var parentClusterNode = this.body.nodes[parentClusterNodeId]; // clustering.clusteredNodes and clustering.clusteredEdges remain unchanged\n\n        parentClusterNode._openChildCluster(clusterNodeId); // All components of child cluster node have been transferred. It can die now.\n\n\n        delete this.body.nodes[clusterNodeId];\n\n        if (refreshData === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n\n        return;\n      } // main body\n\n\n      var containedNodes = clusterNode.containedNodes;\n      var containedEdges = clusterNode.containedEdges; // allow the user to position the nodes after release.\n\n      if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === \"function\") {\n        var positions = {};\n        var clusterPosition = {\n          x: clusterNode.x,\n          y: clusterNode.y\n        };\n\n        for (var nodeId in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {\n            var containedNode = this.body.nodes[nodeId];\n            positions[nodeId] = {\n              x: containedNode.x,\n              y: containedNode.y\n            };\n          }\n        }\n\n        var newPositions = options.releaseFunction(clusterPosition, positions);\n\n        for (var _nodeId2 in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId2)) {\n            var _containedNode = this.body.nodes[_nodeId2];\n\n            if (newPositions[_nodeId2] !== undefined) {\n              _containedNode.x = newPositions[_nodeId2].x === undefined ? clusterNode.x : newPositions[_nodeId2].x;\n              _containedNode.y = newPositions[_nodeId2].y === undefined ? clusterNode.y : newPositions[_nodeId2].y;\n            }\n          }\n        }\n      } else {\n        // copy the position from the cluster\n        forEach$3(containedNodes, function (containedNode) {\n          // inherit position\n          if (containedNode.options.fixed.x === false) {\n            containedNode.x = clusterNode.x;\n          }\n\n          if (containedNode.options.fixed.y === false) {\n            containedNode.y = clusterNode.y;\n          }\n        });\n      } // release nodes\n\n\n      for (var _nodeId3 in containedNodes) {\n        if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId3)) {\n          var _containedNode2 = this.body.nodes[_nodeId3]; // inherit speed\n\n          _containedNode2.vx = clusterNode.vx;\n          _containedNode2.vy = clusterNode.vy;\n\n          _containedNode2.setOptions({\n            physics: true\n          });\n\n          delete this.clusteredNodes[_nodeId3];\n        }\n      } // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.\n\n\n      var edgesToBeDeleted = [];\n\n      for (var i = 0; i < clusterNode.edges.length; i++) {\n        edgesToBeDeleted.push(clusterNode.edges[i]);\n      } // actually handling the deleting.\n\n\n      for (var _i3 = 0; _i3 < edgesToBeDeleted.length; _i3++) {\n        var edge = edgesToBeDeleted[_i3];\n\n        var otherNodeId = this._getConnectedId(edge, clusterNodeId);\n\n        var otherNode = this.clusteredNodes[otherNodeId];\n\n        for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {\n          var transferId = edge.clusteringEdgeReplacingIds[j];\n          var transferEdge = this.body.edges[transferId];\n          if (transferEdge === undefined) continue; // if the other node is in another cluster, we transfer ownership of this edge to the other cluster\n\n          if (otherNode !== undefined) {\n            // transfer ownership:\n            var otherCluster = this.body.nodes[otherNode.clusterId];\n            otherCluster.containedEdges[transferEdge.id] = transferEdge; // delete local reference\n\n            delete containedEdges[transferEdge.id]; // get to and from\n\n            var fromId = transferEdge.fromId;\n            var toId = transferEdge.toId;\n\n            if (transferEdge.toId == otherNodeId) {\n              toId = otherNode.clusterId;\n            } else {\n              fromId = otherNode.clusterId;\n            } // create new cluster edge from the otherCluster\n\n\n            this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, {\n              hidden: false,\n              physics: true\n            });\n          } else {\n            this._restoreEdge(transferEdge);\n          }\n        }\n\n        edge.remove();\n      } // handle the releasing of the edges\n\n\n      for (var edgeId in containedEdges) {\n        if (Object.prototype.hasOwnProperty.call(containedEdges, edgeId)) {\n          this._restoreEdge(containedEdges[edgeId]);\n        }\n      } // remove clusterNode\n\n\n      delete this.body.nodes[clusterNodeId];\n\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    /**\n     *\n     * @param {Cluster.id} clusterId\n     * @returns {Array.<Node.id>}\n     */\n\n  }, {\n    key: \"getNodesInCluster\",\n    value: function getNodesInCluster(clusterId) {\n      var nodesArray = [];\n\n      if (this.isCluster(clusterId) === true) {\n        var containedNodes = this.body.nodes[clusterId].containedNodes;\n\n        for (var nodeId in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {\n            nodesArray.push(this.body.nodes[nodeId].id);\n          }\n        }\n      }\n\n      return nodesArray;\n    }\n    /**\n     * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node\n     *\n     * If a node can't be found in the chain, return an empty array.\n     *\n     * @param {string|number} nodeId\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"findNode\",\n    value: function findNode(nodeId) {\n      var stack = [];\n      var max = 100;\n      var counter = 0;\n      var node;\n\n      while (this.clusteredNodes[nodeId] !== undefined && counter < max) {\n        node = this.body.nodes[nodeId];\n        if (node === undefined) return [];\n        stack.push(node.id);\n        nodeId = this.clusteredNodes[nodeId].clusterId;\n        counter++;\n      }\n\n      node = this.body.nodes[nodeId];\n      if (node === undefined) return [];\n      stack.push(node.id);\n      reverse$2(stack).call(stack);\n      return stack;\n    }\n    /**\n     * Using a clustered nodeId, update with the new options\n     *\n     * @param {Node.id} clusteredNodeId\n     * @param {object} newOptions\n     */\n\n  }, {\n    key: \"updateClusteredNode\",\n    value: function updateClusteredNode(clusteredNodeId, newOptions) {\n      if (clusteredNodeId === undefined) {\n        throw new Error(\"No clusteredNodeId supplied to updateClusteredNode.\");\n      }\n\n      if (newOptions === undefined) {\n        throw new Error(\"No newOptions supplied to updateClusteredNode.\");\n      }\n\n      if (this.body.nodes[clusteredNodeId] === undefined) {\n        throw new Error(\"The clusteredNodeId supplied to updateClusteredNode does not exist.\");\n      }\n\n      this.body.nodes[clusteredNodeId].setOptions(newOptions);\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n    /**\n     * Using a base edgeId, update all related clustered edges with the new options\n     *\n     * @param {vis.Edge.id} startEdgeId\n     * @param {object} newOptions\n     */\n\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(startEdgeId, newOptions) {\n      if (startEdgeId === undefined) {\n        throw new Error(\"No startEdgeId supplied to updateEdge.\");\n      }\n\n      if (newOptions === undefined) {\n        throw new Error(\"No newOptions supplied to updateEdge.\");\n      }\n\n      if (this.body.edges[startEdgeId] === undefined) {\n        throw new Error(\"The startEdgeId supplied to updateEdge does not exist.\");\n      }\n\n      var allEdgeIds = this.getClusteredEdges(startEdgeId);\n\n      for (var i = 0; i < allEdgeIds.length; i++) {\n        var edge = this.body.edges[allEdgeIds[i]];\n        edge.setOptions(newOptions);\n      }\n\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n    /**\n     * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)\n     *\n     * @param {vis.Edge.id} edgeId\n     * @returns {Array.<vis.Edge.id>}\n     */\n\n  }, {\n    key: \"getClusteredEdges\",\n    value: function getClusteredEdges(edgeId) {\n      var stack = [];\n      var max = 100;\n      var counter = 0;\n\n      while (edgeId !== undefined && this.body.edges[edgeId] !== undefined && counter < max) {\n        stack.push(this.body.edges[edgeId].id);\n        edgeId = this.body.edges[edgeId].edgeReplacedById;\n        counter++;\n      }\n\n      reverse$2(stack).call(stack);\n      return stack;\n    }\n    /**\n     * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge\n     *\n     * @param {vis.Edge.id} clusteredEdgeId\n     * @returns {vis.Edge.id} baseEdgeId\n     *\n     * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.\n     */\n\n  }, {\n    key: \"getBaseEdge\",\n    value: function getBaseEdge(clusteredEdgeId) {\n      // Just kludge this by returning the first base edge id found\n      return this.getBaseEdges(clusteredEdgeId)[0];\n    }\n    /**\n     * Get all regular edges for this clustered edge id.\n     *\n     * @param {vis.Edge.id} clusteredEdgeId\n     * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge\n     */\n\n  }, {\n    key: \"getBaseEdges\",\n    value: function getBaseEdges(clusteredEdgeId) {\n      var IdsToHandle = [clusteredEdgeId];\n      var doneIds = [];\n      var foundIds = [];\n      var max = 100;\n      var counter = 0;\n\n      while (IdsToHandle.length > 0 && counter < max) {\n        var nextId = IdsToHandle.pop();\n        if (nextId === undefined) continue; // Paranoia here and onwards\n\n        var nextEdge = this.body.edges[nextId];\n        if (nextEdge === undefined) continue;\n        counter++;\n        var replacingIds = nextEdge.clusteringEdgeReplacingIds;\n\n        if (replacingIds === undefined) {\n          // nextId is a base id\n          foundIds.push(nextId);\n        } else {\n          // Another cluster edge, unravel this one as well\n          for (var i = 0; i < replacingIds.length; ++i) {\n            var replacingId = replacingIds[i]; // Don't add if already handled\n            // TODO: never triggers; find a test-case which does\n\n            if (indexOf$3(IdsToHandle).call(IdsToHandle, replacingIds) !== -1 || indexOf$3(doneIds).call(doneIds, replacingIds) !== -1) {\n              continue;\n            }\n\n            IdsToHandle.push(replacingId);\n          }\n        }\n\n        doneIds.push(nextId);\n      }\n\n      return foundIds;\n    }\n    /**\n     * Get the Id the node is connected to\n     *\n     * @param {vis.Edge} edge\n     * @param {Node.id} nodeId\n     * @returns {*}\n     * @private\n     */\n\n  }, {\n    key: \"_getConnectedId\",\n    value: function _getConnectedId(edge, nodeId) {\n      if (edge.toId != nodeId) {\n        return edge.toId;\n      } else if (edge.fromId != nodeId) {\n        return edge.fromId;\n      } else {\n        return edge.fromId;\n      }\n    }\n    /**\n     * We determine how many connections denote an important hub.\n     * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"_getHubSize\",\n    value: function _getHubSize() {\n      var average = 0;\n      var averageSquared = 0;\n      var hubCounter = 0;\n      var largestHub = 0;\n\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n\n        if (node.edges.length > largestHub) {\n          largestHub = node.edges.length;\n        }\n\n        average += node.edges.length;\n        averageSquared += Math.pow(node.edges.length, 2);\n        hubCounter += 1;\n      }\n\n      average = average / hubCounter;\n      averageSquared = averageSquared / hubCounter;\n      var variance = averageSquared - Math.pow(average, 2);\n      var standardDeviation = Math.sqrt(variance);\n      var hubThreshold = Math.floor(average + 2 * standardDeviation); // always have at least one to cluster\n\n      if (hubThreshold > largestHub) {\n        hubThreshold = largestHub;\n      }\n\n      return hubThreshold;\n    }\n    /**\n     * Create an edge for the cluster representation.\n     *\n     * @param {Node.id} fromId\n     * @param {Node.id} toId\n     * @param {vis.Edge} baseEdge\n     * @param {object} clusterEdgeProperties\n     * @param {object} extraOptions\n     * @returns {Edge} newly created clustered edge\n     * @private\n     */\n\n  }, {\n    key: \"_createClusteredEdge\",\n    value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {\n      // copy the options of the edge we will replace\n      var clonedOptions = NetworkUtil.cloneOptions(baseEdge, \"edge\"); // make sure the properties of clusterEdges are superimposed on it\n\n      deepExtend(clonedOptions, clusterEdgeProperties); // set up the edge\n\n      clonedOptions.from = fromId;\n      clonedOptions.to = toId;\n      clonedOptions.id = \"clusterEdge:\" + v4(); // apply the edge specific options to it if specified\n\n      if (extraOptions !== undefined) {\n        deepExtend(clonedOptions, extraOptions);\n      }\n\n      var newEdge = this.body.functions.createEdge(clonedOptions);\n      newEdge.clusteringEdgeReplacingIds = [baseEdge.id];\n      newEdge.connect(); // Register the new edge\n\n      this.body.edges[newEdge.id] = newEdge;\n      return newEdge;\n    }\n    /**\n     * Add the passed child nodes and edges to the given cluster node.\n     *\n     * @param {object | Node} childNodes  hash of nodes or single node to add in cluster\n     * @param {object | Edge} childEdges  hash of edges or single edge to take into account when clustering\n     * @param {Node} clusterNode  cluster node to add nodes and edges to\n     * @param {object} [clusterEdgeProperties]\n     * @private\n     */\n\n  }, {\n    key: \"_clusterEdges\",\n    value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {\n      if (childEdges instanceof Edge) {\n        var edge = childEdges;\n        var obj = {};\n        obj[edge.id] = edge;\n        childEdges = obj;\n      }\n\n      if (childNodes instanceof Node) {\n        var node = childNodes;\n        var _obj = {};\n        _obj[node.id] = node;\n        childNodes = _obj;\n      }\n\n      if (clusterNode === undefined || clusterNode === null) {\n        throw new Error(\"_clusterEdges: parameter clusterNode required\");\n      }\n\n      if (clusterEdgeProperties === undefined) {\n        // Take the required properties from the cluster node\n        clusterEdgeProperties = clusterNode.clusterEdgeProperties;\n      } // create the new edges that will connect to the cluster.\n      // All self-referencing edges will be added to childEdges here.\n\n\n      this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties); // disable the childEdges\n\n\n      for (var edgeId in childEdges) {\n        if (Object.prototype.hasOwnProperty.call(childEdges, edgeId)) {\n          if (this.body.edges[edgeId] !== undefined) {\n            var _edge2 = this.body.edges[edgeId]; // cache the options before changing\n\n            this._backupEdgeOptions(_edge2); // disable physics and hide the edge\n\n\n            _edge2.setOptions({\n              physics: false\n            });\n          }\n        }\n      } // disable the childNodes\n\n\n      for (var nodeId in childNodes) {\n        if (Object.prototype.hasOwnProperty.call(childNodes, nodeId)) {\n          this.clusteredNodes[nodeId] = {\n            clusterId: clusterNode.id,\n            node: this.body.nodes[nodeId]\n          };\n          this.body.nodes[nodeId].setOptions({\n            physics: false\n          });\n        }\n      }\n    }\n    /**\n     * Determine in which cluster given nodeId resides.\n     *\n     * If not in cluster, return undefined.\n     *\n     * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).\n     *\n     * @param {Node.id} nodeId\n     * @returns {Node|undefined} Node instance for cluster, if present\n     * @private\n     */\n\n  }, {\n    key: \"_getClusterNodeForNode\",\n    value: function _getClusterNodeForNode(nodeId) {\n      if (nodeId === undefined) return undefined;\n      var clusteredNode = this.clusteredNodes[nodeId]; // NOTE: If no cluster info found, it should actually be an error\n\n      if (clusteredNode === undefined) return undefined;\n      var clusterId = clusteredNode.clusterId;\n      if (clusterId === undefined) return undefined;\n      return this.body.nodes[clusterId];\n    }\n    /**\n     * Internal helper function for conditionally removing items in array\n     *\n     * Done like this because Array.filter() is not fully supported by all IE's.\n     *\n     * @param {Array} arr\n     * @param {Function} callback\n     * @returns {Array}\n     * @private\n     */\n\n  }, {\n    key: \"_filter\",\n    value: function _filter(arr, callback) {\n      var ret = [];\n      forEach$3(arr, function (item) {\n        if (callback(item)) {\n          ret.push(item);\n        }\n      });\n      return ret;\n    }\n    /**\n     * Scan all edges for changes in clustering and adjust this if necessary.\n     *\n     * Call this (internally) after there has been a change in node or edge data.\n     *\n     * Pre: States of this.body.nodes and this.body.edges consistent\n     * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges\n     *      of cluster nodes.\n     */\n\n  }, {\n    key: \"_updateState\",\n    value: function _updateState() {\n      var _this4 = this;\n\n      var nodeId;\n      var deletedNodeIds = [];\n      var deletedEdgeIds = {};\n      /**\n       * Utility function to iterate over clustering nodes only\n       *\n       * @param {Function} callback  function to call for each cluster node\n       */\n\n      var eachClusterNode = function eachClusterNode(callback) {\n        forEach$3(_this4.body.nodes, function (node) {\n          if (node.isCluster === true) {\n            callback(node);\n          }\n        });\n      }; //\n      // Remove deleted regular nodes from clustering\n      //\n      // Determine the deleted nodes\n\n\n      for (nodeId in this.clusteredNodes) {\n        if (!Object.prototype.hasOwnProperty.call(this.clusteredNodes, nodeId)) continue;\n        var node = this.body.nodes[nodeId];\n\n        if (node === undefined) {\n          deletedNodeIds.push(nodeId);\n        }\n      } // Remove nodes from cluster nodes\n\n\n      eachClusterNode(function (clusterNode) {\n        for (var n = 0; n < deletedNodeIds.length; n++) {\n          delete clusterNode.containedNodes[deletedNodeIds[n]];\n        }\n      }); // Remove nodes from cluster list\n\n      for (var n = 0; n < deletedNodeIds.length; n++) {\n        delete this.clusteredNodes[deletedNodeIds[n]];\n      } //\n      // Remove deleted edges from clustering\n      //\n      // Add the deleted clustered edges to the list\n\n\n      forEach$3(this.clusteredEdges, function (edgeId) {\n        var edge = _this4.body.edges[edgeId];\n\n        if (edge === undefined || !edge.endPointsValid()) {\n          deletedEdgeIds[edgeId] = edgeId;\n        }\n      }); // Cluster nodes can also contain edges which are not clustered,\n      // i.e. nodes 1-2 within cluster with an edge in between.\n      // So the cluster nodes also need to be scanned for invalid edges\n\n      eachClusterNode(function (clusterNode) {\n        forEach$3(clusterNode.containedEdges, function (edge, edgeId) {\n          if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {\n            deletedEdgeIds[edgeId] = edgeId;\n          }\n        });\n      }); // Also scan for cluster edges which need to be removed in the active list.\n      // Regular edges have been removed beforehand, so this only picks up the cluster edges.\n\n      forEach$3(this.body.edges, function (edge, edgeId) {\n        // Explicitly scan the contained edges for validity\n        var isValid = true;\n        var replacedIds = edge.clusteringEdgeReplacingIds;\n\n        if (replacedIds !== undefined) {\n          var numValid = 0;\n          forEach$3(replacedIds, function (containedEdgeId) {\n            var containedEdge = _this4.body.edges[containedEdgeId];\n\n            if (containedEdge !== undefined && containedEdge.endPointsValid()) {\n              numValid += 1;\n            }\n          });\n          isValid = numValid > 0;\n        }\n\n        if (!edge.endPointsValid() || !isValid) {\n          deletedEdgeIds[edgeId] = edgeId;\n        }\n      }); // Remove edges from cluster nodes\n\n      eachClusterNode(function (clusterNode) {\n        forEach$3(deletedEdgeIds, function (deletedEdgeId) {\n          delete clusterNode.containedEdges[deletedEdgeId];\n          forEach$3(clusterNode.edges, function (edge, m) {\n            if (edge.id === deletedEdgeId) {\n              clusterNode.edges[m] = null; // Don't want to directly delete here, because in the loop\n\n              return;\n            }\n\n            edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function (id) {\n              return !deletedEdgeIds[id];\n            });\n          }); // Clean up the nulls\n\n          clusterNode.edges = _this4._filter(clusterNode.edges, function (item) {\n            return item !== null;\n          });\n        });\n      }); // Remove from cluster list\n\n      forEach$3(deletedEdgeIds, function (edgeId) {\n        delete _this4.clusteredEdges[edgeId];\n      }); // Remove cluster edges from active list (this.body.edges).\n      // deletedEdgeIds still contains id of regular edges, but these should all\n      // be gone when you reach here.\n\n      forEach$3(deletedEdgeIds, function (edgeId) {\n        delete _this4.body.edges[edgeId];\n      }); //\n      // Check changed cluster state of edges\n      //\n      // Iterating over keys here, because edges may be removed in the loop\n\n      var ids = keys$3(this.body.edges);\n      forEach$3(ids, function (edgeId) {\n        var edge = _this4.body.edges[edgeId];\n\n        var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);\n\n        if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {\n          return; // all is well\n        }\n\n        if (shouldBeClustered) {\n          // add edge to clustering\n          var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);\n\n          if (clusterFrom !== undefined) {\n            _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);\n          }\n\n          var clusterTo = _this4._getClusterNodeForNode(edge.toId);\n\n          if (clusterTo !== undefined) {\n            _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);\n          } // TODO: check that it works for both edges clustered\n          //       (This might be paranoia)\n\n        } else {\n          delete _this4._clusterEdges[edgeId];\n\n          _this4._restoreEdge(edge); // This should not be happening, the state should\n          // be properly updated at this point.\n          //\n          // If it *is* reached during normal operation, then we have to implement\n          // undo clustering for this edge here.\n          // throw new Error('remove edge from clustering not implemented!')\n\n        }\n      }); // Clusters may be nested to any level. Keep on opening until nothing to open\n\n      var changed = false;\n      var continueLoop = true;\n\n      var _loop2 = function _loop2() {\n        var clustersToOpen = []; // Determine the id's of clusters that need opening\n\n        eachClusterNode(function (clusterNode) {\n          var numNodes = keys$3(clusterNode.containedNodes).length;\n          var allowSingle = clusterNode.options.allowSingleNodeCluster === true;\n\n          if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {\n            clustersToOpen.push(clusterNode.id);\n          }\n        }); // Open them\n\n        for (var _n = 0; _n < clustersToOpen.length; ++_n) {\n          _this4.openCluster(clustersToOpen[_n], {}, false\n          /* Don't refresh, we're in an refresh/update already */\n          );\n        }\n\n        continueLoop = clustersToOpen.length > 0;\n        changed = changed || continueLoop;\n      };\n\n      while (continueLoop) {\n        _loop2();\n      }\n\n      if (changed) {\n        this._updateState(); // Redo this method (recursion possible! should be safe)\n\n      }\n    }\n    /**\n     * Determine if node with given id is part of a cluster.\n     *\n     * @param {Node.id} nodeId\n     * @returns {boolean} true if part of a cluster.\n     */\n\n  }, {\n    key: \"_isClusteredNode\",\n    value: function _isClusteredNode(nodeId) {\n      return this.clusteredNodes[nodeId] !== undefined;\n    }\n    /**\n     * Determine if edge with given id is not visible due to clustering.\n     *\n     * An edge is considered clustered if:\n     * - it is directly replaced by a clustering edge\n     * - any of its connecting nodes is in a cluster\n     *\n     * @param {vis.Edge.id} edgeId\n     * @returns {boolean} true if part of a cluster.\n     */\n\n  }, {\n    key: \"_isClusteredEdge\",\n    value: function _isClusteredEdge(edgeId) {\n      return this.clusteredEdges[edgeId] !== undefined;\n    }\n  }]);\n  return ClusterEngine;\n}();\n\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$3(o, minLen) {\n  var _context4;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen);\n  var n = slice$5(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from_1$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);\n}\n\nfunction _arrayLikeToArray$3(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * Initializes window.requestAnimationFrame() to a usable form.\n *\n * Specifically, set up this method for the case of running on node.js with jsdom enabled.\n *\n * NOTES:\n *\n * * On node.js, when calling this directly outside of this class, `window` is not defined.\n *   This happens even if jsdom is used.\n * * For node.js + jsdom, `window` is available at the moment the constructor is called.\n *   For this reason, the called is placed within the constructor.\n * * Even then, `window.requestAnimationFrame()` is not defined, so it still needs to be added.\n * * During unit testing, it happens that the window object is reset during execution, causing\n *   a runtime error due to missing `requestAnimationFrame()`. This needs to be compensated for,\n *   see `_requestNextFrame()`.\n * * Since this is a global object, it may affect other modules besides `Network`. With normal\n *   usage, this does not cause any problems. During unit testing, errors may occur. These have\n *   been compensated for, see comment block in _requestNextFrame().\n *\n * @private\n */\n\n\nfunction _initRequestAnimationFrame() {\n  var func;\n\n  if (window !== undefined) {\n    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n  }\n\n  if (func === undefined) {\n    // window or method not present, setting mock requestAnimationFrame\n    window.requestAnimationFrame = function (callback) {\n      //console.log(\"Called mock requestAnimationFrame\");\n      callback();\n    };\n  } else {\n    window.requestAnimationFrame = func;\n  }\n}\n/**\n * The canvas renderer\n */\n\n\nvar CanvasRenderer = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function CanvasRenderer(body, canvas) {\n    classCallCheck(this, CanvasRenderer);\n\n    _initRequestAnimationFrame();\n\n    this.body = body;\n    this.canvas = canvas;\n    this.redrawRequested = false;\n    this.renderTimer = undefined;\n    this.requiresTimeout = true;\n    this.renderingActive = false;\n    this.renderRequests = 0;\n    this.allowRedraw = true;\n    this.dragging = false;\n    this.zooming = false;\n    this.options = {};\n    this.defaultOptions = {\n      hideEdgesOnDrag: false,\n      hideEdgesOnZoom: false,\n      hideNodesOnDrag: false\n    };\n    assign$2(this.options, this.defaultOptions);\n\n    this._determineBrowserMethod();\n\n    this.bindEventListeners();\n  }\n  /**\n   * Binds event listeners\n   */\n\n\n  createClass(CanvasRenderer, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this,\n          _context2;\n\n      this.body.emitter.on(\"dragStart\", function () {\n        _this.dragging = true;\n      });\n      this.body.emitter.on(\"dragEnd\", function () {\n        _this.dragging = false;\n      });\n      this.body.emitter.on(\"zoom\", function () {\n        _this.zooming = true;\n        window.clearTimeout(_this.zoomTimeoutId);\n        _this.zoomTimeoutId = window.setTimeout(function () {\n          var _context;\n\n          _this.zooming = false;\n          bind$2(_context = _this._requestRedraw).call(_context, _this)();\n        }, 250);\n      });\n      this.body.emitter.on(\"_resizeNodes\", function () {\n        _this._resizeNodes();\n      });\n      this.body.emitter.on(\"_redraw\", function () {\n        if (_this.renderingActive === false) {\n          _this._redraw();\n        }\n      });\n      this.body.emitter.on(\"_blockRedraw\", function () {\n        _this.allowRedraw = false;\n      });\n      this.body.emitter.on(\"_allowRedraw\", function () {\n        _this.allowRedraw = true;\n        _this.redrawRequested = false;\n      });\n      this.body.emitter.on(\"_requestRedraw\", bind$2(_context2 = this._requestRedraw).call(_context2, this));\n      this.body.emitter.on(\"_startRendering\", function () {\n        _this.renderRequests += 1;\n        _this.renderingActive = true;\n\n        _this._startRendering();\n      });\n      this.body.emitter.on(\"_stopRendering\", function () {\n        _this.renderRequests -= 1;\n        _this.renderingActive = _this.renderRequests > 0;\n        _this.renderTimer = undefined;\n      });\n      this.body.emitter.on(\"destroy\", function () {\n        _this.renderRequests = 0;\n        _this.allowRedraw = false;\n        _this.renderingActive = false;\n\n        if (_this.requiresTimeout === true) {\n          clearTimeout(_this.renderTimer);\n        } else {\n          window.cancelAnimationFrame(_this.renderTimer);\n        }\n\n        _this.body.emitter.off();\n      });\n    }\n    /**\n     *\n     * @param {object} options\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        var fields = [\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\"];\n        selectiveDeepExtend(fields, this.options, options);\n      }\n    }\n    /**\n     * Prepare the drawing of the next frame.\n     *\n     * Calls the callback when the next frame can or will be drawn.\n     *\n     * @param {Function} callback\n     * @param {number} delay - timeout case only, wait this number of milliseconds\n     * @returns {Function | undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_requestNextFrame\",\n    value: function _requestNextFrame(callback, delay) {\n      // During unit testing, it happens that the mock window object is reset while\n      // the next frame is still pending. Then, either 'window' is not present, or\n      // 'requestAnimationFrame()' is not present because it is not defined on the\n      // mock window object.\n      //\n      // As a consequence, unrelated unit tests may appear to fail, even if the problem\n      // described happens in the current unit test.\n      //\n      // This is not something that will happen in normal operation, but we still need\n      // to take it into account.\n      //\n      if (typeof window === \"undefined\") return; // Doing `if (window === undefined)` does not work here!\n\n      var timer;\n      var myWindow = window; // Grab a reference to reduce the possibility that 'window' is reset\n      // while running this method.\n\n      if (this.requiresTimeout === true) {\n        // wait given number of milliseconds and perform the animation step function\n        timer = myWindow.setTimeout(callback, delay);\n      } else {\n        if (myWindow.requestAnimationFrame) {\n          timer = myWindow.requestAnimationFrame(callback);\n        }\n      }\n\n      return timer;\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_startRendering\",\n    value: function _startRendering() {\n      if (this.renderingActive === true) {\n        if (this.renderTimer === undefined) {\n          var _context3;\n\n          this.renderTimer = this._requestNextFrame(bind$2(_context3 = this._renderStep).call(_context3, this), this.simulationInterval);\n        }\n      }\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_renderStep\",\n    value: function _renderStep() {\n      if (this.renderingActive === true) {\n        // reset the renderTimer so a new scheduled animation step can be set\n        this.renderTimer = undefined;\n\n        if (this.requiresTimeout === true) {\n          // this schedules a new simulation step\n          this._startRendering();\n        }\n\n        this._redraw();\n\n        if (this.requiresTimeout === false) {\n          // this schedules a new simulation step\n          this._startRendering();\n        }\n      }\n    }\n    /**\n     * Redraw the network with the current data\n     * chart will be resized too.\n     */\n\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      this.body.emitter.emit(\"setSize\");\n\n      this._redraw();\n    }\n    /**\n     * Redraw the network with the current data\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_requestRedraw\",\n    value: function _requestRedraw() {\n      var _this2 = this;\n\n      if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {\n        this.redrawRequested = true;\n\n        this._requestNextFrame(function () {\n          _this2._redraw(false);\n        }, 0);\n      }\n    }\n    /**\n     * Redraw the network with the current data\n     *\n     * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.\n     *                                   Only the nodes are drawn after which they are quickly drawn over.\n     * @private\n     */\n\n  }, {\n    key: \"_redraw\",\n    value: function _redraw() {\n      var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.allowRedraw === true) {\n        this.body.emitter.emit(\"initRedraw\");\n        this.redrawRequested = false;\n        var drawLater = {\n          drawExternalLabels: null\n        }; // when the container div was hidden, this fixes it back up!\n\n        if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {\n          this.canvas.setSize();\n        }\n\n        this.canvas.setTransform();\n        var ctx = this.canvas.getContext(); // clear the canvas\n\n        var w = this.canvas.frame.canvas.clientWidth;\n        var h = this.canvas.frame.canvas.clientHeight;\n        ctx.clearRect(0, 0, w, h); // if the div is hidden, we stop the redraw here for performance.\n\n        if (this.canvas.frame.clientWidth === 0) {\n          return;\n        } // set scaling and translation\n\n\n        ctx.save();\n        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);\n        ctx.scale(this.body.view.scale, this.body.view.scale);\n        ctx.beginPath();\n        this.body.emitter.emit(\"beforeDrawing\", ctx);\n        ctx.closePath();\n\n        if (hidden === false) {\n          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {\n            this._drawEdges(ctx);\n          }\n        }\n\n        if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {\n          var _this$_drawNodes = this._drawNodes(ctx, hidden),\n              drawExternalLabels = _this$_drawNodes.drawExternalLabels;\n\n          drawLater.drawExternalLabels = drawExternalLabels;\n        } // draw the arrows last so they will be at the top\n\n\n        if (hidden === false) {\n          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {\n            this._drawArrows(ctx);\n          }\n        }\n\n        if (drawLater.drawExternalLabels != null) {\n          drawLater.drawExternalLabels();\n        }\n\n        if (hidden === false) {\n          this._drawSelectionBox(ctx);\n        }\n\n        ctx.beginPath();\n        this.body.emitter.emit(\"afterDrawing\", ctx);\n        ctx.closePath(); // restore original scaling and translation\n\n        ctx.restore();\n\n        if (hidden === true) {\n          ctx.clearRect(0, 0, w, h);\n        }\n      }\n    }\n    /**\n     * Redraw all nodes\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @param {boolean} [alwaysShow]\n     * @private\n     */\n\n  }, {\n    key: \"_resizeNodes\",\n    value: function _resizeNodes() {\n      this.canvas.setTransform();\n      var ctx = this.canvas.getContext();\n      ctx.save();\n      ctx.translate(this.body.view.translation.x, this.body.view.translation.y);\n      ctx.scale(this.body.view.scale, this.body.view.scale);\n      var nodes = this.body.nodes;\n      var node; // resize all nodes\n\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          node = nodes[nodeId];\n          node.resize(ctx);\n          node.updateBoundingBox(ctx, node.selected);\n        }\n      } // restore original scaling and translation\n\n\n      ctx.restore();\n    }\n    /**\n     * Redraw all nodes\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @param {boolean} [alwaysShow]\n     * @private\n     *\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n\n  }, {\n    key: \"_drawNodes\",\n    value: function _drawNodes(ctx) {\n      var alwaysShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.body.nodeIndices;\n      var node;\n      var selected = [];\n      var hovered = [];\n      var margin = 20;\n      var topLeft = this.canvas.DOMtoCanvas({\n        x: -margin,\n        y: -margin\n      });\n      var bottomRight = this.canvas.DOMtoCanvas({\n        x: this.canvas.frame.canvas.clientWidth + margin,\n        y: this.canvas.frame.canvas.clientHeight + margin\n      });\n      var viewableArea = {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x\n      };\n      var _drawExternalLabels = []; // draw unselected nodes;\n\n      for (var _i = 0; _i < nodeIndices.length; _i++) {\n        node = nodes[nodeIndices[_i]]; // set selected and hovered nodes aside\n\n        if (node.hover) {\n          hovered.push(nodeIndices[_i]);\n        } else if (node.isSelected()) {\n          selected.push(nodeIndices[_i]);\n        } else {\n          if (alwaysShow === true) {\n            var drawLater = node.draw(ctx);\n\n            if (drawLater.drawExternalLabel != null) {\n              _drawExternalLabels.push(drawLater.drawExternalLabel);\n            }\n          } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {\n            var _drawLater = node.draw(ctx);\n\n            if (_drawLater.drawExternalLabel != null) {\n              _drawExternalLabels.push(_drawLater.drawExternalLabel);\n            }\n          } else {\n            node.updateBoundingBox(ctx, node.selected);\n          }\n        }\n      }\n\n      var i;\n      var selectedLength = selected.length;\n      var hoveredLength = hovered.length; // draw the selected nodes on top\n\n      for (i = 0; i < selectedLength; i++) {\n        node = nodes[selected[i]];\n\n        var _drawLater2 = node.draw(ctx);\n\n        if (_drawLater2.drawExternalLabel != null) {\n          _drawExternalLabels.push(_drawLater2.drawExternalLabel);\n        }\n      } // draw hovered nodes above everything else: fixes https://github.com/visjs/vis-network/issues/226\n\n\n      for (i = 0; i < hoveredLength; i++) {\n        node = nodes[hovered[i]];\n\n        var _drawLater3 = node.draw(ctx);\n\n        if (_drawLater3.drawExternalLabel != null) {\n          _drawExternalLabels.push(_drawLater3.drawExternalLabel);\n        }\n      }\n\n      return {\n        drawExternalLabels: function drawExternalLabels() {\n          var _iterator = _createForOfIteratorHelper$2(_drawExternalLabels),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var draw = _step.value;\n              draw();\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      };\n    }\n    /**\n     * Redraw all edges\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @private\n     */\n\n  }, {\n    key: \"_drawEdges\",\n    value: function _drawEdges(ctx) {\n      var edges = this.body.edges;\n      var edgeIndices = this.body.edgeIndices;\n\n      for (var i = 0; i < edgeIndices.length; i++) {\n        var edge = edges[edgeIndices[i]];\n\n        if (edge.connected === true) {\n          edge.draw(ctx);\n        }\n      }\n    }\n    /**\n     * Redraw all arrows\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @private\n     */\n\n  }, {\n    key: \"_drawArrows\",\n    value: function _drawArrows(ctx) {\n      var edges = this.body.edges;\n      var edgeIndices = this.body.edgeIndices;\n\n      for (var i = 0; i < edgeIndices.length; i++) {\n        var edge = edges[edgeIndices[i]];\n\n        if (edge.connected === true) {\n          edge.drawArrows(ctx);\n        }\n      }\n    }\n    /**\n     * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because\n     * some implementations (safari and IE9) did not support requestAnimationFrame\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_determineBrowserMethod\",\n    value: function _determineBrowserMethod() {\n      if (typeof window !== \"undefined\") {\n        var browserType = navigator.userAgent.toLowerCase();\n        this.requiresTimeout = false;\n\n        if (indexOf$3(browserType).call(browserType, \"msie 9.0\") != -1) {\n          // IE 9\n          this.requiresTimeout = true;\n        } else if (indexOf$3(browserType).call(browserType, \"safari\") != -1) {\n          // safari\n          if (indexOf$3(browserType).call(browserType, \"chrome\") <= -1) {\n            this.requiresTimeout = true;\n          }\n        }\n      } else {\n        this.requiresTimeout = true;\n      }\n    }\n    /**\n     * Redraw selection box\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @private\n     */\n\n  }, {\n    key: \"_drawSelectionBox\",\n    value: function _drawSelectionBox(ctx) {\n      if (this.body.selectionBox.show) {\n        ctx.beginPath();\n        var width = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x;\n        var height = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;\n        ctx.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);\n        ctx.fillStyle = \"rgba(151, 194, 252, 0.2)\";\n        ctx.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);\n        ctx.strokeStyle = \"rgba(151, 194, 252, 1)\";\n        ctx.stroke();\n      } else {\n        ctx.closePath();\n      }\n    }\n  }]);\n  return CanvasRenderer;\n}();\n\nvar setInterval = path.setInterval;\nvar setInterval$1 = setInterval;\n/**\n * Register a touch event, taking place before a gesture\n *\n * @param {Hammer} hammer       A hammer instance\n * @param {Function} callback   Callback, called as callback(event)\n */\n\nfunction onTouch(hammer, callback) {\n  callback.inputHandler = function (event) {\n    if (event.isFirst) {\n      callback(event);\n    }\n  };\n\n  hammer.on(\"hammer.input\", callback.inputHandler);\n}\n/**\n * Register a release event, taking place after a gesture\n *\n * @param {Hammer} hammer       A hammer instance\n * @param {Function} callback   Callback, called as callback(event)\n * @returns {*}\n */\n\n\nfunction onRelease(hammer, callback) {\n  callback.inputHandler = function (event) {\n    if (event.isFinal) {\n      callback(event);\n    }\n  };\n\n  return hammer.on(\"hammer.input\", callback.inputHandler);\n}\n/**\n * Create the main frame for the Network.\n * This function is executed once when a Network object is created. The frame\n * contains a canvas, and this canvas contains all objects like the axis and\n * nodes.\n */\n\n\nvar Canvas = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function Canvas(body) {\n    classCallCheck(this, Canvas);\n    this.body = body;\n    this.pixelRatio = 1;\n    this.cameraState = {};\n    this.initialized = false;\n    this.canvasViewCenter = {};\n    this._cleanupCallbacks = [];\n    this.options = {};\n    this.defaultOptions = {\n      autoResize: true,\n      height: \"100%\",\n      width: \"100%\"\n    };\n    assign$2(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n  /**\n   * Binds event listeners\n   */\n\n\n  createClass(Canvas, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this,\n          _context; // bind the events\n\n\n      this.body.emitter.once(\"resize\", function (obj) {\n        if (obj.width !== 0) {\n          _this.body.view.translation.x = obj.width * 0.5;\n        }\n\n        if (obj.height !== 0) {\n          _this.body.view.translation.y = obj.height * 0.5;\n        }\n      });\n      this.body.emitter.on(\"setSize\", bind$2(_context = this.setSize).call(_context, this));\n      this.body.emitter.on(\"destroy\", function () {\n        _this.hammerFrame.destroy();\n\n        _this.hammer.destroy();\n\n        _this._cleanUp();\n      });\n    }\n    /**\n     * @param {object} options\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var _this2 = this;\n\n      if (options !== undefined) {\n        var fields = [\"width\", \"height\", \"autoResize\"];\n        selectiveDeepExtend(fields, this.options, options);\n      } // Automatically adapt to changing size of the container element.\n\n\n      this._cleanUp();\n\n      if (this.options.autoResize === true) {\n        var _context2;\n\n        if (window.ResizeObserver) {\n          // decent browsers, immediate reactions\n          var observer = new ResizeObserver(function () {\n            var changed = _this2.setSize();\n\n            if (changed === true) {\n              _this2.body.emitter.emit(\"_requestRedraw\");\n            }\n          });\n          var frame = this.frame;\n          observer.observe(frame);\n\n          this._cleanupCallbacks.push(function () {\n            observer.unobserve(frame);\n          });\n        } else {\n          // IE11, continous polling\n          var resizeTimer = setInterval$1(function () {\n            var changed = _this2.setSize();\n\n            if (changed === true) {\n              _this2.body.emitter.emit(\"_requestRedraw\");\n            }\n          }, 1000);\n\n          this._cleanupCallbacks.push(function () {\n            clearInterval(resizeTimer);\n          });\n        } // Automatically adapt to changing size of the browser.\n\n\n        var resizeFunction = bind$2(_context2 = this._onResize).call(_context2, this);\n        addEventListener(window, \"resize\", resizeFunction);\n\n        this._cleanupCallbacks.push(function () {\n          removeEventListener(window, \"resize\", resizeFunction);\n        });\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_cleanUp\",\n    value: function _cleanUp() {\n      var _context3, _context4, _context5;\n\n      forEach$2(_context3 = reverse$2(_context4 = splice$2(_context5 = this._cleanupCallbacks).call(_context5, 0)).call(_context4)).call(_context3, function (callback) {\n        try {\n          callback();\n        } catch (error) {\n          console.error(error);\n        }\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      this.setSize();\n      this.body.emitter.emit(\"_redraw\");\n    }\n    /**\n     * Get and store the cameraState\n     *\n     * @param {number} [pixelRatio=this.pixelRatio]\n     * @private\n     */\n\n  }, {\n    key: \"_getCameraState\",\n    value: function _getCameraState() {\n      var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pixelRatio;\n\n      if (this.initialized === true) {\n        this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;\n        this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;\n        this.cameraState.scale = this.body.view.scale;\n        this.cameraState.position = this.DOMtoCanvas({\n          x: 0.5 * this.frame.canvas.width / pixelRatio,\n          y: 0.5 * this.frame.canvas.height / pixelRatio\n        });\n      }\n    }\n    /**\n     * Set the cameraState\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setCameraState\",\n    value: function _setCameraState() {\n      if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {\n        var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;\n        var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;\n        var newScale = this.cameraState.scale;\n\n        if (widthRatio != 1 && heightRatio != 1) {\n          newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);\n        } else if (widthRatio != 1) {\n          newScale = this.cameraState.scale * widthRatio;\n        } else if (heightRatio != 1) {\n          newScale = this.cameraState.scale * heightRatio;\n        }\n\n        this.body.view.scale = newScale; // this comes from the view module.\n\n        var currentViewCenter = this.DOMtoCanvas({\n          x: 0.5 * this.frame.canvas.clientWidth,\n          y: 0.5 * this.frame.canvas.clientHeight\n        });\n        var distanceFromCenter = {\n          // offset from view, distance view has to change by these x and y to center the node\n          x: currentViewCenter.x - this.cameraState.position.x,\n          y: currentViewCenter.y - this.cameraState.position.y\n        };\n        this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;\n        this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;\n      }\n    }\n    /**\n     *\n     * @param {number|string} value\n     * @returns {string}\n     * @private\n     */\n\n  }, {\n    key: \"_prepareValue\",\n    value: function _prepareValue(value) {\n      if (typeof value === \"number\") {\n        return value + \"px\";\n      } else if (typeof value === \"string\") {\n        if (indexOf$3(value).call(value, \"%\") !== -1 || indexOf$3(value).call(value, \"px\") !== -1) {\n          return value;\n        } else if (indexOf$3(value).call(value, \"%\") === -1) {\n          return value + \"px\";\n        }\n      }\n\n      throw new Error(\"Could not use the value supplied for width or height:\" + value);\n    }\n    /**\n     * Create the HTML\n     */\n\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      // remove all elements from the container element.\n      while (this.body.container.hasChildNodes()) {\n        this.body.container.removeChild(this.body.container.firstChild);\n      }\n\n      this.frame = document.createElement(\"div\");\n      this.frame.className = \"vis-network\";\n      this.frame.style.position = \"relative\";\n      this.frame.style.overflow = \"hidden\";\n      this.frame.tabIndex = 900; // tab index is required for keycharm to bind keystrokes to the div instead of the window\n      //////////////////////////////////////////////////////////////////\n\n      this.frame.canvas = document.createElement(\"canvas\");\n      this.frame.canvas.style.position = \"relative\";\n      this.frame.appendChild(this.frame.canvas);\n\n      if (!this.frame.canvas.getContext) {\n        var noCanvas = document.createElement(\"DIV\");\n        noCanvas.style.color = \"red\";\n        noCanvas.style.fontWeight = \"bold\";\n        noCanvas.style.padding = \"10px\";\n        noCanvas.innerHTML = \"Error: your browser does not support HTML canvas\";\n        this.frame.canvas.appendChild(noCanvas);\n      } else {\n        this._setPixelRatio();\n\n        this.setTransform();\n      } // add the frame to the container element\n\n\n      this.body.container.appendChild(this.frame);\n      this.body.view.scale = 1;\n      this.body.view.translation = {\n        x: 0.5 * this.frame.canvas.clientWidth,\n        y: 0.5 * this.frame.canvas.clientHeight\n      };\n\n      this._bindHammer();\n    }\n    /**\n     * This function binds hammer, it can be repeated over and over due to the uniqueness check.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_bindHammer\",\n    value: function _bindHammer() {\n      var _this3 = this;\n\n      if (this.hammer !== undefined) {\n        this.hammer.destroy();\n      }\n\n      this.drag = {};\n      this.pinch = {}; // init hammer\n\n      this.hammer = new Hammer$1(this.frame.canvas);\n      this.hammer.get(\"pinch\").set({\n        enable: true\n      }); // enable to get better response, todo: test on mobile.\n\n      this.hammer.get(\"pan\").set({\n        threshold: 5,\n        direction: Hammer$1.DIRECTION_ALL\n      });\n      onTouch(this.hammer, function (event) {\n        _this3.body.eventListeners.onTouch(event);\n      });\n      this.hammer.on(\"tap\", function (event) {\n        _this3.body.eventListeners.onTap(event);\n      });\n      this.hammer.on(\"doubletap\", function (event) {\n        _this3.body.eventListeners.onDoubleTap(event);\n      });\n      this.hammer.on(\"press\", function (event) {\n        _this3.body.eventListeners.onHold(event);\n      });\n      this.hammer.on(\"panstart\", function (event) {\n        _this3.body.eventListeners.onDragStart(event);\n      });\n      this.hammer.on(\"panmove\", function (event) {\n        _this3.body.eventListeners.onDrag(event);\n      });\n      this.hammer.on(\"panend\", function (event) {\n        _this3.body.eventListeners.onDragEnd(event);\n      });\n      this.hammer.on(\"pinch\", function (event) {\n        _this3.body.eventListeners.onPinch(event);\n      }); // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?\n\n      this.frame.canvas.addEventListener(\"wheel\", function (event) {\n        _this3.body.eventListeners.onMouseWheel(event);\n      });\n      this.frame.canvas.addEventListener(\"mousemove\", function (event) {\n        _this3.body.eventListeners.onMouseMove(event);\n      });\n      this.frame.canvas.addEventListener(\"contextmenu\", function (event) {\n        _this3.body.eventListeners.onContext(event);\n      });\n      this.hammerFrame = new Hammer$1(this.frame);\n      onRelease(this.hammerFrame, function (event) {\n        _this3.body.eventListeners.onRelease(event);\n      });\n    }\n    /**\n     * Set a new size for the network\n     *\n     * @param {string} width   Width in pixels or percentage (for example '800px'\n     *                         or '50%')\n     * @param {string} height  Height in pixels or percentage  (for example '400px'\n     *                         or '30%')\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"setSize\",\n    value: function setSize() {\n      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.width;\n      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.height;\n      width = this._prepareValue(width);\n      height = this._prepareValue(height);\n      var emitEvent = false;\n      var oldWidth = this.frame.canvas.width;\n      var oldHeight = this.frame.canvas.height; // update the pixel ratio\n      //\n      // NOTE: Comment in following is rather inconsistent; this is the ONLY place in the code\n      //       where it is assumed that the pixel ratio could change at runtime.\n      //       The only way I can think of this happening is a rotating screen or tablet; but then\n      //       there should be a mechanism for reloading the data (TODO: check if this is present).\n      //\n      //       If the assumption is true (i.e. pixel ratio can change at runtime), then *all* usage\n      //       of pixel ratio must be overhauled for this.\n      //\n      //       For the time being, I will humor the assumption here, and in the rest of the code assume it is\n      //       constant.\n\n      var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value\n\n      this._setPixelRatio();\n\n      if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {\n        this._getCameraState(previousRatio);\n\n        this.frame.style.width = width;\n        this.frame.style.height = height;\n        this.frame.canvas.style.width = \"100%\";\n        this.frame.canvas.style.height = \"100%\";\n        this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);\n        this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n        this.options.width = width;\n        this.options.height = height;\n        this.canvasViewCenter = {\n          x: 0.5 * this.frame.clientWidth,\n          y: 0.5 * this.frame.clientHeight\n        };\n        emitEvent = true;\n      } else {\n        // this would adapt the width of the canvas to the width from 100% if and only if\n        // there is a change.\n        var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);\n        var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio); // store the camera if there is a change in size.\n\n        if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {\n          this._getCameraState(previousRatio);\n        }\n\n        if (this.frame.canvas.width !== newWidth) {\n          this.frame.canvas.width = newWidth;\n          emitEvent = true;\n        }\n\n        if (this.frame.canvas.height !== newHeight) {\n          this.frame.canvas.height = newHeight;\n          emitEvent = true;\n        }\n      }\n\n      if (emitEvent === true) {\n        this.body.emitter.emit(\"resize\", {\n          width: Math.round(this.frame.canvas.width / this.pixelRatio),\n          height: Math.round(this.frame.canvas.height / this.pixelRatio),\n          oldWidth: Math.round(oldWidth / this.pixelRatio),\n          oldHeight: Math.round(oldHeight / this.pixelRatio)\n        }); // restore the camera on change.\n\n        this._setCameraState();\n      } // set initialized so the get and set camera will work from now on.\n\n\n      this.initialized = true;\n      return emitEvent;\n    }\n    /**\n     *\n     * @returns {CanvasRenderingContext2D}\n     */\n\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.frame.canvas.getContext(\"2d\");\n    }\n    /**\n     * Determine the pixel ratio for various browsers.\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"_determinePixelRatio\",\n    value: function _determinePixelRatio() {\n      var ctx = this.getContext();\n\n      if (ctx === undefined) {\n        throw new Error(\"Could not get canvax context\");\n      }\n\n      var numerator = 1;\n\n      if (typeof window !== \"undefined\") {\n        // (window !== undefined) doesn't work here!\n        // Protection during unit tests, where 'window' can be missing\n        numerator = window.devicePixelRatio || 1;\n      }\n\n      var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n      return numerator / denominator;\n    }\n    /**\n     * Lazy determination of pixel ratio.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setPixelRatio\",\n    value: function _setPixelRatio() {\n      this.pixelRatio = this._determinePixelRatio();\n    }\n    /**\n     * Set the transform in the contained context, based on its pixelRatio\n     */\n\n  }, {\n    key: \"setTransform\",\n    value: function setTransform() {\n      var ctx = this.getContext();\n\n      if (ctx === undefined) {\n        throw new Error(\"Could not get canvax context\");\n      }\n\n      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    }\n    /**\n     * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to\n     * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)\n     *\n     * @param {number} x\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"_XconvertDOMtoCanvas\",\n    value: function _XconvertDOMtoCanvas(x) {\n      return (x - this.body.view.translation.x) / this.body.view.scale;\n    }\n    /**\n     * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to\n     * the X coordinate in DOM-space (coordinate point in browser relative to the container div)\n     *\n     * @param {number} x\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"_XconvertCanvasToDOM\",\n    value: function _XconvertCanvasToDOM(x) {\n      return x * this.body.view.scale + this.body.view.translation.x;\n    }\n    /**\n     * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to\n     * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)\n     *\n     * @param {number} y\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"_YconvertDOMtoCanvas\",\n    value: function _YconvertDOMtoCanvas(y) {\n      return (y - this.body.view.translation.y) / this.body.view.scale;\n    }\n    /**\n     * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to\n     * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)\n     *\n     * @param {number} y\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"_YconvertCanvasToDOM\",\n    value: function _YconvertCanvasToDOM(y) {\n      return y * this.body.view.scale + this.body.view.translation.y;\n    }\n    /**\n     * @param {point} pos\n     * @returns {point}\n     */\n\n  }, {\n    key: \"canvasToDOM\",\n    value: function canvasToDOM(pos) {\n      return {\n        x: this._XconvertCanvasToDOM(pos.x),\n        y: this._YconvertCanvasToDOM(pos.y)\n      };\n    }\n    /**\n     *\n     * @param {point} pos\n     * @returns {point}\n     */\n\n  }, {\n    key: \"DOMtoCanvas\",\n    value: function DOMtoCanvas(pos) {\n      return {\n        x: this._XconvertDOMtoCanvas(pos.x),\n        y: this._YconvertDOMtoCanvas(pos.y)\n      };\n    }\n  }]);\n  return Canvas;\n}();\n/**\r\n * Validate the fit options, replace missing optional values by defaults etc.\r\n *\r\n * @param rawOptions - The raw options.\r\n * @param allNodeIds - All node ids that will be used if nodes are omitted in\r\n * the raw options.\r\n *\r\n * @returns Options with everything filled in and validated.\r\n */\n\n\nfunction normalizeFitOptions(rawOptions, allNodeIds) {\n  var options = assign$2({\n    nodes: allNodeIds,\n    minZoomLevel: Number.MIN_VALUE,\n    maxZoomLevel: 1\n  }, rawOptions !== null && rawOptions !== void 0 ? rawOptions : {});\n\n  if (!isArray$5(options.nodes)) {\n    throw new TypeError(\"Nodes has to be an array of ids.\");\n  }\n\n  if (options.nodes.length === 0) {\n    options.nodes = allNodeIds;\n  }\n\n  if (!(typeof options.minZoomLevel === \"number\" && options.minZoomLevel > 0)) {\n    throw new TypeError(\"Min zoom level has to be a number higher than zero.\");\n  }\n\n  if (!(typeof options.maxZoomLevel === \"number\" && options.minZoomLevel <= options.maxZoomLevel)) {\n    throw new TypeError(\"Max zoom level has to be a number higher than min zoom level.\");\n  }\n\n  return options;\n}\n/**\n * The view\n */\n\n\nvar View = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function View(body, canvas) {\n    var _context,\n        _this = this,\n        _context2;\n\n    classCallCheck(this, View);\n    this.body = body;\n    this.canvas = canvas;\n    this.animationSpeed = 1 / this.renderRefreshRate;\n    this.animationEasingFunction = \"easeInOutQuint\";\n    this.easingTime = 0;\n    this.sourceScale = 0;\n    this.targetScale = 0;\n    this.sourceTranslation = 0;\n    this.targetTranslation = 0;\n    this.lockedOnNodeId = undefined;\n    this.lockedOnNodeOffset = undefined;\n    this.touchTime = 0;\n    this.viewFunction = undefined;\n    this.body.emitter.on(\"fit\", bind$2(_context = this.fit).call(_context, this));\n    this.body.emitter.on(\"animationFinished\", function () {\n      _this.body.emitter.emit(\"_stopRendering\");\n    });\n    this.body.emitter.on(\"unlockNode\", bind$2(_context2 = this.releaseNode).call(_context2, this));\n  }\n  /**\n   *\n   * @param {object} [options={}]\n   */\n\n\n  createClass(View, [{\n    key: \"setOptions\",\n    value: function setOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.options = options;\n    }\n    /**\n     * This function zooms out to fit all data on screen based on amount of nodes\n     *\n     * @param {object} [options={{nodes=Array}}]\n     * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;\n     */\n\n  }, {\n    key: \"fit\",\n    value: function fit(options) {\n      var initialZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      options = normalizeFitOptions(options, this.body.nodeIndices);\n      var canvasWidth = this.canvas.frame.canvas.clientWidth;\n      var canvasHeight = this.canvas.frame.canvas.clientHeight;\n      var range;\n      var zoomLevel;\n\n      if (canvasWidth === 0 || canvasHeight === 0) {\n        // There's no point in trying to fit into zero sized canvas. This could\n        // potentially even result in invalid values being computed. For example\n        // for network without nodes and zero sized canvas the zoom level would\n        // end up being computed as 0/0 which results in NaN. In any other case\n        // this would be 0/something which is again pointless to compute.\n        zoomLevel = 1;\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n      } else if (initialZoom === true) {\n        // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.\n        var positionDefined = 0;\n\n        for (var nodeId in this.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n            var node = this.body.nodes[nodeId];\n\n            if (node.predefinedPosition === true) {\n              positionDefined += 1;\n            }\n          }\n        }\n\n        if (positionDefined > 0.5 * this.body.nodeIndices.length) {\n          this.fit(options, false);\n          return;\n        }\n\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n        var numberOfNodes = this.body.nodeIndices.length;\n        zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.\n        // correct for larger canvasses.\n\n        var factor = Math.min(canvasWidth / 600, canvasHeight / 600);\n        zoomLevel *= factor;\n      } else {\n        this.body.emitter.emit(\"_resizeNodes\");\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n        var xDistance = Math.abs(range.maxX - range.minX) * 1.1;\n        var yDistance = Math.abs(range.maxY - range.minY) * 1.1;\n        var xZoomLevel = canvasWidth / xDistance;\n        var yZoomLevel = canvasHeight / yDistance;\n        zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;\n      }\n\n      if (zoomLevel > options.maxZoomLevel) {\n        zoomLevel = options.maxZoomLevel;\n      } else if (zoomLevel < options.minZoomLevel) {\n        zoomLevel = options.minZoomLevel;\n      }\n\n      var center = NetworkUtil.findCenter(range);\n      var animationOptions = {\n        position: center,\n        scale: zoomLevel,\n        animation: options.animation\n      };\n      this.moveTo(animationOptions);\n    } // animation\n\n    /**\n     * Center a node in view.\n     *\n     * @param {number} nodeId\n     * @param {number} [options]\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus(nodeId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.body.nodes[nodeId] !== undefined) {\n        var nodePosition = {\n          x: this.body.nodes[nodeId].x,\n          y: this.body.nodes[nodeId].y\n        };\n        options.position = nodePosition;\n        options.lockedOnNode = nodeId;\n        this.moveTo(options);\n      } else {\n        console.error(\"Node: \" + nodeId + \" cannot be found.\");\n      }\n    }\n    /**\n     *\n     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels\n     *                          |  options.scale    = number                 // scale to move to\n     *                          |  options.position = {x:number, y:number}   // position to move to\n     *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to\n     */\n\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(options) {\n      if (options === undefined) {\n        options = {};\n        return;\n      }\n\n      if (options.offset != null) {\n        if (options.offset.x != null) {\n          // Coerce and verify that x is valid.\n          options.offset.x = +options.offset.x;\n\n          if (!_isFinite$2(options.offset.x)) {\n            throw new TypeError('The option \"offset.x\" has to be a finite number.');\n          }\n        } else {\n          options.offset.x = 0;\n        }\n\n        if (options.offset.y != null) {\n          // Coerce and verify that y is valid.\n          options.offset.y = +options.offset.y;\n\n          if (!_isFinite$2(options.offset.y)) {\n            throw new TypeError('The option \"offset.y\" has to be a finite number.');\n          }\n        } else {\n          options.offset.x = 0;\n        }\n      } else {\n        options.offset = {\n          x: 0,\n          y: 0\n        };\n      }\n\n      if (options.position != null) {\n        if (options.position.x != null) {\n          // Coerce and verify that x is valid.\n          options.position.x = +options.position.x;\n\n          if (!_isFinite$2(options.position.x)) {\n            throw new TypeError('The option \"position.x\" has to be a finite number.');\n          }\n        } else {\n          options.position.x = 0;\n        }\n\n        if (options.position.y != null) {\n          // Coerce and verify that y is valid.\n          options.position.y = +options.position.y;\n\n          if (!_isFinite$2(options.position.y)) {\n            throw new TypeError('The option \"position.y\" has to be a finite number.');\n          }\n        } else {\n          options.position.x = 0;\n        }\n      } else {\n        options.position = this.getViewPosition();\n      }\n\n      if (options.scale != null) {\n        // Coerce and verify that the scale is valid.\n        options.scale = +options.scale;\n\n        if (!(options.scale > 0)) {\n          throw new TypeError('The option \"scale\" has to be a number greater than zero.');\n        }\n      } else {\n        options.scale = this.body.view.scale;\n      }\n\n      if (options.animation === undefined) {\n        options.animation = {\n          duration: 0\n        };\n      }\n\n      if (options.animation === false) {\n        options.animation = {\n          duration: 0\n        };\n      }\n\n      if (options.animation === true) {\n        options.animation = {};\n      }\n\n      if (options.animation.duration === undefined) {\n        options.animation.duration = 1000;\n      } // default duration\n\n\n      if (options.animation.easingFunction === undefined) {\n        options.animation.easingFunction = \"easeInOutQuad\";\n      } // default easing function\n\n\n      this.animateView(options);\n    }\n    /**\n     *\n     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels\n     *                          |  options.time     = number                 // animation time in milliseconds\n     *                          |  options.scale    = number                 // scale to animate to\n     *                          |  options.position = {x:number, y:number}   // position to animate to\n     *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,\n     *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,\n     *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,\n     *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint\n     */\n\n  }, {\n    key: \"animateView\",\n    value: function animateView(options) {\n      if (options === undefined) {\n        return;\n      }\n\n      this.animationEasingFunction = options.animation.easingFunction; // release if something focussed on the node\n\n      this.releaseNode();\n\n      if (options.locked === true) {\n        this.lockedOnNodeId = options.lockedOnNode;\n        this.lockedOnNodeOffset = options.offset;\n      } // forcefully complete the old animation if it was still running\n\n\n      if (this.easingTime != 0) {\n        this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.\n\n      }\n\n      this.sourceScale = this.body.view.scale;\n      this.sourceTranslation = this.body.view.translation;\n      this.targetScale = options.scale; // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw\n      // but at least then we'll have the target transition\n\n      this.body.view.scale = this.targetScale;\n      var viewCenter = this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n      var distanceFromCenter = {\n        // offset from view, distance view has to change by these x and y to center the node\n        x: viewCenter.x - options.position.x,\n        y: viewCenter.y - options.position.y\n      };\n      this.targetTranslation = {\n        x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,\n        y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y\n      }; // if the time is set to 0, don't do an animation\n\n      if (options.animation.duration === 0) {\n        if (this.lockedOnNodeId != undefined) {\n          var _context3;\n\n          this.viewFunction = bind$2(_context3 = this._lockedRedraw).call(_context3, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        } else {\n          this.body.view.scale = this.targetScale;\n          this.body.view.translation = this.targetTranslation;\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      } else {\n        var _context4;\n\n        this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's\n\n        this.animationEasingFunction = options.animation.easingFunction;\n        this.viewFunction = bind$2(_context4 = this._transitionRedraw).call(_context4, this);\n        this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        this.body.emitter.emit(\"_startRendering\");\n      }\n    }\n    /**\n     * used to animate smoothly by hijacking the redraw function.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_lockedRedraw\",\n    value: function _lockedRedraw() {\n      var nodePosition = {\n        x: this.body.nodes[this.lockedOnNodeId].x,\n        y: this.body.nodes[this.lockedOnNodeId].y\n      };\n      var viewCenter = this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n      var distanceFromCenter = {\n        // offset from view, distance view has to change by these x and y to center the node\n        x: viewCenter.x - nodePosition.x,\n        y: viewCenter.y - nodePosition.y\n      };\n      var sourceTranslation = this.body.view.translation;\n      var targetTranslation = {\n        x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,\n        y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y\n      };\n      this.body.view.translation = targetTranslation;\n    }\n    /**\n     * Resets state of a locked on Node\n     */\n\n  }, {\n    key: \"releaseNode\",\n    value: function releaseNode() {\n      if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.lockedOnNodeId = undefined;\n        this.lockedOnNodeOffset = undefined;\n      }\n    }\n    /**\n     * @param {boolean} [finished=false]\n     * @private\n     */\n\n  }, {\n    key: \"_transitionRedraw\",\n    value: function _transitionRedraw() {\n      var finished = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.easingTime += this.animationSpeed;\n      this.easingTime = finished === true ? 1.0 : this.easingTime;\n      var progress = easingFunctions[this.animationEasingFunction](this.easingTime);\n      this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;\n      this.body.view.translation = {\n        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,\n        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress\n      }; // cleanup\n\n      if (this.easingTime >= 1.0) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.easingTime = 0;\n\n        if (this.lockedOnNodeId != undefined) {\n          var _context5;\n\n          this.viewFunction = bind$2(_context5 = this._lockedRedraw).call(_context5, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        }\n\n        this.body.emitter.emit(\"animationFinished\");\n      }\n    }\n    /**\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getScale\",\n    value: function getScale() {\n      return this.body.view.scale;\n    }\n    /**\n     *\n     * @returns {{x: number, y: number}}\n     */\n\n  }, {\n    key: \"getViewPosition\",\n    value: function getViewPosition() {\n      return this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n    }\n  }]);\n  return View;\n}();\n/**\n * Navigation Handler\n */\n\n\nvar NavigationHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function NavigationHandler(body, canvas) {\n    var _this = this;\n\n    classCallCheck(this, NavigationHandler);\n    this.body = body;\n    this.canvas = canvas;\n    this.iconsCreated = false;\n    this.navigationHammers = [];\n    this.boundFunctions = {};\n    this.touchTime = 0;\n    this.activated = false;\n    this.body.emitter.on(\"activate\", function () {\n      _this.activated = true;\n\n      _this.configureKeyboardBindings();\n    });\n    this.body.emitter.on(\"deactivate\", function () {\n      _this.activated = false;\n\n      _this.configureKeyboardBindings();\n    });\n    this.body.emitter.on(\"destroy\", function () {\n      if (_this.keycharm !== undefined) {\n        _this.keycharm.destroy();\n      }\n    });\n    this.options = {};\n  }\n  /**\n   *\n   * @param {object} options\n   */\n\n\n  createClass(NavigationHandler, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        this.options = options;\n        this.create();\n      }\n    }\n    /**\n     * Creates or refreshes navigation and sets key bindings\n     */\n\n  }, {\n    key: \"create\",\n    value: function create() {\n      if (this.options.navigationButtons === true) {\n        if (this.iconsCreated === false) {\n          this.loadNavigationElements();\n        }\n      } else if (this.iconsCreated === true) {\n        this.cleanNavigation();\n      }\n\n      this.configureKeyboardBindings();\n    }\n    /**\n     * Cleans up previous navigation items\n     */\n\n  }, {\n    key: \"cleanNavigation\",\n    value: function cleanNavigation() {\n      // clean hammer bindings\n      if (this.navigationHammers.length != 0) {\n        for (var i = 0; i < this.navigationHammers.length; i++) {\n          this.navigationHammers[i].destroy();\n        }\n\n        this.navigationHammers = [];\n      } // clean up previous navigation items\n\n\n      if (this.navigationDOM && this.navigationDOM[\"wrapper\"] && this.navigationDOM[\"wrapper\"].parentNode) {\n        this.navigationDOM[\"wrapper\"].parentNode.removeChild(this.navigationDOM[\"wrapper\"]);\n      }\n\n      this.iconsCreated = false;\n    }\n    /**\n     * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation\n     * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent\n     * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.\n     * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"loadNavigationElements\",\n    value: function loadNavigationElements() {\n      var _this2 = this;\n\n      this.cleanNavigation();\n      this.navigationDOM = {};\n      var navigationDivs = [\"up\", \"down\", \"left\", \"right\", \"zoomIn\", \"zoomOut\", \"zoomExtends\"];\n      var navigationDivActions = [\"_moveUp\", \"_moveDown\", \"_moveLeft\", \"_moveRight\", \"_zoomIn\", \"_zoomOut\", \"_fit\"];\n      this.navigationDOM[\"wrapper\"] = document.createElement(\"div\");\n      this.navigationDOM[\"wrapper\"].className = \"vis-navigation\";\n      this.canvas.frame.appendChild(this.navigationDOM[\"wrapper\"]);\n\n      for (var i = 0; i < navigationDivs.length; i++) {\n        this.navigationDOM[navigationDivs[i]] = document.createElement(\"div\");\n        this.navigationDOM[navigationDivs[i]].className = \"vis-button vis-\" + navigationDivs[i];\n        this.navigationDOM[\"wrapper\"].appendChild(this.navigationDOM[navigationDivs[i]]);\n        var hammer = new Hammer$1(this.navigationDOM[navigationDivs[i]]);\n\n        if (navigationDivActions[i] === \"_fit\") {\n          var _context;\n\n          onTouch(hammer, bind$2(_context = this._fit).call(_context, this));\n        } else {\n          var _context2;\n\n          onTouch(hammer, bind$2(_context2 = this.bindToRedraw).call(_context2, this, navigationDivActions[i]));\n        }\n\n        this.navigationHammers.push(hammer);\n      } // use a hammer for the release so we do not require the one used in the rest of the network\n      // the one the rest uses can be overloaded by the manipulation system.\n\n\n      var hammerFrame = new Hammer$1(this.canvas.frame);\n      onRelease(hammerFrame, function () {\n        _this2._stopMovement();\n      });\n      this.navigationHammers.push(hammerFrame);\n      this.iconsCreated = true;\n    }\n    /**\n     *\n     * @param {string} action\n     */\n\n  }, {\n    key: \"bindToRedraw\",\n    value: function bindToRedraw(action) {\n      if (this.boundFunctions[action] === undefined) {\n        var _context3;\n\n        this.boundFunctions[action] = bind$2(_context3 = this[action]).call(_context3, this);\n        this.body.emitter.on(\"initRedraw\", this.boundFunctions[action]);\n        this.body.emitter.emit(\"_startRendering\");\n      }\n    }\n    /**\n     *\n     * @param {string} action\n     */\n\n  }, {\n    key: \"unbindFromRedraw\",\n    value: function unbindFromRedraw(action) {\n      if (this.boundFunctions[action] !== undefined) {\n        this.body.emitter.off(\"initRedraw\", this.boundFunctions[action]);\n        this.body.emitter.emit(\"_stopRendering\");\n        delete this.boundFunctions[action];\n      }\n    }\n    /**\n     * this stops all movement induced by the navigation buttons\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_fit\",\n    value: function _fit() {\n      if (new Date().valueOf() - this.touchTime > 700) {\n        // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)\n        this.body.emitter.emit(\"fit\", {\n          duration: 700\n        });\n        this.touchTime = new Date().valueOf();\n      }\n    }\n    /**\n     * this stops all movement induced by the navigation buttons\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_stopMovement\",\n    value: function _stopMovement() {\n      for (var boundAction in this.boundFunctions) {\n        if (Object.prototype.hasOwnProperty.call(this.boundFunctions, boundAction)) {\n          this.body.emitter.off(\"initRedraw\", this.boundFunctions[boundAction]);\n          this.body.emitter.emit(\"_stopRendering\");\n        }\n      }\n\n      this.boundFunctions = {};\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_moveUp\",\n    value: function _moveUp() {\n      this.body.view.translation.y += this.options.keyboard.speed.y;\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_moveDown\",\n    value: function _moveDown() {\n      this.body.view.translation.y -= this.options.keyboard.speed.y;\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_moveLeft\",\n    value: function _moveLeft() {\n      this.body.view.translation.x += this.options.keyboard.speed.x;\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_moveRight\",\n    value: function _moveRight() {\n      this.body.view.translation.x -= this.options.keyboard.speed.x;\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_zoomIn\",\n    value: function _zoomIn() {\n      var scaleOld = this.body.view.scale;\n      var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);\n      var translation = this.body.view.translation;\n      var scaleFrac = scale / scaleOld;\n      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;\n      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;\n      this.body.view.scale = scale;\n      this.body.view.translation = {\n        x: tx,\n        y: ty\n      };\n      this.body.emitter.emit(\"zoom\", {\n        direction: \"+\",\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n    /**\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_zoomOut\",\n    value: function _zoomOut() {\n      var scaleOld = this.body.view.scale;\n      var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);\n      var translation = this.body.view.translation;\n      var scaleFrac = scale / scaleOld;\n      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;\n      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;\n      this.body.view.scale = scale;\n      this.body.view.translation = {\n        x: tx,\n        y: ty\n      };\n      this.body.emitter.emit(\"zoom\", {\n        direction: \"-\",\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n    /**\n     * bind all keys using keycharm.\n     */\n\n  }, {\n    key: \"configureKeyboardBindings\",\n    value: function configureKeyboardBindings() {\n      var _this3 = this;\n\n      if (this.keycharm !== undefined) {\n        this.keycharm.destroy();\n      }\n\n      if (this.options.keyboard.enabled === true) {\n        if (this.options.keyboard.bindToWindow === true) {\n          this.keycharm = keycharm({\n            container: window,\n            preventDefault: true\n          });\n        } else {\n          this.keycharm = keycharm({\n            container: this.canvas.frame,\n            preventDefault: true\n          });\n        }\n\n        this.keycharm.reset();\n\n        if (this.activated === true) {\n          var _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20, _context21, _context22, _context23, _context24, _context25, _context26, _context27;\n\n          bind$2(_context4 = this.keycharm).call(_context4, \"up\", function () {\n            _this3.bindToRedraw(\"_moveUp\");\n          }, \"keydown\");\n          bind$2(_context5 = this.keycharm).call(_context5, \"down\", function () {\n            _this3.bindToRedraw(\"_moveDown\");\n          }, \"keydown\");\n          bind$2(_context6 = this.keycharm).call(_context6, \"left\", function () {\n            _this3.bindToRedraw(\"_moveLeft\");\n          }, \"keydown\");\n          bind$2(_context7 = this.keycharm).call(_context7, \"right\", function () {\n            _this3.bindToRedraw(\"_moveRight\");\n          }, \"keydown\");\n          bind$2(_context8 = this.keycharm).call(_context8, \"=\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          bind$2(_context9 = this.keycharm).call(_context9, \"num+\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          bind$2(_context10 = this.keycharm).call(_context10, \"num-\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          bind$2(_context11 = this.keycharm).call(_context11, \"-\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          bind$2(_context12 = this.keycharm).call(_context12, \"[\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          bind$2(_context13 = this.keycharm).call(_context13, \"]\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          bind$2(_context14 = this.keycharm).call(_context14, \"pageup\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          bind$2(_context15 = this.keycharm).call(_context15, \"pagedown\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          bind$2(_context16 = this.keycharm).call(_context16, \"up\", function () {\n            _this3.unbindFromRedraw(\"_moveUp\");\n          }, \"keyup\");\n          bind$2(_context17 = this.keycharm).call(_context17, \"down\", function () {\n            _this3.unbindFromRedraw(\"_moveDown\");\n          }, \"keyup\");\n          bind$2(_context18 = this.keycharm).call(_context18, \"left\", function () {\n            _this3.unbindFromRedraw(\"_moveLeft\");\n          }, \"keyup\");\n          bind$2(_context19 = this.keycharm).call(_context19, \"right\", function () {\n            _this3.unbindFromRedraw(\"_moveRight\");\n          }, \"keyup\");\n          bind$2(_context20 = this.keycharm).call(_context20, \"=\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          bind$2(_context21 = this.keycharm).call(_context21, \"num+\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          bind$2(_context22 = this.keycharm).call(_context22, \"num-\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          bind$2(_context23 = this.keycharm).call(_context23, \"-\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          bind$2(_context24 = this.keycharm).call(_context24, \"[\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          bind$2(_context25 = this.keycharm).call(_context25, \"]\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          bind$2(_context26 = this.keycharm).call(_context26, \"pageup\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          bind$2(_context27 = this.keycharm).call(_context27, \"pagedown\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n        }\n      }\n    }\n  }]);\n  return NavigationHandler;\n}();\n/**\n * Popup is a class to create a popup window with some text\n */\n\n\nvar Popup = /*#__PURE__*/function () {\n  /**\n   * @param {Element} container       The container object.\n   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip' or 'cap')\n   */\n  function Popup(container, overflowMethod) {\n    classCallCheck(this, Popup);\n    this.container = container;\n    this.overflowMethod = overflowMethod || \"cap\";\n    this.x = 0;\n    this.y = 0;\n    this.padding = 5;\n    this.hidden = false; // create the frame\n\n    this.frame = document.createElement(\"div\");\n    this.frame.className = \"vis-tooltip\";\n    this.container.appendChild(this.frame);\n  }\n  /**\n   * @param {number} x   Horizontal position of the popup window\n   * @param {number} y   Vertical position of the popup window\n   */\n\n\n  createClass(Popup, [{\n    key: \"setPosition\",\n    value: function setPosition(x, y) {\n      this.x = _parseInt$2(x);\n      this.y = _parseInt$2(y);\n    }\n    /**\n     * Set the content for the popup window. This can be HTML code or text.\n     *\n     * @param {string | Element} content\n     */\n\n  }, {\n    key: \"setText\",\n    value: function setText(content) {\n      if (content instanceof Element) {\n        this.frame.innerHTML = \"\";\n        this.frame.appendChild(content);\n      } else {\n        this.frame.innerHTML = content; // string containing text or HTML\n      }\n    }\n    /**\n     * Show the popup window\n     *\n     * @param {boolean} [doShow]    Show or hide the window\n     */\n\n  }, {\n    key: \"show\",\n    value: function show(doShow) {\n      if (doShow === undefined) {\n        doShow = true;\n      }\n\n      if (doShow === true) {\n        var height = this.frame.clientHeight;\n        var width = this.frame.clientWidth;\n        var maxHeight = this.frame.parentNode.clientHeight;\n        var maxWidth = this.frame.parentNode.clientWidth;\n        var left = 0,\n            top = 0;\n\n        if (this.overflowMethod == \"flip\") {\n          var isLeft = false,\n              isTop = true; // Where around the position it's located\n\n          if (this.y - height < this.padding) {\n            isTop = false;\n          }\n\n          if (this.x + width > maxWidth - this.padding) {\n            isLeft = true;\n          }\n\n          if (isLeft) {\n            left = this.x - width;\n          } else {\n            left = this.x;\n          }\n\n          if (isTop) {\n            top = this.y - height;\n          } else {\n            top = this.y;\n          }\n        } else {\n          top = this.y - height;\n\n          if (top + height + this.padding > maxHeight) {\n            top = maxHeight - height - this.padding;\n          }\n\n          if (top < this.padding) {\n            top = this.padding;\n          }\n\n          left = this.x;\n\n          if (left + width + this.padding > maxWidth) {\n            left = maxWidth - width - this.padding;\n          }\n\n          if (left < this.padding) {\n            left = this.padding;\n          }\n        }\n\n        this.frame.style.left = left + \"px\";\n        this.frame.style.top = top + \"px\";\n        this.frame.style.visibility = \"visible\";\n        this.hidden = false;\n      } else {\n        this.hide();\n      }\n    }\n    /**\n     * Hide the popup window\n     */\n\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.hidden = true;\n      this.frame.style.left = \"0\";\n      this.frame.style.top = \"0\";\n      this.frame.style.visibility = \"hidden\";\n    }\n    /**\n     * Remove the popup window\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.frame.parentNode.removeChild(this.frame); // Remove element from DOM\n    }\n  }]);\n  return Popup;\n}();\n\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$4(o, minLen) {\n  var _context15;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen);\n  var n = slice$5(_context15 = Object.prototype.toString.call(o)).call(_context15, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from_1$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);\n}\n\nfunction _arrayLikeToArray$4(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * Handler for interactions\n */\n\n\nvar InteractionHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   * @param {SelectionHandler} selectionHandler\n   */\n  function InteractionHandler(body, canvas, selectionHandler) {\n    var _context, _context2, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13;\n\n    classCallCheck(this, InteractionHandler);\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionHandler = selectionHandler;\n    this.navigationHandler = new NavigationHandler(body, canvas); // bind the events from hammer to functions in this object\n\n    this.body.eventListeners.onTap = bind$2(_context = this.onTap).call(_context, this);\n    this.body.eventListeners.onTouch = bind$2(_context2 = this.onTouch).call(_context2, this);\n    this.body.eventListeners.onDoubleTap = bind$2(_context3 = this.onDoubleTap).call(_context3, this);\n    this.body.eventListeners.onHold = bind$2(_context4 = this.onHold).call(_context4, this);\n    this.body.eventListeners.onDragStart = bind$2(_context5 = this.onDragStart).call(_context5, this);\n    this.body.eventListeners.onDrag = bind$2(_context6 = this.onDrag).call(_context6, this);\n    this.body.eventListeners.onDragEnd = bind$2(_context7 = this.onDragEnd).call(_context7, this);\n    this.body.eventListeners.onMouseWheel = bind$2(_context8 = this.onMouseWheel).call(_context8, this);\n    this.body.eventListeners.onPinch = bind$2(_context9 = this.onPinch).call(_context9, this);\n    this.body.eventListeners.onMouseMove = bind$2(_context10 = this.onMouseMove).call(_context10, this);\n    this.body.eventListeners.onRelease = bind$2(_context11 = this.onRelease).call(_context11, this);\n    this.body.eventListeners.onContext = bind$2(_context12 = this.onContext).call(_context12, this);\n    this.touchTime = 0;\n    this.drag = {};\n    this.pinch = {};\n    this.popup = undefined;\n    this.popupObj = undefined;\n    this.popupTimer = undefined;\n    this.body.functions.getPointer = bind$2(_context13 = this.getPointer).call(_context13, this);\n    this.options = {};\n    this.defaultOptions = {\n      dragNodes: true,\n      dragView: true,\n      hover: false,\n      keyboard: {\n        enabled: false,\n        speed: {\n          x: 10,\n          y: 10,\n          zoom: 0.02\n        },\n        bindToWindow: true\n      },\n      navigationButtons: false,\n      tooltipDelay: 300,\n      zoomView: true,\n      zoomSpeed: 1\n    };\n    assign$2(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n  /**\n   * Binds event listeners\n   */\n\n\n  createClass(InteractionHandler, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this;\n\n      this.body.emitter.on(\"destroy\", function () {\n        clearTimeout(_this.popupTimer);\n        delete _this.body.functions.getPointer;\n      });\n    }\n    /**\n     *\n     * @param {object} options\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // extend all but the values in fields\n        var fields = [\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\", \"keyboard\", \"multiselect\", \"selectable\", \"selectConnectedEdges\"];\n        selectiveNotDeepExtend(fields, this.options, options); // merge the keyboard options in.\n\n        mergeOptions(this.options, options, \"keyboard\");\n\n        if (options.tooltip) {\n          assign$2(this.options.tooltip, options.tooltip);\n\n          if (options.tooltip.color) {\n            this.options.tooltip.color = parseColor(options.tooltip.color);\n          }\n        }\n      }\n\n      this.navigationHandler.setOptions(this.options);\n    }\n    /**\n     * Get the pointer location from a touch location\n     *\n     * @param {{x: number, y: number}} touch\n     * @returns {{x: number, y: number}} pointer\n     * @private\n     */\n\n  }, {\n    key: \"getPointer\",\n    value: function getPointer(touch) {\n      return {\n        x: touch.x - getAbsoluteLeft(this.canvas.frame.canvas),\n        y: touch.y - getAbsoluteTop(this.canvas.frame.canvas)\n      };\n    }\n    /**\n     * On start of a touch gesture, store the pointer\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: \"onTouch\",\n    value: function onTouch(event) {\n      if (new Date().valueOf() - this.touchTime > 50) {\n        this.drag.pointer = this.getPointer(event.center);\n        this.drag.pinched = false;\n        this.pinch.scale = this.body.view.scale; // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)\n\n        this.touchTime = new Date().valueOf();\n      }\n    }\n    /**\n     * handle tap/click event: select/unselect a node\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"onTap\",\n    value: function onTap(event) {\n      var pointer = this.getPointer(event.center);\n      var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);\n      this.checkSelectionChanges(pointer, multiselect);\n      this.selectionHandler.commitAndEmit(pointer, event);\n      this.selectionHandler.generateClickEvent(\"click\", event, pointer);\n    }\n    /**\n     * handle doubletap event\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"onDoubleTap\",\n    value: function onDoubleTap(event) {\n      var pointer = this.getPointer(event.center);\n      this.selectionHandler.generateClickEvent(\"doubleClick\", event, pointer);\n    }\n    /**\n     * handle long tap event: multi select nodes\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"onHold\",\n    value: function onHold(event) {\n      var pointer = this.getPointer(event.center);\n      var multiselect = this.selectionHandler.options.multiselect;\n      this.checkSelectionChanges(pointer, multiselect);\n      this.selectionHandler.commitAndEmit(pointer, event);\n      this.selectionHandler.generateClickEvent(\"click\", event, pointer);\n      this.selectionHandler.generateClickEvent(\"hold\", event, pointer);\n    }\n    /**\n     * handle the release of the screen\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"onRelease\",\n    value: function onRelease(event) {\n      if (new Date().valueOf() - this.touchTime > 10) {\n        var pointer = this.getPointer(event.center);\n        this.selectionHandler.generateClickEvent(\"release\", event, pointer); // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)\n\n        this.touchTime = new Date().valueOf();\n      }\n    }\n    /**\n     *\n     * @param {Event} event\n     */\n\n  }, {\n    key: \"onContext\",\n    value: function onContext(event) {\n      var pointer = this.getPointer({\n        x: event.clientX,\n        y: event.clientY\n      });\n      this.selectionHandler.generateClickEvent(\"oncontext\", event, pointer);\n    }\n    /**\n     * Select and deselect nodes depending current selection change.\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [add=false]\n     */\n\n  }, {\n    key: \"checkSelectionChanges\",\n    value: function checkSelectionChanges(pointer) {\n      var add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (add === true) {\n        this.selectionHandler.selectAdditionalOnPoint(pointer);\n      } else {\n        this.selectionHandler.selectOnPoint(pointer);\n      }\n    }\n    /**\n     * Remove all node and edge id's from the first set that are present in the second one.\n     *\n     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet\n     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet\n     * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}\n     * @private\n     */\n\n  }, {\n    key: \"_determineDifference\",\n    value: function _determineDifference(firstSet, secondSet) {\n      var arrayDiff = function arrayDiff(firstArr, secondArr) {\n        var result = [];\n\n        for (var i = 0; i < firstArr.length; i++) {\n          var value = firstArr[i];\n\n          if (indexOf$3(secondArr).call(secondArr, value) === -1) {\n            result.push(value);\n          }\n        }\n\n        return result;\n      };\n\n      return {\n        nodes: arrayDiff(firstSet.nodes, secondSet.nodes),\n        edges: arrayDiff(firstSet.edges, secondSet.edges)\n      };\n    }\n    /**\n     * This function is called by onDragStart.\n     * It is separated out because we can then overload it for the datamanipulation system.\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"onDragStart\",\n    value: function onDragStart(event) {\n      // if already dragging, do not start\n      // this can happen on touch screens with multiple fingers\n      if (this.drag.dragging) {\n        return;\n      } //in case the touch event was triggered on an external div, do the initial touch now.\n\n\n      if (this.drag.pointer === undefined) {\n        this.onTouch(event);\n      } // note: drag.pointer is set in onTouch to get the initial touch location\n\n\n      var node = this.selectionHandler.getNodeAt(this.drag.pointer);\n      this.drag.dragging = true;\n      this.drag.selection = [];\n      this.drag.translation = assign$2({}, this.body.view.translation); // copy the object\n\n      this.drag.nodeId = undefined;\n\n      if (event.srcEvent.shiftKey) {\n        this.body.selectionBox.show = true;\n        var pointer = this.getPointer(event.center);\n        this.body.selectionBox.position.start = {\n          x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n          y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n        };\n        this.body.selectionBox.position.end = {\n          x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n          y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n        };\n      }\n\n      if (node !== undefined && this.options.dragNodes === true) {\n        this.drag.nodeId = node.id; // select the clicked node if not yet selected\n\n        if (node.isSelected() === false) {\n          this.selectionHandler.unselectAll();\n          this.selectionHandler.selectObject(node);\n        } // after select to contain the node\n\n\n        this.selectionHandler.generateClickEvent(\"dragStart\", event, this.drag.pointer); // create an array with the selected nodes and their original location and status\n\n        var _iterator = _createForOfIteratorHelper$3(this.selectionHandler.getSelectedNodes()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _node = _step.value;\n            var s = {\n              id: _node.id,\n              node: _node,\n              // store original x, y, xFixed and yFixed, make the node temporarily Fixed\n              x: _node.x,\n              y: _node.y,\n              xFixed: _node.options.fixed.x,\n              yFixed: _node.options.fixed.y\n            };\n            _node.options.fixed.x = true;\n            _node.options.fixed.y = true;\n            this.drag.selection.push(s);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        // fallback if no node is selected and thus the view is dragged.\n        this.selectionHandler.generateClickEvent(\"dragStart\", event, this.drag.pointer, undefined, true);\n      }\n    }\n    /**\n     * handle drag event\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"onDrag\",\n    value: function onDrag(event) {\n      var _this2 = this;\n\n      if (this.drag.pinched === true) {\n        return;\n      } // remove the focus on node if it is focussed on by the focusOnNode\n\n\n      this.body.emitter.emit(\"unlockNode\");\n      var pointer = this.getPointer(event.center);\n      var selection = this.drag.selection;\n\n      if (selection && selection.length && this.options.dragNodes === true) {\n        this.selectionHandler.generateClickEvent(\"dragging\", event, pointer); // calculate delta's and new location\n\n        var deltaX = pointer.x - this.drag.pointer.x;\n        var deltaY = pointer.y - this.drag.pointer.y; // update position of all selected nodes\n\n        forEach$2(selection).call(selection, function (selection) {\n          var node = selection.node; // only move the node if it was not fixed initially\n\n          if (selection.xFixed === false) {\n            node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);\n          } // only move the node if it was not fixed initially\n\n\n          if (selection.yFixed === false) {\n            node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);\n          }\n        }); // start the simulation of the physics\n\n        this.body.emitter.emit(\"startSimulation\");\n      } else {\n        // create selection box\n        if (event.srcEvent.shiftKey) {\n          this.selectionHandler.generateClickEvent(\"dragging\", event, pointer, undefined, true); // if the drag was not started properly because the click started outside the network div, start it now.\n\n          if (this.drag.pointer === undefined) {\n            this.onDragStart(event);\n            return;\n          }\n\n          this.body.selectionBox.position.end = {\n            x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n            y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n          };\n          this.body.emitter.emit(\"_requestRedraw\");\n        } // move the network\n\n\n        if (this.options.dragView === true && !event.srcEvent.shiftKey) {\n          this.selectionHandler.generateClickEvent(\"dragging\", event, pointer, undefined, true); // if the drag was not started properly because the click started outside the network div, start it now.\n\n          if (this.drag.pointer === undefined) {\n            this.onDragStart(event);\n            return;\n          }\n\n          var diffX = pointer.x - this.drag.pointer.x;\n          var diffY = pointer.y - this.drag.pointer.y;\n          this.body.view.translation = {\n            x: this.drag.translation.x + diffX,\n            y: this.drag.translation.y + diffY\n          };\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n    }\n    /**\n     * handle drag start event\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"onDragEnd\",\n    value: function onDragEnd(event) {\n      var _this3 = this;\n\n      this.drag.dragging = false;\n\n      if (this.body.selectionBox.show) {\n        var _context14;\n\n        this.body.selectionBox.show = false;\n        var selectionBoxPosition = this.body.selectionBox.position;\n        var selectionBoxPositionMinMax = {\n          minX: Math.min(selectionBoxPosition.start.x, selectionBoxPosition.end.x),\n          minY: Math.min(selectionBoxPosition.start.y, selectionBoxPosition.end.y),\n          maxX: Math.max(selectionBoxPosition.start.x, selectionBoxPosition.end.x),\n          maxY: Math.max(selectionBoxPosition.start.y, selectionBoxPosition.end.y)\n        };\n        var toBeSelectedNodes = filter$2(_context14 = this.body.nodeIndices).call(_context14, function (nodeId) {\n          var node = _this3.body.nodes[nodeId];\n          return node.x >= selectionBoxPositionMinMax.minX && node.x <= selectionBoxPositionMinMax.maxX && node.y >= selectionBoxPositionMinMax.minY && node.y <= selectionBoxPositionMinMax.maxY;\n        });\n        forEach$2(toBeSelectedNodes).call(toBeSelectedNodes, function (nodeId) {\n          return _this3.selectionHandler.selectObject(_this3.body.nodes[nodeId]);\n        });\n        var pointer = this.getPointer(event.center);\n        this.selectionHandler.commitAndEmit(pointer, event);\n        this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center), undefined, true);\n        this.body.emitter.emit(\"_requestRedraw\");\n      } else {\n        var selection = this.drag.selection;\n\n        if (selection && selection.length) {\n          forEach$2(selection).call(selection, function (s) {\n            // restore original xFixed and yFixed\n            s.node.options.fixed.x = s.xFixed;\n            s.node.options.fixed.y = s.yFixed;\n          });\n          this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center));\n          this.body.emitter.emit(\"startSimulation\");\n        } else {\n          this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center), undefined, true);\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n    }\n    /**\n     * Handle pinch event\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: \"onPinch\",\n    value: function onPinch(event) {\n      var pointer = this.getPointer(event.center);\n      this.drag.pinched = true;\n\n      if (this.pinch[\"scale\"] === undefined) {\n        this.pinch.scale = 1;\n      } // TODO: enabled moving while pinching?\n\n\n      var scale = this.pinch.scale * event.scale;\n      this.zoom(scale, pointer);\n    }\n    /**\n     * Zoom the network in or out\n     *\n     * @param {number} scale a number around 1, and between 0.01 and 10\n     * @param {{x: number, y: number}} pointer    Position on screen\n     * @private\n     */\n\n  }, {\n    key: \"zoom\",\n    value: function zoom(scale, pointer) {\n      if (this.options.zoomView === true) {\n        var scaleOld = this.body.view.scale;\n\n        if (scale < 0.00001) {\n          scale = 0.00001;\n        }\n\n        if (scale > 10) {\n          scale = 10;\n        }\n\n        var preScaleDragPointer = undefined;\n\n        if (this.drag !== undefined) {\n          if (this.drag.dragging === true) {\n            preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);\n          }\n        } // + this.canvas.frame.canvas.clientHeight / 2\n\n\n        var translation = this.body.view.translation;\n        var scaleFrac = scale / scaleOld;\n        var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;\n        var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;\n        this.body.view.scale = scale;\n        this.body.view.translation = {\n          x: tx,\n          y: ty\n        };\n\n        if (preScaleDragPointer != undefined) {\n          var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);\n          this.drag.pointer.x = postScaleDragPointer.x;\n          this.drag.pointer.y = postScaleDragPointer.y;\n        }\n\n        this.body.emitter.emit(\"_requestRedraw\");\n\n        if (scaleOld < scale) {\n          this.body.emitter.emit(\"zoom\", {\n            direction: \"+\",\n            scale: this.body.view.scale,\n            pointer: pointer\n          });\n        } else {\n          this.body.emitter.emit(\"zoom\", {\n            direction: \"-\",\n            scale: this.body.view.scale,\n            pointer: pointer\n          });\n        }\n      }\n    }\n    /**\n     * Event handler for mouse wheel event, used to zoom the timeline\n     * See http://adomas.org/javascript-mouse-wheel/\n     *     https://github.com/EightMedia/hammer.js/issues/256\n     *\n     * @param {MouseEvent}  event\n     * @private\n     */\n\n  }, {\n    key: \"onMouseWheel\",\n    value: function onMouseWheel(event) {\n      if (this.options.zoomView === true) {\n        // If delta is nonzero, handle it.\n        // Basically, delta is now positive if wheel was scrolled up,\n        // and negative, if wheel was scrolled down.\n        if (event.deltaY !== 0) {\n          // calculate the new scale\n          var scale = this.body.view.scale;\n          scale *= 1 + (event.deltaY < 0 ? 1 : -1) * (this.options.zoomSpeed * 0.1); // calculate the pointer location\n\n          var pointer = this.getPointer({\n            x: event.clientX,\n            y: event.clientY\n          }); // apply the new scale\n\n          this.zoom(scale, pointer);\n        } // Prevent default actions caused by mouse wheel.\n\n\n        event.preventDefault();\n      }\n    }\n    /**\n     * Mouse move handler for checking whether the title moves over a node with a title.\n     *\n     * @param  {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      var _this4 = this;\n\n      var pointer = this.getPointer({\n        x: event.clientX,\n        y: event.clientY\n      });\n      var popupVisible = false; // check if the previously selected node is still selected\n\n      if (this.popup !== undefined) {\n        if (this.popup.hidden === false) {\n          this._checkHidePopup(pointer);\n        } // if the popup was not hidden above\n\n\n        if (this.popup.hidden === false) {\n          popupVisible = true;\n          this.popup.setPosition(pointer.x + 3, pointer.y - 5);\n          this.popup.show();\n        }\n      } // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.\n\n\n      if (this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {\n        this.canvas.frame.focus();\n      } // start a timeout that will check if the mouse is positioned above an element\n\n\n      if (popupVisible === false) {\n        if (this.popupTimer !== undefined) {\n          clearInterval(this.popupTimer); // stop any running calculationTimer\n\n          this.popupTimer = undefined;\n        }\n\n        if (!this.drag.dragging) {\n          this.popupTimer = setTimeout$2(function () {\n            return _this4._checkShowPopup(pointer);\n          }, this.options.tooltipDelay);\n        }\n      } // adding hover highlights\n\n\n      if (this.options.hover === true) {\n        this.selectionHandler.hoverObject(event, pointer);\n      }\n    }\n    /**\n     * Check if there is an element on the given position in the network\n     * (a node or edge). If so, and if this element has a title,\n     * show a popup window with its title.\n     *\n     * @param {{x:number, y:number}} pointer\n     * @private\n     */\n\n  }, {\n    key: \"_checkShowPopup\",\n    value: function _checkShowPopup(pointer) {\n      var x = this.canvas._XconvertDOMtoCanvas(pointer.x);\n\n      var y = this.canvas._YconvertDOMtoCanvas(pointer.y);\n\n      var pointerObj = {\n        left: x,\n        top: y,\n        right: x,\n        bottom: y\n      };\n      var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;\n      var nodeUnderCursor = false;\n      var popupType = \"node\"; // check if a node is under the cursor.\n\n      if (this.popupObj === undefined) {\n        // search the nodes for overlap, select the top one in case of multiple nodes\n        var nodeIndices = this.body.nodeIndices;\n        var nodes = this.body.nodes;\n        var node;\n        var overlappingNodes = [];\n\n        for (var i = 0; i < nodeIndices.length; i++) {\n          node = nodes[nodeIndices[i]];\n\n          if (node.isOverlappingWith(pointerObj) === true) {\n            nodeUnderCursor = true;\n\n            if (node.getTitle() !== undefined) {\n              overlappingNodes.push(nodeIndices[i]);\n            }\n          }\n        }\n\n        if (overlappingNodes.length > 0) {\n          // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others\n          this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]]; // if you hover over a node, the title of the edge is not supposed to be shown.\n\n          nodeUnderCursor = true;\n        }\n      }\n\n      if (this.popupObj === undefined && nodeUnderCursor === false) {\n        // search the edges for overlap\n        var edgeIndices = this.body.edgeIndices;\n        var edges = this.body.edges;\n        var edge;\n        var overlappingEdges = [];\n\n        for (var _i = 0; _i < edgeIndices.length; _i++) {\n          edge = edges[edgeIndices[_i]];\n\n          if (edge.isOverlappingWith(pointerObj) === true) {\n            if (edge.connected === true && edge.getTitle() !== undefined) {\n              overlappingEdges.push(edgeIndices[_i]);\n            }\n          }\n        }\n\n        if (overlappingEdges.length > 0) {\n          this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];\n          popupType = \"edge\";\n        }\n      }\n\n      if (this.popupObj !== undefined) {\n        // show popup message window\n        if (this.popupObj.id !== previousPopupObjId) {\n          if (this.popup === undefined) {\n            this.popup = new Popup(this.canvas.frame);\n          }\n\n          this.popup.popupTargetType = popupType;\n          this.popup.popupTargetId = this.popupObj.id; // adjust a small offset such that the mouse cursor is located in the\n          // bottom left location of the popup, and you can easily move over the\n          // popup area\n\n          this.popup.setPosition(pointer.x + 3, pointer.y - 5);\n          this.popup.setText(this.popupObj.getTitle());\n          this.popup.show();\n          this.body.emitter.emit(\"showPopup\", this.popupObj.id);\n        }\n      } else {\n        if (this.popup !== undefined) {\n          this.popup.hide();\n          this.body.emitter.emit(\"hidePopup\");\n        }\n      }\n    }\n    /**\n     * Check if the popup must be hidden, which is the case when the mouse is no\n     * longer hovering on the object\n     *\n     * @param {{x:number, y:number}} pointer\n     * @private\n     */\n\n  }, {\n    key: \"_checkHidePopup\",\n    value: function _checkHidePopup(pointer) {\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n\n      var stillOnObj = false;\n\n      if (this.popup.popupTargetType === \"node\") {\n        if (this.body.nodes[this.popup.popupTargetId] !== undefined) {\n          stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj); // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.\n          // we initially only check stillOnObj because this is much faster.\n\n          if (stillOnObj === true) {\n            var overNode = this.selectionHandler.getNodeAt(pointer);\n            stillOnObj = overNode === undefined ? false : overNode.id === this.popup.popupTargetId;\n          }\n        }\n      } else {\n        if (this.selectionHandler.getNodeAt(pointer) === undefined) {\n          if (this.body.edges[this.popup.popupTargetId] !== undefined) {\n            stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);\n          }\n        }\n      }\n\n      if (stillOnObj === false) {\n        this.popupObj = undefined;\n        this.popup.hide();\n        this.body.emitter.emit(\"hidePopup\");\n      }\n    }\n  }]);\n  return InteractionHandler;\n}();\n\nvar getWeakData = internalMetadata.getWeakData;\nvar setInternalState$5 = internalState.set;\nvar internalStateGetterFor$2 = internalState.getterFor;\nvar find = arrayIteration.find;\nvar findIndex = arrayIteration.findIndex;\nvar id$1 = 0; // fallback for uncaught frozen keys\n\nvar uncaughtFrozenStore = function (store) {\n  return store.frozen || (store.frozen = new UncaughtFrozenStore());\n};\n\nvar UncaughtFrozenStore = function () {\n  this.entries = [];\n};\n\nvar findUncaughtFrozen = function (store, key) {\n  return find(store.entries, function (it) {\n    return it[0] === key;\n  });\n};\n\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;else this.entries.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = findIndex(this.entries, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.entries.splice(index, 1);\n    return !!~index;\n  }\n};\nvar collectionWeak = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, CONSTRUCTOR_NAME);\n      setInternalState$5(that, {\n        type: CONSTRUCTOR_NAME,\n        id: id$1++,\n        frozen: undefined\n      });\n      if (iterable != undefined) iterate(iterable, that[ADDER], {\n        that: that,\n        AS_ENTRIES: IS_MAP\n      });\n    });\n    var getInternalState = internalStateGetterFor$2(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var data = getWeakData(anObject(key), true);\n      if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;\n      return that;\n    };\n\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        var state = getInternalState(this);\n        if (!isObject(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state)['delete'](key);\n        return data && has(data, state.id) && delete data[state.id];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has$1(key) {\n        var state = getInternalState(this);\n        if (!isObject(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state).has(key);\n        return data && has(data, state.id);\n      }\n    });\n    redefineAll(C.prototype, IS_MAP ? {\n      // 23.3.3.3 WeakMap.prototype.get(key)\n      get: function get(key) {\n        var state = getInternalState(this);\n\n        if (isObject(key)) {\n          var data = getWeakData(key);\n          if (data === true) return uncaughtFrozenStore(state).get(key);\n          return data ? data[state.id] : undefined;\n        }\n      },\n      // 23.3.3.5 WeakMap.prototype.set(key, value)\n      set: function set(key, value) {\n        return define(this, key, value);\n      }\n    } : {\n      // 23.4.3.1 WeakSet.prototype.add(value)\n      add: function add(value) {\n        return define(this, value, true);\n      }\n    });\n    return C;\n  }\n};\nvar es_weakMap = createCommonjsModule(function (module) {\n  var enforceIternalState = internalState.enforce;\n  var IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;\n  var isExtensible = Object.isExtensible;\n  var InternalWeakMap;\n\n  var wrapper = function (init) {\n    return function WeakMap() {\n      return init(this, arguments.length ? arguments[0] : undefined);\n    };\n  }; // `WeakMap` constructor\n  // https://tc39.github.io/ecma262/#sec-weakmap-constructor\n\n\n  var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak); // IE11 WeakMap frozen keys fix\n  // We can't use feature detection because it crash some old IE builds\n  // https://github.com/zloirock/core-js/issues/485\n\n  if (nativeWeakMap && IS_IE11) {\n    InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);\n    internalMetadata.REQUIRED = true;\n    var WeakMapPrototype = $WeakMap.prototype;\n    var nativeDelete = WeakMapPrototype['delete'];\n    var nativeHas = WeakMapPrototype.has;\n    var nativeGet = WeakMapPrototype.get;\n    var nativeSet = WeakMapPrototype.set;\n    redefineAll(WeakMapPrototype, {\n      'delete': function (key) {\n        if (isObject(key) && !isExtensible(key)) {\n          var state = enforceIternalState(this);\n          if (!state.frozen) state.frozen = new InternalWeakMap();\n          return nativeDelete.call(this, key) || state.frozen['delete'](key);\n        }\n\n        return nativeDelete.call(this, key);\n      },\n      has: function has(key) {\n        if (isObject(key) && !isExtensible(key)) {\n          var state = enforceIternalState(this);\n          if (!state.frozen) state.frozen = new InternalWeakMap();\n          return nativeHas.call(this, key) || state.frozen.has(key);\n        }\n\n        return nativeHas.call(this, key);\n      },\n      get: function get(key) {\n        if (isObject(key) && !isExtensible(key)) {\n          var state = enforceIternalState(this);\n          if (!state.frozen) state.frozen = new InternalWeakMap();\n          return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);\n        }\n\n        return nativeGet.call(this, key);\n      },\n      set: function set(key, value) {\n        if (isObject(key) && !isExtensible(key)) {\n          var state = enforceIternalState(this);\n          if (!state.frozen) state.frozen = new InternalWeakMap();\n          nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);\n        } else nativeSet.call(this, key, value);\n\n        return this;\n      }\n    });\n  }\n});\nvar weakMap = path.WeakMap;\nvar weakMap$1 = weakMap;\nvar weakMap$2 = weakMap$1; // https://tc39.github.io/ecma262/#sec-set-objects\n\nvar es_set = collection('Set', function (init) {\n  return function Set() {\n    return init(this, arguments.length ? arguments[0] : undefined);\n  };\n}, collectionStrong);\nvar set$1 = path.Set;\nvar set$2 = set$1;\nvar set$3 = set$2;\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __classPrivateFieldGet(receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n}\n\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$5(o, minLen) {\n  var _context2;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$5(o, minLen);\n  var n = slice$5(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from_1$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);\n}\n\nfunction _arrayLikeToArray$5(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar _previousSelection, _selection, _nodes, _edges, _commitHandler;\n/**\r\n * @param prev\r\n * @param next\r\n */\n\n\nfunction diffSets(prev, next) {\n  var diff = new set$3();\n\n  var _iterator = _createForOfIteratorHelper$4(next),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n\n      if (!prev.has(item)) {\n        diff.add(item);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return diff;\n}\n\nvar SingleTypeSelectionAccumulator = /*#__PURE__*/function () {\n  function SingleTypeSelectionAccumulator() {\n    classCallCheck(this, SingleTypeSelectionAccumulator);\n\n    _previousSelection.set(this, new set$3());\n\n    _selection.set(this, new set$3());\n  }\n\n  createClass(SingleTypeSelectionAccumulator, [{\n    key: \"add\",\n    value: function add() {\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _items = items; _i < _items.length; _i++) {\n        var item = _items[_i];\n\n        __classPrivateFieldGet(this, _selection).add(item);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      for (var _i2 = 0, _items2 = items; _i2 < _items2.length; _i2++) {\n        var item = _items2[_i2];\n\n        __classPrivateFieldGet(this, _selection).delete(item);\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      __classPrivateFieldGet(this, _selection).clear();\n    }\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      return toConsumableArray(__classPrivateFieldGet(this, _selection));\n    }\n  }, {\n    key: \"getChanges\",\n    value: function getChanges() {\n      return {\n        added: toConsumableArray(diffSets(__classPrivateFieldGet(this, _previousSelection), __classPrivateFieldGet(this, _selection))),\n        deleted: toConsumableArray(diffSets(__classPrivateFieldGet(this, _selection), __classPrivateFieldGet(this, _previousSelection))),\n        previous: toConsumableArray(new set$3(__classPrivateFieldGet(this, _previousSelection))),\n        current: toConsumableArray(new set$3(__classPrivateFieldGet(this, _selection)))\n      };\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var changes = this.getChanges();\n\n      __classPrivateFieldSet(this, _previousSelection, __classPrivateFieldGet(this, _selection));\n\n      __classPrivateFieldSet(this, _selection, new set$3(__classPrivateFieldGet(this, _previousSelection)));\n\n      var _iterator2 = _createForOfIteratorHelper$4(changes.added),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          item.select();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper$4(changes.deleted),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _item = _step3.value;\n\n          _item.unselect();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return changes;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _selection).size;\n    }\n  }]);\n  return SingleTypeSelectionAccumulator;\n}();\n\n_previousSelection = new weakMap$2(), _selection = new weakMap$2();\n\nvar SelectionAccumulator = /*#__PURE__*/function () {\n  function SelectionAccumulator() {\n    var commitHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n    classCallCheck(this, SelectionAccumulator);\n\n    _nodes.set(this, new SingleTypeSelectionAccumulator());\n\n    _edges.set(this, new SingleTypeSelectionAccumulator());\n\n    _commitHandler.set(this, void 0);\n\n    __classPrivateFieldSet(this, _commitHandler, commitHandler);\n  }\n\n  createClass(SelectionAccumulator, [{\n    key: \"getNodes\",\n    value: function getNodes() {\n      return __classPrivateFieldGet(this, _nodes).getSelection();\n    }\n  }, {\n    key: \"getEdges\",\n    value: function getEdges() {\n      return __classPrivateFieldGet(this, _edges).getSelection();\n    }\n  }, {\n    key: \"addNodes\",\n    value: function addNodes() {\n      var _classPrivateFieldGe;\n\n      (_classPrivateFieldGe = __classPrivateFieldGet(this, _nodes)).add.apply(_classPrivateFieldGe, arguments);\n    }\n  }, {\n    key: \"addEdges\",\n    value: function addEdges() {\n      var _classPrivateFieldGe2;\n\n      (_classPrivateFieldGe2 = __classPrivateFieldGet(this, _edges)).add.apply(_classPrivateFieldGe2, arguments);\n    }\n  }, {\n    key: \"deleteNodes\",\n    value: function deleteNodes(node) {\n      __classPrivateFieldGet(this, _nodes).delete(node);\n    }\n  }, {\n    key: \"deleteEdges\",\n    value: function deleteEdges(edge) {\n      __classPrivateFieldGet(this, _edges).delete(edge);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      __classPrivateFieldGet(this, _nodes).clear();\n\n      __classPrivateFieldGet(this, _edges).clear();\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var _classPrivateFieldGe3, _context;\n\n      var summary = {\n        nodes: __classPrivateFieldGet(this, _nodes).commit(),\n        edges: __classPrivateFieldGet(this, _edges).commit()\n      };\n\n      for (var _len3 = arguments.length, rest = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        rest[_key3] = arguments[_key3];\n      }\n\n      (_classPrivateFieldGe3 = __classPrivateFieldGet(this, _commitHandler)).call.apply(_classPrivateFieldGe3, concat$2(_context = [this, summary]).call(_context, rest));\n\n      return summary;\n    }\n  }, {\n    key: \"sizeNodes\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _nodes).size;\n    }\n  }, {\n    key: \"sizeEdges\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _edges).size;\n    }\n  }]);\n  return SelectionAccumulator;\n}();\n\n_nodes = new weakMap$2(), _edges = new weakMap$2(), _commitHandler = new weakMap$2();\n\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$6(o, minLen) {\n  var _context3;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$6(o, minLen);\n  var n = slice$5(_context3 = Object.prototype.toString.call(o)).call(_context3, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from_1$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);\n}\n\nfunction _arrayLikeToArray$6(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * The handler for selections\n */\n\n\nvar SelectionHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function SelectionHandler(body, canvas) {\n    var _this = this;\n\n    classCallCheck(this, SelectionHandler);\n    this.body = body;\n    this.canvas = canvas;\n    this._selectionAccumulator = new SelectionAccumulator();\n    this.hoverObj = {\n      nodes: {},\n      edges: {}\n    };\n    this.options = {};\n    this.defaultOptions = {\n      multiselect: false,\n      selectable: true,\n      selectConnectedEdges: true,\n      hoverConnectedEdges: true\n    };\n    assign$2(this.options, this.defaultOptions);\n    this.body.emitter.on(\"_dataChanged\", function () {\n      _this.updateSelection();\n    });\n  }\n  /**\n   *\n   * @param {object} [options]\n   */\n\n\n  createClass(SelectionHandler, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        var fields = [\"multiselect\", \"hoverConnectedEdges\", \"selectable\", \"selectConnectedEdges\"];\n        selectiveDeepExtend(fields, this.options, options);\n      }\n    }\n    /**\n     * handles the selection part of the tap;\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"selectOnPoint\",\n    value: function selectOnPoint(pointer) {\n      var selected = false;\n\n      if (this.options.selectable === true) {\n        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer); // unselect after getting the objects in order to restore width and height.\n\n        this.unselectAll();\n\n        if (obj !== undefined) {\n          selected = this.selectObject(obj);\n        }\n\n        this.body.emitter.emit(\"_requestRedraw\");\n      }\n\n      return selected;\n    }\n    /**\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"selectAdditionalOnPoint\",\n    value: function selectAdditionalOnPoint(pointer) {\n      var selectionChanged = false;\n\n      if (this.options.selectable === true) {\n        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);\n\n        if (obj !== undefined) {\n          selectionChanged = true;\n\n          if (obj.isSelected() === true) {\n            this.deselectObject(obj);\n          } else {\n            this.selectObject(obj);\n          }\n\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n\n      return selectionChanged;\n    }\n    /**\n     * Create an object containing the standard fields for an event.\n     *\n     * @param {Event} event\n     * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse\n     * @returns {{}}\n     * @private\n     */\n\n  }, {\n    key: \"_initBaseEvent\",\n    value: function _initBaseEvent(event, pointer) {\n      var properties = {};\n      properties[\"pointer\"] = {\n        DOM: {\n          x: pointer.x,\n          y: pointer.y\n        },\n        canvas: this.canvas.DOMtoCanvas(pointer)\n      };\n      properties[\"event\"] = event;\n      return properties;\n    }\n    /**\n     * Generate an event which the user can catch.\n     *\n     * This adds some extra data to the event with respect to cursor position and\n     * selected nodes and edges.\n     *\n     * @param {string} eventType                          Name of event to send\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse\n     * @param {object | undefined} oldSelection             If present, selection state before event occured\n     * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed\n     */\n\n  }, {\n    key: \"generateClickEvent\",\n    value: function generateClickEvent(eventType, event, pointer, oldSelection) {\n      var emptySelection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n      var properties = this._initBaseEvent(event, pointer);\n\n      if (emptySelection === true) {\n        properties.nodes = [];\n        properties.edges = [];\n      } else {\n        var tmp = this.getSelection();\n        properties.nodes = tmp.nodes;\n        properties.edges = tmp.edges;\n      }\n\n      if (oldSelection !== undefined) {\n        properties[\"previousSelection\"] = oldSelection;\n      }\n\n      if (eventType == \"click\") {\n        // For the time being, restrict this functionality to\n        // just the click event.\n        properties.items = this.getClickedItems(pointer);\n      }\n\n      if (event.controlEdge !== undefined) {\n        properties.controlEdge = event.controlEdge;\n      }\n\n      this.body.emitter.emit(eventType, properties);\n    }\n    /**\n     *\n     * @param {object} obj\n     * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"selectObject\",\n    value: function selectObject(obj) {\n      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.selectConnectedEdges;\n\n      if (obj !== undefined) {\n        if (obj instanceof Node) {\n          if (highlightEdges === true) {\n            var _this$_selectionAccum;\n\n            (_this$_selectionAccum = this._selectionAccumulator).addEdges.apply(_this$_selectionAccum, toConsumableArray(obj.edges));\n          }\n\n          this._selectionAccumulator.addNodes(obj);\n        } else {\n          this._selectionAccumulator.addEdges(obj);\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     *\n     * @param {object} obj\n     */\n\n  }, {\n    key: \"deselectObject\",\n    value: function deselectObject(obj) {\n      if (obj.isSelected() === true) {\n        obj.selected = false;\n\n        this._removeFromSelection(obj);\n      }\n    }\n    /**\n     * retrieve all nodes overlapping with given object\n     *\n     * @param {object} object  An object with parameters left, top, right, bottom\n     * @returns {number[]}   An array with id's of the overlapping nodes\n     * @private\n     */\n\n  }, {\n    key: \"_getAllNodesOverlappingWith\",\n    value: function _getAllNodesOverlappingWith(object) {\n      var overlappingNodes = [];\n      var nodes = this.body.nodes;\n\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var nodeId = this.body.nodeIndices[i];\n\n        if (nodes[nodeId].isOverlappingWith(object)) {\n          overlappingNodes.push(nodeId);\n        }\n      }\n\n      return overlappingNodes;\n    }\n    /**\n     * Return a position object in canvasspace from a single point in screenspace\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {{left: number, top: number, right: number, bottom: number}}\n     * @private\n     */\n\n  }, {\n    key: \"_pointerToPositionObject\",\n    value: function _pointerToPositionObject(pointer) {\n      var canvasPos = this.canvas.DOMtoCanvas(pointer);\n      return {\n        left: canvasPos.x - 1,\n        top: canvasPos.y + 1,\n        right: canvasPos.x + 1,\n        bottom: canvasPos.y - 1\n      };\n    }\n    /**\n     * Get the top node at the passed point (like a click)\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [returnNode=true]\n     * @returns {Node | undefined} node\n     */\n\n  }, {\n    key: \"getNodeAt\",\n    value: function getNodeAt(pointer) {\n      var returnNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true; // we first check if this is an navigation controls element\n\n      var positionObject = this._pointerToPositionObject(pointer);\n\n      var overlappingNodes = this._getAllNodesOverlappingWith(positionObject); // if there are overlapping nodes, select the last one, this is the\n      // one which is drawn on top of the others\n\n\n      if (overlappingNodes.length > 0) {\n        if (returnNode === true) {\n          return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];\n        } else {\n          return overlappingNodes[overlappingNodes.length - 1];\n        }\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * retrieve all edges overlapping with given object, selector is around center\n     *\n     * @param {object} object  An object with parameters left, top, right, bottom\n     * @param {number[]} overlappingEdges An array with id's of the overlapping nodes\n     * @private\n     */\n\n  }, {\n    key: \"_getEdgesOverlappingWith\",\n    value: function _getEdgesOverlappingWith(object, overlappingEdges) {\n      var edges = this.body.edges;\n\n      for (var i = 0; i < this.body.edgeIndices.length; i++) {\n        var edgeId = this.body.edgeIndices[i];\n\n        if (edges[edgeId].isOverlappingWith(object)) {\n          overlappingEdges.push(edgeId);\n        }\n      }\n    }\n    /**\n     * retrieve all nodes overlapping with given object\n     *\n     * @param {object} object  An object with parameters left, top, right, bottom\n     * @returns {number[]}   An array with id's of the overlapping nodes\n     * @private\n     */\n\n  }, {\n    key: \"_getAllEdgesOverlappingWith\",\n    value: function _getAllEdgesOverlappingWith(object) {\n      var overlappingEdges = [];\n\n      this._getEdgesOverlappingWith(object, overlappingEdges);\n\n      return overlappingEdges;\n    }\n    /**\n     * Get the edges nearest to the passed point (like a click)\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [returnEdge=true]\n     * @returns {Edge | undefined} node\n     */\n\n  }, {\n    key: \"getEdgeAt\",\n    value: function getEdgeAt(pointer) {\n      var returnEdge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true; // Iterate over edges, pick closest within 10\n\n      var canvasPos = this.canvas.DOMtoCanvas(pointer);\n      var mindist = 10;\n      var overlappingEdge = null;\n      var edges = this.body.edges;\n\n      for (var i = 0; i < this.body.edgeIndices.length; i++) {\n        var edgeId = this.body.edgeIndices[i];\n        var edge = edges[edgeId];\n\n        if (edge.connected) {\n          var xFrom = edge.from.x;\n          var yFrom = edge.from.y;\n          var xTo = edge.to.x;\n          var yTo = edge.to.y;\n          var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);\n\n          if (dist < mindist) {\n            overlappingEdge = edgeId;\n            mindist = dist;\n          }\n        }\n      }\n\n      if (overlappingEdge !== null) {\n        if (returnEdge === true) {\n          return this.body.edges[overlappingEdge];\n        } else {\n          return overlappingEdge;\n        }\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Add object to the selection array.\n     *\n     * @param {object} obj\n     * @private\n     */\n\n  }, {\n    key: \"_addToHover\",\n    value: function _addToHover(obj) {\n      if (obj instanceof Node) {\n        this.hoverObj.nodes[obj.id] = obj;\n      } else {\n        this.hoverObj.edges[obj.id] = obj;\n      }\n    }\n    /**\n     * Remove a single option from selection.\n     *\n     * @param {object} obj\n     * @private\n     */\n\n  }, {\n    key: \"_removeFromSelection\",\n    value: function _removeFromSelection(obj) {\n      if (obj instanceof Node) {\n        var _this$_selectionAccum2;\n\n        this._selectionAccumulator.deleteNodes(obj);\n\n        (_this$_selectionAccum2 = this._selectionAccumulator).deleteEdges.apply(_this$_selectionAccum2, toConsumableArray(obj.edges));\n      } else {\n        this._selectionAccumulator.deleteEdges(obj);\n      }\n    }\n    /**\n     * Unselect all nodes and edges.\n     */\n\n  }, {\n    key: \"unselectAll\",\n    value: function unselectAll() {\n      this._selectionAccumulator.clear();\n\n      this._selectionAccumulator.commit();\n    }\n    /**\n     * return the number of selected nodes\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getSelectedNodeCount\",\n    value: function getSelectedNodeCount() {\n      return this._selectionAccumulator.sizeNodes;\n    }\n    /**\n     * return the number of selected edges\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getSelectedEdgeCount\",\n    value: function getSelectedEdgeCount() {\n      return this._selectionAccumulator.sizeEdges;\n    }\n    /**\n     * select the edges connected to the node that is being selected\n     *\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: \"_hoverConnectedEdges\",\n    value: function _hoverConnectedEdges(node) {\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        edge.hover = true;\n\n        this._addToHover(edge);\n      }\n    }\n    /**\n     * Remove the highlight from a node or edge, in response to mouse movement\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse\n     * @param {Node|vis.Edge} object\n     * @private\n     */\n\n  }, {\n    key: \"emitBlurEvent\",\n    value: function emitBlurEvent(event, pointer, object) {\n      var properties = this._initBaseEvent(event, pointer);\n\n      if (object.hover === true) {\n        object.hover = false;\n\n        if (object instanceof Node) {\n          properties.node = object.id;\n          this.body.emitter.emit(\"blurNode\", properties);\n        } else {\n          properties.edge = object.id;\n          this.body.emitter.emit(\"blurEdge\", properties);\n        }\n      }\n    }\n    /**\n     * Create the highlight for a node or edge, in response to mouse movement\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse\n     * @param {Node|vis.Edge} object\n     * @returns {boolean} hoverChanged\n     * @private\n     */\n\n  }, {\n    key: \"emitHoverEvent\",\n    value: function emitHoverEvent(event, pointer, object) {\n      var properties = this._initBaseEvent(event, pointer);\n\n      var hoverChanged = false;\n\n      if (object.hover === false) {\n        object.hover = true;\n\n        this._addToHover(object);\n\n        hoverChanged = true;\n\n        if (object instanceof Node) {\n          properties.node = object.id;\n          this.body.emitter.emit(\"hoverNode\", properties);\n        } else {\n          properties.edge = object.id;\n          this.body.emitter.emit(\"hoverEdge\", properties);\n        }\n      }\n\n      return hoverChanged;\n    }\n    /**\n     * Perform actions in response to a mouse movement.\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse\n     */\n\n  }, {\n    key: \"hoverObject\",\n    value: function hoverObject(event, pointer) {\n      var object = this.getNodeAt(pointer);\n\n      if (object === undefined) {\n        object = this.getEdgeAt(pointer);\n      }\n\n      var hoverChanged = false; // remove all node hover highlights\n\n      for (var nodeId in this.hoverObj.nodes) {\n        if (Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, nodeId)) {\n          if (object === undefined || object instanceof Node && object.id != nodeId || object instanceof Edge) {\n            this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);\n            delete this.hoverObj.nodes[nodeId];\n            hoverChanged = true;\n          }\n        }\n      } // removing all edge hover highlights\n\n\n      for (var edgeId in this.hoverObj.edges) {\n        if (Object.prototype.hasOwnProperty.call(this.hoverObj.edges, edgeId)) {\n          // if the hover has been changed here it means that the node has been hovered over or off\n          // we then do not use the emitBlurEvent method here.\n          if (hoverChanged === true) {\n            this.hoverObj.edges[edgeId].hover = false;\n            delete this.hoverObj.edges[edgeId];\n          } // if the blur remains the same and the object is undefined (mouse off) or another\n          // edge has been hovered, or another node has been hovered we blur the edge.\n          else if (object === undefined || object instanceof Edge && object.id != edgeId || object instanceof Node && !object.hover) {\n            this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);\n            delete this.hoverObj.edges[edgeId];\n            hoverChanged = true;\n          }\n        }\n      }\n\n      if (object !== undefined) {\n        var hoveredEdgesCount = keys$3(this.hoverObj.edges).length;\n        var hoveredNodesCount = keys$3(this.hoverObj.nodes).length;\n        var newOnlyHoveredEdge = object instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;\n        var newOnlyHoveredNode = object instanceof Node && hoveredEdgesCount === 0 && hoveredNodesCount === 0;\n\n        if (hoverChanged || newOnlyHoveredEdge || newOnlyHoveredNode) {\n          hoverChanged = this.emitHoverEvent(event, pointer, object);\n        }\n\n        if (object instanceof Node && this.options.hoverConnectedEdges === true) {\n          this._hoverConnectedEdges(object);\n        }\n      }\n\n      if (hoverChanged === true) {\n        this.body.emitter.emit(\"_requestRedraw\");\n      }\n    }\n    /**\n     * Select and deselect nodes depending current selection change.\n     *\n     * For changing nodes, select/deselect events are fired.\n     *\n     * NOTE: For a given edge, if one connecting node is deselected and with the\n     * same click the other node is selected, no events for the edge will fire. It\n     * was selected and it will remain selected.\n     *\n     * @param {{x: number, y: number}} pointer - The x and y coordinates of the\n     * click, tap, dragend… that triggered this.\n     * @param {UIEvent} event - The event that triggered this.\n     */\n\n  }, {\n    key: \"commitAndEmit\",\n    value: function commitAndEmit(pointer, event) {\n      var selected = false;\n\n      var selectionChanges = this._selectionAccumulator.commit();\n\n      var previousSelection = {\n        nodes: selectionChanges.nodes.previous,\n        edges: selectionChanges.edges.previous\n      };\n\n      if (selectionChanges.edges.deleted.length > 0) {\n        this.generateClickEvent(\"deselectEdge\", event, pointer, previousSelection);\n        selected = true;\n      }\n\n      if (selectionChanges.nodes.deleted.length > 0) {\n        this.generateClickEvent(\"deselectNode\", event, pointer, previousSelection);\n        selected = true;\n      }\n\n      if (selectionChanges.nodes.added.length > 0) {\n        this.generateClickEvent(\"selectNode\", event, pointer);\n        selected = true;\n      }\n\n      if (selectionChanges.edges.added.length > 0) {\n        this.generateClickEvent(\"selectEdge\", event, pointer);\n        selected = true;\n      } // fire the select event if anything has been selected or deselected\n\n\n      if (selected === true) {\n        // select or unselect\n        this.generateClickEvent(\"select\", event, pointer);\n      }\n    }\n    /**\n     * Retrieve the currently selected node and edge ids.\n     *\n     * @returns {{nodes: Array.<string>, edges: Array.<string>}} Arrays with the\n     * ids of the selected nodes and edges.\n     */\n\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      return {\n        nodes: this.getSelectedNodeIds(),\n        edges: this.getSelectedEdgeIds()\n      };\n    }\n    /**\n     * Retrieve the currently selected nodes.\n     *\n     * @returns {Array} An array with selected nodes.\n     */\n\n  }, {\n    key: \"getSelectedNodes\",\n    value: function getSelectedNodes() {\n      return this._selectionAccumulator.getNodes();\n    }\n    /**\n     * Retrieve the currently selected edges.\n     *\n     * @returns {Array} An array with selected edges.\n     */\n\n  }, {\n    key: \"getSelectedEdges\",\n    value: function getSelectedEdges() {\n      return this._selectionAccumulator.getEdges();\n    }\n    /**\n     * Retrieve the currently selected node ids.\n     *\n     * @returns {Array} An array with the ids of the selected nodes.\n     */\n\n  }, {\n    key: \"getSelectedNodeIds\",\n    value: function getSelectedNodeIds() {\n      var _context;\n\n      return map$2(_context = this._selectionAccumulator.getNodes()).call(_context, function (node) {\n        return node.id;\n      });\n    }\n    /**\n     * Retrieve the currently selected edge ids.\n     *\n     * @returns {Array} An array with the ids of the selected edges.\n     */\n\n  }, {\n    key: \"getSelectedEdgeIds\",\n    value: function getSelectedEdgeIds() {\n      var _context2;\n\n      return map$2(_context2 = this._selectionAccumulator.getEdges()).call(_context2, function (edge) {\n        return edge.id;\n      });\n    }\n    /**\n     * Updates the current selection\n     *\n     * @param {{nodes: Array.<string>, edges: Array.<string>}} selection\n     * @param {object} options                                 Options\n     */\n\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selection) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!selection || !selection.nodes && !selection.edges) {\n        throw new TypeError(\"Selection must be an object with nodes and/or edges properties\");\n      } // first unselect any selected node, if option is true or undefined\n\n\n      if (options.unselectAll || options.unselectAll === undefined) {\n        this.unselectAll();\n      }\n\n      if (selection.nodes) {\n        var _iterator = _createForOfIteratorHelper$5(selection.nodes),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var id = _step.value;\n            var node = this.body.nodes[id];\n\n            if (!node) {\n              throw new RangeError('Node with id \"' + id + '\" not found');\n            } // don't select edges with it\n\n\n            this.selectObject(node, options.highlightEdges);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (selection.edges) {\n        var _iterator2 = _createForOfIteratorHelper$5(selection.edges),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _id = _step2.value;\n            var edge = this.body.edges[_id];\n\n            if (!edge) {\n              throw new RangeError('Edge with id \"' + _id + '\" not found');\n            }\n\n            this.selectObject(edge);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      this.body.emitter.emit(\"_requestRedraw\");\n\n      this._selectionAccumulator.commit();\n    }\n    /**\n     * select zero or more nodes with the option to highlight edges\n     *\n     * @param {number[] | string[]} selection     An array with the ids of the\n     *                                            selected nodes.\n     * @param {boolean} [highlightEdges]\n     */\n\n  }, {\n    key: \"selectNodes\",\n    value: function selectNodes(selection) {\n      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (!selection || selection.length === undefined) throw \"Selection must be an array with ids\";\n      this.setSelection({\n        nodes: selection\n      }, {\n        highlightEdges: highlightEdges\n      });\n    }\n    /**\n     * select zero or more edges\n     *\n     * @param {number[] | string[]} selection     An array with the ids of the\n     *                                            selected nodes.\n     */\n\n  }, {\n    key: \"selectEdges\",\n    value: function selectEdges(selection) {\n      if (!selection || selection.length === undefined) throw \"Selection must be an array with ids\";\n      this.setSelection({\n        edges: selection\n      });\n    }\n    /**\n     * Validate the selection: remove ids of nodes which no longer exist\n     *\n     * @private\n     */\n\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection() {\n      for (var node in this._selectionAccumulator.getNodes()) {\n        if (!Object.prototype.hasOwnProperty.call(this.body.nodes, node.id)) {\n          this._selectionAccumulator.deleteNodes(node);\n        }\n      }\n\n      for (var edge in this._selectionAccumulator.getEdges()) {\n        if (!Object.prototype.hasOwnProperty.call(this.body.edges, edge.id)) {\n          this._selectionAccumulator.deleteEdges(edge);\n        }\n      }\n    }\n    /**\n     * Determine all the visual elements clicked which are on the given point.\n     *\n     * All elements are returned; this includes nodes, edges and their labels.\n     * The order returned is from highest to lowest, i.e. element 0 of the return\n     * value is the topmost item clicked on.\n     *\n     * The return value consists of an array of the following possible elements:\n     *\n     * - `{nodeId:number}`             - node with given id clicked on\n     * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on\n     * - `{edgeId:number}`             - edge with given id clicked on\n     * - `{edge:number, labelId:0}`    - label of edge with given id clicked on\n     *\n     * ## NOTES\n     *\n     * - Currently, there is only one label associated with a node or an edge,\n     *   but this is expected to change somewhere in the future.\n     * - Since there is no z-indexing yet, it is not really possible to set the nodes and\n     *   edges in the correct order. For the time being, nodes come first.\n     *\n     * @param {point} pointer  mouse position in screen coordinates\n     * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}\n     * @private\n     */\n\n  }, {\n    key: \"getClickedItems\",\n    value: function getClickedItems(pointer) {\n      var point = this.canvas.DOMtoCanvas(pointer);\n      var items = []; // Note reverse order; we want the topmost clicked items to be first in the array\n      // Also note that selected nodes are disregarded here; these normally display on top\n\n      var nodeIndices = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n\n      for (var i = nodeIndices.length - 1; i >= 0; i--) {\n        var node = nodes[nodeIndices[i]];\n        var ret = node.getItemsOnPoint(point);\n        items.push.apply(items, ret); // Append the return value to the running list.\n      }\n\n      var edgeIndices = this.body.edgeIndices;\n      var edges = this.body.edges;\n\n      for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {\n        var edge = edges[edgeIndices[_i]];\n\n        var _ret = edge.getItemsOnPoint(point);\n\n        items.push.apply(items, _ret); // Append the return value to the running list.\n      }\n\n      return items;\n    }\n  }]);\n  return SelectionHandler;\n}();\n\nvar createMethod$5 = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aFunction(callbackfn);\n    var O = toObject(that);\n    var self = indexedObject(O);\n    var length = toLength(O.length);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n\n      index += i;\n\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw TypeError('Reduce of empty array with no initial value');\n      }\n    }\n\n    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n\n    return memo;\n  };\n};\n\nvar arrayReduce = {\n  // `Array.prototype.reduce` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n  left: createMethod$5(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright\n  right: createMethod$5(true)\n};\nvar engineIsNode = classofRaw(global_1.process) == 'process';\nvar $reduce = arrayReduce.left;\nvar STRICT_METHOD$3 = arrayMethodIsStrict('reduce');\nvar USES_TO_LENGTH$8 = arrayMethodUsesToLength('reduce', {\n  1: 0\n}); // Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\n\nvar CHROME_BUG = !engineIsNode && engineV8Version > 79 && engineV8Version < 83; // `Array.prototype.reduce` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !STRICT_METHOD$3 || !USES_TO_LENGTH$8 || CHROME_BUG\n}, {\n  reduce: function reduce(callbackfn\n  /* , initialValue */\n  ) {\n    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar reduce = entryVirtual('Array').reduce;\nvar ArrayPrototype$d = Array.prototype;\n\nvar reduce_1 = function (it) {\n  var own = it.reduce;\n  return it === ArrayPrototype$d || it instanceof Array && own === ArrayPrototype$d.reduce ? reduce : own;\n};\n\nvar reduce$1 = reduce_1;\nvar reduce$2 = reduce$1;\nvar test$2 = [];\nvar nativeSort = test$2.sort; // IE8-\n\nvar FAILS_ON_UNDEFINED = fails(function () {\n  test$2.sort(undefined);\n}); // V8 bug\n\nvar FAILS_ON_NULL = fails(function () {\n  test$2.sort(null);\n}); // Old WebKit\n\nvar STRICT_METHOD$4 = arrayMethodIsStrict('sort');\nvar FORCED$6 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$4; // `Array.prototype.sort` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.sort\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: FORCED$6\n}, {\n  sort: function sort(comparefn) {\n    return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction(comparefn));\n  }\n});\n\nvar sort = entryVirtual('Array').sort;\nvar ArrayPrototype$e = Array.prototype;\n\nvar sort_1 = function (it) {\n  var own = it.sort;\n  return it === ArrayPrototype$e || it instanceof Array && own === ArrayPrototype$e.sort ? sort : own;\n};\n\nvar sort$1 = sort_1;\nvar sort$2 = sort$1;\nvar timsort = createCommonjsModule(function (module, exports) {\n  /****\n   * The MIT License\n   *\n   * Copyright (c) 2015 Marco Ziccardi\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   * THE SOFTWARE.\n   *\n   ****/\n  (function (global, factory) {\n    {\n      factory(exports);\n    }\n  })(commonjsGlobal, function (exports) {\n    exports.__esModule = true;\n    exports.sort = sort;\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError('Cannot call a class as a function');\n      }\n    }\n\n    var DEFAULT_MIN_MERGE = 32;\n    var DEFAULT_MIN_GALLOPING = 7;\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n    var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];\n\n    function log10(x) {\n      if (x < 1e5) {\n        if (x < 1e2) {\n          return x < 1e1 ? 0 : 1;\n        }\n\n        if (x < 1e4) {\n          return x < 1e3 ? 2 : 3;\n        }\n\n        return 4;\n      }\n\n      if (x < 1e7) {\n        return x < 1e6 ? 5 : 6;\n      }\n\n      if (x < 1e9) {\n        return x < 1e8 ? 7 : 8;\n      }\n\n      return 9;\n    }\n\n    function alphabeticalCompare(a, b) {\n      if (a === b) {\n        return 0;\n      }\n\n      if (~~a === a && ~~b === b) {\n        if (a === 0 || b === 0) {\n          return a < b ? -1 : 1;\n        }\n\n        if (a < 0 || b < 0) {\n          if (b >= 0) {\n            return -1;\n          }\n\n          if (a >= 0) {\n            return 1;\n          }\n\n          a = -a;\n          b = -b;\n        }\n\n        var al = log10(a);\n        var bl = log10(b);\n        var t = 0;\n\n        if (al < bl) {\n          a *= POWERS_OF_TEN[bl - al - 1];\n          b /= 10;\n          t = -1;\n        } else if (al > bl) {\n          b *= POWERS_OF_TEN[al - bl - 1];\n          a /= 10;\n          t = 1;\n        }\n\n        if (a === b) {\n          return t;\n        }\n\n        return a < b ? -1 : 1;\n      }\n\n      var aStr = String(a);\n      var bStr = String(b);\n\n      if (aStr === bStr) {\n        return 0;\n      }\n\n      return aStr < bStr ? -1 : 1;\n    }\n\n    function minRunLength(n) {\n      var r = 0;\n\n      while (n >= DEFAULT_MIN_MERGE) {\n        r |= n & 1;\n        n >>= 1;\n      }\n\n      return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n      var runHi = lo + 1;\n\n      if (runHi === hi) {\n        return 1;\n      }\n\n      if (compare(array[runHi++], array[lo]) < 0) {\n        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n          runHi++;\n        }\n\n        reverseRun(array, lo, runHi);\n      } else {\n        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n          runHi++;\n        }\n      }\n\n      return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n      hi--;\n\n      while (lo < hi) {\n        var t = array[lo];\n        array[lo++] = array[hi];\n        array[hi--] = t;\n      }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n      if (start === lo) {\n        start++;\n      }\n\n      for (; start < hi; start++) {\n        var pivot = array[start];\n        var left = lo;\n        var right = start;\n\n        while (left < right) {\n          var mid = left + right >>> 1;\n\n          if (compare(pivot, array[mid]) < 0) {\n            right = mid;\n          } else {\n            left = mid + 1;\n          }\n        }\n\n        var n = start - left;\n\n        switch (n) {\n          case 3:\n            array[left + 3] = array[left + 2];\n\n          case 2:\n            array[left + 2] = array[left + 1];\n\n          case 1:\n            array[left + 1] = array[left];\n            break;\n\n          default:\n            while (n > 0) {\n              array[left + n] = array[left + n - 1];\n              n--;\n            }\n\n        }\n\n        array[left] = pivot;\n      }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n      var lastOffset = 0;\n      var maxOffset = 0;\n      var offset = 1;\n\n      if (compare(value, array[start + hint]) > 0) {\n        maxOffset = length - hint;\n\n        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n          lastOffset = offset;\n          offset = (offset << 1) + 1;\n\n          if (offset <= 0) {\n            offset = maxOffset;\n          }\n        }\n\n        if (offset > maxOffset) {\n          offset = maxOffset;\n        }\n\n        lastOffset += hint;\n        offset += hint;\n      } else {\n        maxOffset = hint + 1;\n\n        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n          lastOffset = offset;\n          offset = (offset << 1) + 1;\n\n          if (offset <= 0) {\n            offset = maxOffset;\n          }\n        }\n\n        if (offset > maxOffset) {\n          offset = maxOffset;\n        }\n\n        var tmp = lastOffset;\n        lastOffset = hint - offset;\n        offset = hint - tmp;\n      }\n\n      lastOffset++;\n\n      while (lastOffset < offset) {\n        var m = lastOffset + (offset - lastOffset >>> 1);\n\n        if (compare(value, array[start + m]) > 0) {\n          lastOffset = m + 1;\n        } else {\n          offset = m;\n        }\n      }\n\n      return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n      var lastOffset = 0;\n      var maxOffset = 0;\n      var offset = 1;\n\n      if (compare(value, array[start + hint]) < 0) {\n        maxOffset = hint + 1;\n\n        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n          lastOffset = offset;\n          offset = (offset << 1) + 1;\n\n          if (offset <= 0) {\n            offset = maxOffset;\n          }\n        }\n\n        if (offset > maxOffset) {\n          offset = maxOffset;\n        }\n\n        var tmp = lastOffset;\n        lastOffset = hint - offset;\n        offset = hint - tmp;\n      } else {\n        maxOffset = length - hint;\n\n        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n          lastOffset = offset;\n          offset = (offset << 1) + 1;\n\n          if (offset <= 0) {\n            offset = maxOffset;\n          }\n        }\n\n        if (offset > maxOffset) {\n          offset = maxOffset;\n        }\n\n        lastOffset += hint;\n        offset += hint;\n      }\n\n      lastOffset++;\n\n      while (lastOffset < offset) {\n        var m = lastOffset + (offset - lastOffset >>> 1);\n\n        if (compare(value, array[start + m]) < 0) {\n          offset = m;\n        } else {\n          lastOffset = m + 1;\n        }\n      }\n\n      return offset;\n    }\n\n    var TimSort = function () {\n      function TimSort(array, compare) {\n        _classCallCheck(this, TimSort);\n\n        this.array = null;\n        this.compare = null;\n        this.minGallop = DEFAULT_MIN_GALLOPING;\n        this.length = 0;\n        this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        this.stackLength = 0;\n        this.runStart = null;\n        this.runLength = null;\n        this.stackSize = 0;\n        this.array = array;\n        this.compare = compare;\n        this.length = array.length;\n\n        if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n          this.tmpStorageLength = this.length >>> 1;\n        }\n\n        this.tmp = new Array(this.tmpStorageLength);\n        this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;\n        this.runStart = new Array(this.stackLength);\n        this.runLength = new Array(this.stackLength);\n      }\n\n      TimSort.prototype.pushRun = function pushRun(runStart, runLength) {\n        this.runStart[this.stackSize] = runStart;\n        this.runLength[this.stackSize] = runLength;\n        this.stackSize += 1;\n      };\n\n      TimSort.prototype.mergeRuns = function mergeRuns() {\n        while (this.stackSize > 1) {\n          var n = this.stackSize - 2;\n\n          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {\n            if (this.runLength[n - 1] < this.runLength[n + 1]) {\n              n--;\n            }\n          } else if (this.runLength[n] > this.runLength[n + 1]) {\n            break;\n          }\n\n          this.mergeAt(n);\n        }\n      };\n\n      TimSort.prototype.forceMergeRuns = function forceMergeRuns() {\n        while (this.stackSize > 1) {\n          var n = this.stackSize - 2;\n\n          if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {\n            n--;\n          }\n\n          this.mergeAt(n);\n        }\n      };\n\n      TimSort.prototype.mergeAt = function mergeAt(i) {\n        var compare = this.compare;\n        var array = this.array;\n        var start1 = this.runStart[i];\n        var length1 = this.runLength[i];\n        var start2 = this.runStart[i + 1];\n        var length2 = this.runLength[i + 1];\n        this.runLength[i] = length1 + length2;\n\n        if (i === this.stackSize - 3) {\n          this.runStart[i + 1] = this.runStart[i + 2];\n          this.runLength[i + 1] = this.runLength[i + 2];\n        }\n\n        this.stackSize--;\n        var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n        start1 += k;\n        length1 -= k;\n\n        if (length1 === 0) {\n          return;\n        }\n\n        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n        if (length2 === 0) {\n          return;\n        }\n\n        if (length1 <= length2) {\n          this.mergeLow(start1, length1, start2, length2);\n        } else {\n          this.mergeHigh(start1, length1, start2, length2);\n        }\n      };\n\n      TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {\n        var compare = this.compare;\n        var array = this.array;\n        var tmp = this.tmp;\n        var i = 0;\n\n        for (i = 0; i < length1; i++) {\n          tmp[i] = array[start1 + i];\n        }\n\n        var cursor1 = 0;\n        var cursor2 = start2;\n        var dest = start1;\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          for (i = 0; i < length1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          return;\n        }\n\n        if (length1 === 1) {\n          for (i = 0; i < length2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          array[dest + length2] = tmp[cursor1];\n          return;\n        }\n\n        var minGallop = this.minGallop;\n\n        while (true) {\n          var count1 = 0;\n          var count2 = 0;\n          var exit = false;\n\n          do {\n            if (compare(array[cursor2], tmp[cursor1]) < 0) {\n              array[dest++] = array[cursor2++];\n              count2++;\n              count1 = 0;\n\n              if (--length2 === 0) {\n                exit = true;\n                break;\n              }\n            } else {\n              array[dest++] = tmp[cursor1++];\n              count1++;\n              count2 = 0;\n\n              if (--length1 === 1) {\n                exit = true;\n                break;\n              }\n            }\n          } while ((count1 | count2) < minGallop);\n\n          if (exit) {\n            break;\n          }\n\n          do {\n            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n            if (count1 !== 0) {\n              for (i = 0; i < count1; i++) {\n                array[dest + i] = tmp[cursor1 + i];\n              }\n\n              dest += count1;\n              cursor1 += count1;\n              length1 -= count1;\n\n              if (length1 <= 1) {\n                exit = true;\n                break;\n              }\n            }\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n              exit = true;\n              break;\n            }\n\n            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n            if (count2 !== 0) {\n              for (i = 0; i < count2; i++) {\n                array[dest + i] = array[cursor2 + i];\n              }\n\n              dest += count2;\n              cursor2 += count2;\n              length2 -= count2;\n\n              if (length2 === 0) {\n                exit = true;\n                break;\n              }\n            }\n\n            array[dest++] = tmp[cursor1++];\n\n            if (--length1 === 1) {\n              exit = true;\n              break;\n            }\n\n            minGallop--;\n          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n          if (exit) {\n            break;\n          }\n\n          if (minGallop < 0) {\n            minGallop = 0;\n          }\n\n          minGallop += 2;\n        }\n\n        this.minGallop = minGallop;\n\n        if (minGallop < 1) {\n          this.minGallop = 1;\n        }\n\n        if (length1 === 1) {\n          for (i = 0; i < length2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          array[dest + length2] = tmp[cursor1];\n        } else if (length1 === 0) {\n          throw new Error('mergeLow preconditions were not respected');\n        } else {\n          for (i = 0; i < length1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n        }\n      };\n\n      TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {\n        var compare = this.compare;\n        var array = this.array;\n        var tmp = this.tmp;\n        var i = 0;\n\n        for (i = 0; i < length2; i++) {\n          tmp[i] = array[start2 + i];\n        }\n\n        var cursor1 = start1 + length1 - 1;\n        var cursor2 = length2 - 1;\n        var dest = start2 + length2 - 1;\n        var customCursor = 0;\n        var customDest = 0;\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          customCursor = dest - (length2 - 1);\n\n          for (i = 0; i < length2; i++) {\n            array[customCursor + i] = tmp[i];\n          }\n\n          return;\n        }\n\n        if (length2 === 1) {\n          dest -= length1;\n          cursor1 -= length1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = length1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          array[dest] = tmp[cursor2];\n          return;\n        }\n\n        var minGallop = this.minGallop;\n\n        while (true) {\n          var count1 = 0;\n          var count2 = 0;\n          var exit = false;\n\n          do {\n            if (compare(tmp[cursor2], array[cursor1]) < 0) {\n              array[dest--] = array[cursor1--];\n              count1++;\n              count2 = 0;\n\n              if (--length1 === 0) {\n                exit = true;\n                break;\n              }\n            } else {\n              array[dest--] = tmp[cursor2--];\n              count2++;\n              count1 = 0;\n\n              if (--length2 === 1) {\n                exit = true;\n                break;\n              }\n            }\n          } while ((count1 | count2) < minGallop);\n\n          if (exit) {\n            break;\n          }\n\n          do {\n            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n            if (count1 !== 0) {\n              dest -= count1;\n              cursor1 -= count1;\n              length1 -= count1;\n              customDest = dest + 1;\n              customCursor = cursor1 + 1;\n\n              for (i = count1 - 1; i >= 0; i--) {\n                array[customDest + i] = array[customCursor + i];\n              }\n\n              if (length1 === 0) {\n                exit = true;\n                break;\n              }\n            }\n\n            array[dest--] = tmp[cursor2--];\n\n            if (--length2 === 1) {\n              exit = true;\n              break;\n            }\n\n            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n            if (count2 !== 0) {\n              dest -= count2;\n              cursor2 -= count2;\n              length2 -= count2;\n              customDest = dest + 1;\n              customCursor = cursor2 + 1;\n\n              for (i = 0; i < count2; i++) {\n                array[customDest + i] = tmp[customCursor + i];\n              }\n\n              if (length2 <= 1) {\n                exit = true;\n                break;\n              }\n            }\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n              exit = true;\n              break;\n            }\n\n            minGallop--;\n          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n          if (exit) {\n            break;\n          }\n\n          if (minGallop < 0) {\n            minGallop = 0;\n          }\n\n          minGallop += 2;\n        }\n\n        this.minGallop = minGallop;\n\n        if (minGallop < 1) {\n          this.minGallop = 1;\n        }\n\n        if (length2 === 1) {\n          dest -= length1;\n          cursor1 -= length1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = length1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          array[dest] = tmp[cursor2];\n        } else if (length2 === 0) {\n          throw new Error('mergeHigh preconditions were not respected');\n        } else {\n          customCursor = dest - (length2 - 1);\n\n          for (i = 0; i < length2; i++) {\n            array[customCursor + i] = tmp[i];\n          }\n        }\n      };\n\n      return TimSort;\n    }();\n\n    function sort(array, compare, lo, hi) {\n      if (!Array.isArray(array)) {\n        throw new TypeError('Can only sort arrays');\n      }\n\n      if (!compare) {\n        compare = alphabeticalCompare;\n      } else if (typeof compare !== 'function') {\n        hi = lo;\n        lo = compare;\n        compare = alphabeticalCompare;\n      }\n\n      if (!lo) {\n        lo = 0;\n      }\n\n      if (!hi) {\n        hi = array.length;\n      }\n\n      var remaining = hi - lo;\n\n      if (remaining < 2) {\n        return;\n      }\n\n      var runLength = 0;\n\n      if (remaining < DEFAULT_MIN_MERGE) {\n        runLength = makeAscendingRun(array, lo, hi, compare);\n        binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n        return;\n      }\n\n      var ts = new TimSort(array, compare);\n      var minRun = minRunLength(remaining);\n\n      do {\n        runLength = makeAscendingRun(array, lo, hi, compare);\n\n        if (runLength < minRun) {\n          var force = remaining;\n\n          if (force > minRun) {\n            force = minRun;\n          }\n\n          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n          runLength = force;\n        }\n\n        ts.pushRun(lo, runLength);\n        ts.mergeRuns();\n        remaining -= runLength;\n        lo += runLength;\n      } while (remaining !== 0);\n\n      ts.forceMergeRuns();\n    }\n  });\n});\nvar timsort$1 = timsort;\n\nfunction _createSuper$s(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf$5(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf$5(this).constructor;\n      result = construct$3(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$s() {\n  if (typeof Reflect === \"undefined\" || !construct$3) return false;\n  if (construct$3.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(construct$3(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Interface definition for direction strategy classes.\n *\n * This class describes the interface for the Strategy\n * pattern classes used to differentiate horizontal and vertical\n * direction of hierarchical results.\n *\n * For a given direction, one coordinate will be 'fixed', meaning that it is\n * determined by level.\n * The other coordinate is 'unfixed', meaning that the nodes on a given level\n * can still move along that coordinate. So:\n *\n * - `vertical` layout: `x` unfixed, `y` fixed per level\n * - `horizontal` layout: `x` fixed per level, `y` unfixed\n *\n * The local methods are stubs and should be regarded as abstract.\n * Derived classes **must** implement all the methods themselves.\n *\n * @private\n */\n\n\nvar DirectionInterface = /*#__PURE__*/function () {\n  function DirectionInterface() {\n    classCallCheck(this, DirectionInterface);\n  }\n\n  createClass(DirectionInterface, [{\n    key: \"abstract\",\n\n    /**\n     * @ignore\n     */\n    value: function abstract() {\n      throw new Error(\"Can't instantiate abstract class!\");\n    }\n    /**\n     * This is a dummy call which is used to suppress the jsdoc errors of type:\n     *\n     *   \"'param' is assigned a value but never used\"\n     *\n     * @ignore\n     **/\n\n  }, {\n    key: \"fake_use\",\n    value: function fake_use() {// Do nothing special\n    }\n    /**\n     * Type to use to translate dynamic curves to, in the case of hierarchical layout.\n     * Dynamic curves do not work for these.\n     *\n     * The value should be perpendicular to the actual direction of the layout.\n     *\n     * @returns {string} Direction, either 'vertical' or 'horizontal'\n     */\n\n  }, {\n    key: \"curveType\",\n    value: function curveType() {\n      return this.abstract();\n    }\n    /**\n     * Return the value of the coordinate that is not fixed for this direction.\n     *\n     * @param {Node} node The node to read\n     * @returns {number} Value of the unfixed coordinate\n     */\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      this.fake_use(node);\n      return this.abstract();\n    }\n    /**\n     * Set the value of the coordinate that is not fixed for this direction.\n     *\n     * @param {Node} node The node to adjust\n     * @param {number} position\n     * @param {number} [level] if specified, the hierarchy level that this node should be fixed to\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      this.fake_use(node, position, level);\n      this.abstract();\n    }\n    /**\n     * Get the width of a tree.\n     *\n     * A `tree` here is a subset of nodes within the network which are not connected to other nodes,\n     * only among themselves. In essence, it is a sub-network.\n     *\n     * @param {number} index The index number of a tree\n     * @returns {number} the width of a tree in the view coordinates\n     */\n\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index) {\n      this.fake_use(index);\n      return this.abstract();\n    }\n    /**\n     * Sort array of nodes on the unfixed coordinates.\n     *\n     * **Note:** chrome has non-stable sorting implementation, which\n     * has a tendency to change the order of the array items,\n     * even if the custom sort function returns 0.\n     *\n     * For this reason, an external sort implementation is used,\n     * which has the added benefit of being faster than the standard\n     * platforms implementation. This has been verified on `node.js`,\n     * `firefox` and `chrome` (all linux).\n     *\n     * @param {Array.<Node>} nodeArray array of nodes to sort\n     */\n\n  }, {\n    key: \"sort\",\n    value: function sort(nodeArray) {\n      this.fake_use(nodeArray);\n      this.abstract();\n    }\n    /**\n     * Assign the fixed coordinate of the node to the given level\n     *\n     * @param {Node} node The node to adjust\n     * @param {number} level The level to fix to\n     */\n\n  }, {\n    key: \"fix\",\n    value: function fix(node, level) {\n      this.fake_use(node, level);\n      this.abstract();\n    }\n    /**\n     * Add an offset to the unfixed coordinate of the given node.\n     *\n     * @param {NodeId} nodeId Id of the node to adjust\n     * @param {number} diff Offset to add to the unfixed coordinate\n     */\n\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.fake_use(nodeId, diff);\n      this.abstract();\n    }\n  }]);\n  return DirectionInterface;\n}();\n/**\n * Vertical Strategy\n *\n * Coordinate `y` is fixed on levels, coordinate `x` is unfixed.\n *\n * @augments DirectionInterface\n * @private\n */\n\n\nvar VerticalStrategy = /*#__PURE__*/function (_DirectionInterface) {\n  inherits(VerticalStrategy, _DirectionInterface);\n\n  var _super = _createSuper$s(VerticalStrategy);\n  /**\n   * Constructor\n   *\n   * @param {object} layout reference to the parent LayoutEngine instance.\n   */\n\n\n  function VerticalStrategy(layout) {\n    var _this;\n\n    classCallCheck(this, VerticalStrategy);\n    _this = _super.call(this);\n    _this.layout = layout;\n    return _this;\n  }\n  /** @inheritDoc */\n\n\n  createClass(VerticalStrategy, [{\n    key: \"curveType\",\n    value: function curveType() {\n      return \"horizontal\";\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      return node.x;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      if (level !== undefined) {\n        this.layout.hierarchical.addToOrdering(node, level);\n      }\n\n      node.x = position;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index) {\n      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);\n      return {\n        min: res.min_x,\n        max: res.max_x\n      };\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"sort\",\n    value: function sort(nodeArray) {\n      timsort$1.sort(nodeArray, function (a, b) {\n        return a.x - b.x;\n      });\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"fix\",\n    value: function fix(node, level) {\n      node.y = this.layout.options.hierarchical.levelSeparation * level;\n      node.options.fixed.y = true;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.layout.body.nodes[nodeId].x += diff;\n    }\n  }]);\n  return VerticalStrategy;\n}(DirectionInterface);\n/**\n * Horizontal Strategy\n *\n * Coordinate `x` is fixed on levels, coordinate `y` is unfixed.\n *\n * @augments DirectionInterface\n * @private\n */\n\n\nvar HorizontalStrategy = /*#__PURE__*/function (_DirectionInterface2) {\n  inherits(HorizontalStrategy, _DirectionInterface2);\n\n  var _super2 = _createSuper$s(HorizontalStrategy);\n  /**\n   * Constructor\n   *\n   * @param {object} layout reference to the parent LayoutEngine instance.\n   */\n\n\n  function HorizontalStrategy(layout) {\n    var _this2;\n\n    classCallCheck(this, HorizontalStrategy);\n    _this2 = _super2.call(this);\n    _this2.layout = layout;\n    return _this2;\n  }\n  /** @inheritDoc */\n\n\n  createClass(HorizontalStrategy, [{\n    key: \"curveType\",\n    value: function curveType() {\n      return \"vertical\";\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      return node.y;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      if (level !== undefined) {\n        this.layout.hierarchical.addToOrdering(node, level);\n      }\n\n      node.y = position;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index) {\n      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);\n      return {\n        min: res.min_y,\n        max: res.max_y\n      };\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"sort\",\n    value: function sort(nodeArray) {\n      timsort$1.sort(nodeArray, function (a, b) {\n        return a.y - b.y;\n      });\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"fix\",\n    value: function fix(node, level) {\n      node.x = this.layout.options.hierarchical.levelSeparation * level;\n      node.options.fixed.x = true;\n    }\n    /** @inheritDoc */\n\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.layout.body.nodes[nodeId].y += diff;\n    }\n  }]);\n  return HorizontalStrategy;\n}(DirectionInterface);\n\nvar $every = arrayIteration.every;\nvar STRICT_METHOD$5 = arrayMethodIsStrict('every');\nvar USES_TO_LENGTH$9 = arrayMethodUsesToLength('every'); // `Array.prototype.every` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.every\n\n_export({\n  target: 'Array',\n  proto: true,\n  forced: !STRICT_METHOD$5 || !USES_TO_LENGTH$9\n}, {\n  every: function every(callbackfn\n  /* , thisArg */\n  ) {\n    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar every = entryVirtual('Array').every;\nvar ArrayPrototype$f = Array.prototype;\n\nvar every_1 = function (it) {\n  var own = it.every;\n  return it === ArrayPrototype$f || it instanceof Array && own === ArrayPrototype$f.every ? every : own;\n};\n\nvar every$1 = every_1;\nvar every$2 = every$1;\n\nfunction _createForOfIteratorHelper$6(o, allowArrayLike) {\n  var it;\n\n  if (typeof symbol$4 === \"undefined\" || getIteratorMethod$1(o) == null) {\n    if (isArray$5(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = getIterator$1(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$7(o, minLen) {\n  var _context9;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$7(o, minLen);\n  var n = slice$5(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return from_1$2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);\n}\n\nfunction _arrayLikeToArray$7(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\r\n * Try to assign levels to nodes according to their positions in the cyclic “hierarchy”.\r\n *\r\n * @param nodes - Visible nodes of the graph.\r\n * @param levels - If present levels will be added to it, if not a new object will be created.\r\n *\r\n * @returns Populated node levels.\r\n */\n\n\nfunction fillLevelsByDirectionCyclic(nodes, levels) {\n  var edges = new set$3();\n  forEach$2(nodes).call(nodes, function (node) {\n    var _context;\n\n    forEach$2(_context = node.edges).call(_context, function (edge) {\n      if (edge.connected) {\n        edges.add(edge);\n      }\n    });\n  });\n  forEach$2(edges).call(edges, function (edge) {\n    var fromId = edge.from.id;\n    var toId = edge.to.id;\n\n    if (levels[fromId] == null) {\n      levels[fromId] = 0;\n    }\n\n    if (levels[toId] == null || levels[fromId] >= levels[toId]) {\n      levels[toId] = levels[fromId] + 1;\n    }\n  });\n  return levels;\n}\n/**\r\n * Assign levels to nodes according to their positions in the hierarchy. Leaves will be lined up at the bottom and all other nodes as close to their children as possible.\r\n *\r\n * @param nodes - Visible nodes of the graph.\r\n *\r\n * @returns Populated node levels.\r\n */\n\n\nfunction fillLevelsByDirectionLeaves(nodes) {\n  return fillLevelsByDirection( // Pick only leaves (nodes without children).\n  function (node) {\n    var _context2, _context3;\n\n    return every$2(_context2 = filter$2(_context3 = node.edges // Take only visible nodes into account.\n    ).call(_context3, function (edge) {\n      return nodes.has(edge.toId);\n    }) // Check that all edges lead to this node (leaf).\n    ).call(_context2, function (edge) {\n      return edge.to === node;\n    });\n  }, // Use the lowest level.\n  function (newLevel, oldLevel) {\n    return oldLevel > newLevel;\n  }, // Go against the direction of the edges.\n  \"from\", nodes);\n}\n/**\r\n * Assign levels to nodes according to their positions in the hierarchy. Roots will be lined up at the top and all nodes as close to their parents as possible.\r\n *\r\n * @param nodes - Visible nodes of the graph.\r\n *\r\n * @returns Populated node levels.\r\n */\n\n\nfunction fillLevelsByDirectionRoots(nodes) {\n  return fillLevelsByDirection( // Pick only roots (nodes without parents).\n  function (node) {\n    var _context4, _context5;\n\n    return every$2(_context4 = filter$2(_context5 = node.edges // Take only visible nodes into account.\n    ).call(_context5, function (edge) {\n      return nodes.has(edge.toId);\n    }) // Check that all edges lead from this node (root).\n    ).call(_context4, function (edge) {\n      return edge.from === node;\n    });\n  }, // Use the highest level.\n  function (newLevel, oldLevel) {\n    return oldLevel < newLevel;\n  }, // Go in the direction of the edges.\n  \"to\", nodes);\n}\n/**\r\n * Assign levels to nodes according to their positions in the hierarchy.\r\n *\r\n * @param isEntryNode - Checks and return true if the graph should be traversed from this node.\r\n * @param shouldLevelBeReplaced - Checks and returns true if the level of given node should be updated to the new value.\r\n * @param direction - Wheter the graph should be traversed in the direction of the edges `\"to\"` or in the other way `\"from\"`.\r\n * @param nodes - Visible nodes of the graph.\r\n *\r\n * @returns Populated node levels.\r\n */\n\n\nfunction fillLevelsByDirection(isEntryNode, shouldLevelBeReplaced, direction, nodes) {\n  var _context6;\n\n  var levels = create$2(null); // If acyclic, the graph can be walked through with (most likely way) fewer\n  // steps than the number bellow. The exact value isn't too important as long\n  // as it's quick to compute (doesn't impact acyclic graphs too much), is\n  // higher than the number of steps actually needed (doesn't cut off before\n  // acyclic graph is walked through) and prevents infinite loops (cuts off for\n  // cyclic graphs).\n\n  var limit = reduce$2(_context6 = toConsumableArray(values$3(nodes).call(nodes))).call(_context6, function (acc, node) {\n    return acc + 1 + node.edges.length;\n  }, 0);\n  var edgeIdProp = direction + \"Id\";\n  var newLevelDiff = direction === \"to\" ? 1 : -1;\n\n  var _iterator = _createForOfIteratorHelper$6(nodes),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var _step$value = slicedToArray(_step.value, 2),\n          entryNodeId = _step$value[0],\n          entryNode = _step$value[1];\n\n      if ( // Skip if the node is not visible.\n      !nodes.has(entryNodeId) || // Skip if the node is not an entry node.\n      !isEntryNode(entryNode)) {\n        return \"continue\";\n      } // Line up all the entry nodes on level 0.\n\n\n      levels[entryNodeId] = 0;\n      var stack = [entryNode];\n      var done = 0;\n      var node = void 0;\n\n      var _loop2 = function _loop2() {\n        var _context7, _context8;\n\n        if (!nodes.has(entryNodeId)) {\n          // Skip if the node is not visible.\n          return \"continue\";\n        }\n\n        var newLevel = levels[node.id] + newLevelDiff;\n        forEach$2(_context7 = filter$2(_context8 = node.edges).call(_context8, function (edge) {\n          return (// Ignore disconnected edges.\n            edge.connected && // Ignore circular edges.\n            edge.to !== edge.from && // Ignore edges leading to the node that's currently being processed.\n            edge[direction] !== node && // Ignore edges connecting to an invisible node.\n            nodes.has(edge.toId) && // Ignore edges connecting from an invisible node.\n            nodes.has(edge.fromId)\n          );\n        })).call(_context7, function (edge) {\n          var targetNodeId = edge[edgeIdProp];\n          var oldLevel = levels[targetNodeId];\n\n          if (oldLevel == null || shouldLevelBeReplaced(newLevel, oldLevel)) {\n            levels[targetNodeId] = newLevel;\n            stack.push(edge[direction]);\n          }\n        });\n\n        if (done > limit) {\n          // This would run forever on a cyclic graph.\n          return {\n            v: {\n              v: fillLevelsByDirectionCyclic(nodes, levels)\n            }\n          };\n        } else {\n          ++done;\n        }\n      };\n\n      while (node = stack.pop()) {\n        var _ret2 = _loop2();\n\n        if (_ret2 === \"continue\") continue;\n        if (_typeof_1(_ret2) === \"object\") return _ret2.v;\n      }\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n      if (_typeof_1(_ret) === \"object\") return _ret.v;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return levels;\n}\n/**\n * There's a mix-up with terms in the code. Following are the formal definitions:\n *\n *   tree   - a strict hierarchical network, i.e. every node has at most one parent\n *   forest - a collection of trees. These distinct trees are thus not connected.\n *\n * So:\n * - in a network that is not a tree, there exist nodes with multiple parents.\n * - a network consisting of unconnected sub-networks, of which at least one\n *   is not a tree, is not a forest.\n *\n * In the code, the definitions are:\n *\n *   tree   - any disconnected sub-network, strict hierarchical or not.\n *   forest - a bunch of these sub-networks\n *\n * The difference between tree and not-tree is important in the code, notably within\n * to the block-shifting algorithm. The algorithm assumes formal trees and fails\n * for not-trees, often in a spectacular manner (search for 'exploding network' in the issues).\n *\n * In order to distinguish the definitions in the following code, the adjective 'formal' is\n * used. If 'formal' is absent, you must assume the non-formal definition.\n *\n * ----------------------------------------------------------------------------------\n * NOTES\n * =====\n *\n * A hierarchical layout is a different thing from a hierarchical network.\n * The layout is a way to arrange the nodes in the view; this can be done\n * on non-hierarchical networks as well. The converse is also possible.\n */\n\n/**\n * Container for derived data on current network, relating to hierarchy.\n *\n * @private\n */\n\n\nvar HierarchicalStatus = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function HierarchicalStatus() {\n    classCallCheck(this, HierarchicalStatus);\n    this.childrenReference = {}; // child id's per node id\n\n    this.parentReference = {}; // parent id's per node id\n\n    this.trees = {}; // tree id per node id; i.e. to which tree does given node id belong\n\n    this.distributionOrdering = {}; // The nodes per level, in the display order\n\n    this.levels = {}; // hierarchy level per node id\n\n    this.distributionIndex = {}; // The position of the node in the level sorting order, per node id.\n\n    this.isTree = false; // True if current network is a formal tree\n\n    this.treeIndex = -1; // Highest tree id in current network.\n  }\n  /**\n   * Add the relation between given nodes to the current state.\n   *\n   * @param {Node.id} parentNodeId\n   * @param {Node.id} childNodeId\n   */\n\n\n  createClass(HierarchicalStatus, [{\n    key: \"addRelation\",\n    value: function addRelation(parentNodeId, childNodeId) {\n      if (this.childrenReference[parentNodeId] === undefined) {\n        this.childrenReference[parentNodeId] = [];\n      }\n\n      this.childrenReference[parentNodeId].push(childNodeId);\n\n      if (this.parentReference[childNodeId] === undefined) {\n        this.parentReference[childNodeId] = [];\n      }\n\n      this.parentReference[childNodeId].push(parentNodeId);\n    }\n    /**\n     * Check if the current state is for a formal tree or formal forest.\n     *\n     * This is the case if every node has at most one parent.\n     *\n     * Pre: parentReference init'ed properly for current network\n     */\n\n  }, {\n    key: \"checkIfTree\",\n    value: function checkIfTree() {\n      for (var i in this.parentReference) {\n        if (this.parentReference[i].length > 1) {\n          this.isTree = false;\n          return;\n        }\n      }\n\n      this.isTree = true;\n    }\n    /**\n     * Return the number of separate trees in the current network.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"numTrees\",\n    value: function numTrees() {\n      return this.treeIndex + 1; // This assumes the indexes are assigned consecitively\n    }\n    /**\n     * Assign a tree id to a node\n     *\n     * @param {Node} node\n     * @param {string|number} treeId\n     */\n\n  }, {\n    key: \"setTreeIndex\",\n    value: function setTreeIndex(node, treeId) {\n      if (treeId === undefined) return; // Don't bother\n\n      if (this.trees[node.id] === undefined) {\n        this.trees[node.id] = treeId;\n        this.treeIndex = Math.max(treeId, this.treeIndex);\n      }\n    }\n    /**\n     * Ensure level for given id is defined.\n     *\n     * Sets level to zero for given node id if not already present\n     *\n     * @param {Node.id} nodeId\n     */\n\n  }, {\n    key: \"ensureLevel\",\n    value: function ensureLevel(nodeId) {\n      if (this.levels[nodeId] === undefined) {\n        this.levels[nodeId] = 0;\n      }\n    }\n    /**\n     * get the maximum level of a branch.\n     *\n     * TODO: Never entered; find a test case to test this!\n     *\n     * @param {Node.id} nodeId\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getMaxLevel\",\n    value: function getMaxLevel(nodeId) {\n      var _this = this;\n\n      var accumulator = {};\n\n      var _getMaxLevel = function _getMaxLevel(nodeId) {\n        if (accumulator[nodeId] !== undefined) {\n          return accumulator[nodeId];\n        }\n\n        var level = _this.levels[nodeId];\n\n        if (_this.childrenReference[nodeId]) {\n          var children = _this.childrenReference[nodeId];\n\n          if (children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n              level = Math.max(level, _getMaxLevel(children[i]));\n            }\n          }\n        }\n\n        accumulator[nodeId] = level;\n        return level;\n      };\n\n      return _getMaxLevel(nodeId);\n    }\n    /**\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n\n  }, {\n    key: \"levelDownstream\",\n    value: function levelDownstream(nodeA, nodeB) {\n      if (this.levels[nodeB.id] === undefined) {\n        // set initial level\n        if (this.levels[nodeA.id] === undefined) {\n          this.levels[nodeA.id] = 0;\n        } // set level\n\n\n        this.levels[nodeB.id] = this.levels[nodeA.id] + 1;\n      }\n    }\n    /**\n     * Small util method to set the minimum levels of the nodes to zero.\n     *\n     * @param {Array.<Node>} nodes\n     */\n\n  }, {\n    key: \"setMinLevelToZero\",\n    value: function setMinLevelToZero(nodes) {\n      var minLevel = 1e9; // get the minimum level\n\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          if (this.levels[nodeId] !== undefined) {\n            minLevel = Math.min(this.levels[nodeId], minLevel);\n          }\n        }\n      } // subtract the minimum from the set so we have a range starting from 0\n\n\n      for (var _nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, _nodeId)) {\n          if (this.levels[_nodeId] !== undefined) {\n            this.levels[_nodeId] -= minLevel;\n          }\n        }\n      }\n    }\n    /**\n     * Get the min and max xy-coordinates of a given tree\n     *\n     * @param {Array.<Node>} nodes\n     * @param {number} index\n     * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}\n     */\n\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(nodes, index) {\n      var min_x = 1e9;\n      var max_x = -1e9;\n      var min_y = 1e9;\n      var max_y = -1e9;\n\n      for (var nodeId in this.trees) {\n        if (Object.prototype.hasOwnProperty.call(this.trees, nodeId)) {\n          if (this.trees[nodeId] === index) {\n            var node = nodes[nodeId];\n            min_x = Math.min(node.x, min_x);\n            max_x = Math.max(node.x, max_x);\n            min_y = Math.min(node.y, min_y);\n            max_y = Math.max(node.y, max_y);\n          }\n        }\n      }\n\n      return {\n        min_x: min_x,\n        max_x: max_x,\n        min_y: min_y,\n        max_y: max_y\n      };\n    }\n    /**\n     * Check if two nodes have the same parent(s)\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @returns {boolean} true if the two nodes have a same ancestor node, false otherwise\n     */\n\n  }, {\n    key: \"hasSameParent\",\n    value: function hasSameParent(node1, node2) {\n      var parents1 = this.parentReference[node1.id];\n      var parents2 = this.parentReference[node2.id];\n\n      if (parents1 === undefined || parents2 === undefined) {\n        return false;\n      }\n\n      for (var i = 0; i < parents1.length; i++) {\n        for (var j = 0; j < parents2.length; j++) {\n          if (parents1[i] == parents2[j]) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Check if two nodes are in the same tree.\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @returns {boolean} true if this is so, false otherwise\n     */\n\n  }, {\n    key: \"inSameSubNetwork\",\n    value: function inSameSubNetwork(node1, node2) {\n      return this.trees[node1.id] === this.trees[node2.id];\n    }\n    /**\n     * Get a list of the distinct levels in the current network\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getLevels\",\n    value: function getLevels() {\n      return keys$3(this.distributionOrdering);\n    }\n    /**\n     * Add a node to the ordering per level\n     *\n     * @param {Node} node\n     * @param {number} level\n     */\n\n  }, {\n    key: \"addToOrdering\",\n    value: function addToOrdering(node, level) {\n      if (this.distributionOrdering[level] === undefined) {\n        this.distributionOrdering[level] = [];\n      }\n\n      var isPresent = false;\n      var curLevel = this.distributionOrdering[level];\n\n      for (var n in curLevel) {\n        //if (curLevel[n].id === node.id) {\n        if (curLevel[n] === node) {\n          isPresent = true;\n          break;\n        }\n      }\n\n      if (!isPresent) {\n        this.distributionOrdering[level].push(node);\n        this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;\n      }\n    }\n  }]);\n  return HierarchicalStatus;\n}();\n/**\n * The Layout Engine\n */\n\n\nvar LayoutEngine = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function LayoutEngine(body) {\n    classCallCheck(this, LayoutEngine);\n    this.body = body; // Make sure there always is some RNG because the setOptions method won't\n    // set it unless there's a seed for it.\n\n    this._resetRNG(Math.random() + \":\" + now$2());\n\n    this.setPhysics = false;\n    this.options = {};\n    this.optionsBackup = {\n      physics: {}\n    };\n    this.defaultOptions = {\n      randomSeed: undefined,\n      improvedLayout: true,\n      clusterThreshold: 150,\n      hierarchical: {\n        enabled: false,\n        levelSeparation: 150,\n        nodeSpacing: 100,\n        treeSpacing: 200,\n        blockShifting: true,\n        edgeMinimization: true,\n        parentCentralization: true,\n        direction: \"UD\",\n        // UD, DU, LR, RL\n        sortMethod: \"hubsize\" // hubsize, directed\n\n      }\n    };\n    assign$2(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n  /**\n   * Binds event listeners\n   */\n\n\n  createClass(LayoutEngine, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this2 = this;\n\n      this.body.emitter.on(\"_dataChanged\", function () {\n        _this2.setupHierarchicalLayout();\n      });\n      this.body.emitter.on(\"_dataLoaded\", function () {\n        _this2.layoutNetwork();\n      });\n      this.body.emitter.on(\"_resetHierarchicalLayout\", function () {\n        _this2.setupHierarchicalLayout();\n      });\n      this.body.emitter.on(\"_adjustEdgesForHierarchicalLayout\", function () {\n        if (_this2.options.hierarchical.enabled !== true) {\n          return;\n        } // get the type of static smooth curve in case it is required\n\n\n        var type = _this2.direction.curveType(); // force all edges into static smooth curves.\n\n\n        _this2.body.emitter.emit(\"_forceDisableDynamicCurves\", type, false);\n      });\n    }\n    /**\n     *\n     * @param {object} options\n     * @param {object} allOptions\n     * @returns {object}\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options, allOptions) {\n      if (options !== undefined) {\n        var hierarchical = this.options.hierarchical;\n        var prevHierarchicalState = hierarchical.enabled;\n        selectiveDeepExtend([\"randomSeed\", \"improvedLayout\", \"clusterThreshold\"], this.options, options);\n        mergeOptions(this.options, options, \"hierarchical\");\n\n        if (options.randomSeed !== undefined) {\n          this._resetRNG(options.randomSeed);\n        }\n\n        if (hierarchical.enabled === true) {\n          if (prevHierarchicalState === true) {\n            // refresh the overridden options for nodes and edges.\n            this.body.emitter.emit(\"refresh\", true);\n          } // make sure the level separation is the right way up\n\n\n          if (hierarchical.direction === \"RL\" || hierarchical.direction === \"DU\") {\n            if (hierarchical.levelSeparation > 0) {\n              hierarchical.levelSeparation *= -1;\n            }\n          } else {\n            if (hierarchical.levelSeparation < 0) {\n              hierarchical.levelSeparation *= -1;\n            }\n          }\n\n          this.setDirectionStrategy();\n          this.body.emitter.emit(\"_resetHierarchicalLayout\"); // because the hierarchical system needs it's own physics and smooth curve settings,\n          // we adapt the other options if needed.\n\n          return this.adaptAllOptionsForHierarchicalLayout(allOptions);\n        } else {\n          if (prevHierarchicalState === true) {\n            // refresh the overridden options for nodes and edges.\n            this.body.emitter.emit(\"refresh\");\n            return deepExtend(allOptions, this.optionsBackup);\n          }\n        }\n      }\n\n      return allOptions;\n    }\n    /**\n     * Reset the random number generator with given seed.\n     *\n     * @param {any} seed - The seed that will be forwarded the the RNG.\n     */\n\n  }, {\n    key: \"_resetRNG\",\n    value: function _resetRNG(seed) {\n      this.initialRandomSeed = seed;\n      this._rng = Alea(this.initialRandomSeed);\n    }\n    /**\n     *\n     * @param {object} allOptions\n     * @returns {object}\n     */\n\n  }, {\n    key: \"adaptAllOptionsForHierarchicalLayout\",\n    value: function adaptAllOptionsForHierarchicalLayout(allOptions) {\n      if (this.options.hierarchical.enabled === true) {\n        var backupPhysics = this.optionsBackup.physics; // set the physics\n\n        if (allOptions.physics === undefined || allOptions.physics === true) {\n          allOptions.physics = {\n            enabled: backupPhysics.enabled === undefined ? true : backupPhysics.enabled,\n            solver: \"hierarchicalRepulsion\"\n          };\n          backupPhysics.enabled = backupPhysics.enabled === undefined ? true : backupPhysics.enabled;\n          backupPhysics.solver = backupPhysics.solver || \"barnesHut\";\n        } else if (_typeof_1(allOptions.physics) === \"object\") {\n          backupPhysics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;\n          backupPhysics.solver = allOptions.physics.solver || \"barnesHut\";\n          allOptions.physics.solver = \"hierarchicalRepulsion\";\n        } else if (allOptions.physics !== false) {\n          backupPhysics.solver = \"barnesHut\";\n          allOptions.physics = {\n            solver: \"hierarchicalRepulsion\"\n          };\n        } // get the type of static smooth curve in case it is required\n\n\n        var type = this.direction.curveType(); // disable smooth curves if nothing is defined. If smooth curves have been turned on,\n        // turn them into static smooth curves.\n\n        if (allOptions.edges === undefined) {\n          this.optionsBackup.edges = {\n            smooth: {\n              enabled: true,\n              type: \"dynamic\"\n            }\n          };\n          allOptions.edges = {\n            smooth: false\n          };\n        } else if (allOptions.edges.smooth === undefined) {\n          this.optionsBackup.edges = {\n            smooth: {\n              enabled: true,\n              type: \"dynamic\"\n            }\n          };\n          allOptions.edges.smooth = false;\n        } else {\n          if (typeof allOptions.edges.smooth === \"boolean\") {\n            this.optionsBackup.edges = {\n              smooth: allOptions.edges.smooth\n            };\n            allOptions.edges.smooth = {\n              enabled: allOptions.edges.smooth,\n              type: type\n            };\n          } else {\n            var smooth = allOptions.edges.smooth; // allow custom types except for dynamic\n\n            if (smooth.type !== undefined && smooth.type !== \"dynamic\") {\n              type = smooth.type;\n            } // TODO: this is options merging; see if the standard routines can be used here.\n\n\n            this.optionsBackup.edges = {\n              smooth: {\n                enabled: smooth.enabled === undefined ? true : smooth.enabled,\n                type: smooth.type === undefined ? \"dynamic\" : smooth.type,\n                roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,\n                forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection\n              }\n            }; // NOTE: Copying an object to self; this is basically setting defaults for undefined variables\n\n            allOptions.edges.smooth = {\n              enabled: smooth.enabled === undefined ? true : smooth.enabled,\n              type: type,\n              roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,\n              forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection\n            };\n          }\n        } // Force all edges into static smooth curves.\n        // Only applies to edges that do not use the global options for smooth.\n\n\n        this.body.emitter.emit(\"_forceDisableDynamicCurves\", type);\n      }\n\n      return allOptions;\n    }\n    /**\n     *\n     * @param {Array.<Node>} nodesArray\n     */\n\n  }, {\n    key: \"positionInitially\",\n    value: function positionInitially(nodesArray) {\n      if (this.options.hierarchical.enabled !== true) {\n        this._resetRNG(this.initialRandomSeed);\n\n        var radius = nodesArray.length + 50;\n\n        for (var i = 0; i < nodesArray.length; i++) {\n          var node = nodesArray[i];\n\n          var angle = 2 * Math.PI * this._rng();\n\n          if (node.x === undefined) {\n            node.x = radius * Math.cos(angle);\n          }\n\n          if (node.y === undefined) {\n            node.y = radius * Math.sin(angle);\n          }\n        }\n      }\n    }\n    /**\n     * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we\n     * cluster them first to reduce the amount.\n     */\n\n  }, {\n    key: \"layoutNetwork\",\n    value: function layoutNetwork() {\n      if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {\n        var indices = this.body.nodeIndices; // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible\n        // nodes have predefined positions we use this.\n\n        var positionDefined = 0;\n\n        for (var i = 0; i < indices.length; i++) {\n          var node = this.body.nodes[indices[i]];\n\n          if (node.predefinedPosition === true) {\n            positionDefined += 1;\n          }\n        } // if less than half of the nodes have a predefined position we continue\n\n\n        if (positionDefined < 0.5 * indices.length) {\n          var MAX_LEVELS = 10;\n          var level = 0;\n          var clusterThreshold = this.options.clusterThreshold; //\n          // Define the options for the hidden cluster nodes\n          // These options don't propagate outside the clustering phase.\n          //\n          // Some options are explicitly disabled, because they may be set in group or default node options.\n          // The clusters are never displayed, so most explicit settings here serve as performance optimizations.\n          //\n          // The explicit setting of 'shape' is to avoid `shape: 'image'`; images are not passed to the hidden\n          // cluster nodes, leading to an exception on creation.\n          //\n          // All settings here are performance related, except when noted otherwise.\n          //\n\n          var clusterOptions = {\n            clusterNodeProperties: {\n              shape: \"ellipse\",\n              // Bugfix: avoid type 'image', no images supplied\n              label: \"\",\n              // avoid label handling\n              group: \"\",\n              // avoid group handling\n              font: {\n                multi: false\n              } // avoid font propagation\n\n            },\n            clusterEdgeProperties: {\n              label: \"\",\n              // avoid label handling\n              font: {\n                multi: false\n              },\n              // avoid font propagation\n              smooth: {\n                enabled: false // avoid drawing penalty for complex edges\n\n              }\n            }\n          }; // if there are a lot of nodes, we cluster before we run the algorithm.\n          // NOTE: this part fails to find clusters for large scale-free networks, which should\n          //       be easily clusterable.\n          // TODO: examine why this is so\n\n          if (indices.length > clusterThreshold) {\n            var startLength = indices.length;\n\n            while (indices.length > clusterThreshold && level <= MAX_LEVELS) {\n              //console.time(\"clustering\")\n              level += 1;\n              var before = indices.length; // if there are many nodes we do a hubsize cluster\n\n              if (level % 3 === 0) {\n                this.body.modules.clustering.clusterBridges(clusterOptions);\n              } else {\n                this.body.modules.clustering.clusterOutliers(clusterOptions);\n              }\n\n              var after = indices.length;\n\n              if (before == after && level % 3 !== 0) {\n                this._declusterAll();\n\n                this.body.emitter.emit(\"_layoutFailed\");\n                console.info(\"This network could not be positioned by this version of the improved layout algorithm.\" + \" Please disable improvedLayout for better performance.\");\n                return;\n              } //console.timeEnd(\"clustering\")\n              //console.log(before,level,after);\n\n            } // increase the size of the edges\n\n\n            this.body.modules.kamadaKawai.setOptions({\n              springLength: Math.max(150, 2 * startLength)\n            });\n          }\n\n          if (level > MAX_LEVELS) {\n            console.info(\"The clustering didn't succeed within the amount of interations allowed,\" + \" progressing with partial result.\");\n          } // position the system for these nodes and edges\n\n\n          this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true); // shift to center point\n\n          this._shiftToCenter(); // perturb the nodes a little bit to force the physics to kick in\n\n\n          var offset = 70;\n\n          for (var _i = 0; _i < indices.length; _i++) {\n            // Only perturb the nodes that aren't fixed\n            var _node = this.body.nodes[indices[_i]];\n\n            if (_node.predefinedPosition === false) {\n              _node.x += (0.5 - this._rng()) * offset;\n              _node.y += (0.5 - this._rng()) * offset;\n            }\n          } // uncluster all clusters\n\n\n          this._declusterAll(); // reposition all bezier nodes.\n\n\n          this.body.emitter.emit(\"_repositionBezierNodes\");\n        }\n      }\n    }\n    /**\n     * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_shiftToCenter\",\n    value: function _shiftToCenter() {\n      var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);\n      var center = NetworkUtil.findCenter(range);\n\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        node.x -= center.x;\n        node.y -= center.y;\n      }\n    }\n    /**\n     * Expands all clusters\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_declusterAll\",\n    value: function _declusterAll() {\n      var clustersPresent = true;\n\n      while (clustersPresent === true) {\n        clustersPresent = false;\n\n        for (var i = 0; i < this.body.nodeIndices.length; i++) {\n          if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {\n            clustersPresent = true;\n            this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);\n          }\n        }\n\n        if (clustersPresent === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n    /**\n     *\n     * @returns {number|*}\n     */\n\n  }, {\n    key: \"getSeed\",\n    value: function getSeed() {\n      return this.initialRandomSeed;\n    }\n    /**\n     * This is the main function to layout the nodes in a hierarchical way.\n     * It checks if the node details are supplied correctly\n     *\n     * @private\n     */\n\n  }, {\n    key: \"setupHierarchicalLayout\",\n    value: function setupHierarchicalLayout() {\n      if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {\n        // get the size of the largest hubs and check if the user has defined a level for a node.\n        var node, nodeId;\n        var definedLevel = false;\n        var undefinedLevel = false;\n        this.lastNodeOnLevel = {};\n        this.hierarchical = new HierarchicalStatus();\n\n        for (nodeId in this.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n            node = this.body.nodes[nodeId];\n\n            if (node.options.level !== undefined) {\n              definedLevel = true;\n              this.hierarchical.levels[nodeId] = node.options.level;\n            } else {\n              undefinedLevel = true;\n            }\n          }\n        } // if the user defined some levels but not all, alert and run without hierarchical layout\n\n\n        if (undefinedLevel === true && definedLevel === true) {\n          throw new Error(\"To use the hierarchical layout, nodes require either no predefined levels\" + \" or levels have to be defined for all nodes.\");\n        } else {\n          // define levels if undefined by the users. Based on hubsize.\n          if (undefinedLevel === true) {\n            var sortMethod = this.options.hierarchical.sortMethod;\n\n            if (sortMethod === \"hubsize\") {\n              this._determineLevelsByHubsize();\n            } else if (sortMethod === \"directed\") {\n              this._determineLevelsDirected();\n            } else if (sortMethod === \"custom\") {\n              this._determineLevelsCustomCallback();\n            }\n          } // fallback for cases where there are nodes but no edges\n\n\n          for (var _nodeId2 in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {\n              this.hierarchical.ensureLevel(_nodeId2);\n            }\n          } // check the distribution of the nodes per level.\n\n\n          var distribution = this._getDistribution(); // get the parent children relations.\n\n\n          this._generateMap(); // place the nodes on the canvas.\n\n\n          this._placeNodesByHierarchy(distribution); // condense the whitespace.\n\n\n          this._condenseHierarchy(); // shift to center so gravity does not have to do much\n\n\n          this._shiftToCenter();\n        }\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_condenseHierarchy\",\n    value: function _condenseHierarchy() {\n      var _this3 = this; // Global var in this scope to define when the movement has stopped.\n\n\n      var stillShifting = false;\n      var branches = {}; // first we have some methods to help shifting trees around.\n      // the main method to shift the trees\n\n      var shiftTrees = function shiftTrees() {\n        var treeSizes = getTreeSizes();\n        var shiftBy = 0;\n\n        for (var i = 0; i < treeSizes.length - 1; i++) {\n          var diff = treeSizes[i].max - treeSizes[i + 1].min;\n          shiftBy += diff + _this3.options.hierarchical.treeSpacing;\n          shiftTree(i + 1, shiftBy);\n        }\n      }; // shift a single tree by an offset\n\n\n      var shiftTree = function shiftTree(index, offset) {\n        var trees = _this3.hierarchical.trees;\n\n        for (var nodeId in trees) {\n          if (Object.prototype.hasOwnProperty.call(trees, nodeId)) {\n            if (trees[nodeId] === index) {\n              _this3.direction.shift(nodeId, offset);\n            }\n          }\n        }\n      }; // get the width of all trees\n\n\n      var getTreeSizes = function getTreeSizes() {\n        var treeWidths = [];\n\n        for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {\n          treeWidths.push(_this3.direction.getTreeSize(i));\n        }\n\n        return treeWidths;\n      }; // get a map of all nodes in this branch\n\n\n      var getBranchNodes = function getBranchNodes(source, map) {\n        if (map[source.id]) {\n          return;\n        }\n\n        map[source.id] = true;\n\n        if (_this3.hierarchical.childrenReference[source.id]) {\n          var children = _this3.hierarchical.childrenReference[source.id];\n\n          if (children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n              getBranchNodes(_this3.body.nodes[children[i]], map);\n            }\n          }\n        }\n      }; // get a min max width as well as the maximum movement space it has on either sides\n      // we use min max terminology because width and height can interchange depending on the direction of the layout\n\n\n      var getBranchBoundary = function getBranchBoundary(branchMap) {\n        var maxLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e9;\n        var minSpace = 1e9;\n        var maxSpace = 1e9;\n        var min = 1e9;\n        var max = -1e9;\n\n        for (var branchNode in branchMap) {\n          if (Object.prototype.hasOwnProperty.call(branchMap, branchNode)) {\n            var node = _this3.body.nodes[branchNode];\n            var level = _this3.hierarchical.levels[node.id];\n\n            var position = _this3.direction.getPosition(node); // get the space around the node.\n\n\n            var _this3$_getSpaceAroun = _this3._getSpaceAroundNode(node, branchMap),\n                _this3$_getSpaceAroun2 = slicedToArray(_this3$_getSpaceAroun, 2),\n                minSpaceNode = _this3$_getSpaceAroun2[0],\n                maxSpaceNode = _this3$_getSpaceAroun2[1];\n\n            minSpace = Math.min(minSpaceNode, minSpace);\n            maxSpace = Math.min(maxSpaceNode, maxSpace); // the width is only relevant for the levels two nodes have in common. This is why we filter on this.\n\n            if (level <= maxLevel) {\n              min = Math.min(position, min);\n              max = Math.max(position, max);\n            }\n          }\n        }\n\n        return [min, max, minSpace, maxSpace];\n      }; // check what the maximum level is these nodes have in common.\n\n\n      var getCollisionLevel = function getCollisionLevel(node1, node2) {\n        var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);\n\n        var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);\n\n        return Math.min(maxLevel1, maxLevel2);\n      };\n      /**\n       * Condense elements. These can be nodes or branches depending on the callback.\n       *\n       * @param {Function} callback\n       * @param {Array.<number>} levels\n       * @param {*} centerParents\n       */\n\n\n      var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {\n        var hier = _this3.hierarchical;\n\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var levelNodes = hier.distributionOrdering[level];\n\n          if (levelNodes.length > 1) {\n            for (var j = 0; j < levelNodes.length - 1; j++) {\n              var node1 = levelNodes[j];\n              var node2 = levelNodes[j + 1]; // NOTE: logic maintained as it was; if nodes have same ancestor,\n              //       then of course they are in the same sub-network.\n\n              if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {\n                callback(node1, node2, centerParents);\n              }\n            }\n          }\n        }\n      }; // callback for shifting branches\n\n\n      var branchShiftCallback = function branchShiftCallback(node1, node2) {\n        var centerParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; //window.CALLBACKS.push(() => {\n\n        var pos1 = _this3.direction.getPosition(node1);\n\n        var pos2 = _this3.direction.getPosition(node2);\n\n        var diffAbs = Math.abs(pos2 - pos1);\n        var nodeSpacing = _this3.options.hierarchical.nodeSpacing; //console.log(\"NOW CHECKING:\", node1.id, node2.id, diffAbs);\n\n        if (diffAbs > nodeSpacing) {\n          var branchNodes1 = {};\n          var branchNodes2 = {};\n          getBranchNodes(node1, branchNodes1);\n          getBranchNodes(node2, branchNodes2); // check the largest distance between the branches\n\n          var maxLevel = getCollisionLevel(node1, node2);\n          var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);\n          var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);\n          var max1 = branchNodeBoundary1[1];\n          var min2 = branchNodeBoundary2[0];\n          var minSpace2 = branchNodeBoundary2[2]; //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id,\n          //            getBranchBoundary(branchNodes2, maxLevel), maxLevel);\n\n          var diffBranch = Math.abs(max1 - min2);\n\n          if (diffBranch > nodeSpacing) {\n            var offset = max1 - min2 + nodeSpacing;\n\n            if (offset < -minSpace2 + nodeSpacing) {\n              offset = -minSpace2 + nodeSpacing; //console.log(\"RESETTING OFFSET\", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);\n            }\n\n            if (offset < 0) {\n              //console.log(\"SHIFTING\", node2.id, offset);\n              _this3._shiftBlock(node2.id, offset);\n\n              stillShifting = true;\n              if (centerParent === true) _this3._centerParent(node2);\n            }\n          }\n        } //this.body.emitter.emit(\"_redraw\");})\n\n      };\n\n      var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {\n        //window.CALLBACKS.push(() => {\n        //  console.log(\"ts\",node.id);\n        var nodeId = node.id;\n        var allEdges = node.edges;\n        var nodeLevel = _this3.hierarchical.levels[node.id]; // gather constants\n\n        var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;\n        var referenceNodes = {};\n        var aboveEdges = [];\n\n        for (var i = 0; i < allEdges.length; i++) {\n          var edge = allEdges[i];\n\n          if (edge.toId != edge.fromId) {\n            var otherNode = edge.toId == nodeId ? edge.from : edge.to;\n            referenceNodes[allEdges[i].id] = otherNode;\n\n            if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {\n              aboveEdges.push(edge);\n            }\n          }\n        } // differentiated sum of lengths based on only moving one node over one axis\n\n\n        var getFx = function getFx(point, edges) {\n          var sum = 0;\n\n          for (var _i2 = 0; _i2 < edges.length; _i2++) {\n            if (referenceNodes[edges[_i2].id] !== undefined) {\n              var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;\n              sum += a / Math.sqrt(a * a + C2);\n            }\n          }\n\n          return sum;\n        }; // doubly differentiated sum of lengths based on only moving one node over one axis\n\n\n        var getDFx = function getDFx(point, edges) {\n          var sum = 0;\n\n          for (var _i3 = 0; _i3 < edges.length; _i3++) {\n            if (referenceNodes[edges[_i3].id] !== undefined) {\n              var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;\n              sum -= C2 * Math.pow(a * a + C2, -1.5);\n            }\n          }\n\n          return sum;\n        };\n\n        var getGuess = function getGuess(iterations, edges) {\n          var guess = _this3.direction.getPosition(node); // Newton's method for optimization\n\n\n          var guessMap = {};\n\n          for (var _i4 = 0; _i4 < iterations; _i4++) {\n            var fx = getFx(guess, edges);\n            var dfx = getDFx(guess, edges); // we limit the movement to avoid instability.\n\n            var limit = 40;\n            var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));\n            guess = guess - ratio; // reduce duplicates\n\n            if (guessMap[guess] !== undefined) {\n              break;\n            }\n\n            guessMap[guess] = _i4;\n          }\n\n          return guess;\n        };\n\n        var moveBranch = function moveBranch(guess) {\n          // position node if there is space\n          var nodePosition = _this3.direction.getPosition(node); // check movable area of the branch\n\n\n          if (branches[node.id] === undefined) {\n            var branchNodes = {};\n            getBranchNodes(node, branchNodes);\n            branches[node.id] = branchNodes;\n          }\n\n          var branchBoundary = getBranchBoundary(branches[node.id]);\n          var minSpaceBranch = branchBoundary[2];\n          var maxSpaceBranch = branchBoundary[3];\n          var diff = guess - nodePosition; // check if we are allowed to move the node:\n\n          var branchOffset = 0;\n\n          if (diff > 0) {\n            branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);\n          } else if (diff < 0) {\n            branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);\n          }\n\n          if (branchOffset != 0) {\n            //console.log(\"moving branch:\",branchOffset, maxSpaceBranch, minSpaceBranch)\n            _this3._shiftBlock(node.id, branchOffset); //this.body.emitter.emit(\"_redraw\");\n\n\n            stillShifting = true;\n          }\n        };\n\n        var moveNode = function moveNode(guess) {\n          var nodePosition = _this3.direction.getPosition(node); // position node if there is space\n\n\n          var _this3$_getSpaceAroun3 = _this3._getSpaceAroundNode(node),\n              _this3$_getSpaceAroun4 = slicedToArray(_this3$_getSpaceAroun3, 2),\n              minSpace = _this3$_getSpaceAroun4[0],\n              maxSpace = _this3$_getSpaceAroun4[1];\n\n          var diff = guess - nodePosition; // check if we are allowed to move the node:\n\n          var newPosition = nodePosition;\n\n          if (diff > 0) {\n            newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess);\n          } else if (diff < 0) {\n            newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess);\n          }\n\n          if (newPosition !== nodePosition) {\n            //console.log(\"moving Node:\",diff, minSpace, maxSpace);\n            _this3.direction.setPosition(node, newPosition); //this.body.emitter.emit(\"_redraw\");\n\n\n            stillShifting = true;\n          }\n        };\n\n        var guess = getGuess(iterations, aboveEdges);\n        moveBranch(guess);\n        guess = getGuess(iterations, allEdges);\n        moveNode(guess); //})\n      }; // method to remove whitespace between branches. Because we do bottom up, we can center the parents.\n\n\n      var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {\n        var levels = _this3.hierarchical.getLevels();\n\n        levels = reverse$2(levels).call(levels);\n\n        for (var i = 0; i < iterations; i++) {\n          stillShifting = false;\n\n          for (var j = 0; j < levels.length; j++) {\n            var level = levels[j];\n            var levelNodes = _this3.hierarchical.distributionOrdering[level];\n\n            for (var k = 0; k < levelNodes.length; k++) {\n              minimizeEdgeLength(1000, levelNodes[k]);\n            }\n          }\n\n          if (stillShifting !== true) {\n            //console.log(\"FINISHED minimizeEdgeLengthBottomUp IN \" + i);\n            break;\n          }\n        }\n      }; // method to remove whitespace between branches. Because we do bottom up, we can center the parents.\n\n\n      var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {\n        var levels = _this3.hierarchical.getLevels();\n\n        levels = reverse$2(levels).call(levels);\n\n        for (var i = 0; i < iterations; i++) {\n          stillShifting = false;\n          shiftElementsCloser(branchShiftCallback, levels, true);\n\n          if (stillShifting !== true) {\n            //console.log(\"FINISHED shiftBranchesCloserBottomUp IN \" + (i+1));\n            break;\n          }\n        }\n      }; // center all parents\n\n\n      var centerAllParents = function centerAllParents() {\n        for (var nodeId in _this3.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(_this3.body.nodes, nodeId)) _this3._centerParent(_this3.body.nodes[nodeId]);\n        }\n      }; // center all parents\n\n\n      var centerAllParentsBottomUp = function centerAllParentsBottomUp() {\n        var levels = _this3.hierarchical.getLevels();\n\n        levels = reverse$2(levels).call(levels);\n\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var levelNodes = _this3.hierarchical.distributionOrdering[level];\n\n          for (var j = 0; j < levelNodes.length; j++) {\n            _this3._centerParent(levelNodes[j]);\n          }\n        }\n      }; // the actual work is done here.\n\n\n      if (this.options.hierarchical.blockShifting === true) {\n        shiftBranchesCloserBottomUp(5);\n        centerAllParents();\n      } // minimize edge length\n\n\n      if (this.options.hierarchical.edgeMinimization === true) {\n        minimizeEdgeLengthBottomUp(20);\n      }\n\n      if (this.options.hierarchical.parentCentralization === true) {\n        centerAllParentsBottomUp();\n      }\n\n      shiftTrees();\n    }\n    /**\n     * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.\n     * This is used to only get the distances to nodes outside of a branch.\n     *\n     * @param {Node} node\n     * @param {{Node.id: vis.Node}} map\n     * @returns {number[]}\n     * @private\n     */\n\n  }, {\n    key: \"_getSpaceAroundNode\",\n    value: function _getSpaceAroundNode(node, map) {\n      var useMap = true;\n\n      if (map === undefined) {\n        useMap = false;\n      }\n\n      var level = this.hierarchical.levels[node.id];\n\n      if (level !== undefined) {\n        var index = this.hierarchical.distributionIndex[node.id];\n        var position = this.direction.getPosition(node);\n        var ordering = this.hierarchical.distributionOrdering[level];\n        var minSpace = 1e9;\n        var maxSpace = 1e9;\n\n        if (index !== 0) {\n          var prevNode = ordering[index - 1];\n\n          if (useMap === true && map[prevNode.id] === undefined || useMap === false) {\n            var prevPos = this.direction.getPosition(prevNode);\n            minSpace = position - prevPos;\n          }\n        }\n\n        if (index != ordering.length - 1) {\n          var nextNode = ordering[index + 1];\n\n          if (useMap === true && map[nextNode.id] === undefined || useMap === false) {\n            var nextPos = this.direction.getPosition(nextNode);\n            maxSpace = Math.min(maxSpace, nextPos - position);\n          }\n        }\n\n        return [minSpace, maxSpace];\n      } else {\n        return [0, 0];\n      }\n    }\n    /**\n     * We use this method to center a parent node and check if it does not cross other nodes when it does.\n     *\n     * @param {Node} node\n     * @private\n     */\n\n  }, {\n    key: \"_centerParent\",\n    value: function _centerParent(node) {\n      if (this.hierarchical.parentReference[node.id]) {\n        var parents = this.hierarchical.parentReference[node.id];\n\n        for (var i = 0; i < parents.length; i++) {\n          var parentId = parents[i];\n          var parentNode = this.body.nodes[parentId];\n          var children = this.hierarchical.childrenReference[parentId];\n\n          if (children !== undefined) {\n            // get the range of the children\n            var newPosition = this._getCenterPosition(children);\n\n            var position = this.direction.getPosition(parentNode);\n\n            var _this$_getSpaceAround = this._getSpaceAroundNode(parentNode),\n                _this$_getSpaceAround2 = slicedToArray(_this$_getSpaceAround, 2),\n                minSpace = _this$_getSpaceAround2[0],\n                maxSpace = _this$_getSpaceAround2[1];\n\n            var diff = position - newPosition;\n\n            if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {\n              this.direction.setPosition(parentNode, newPosition);\n            }\n          }\n        }\n      }\n    }\n    /**\n     * This function places the nodes on the canvas based on the hierarchial distribution.\n     *\n     * @param {object} distribution | obtained by the function this._getDistribution()\n     * @private\n     */\n\n  }, {\n    key: \"_placeNodesByHierarchy\",\n    value: function _placeNodesByHierarchy(distribution) {\n      this.positionedNodes = {}; // start placing all the level 0 nodes first. Then recursively position their branches.\n\n      for (var level in distribution) {\n        if (Object.prototype.hasOwnProperty.call(distribution, level)) {\n          var _context; // sort nodes in level by position:\n\n\n          var nodeArray = keys$3(distribution[level]);\n          nodeArray = this._indexArrayToNodes(nodeArray);\n          sort$2(_context = this.direction).call(_context, nodeArray);\n          var handledNodeCount = 0;\n\n          for (var i = 0; i < nodeArray.length; i++) {\n            var node = nodeArray[i];\n\n            if (this.positionedNodes[node.id] === undefined) {\n              var spacing = this.options.hierarchical.nodeSpacing;\n              var pos = spacing * handledNodeCount; // We get the X or Y values we need and store them in pos and previousPos.\n              // The get and set make sure we get X or Y\n\n              if (handledNodeCount > 0) {\n                pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;\n              }\n\n              this.direction.setPosition(node, pos, level);\n\n              this._validatePositionAndContinue(node, level, pos);\n\n              handledNodeCount++;\n            }\n          }\n        }\n      }\n    }\n    /**\n     * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes\n     * on a X position that ensures there will be no overlap.\n     *\n     * @param {Node.id} parentId\n     * @param {number} parentLevel\n     * @private\n     */\n\n  }, {\n    key: \"_placeBranchNodes\",\n    value: function _placeBranchNodes(parentId, parentLevel) {\n      var _context2;\n\n      var childRef = this.hierarchical.childrenReference[parentId]; // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.\n\n      if (childRef === undefined) {\n        return;\n      } // get a list of childNodes\n\n\n      var childNodes = [];\n\n      for (var i = 0; i < childRef.length; i++) {\n        childNodes.push(this.body.nodes[childRef[i]]);\n      } // use the positions to order the nodes.\n\n\n      sort$2(_context2 = this.direction).call(_context2, childNodes); // position the childNodes\n\n      for (var _i5 = 0; _i5 < childNodes.length; _i5++) {\n        var childNode = childNodes[_i5];\n        var childNodeLevel = this.hierarchical.levels[childNode.id]; // check if the child node is below the parent node and if it has already been positioned.\n\n        if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {\n          // get the amount of space required for this node. If parent the width is based on the amount of children.\n          var spacing = this.options.hierarchical.nodeSpacing;\n          var pos = void 0; // we get the X or Y values we need and store them in pos and previousPos.\n          // The get and set make sure we get X or Y\n\n          if (_i5 === 0) {\n            pos = this.direction.getPosition(this.body.nodes[parentId]);\n          } else {\n            pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;\n          }\n\n          this.direction.setPosition(childNode, pos, childNodeLevel);\n\n          this._validatePositionAndContinue(childNode, childNodeLevel, pos);\n        } else {\n          return;\n        }\n      } // center the parent nodes.\n\n\n      var center = this._getCenterPosition(childNodes);\n\n      this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);\n    }\n    /**\n     * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.\n     * Finally it will call _placeBranchNodes to place the branch nodes.\n     *\n     * @param {Node} node\n     * @param {number} level\n     * @param {number} pos\n     * @private\n     */\n\n  }, {\n    key: \"_validatePositionAndContinue\",\n    value: function _validatePositionAndContinue(node, level, pos) {\n      // This method only works for formal trees and formal forests\n      // Early exit if this is not the case\n      if (!this.hierarchical.isTree) return; // if overlap has been detected, we shift the branch\n\n      if (this.lastNodeOnLevel[level] !== undefined) {\n        var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);\n\n        if (pos - previousPos < this.options.hierarchical.nodeSpacing) {\n          var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;\n\n          var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);\n\n          this._shiftBlock(sharedParent.withChild, diff);\n        }\n      }\n\n      this.lastNodeOnLevel[level] = node.id; // store change in position.\n\n      this.positionedNodes[node.id] = true;\n\n      this._placeBranchNodes(node.id, level);\n    }\n    /**\n     * Receives an array with node indices and returns an array with the actual node references.\n     * Used for sorting based on node properties.\n     *\n     * @param {Array.<Node.id>} idArray\n     * @returns {Array.<Node>}\n     */\n\n  }, {\n    key: \"_indexArrayToNodes\",\n    value: function _indexArrayToNodes(idArray) {\n      var array = [];\n\n      for (var i = 0; i < idArray.length; i++) {\n        array.push(this.body.nodes[idArray[i]]);\n      }\n\n      return array;\n    }\n    /**\n     * This function get the distribution of levels based on hubsize\n     *\n     * @returns {object}\n     * @private\n     */\n\n  }, {\n    key: \"_getDistribution\",\n    value: function _getDistribution() {\n      var distribution = {};\n      var nodeId, node; // we fix Y because the hierarchy is vertical,\n      // we fix X so we do not give a node an x position for a second time.\n      // the fix of X is removed after the x value has been set.\n\n      for (nodeId in this.body.nodes) {\n        if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n          node = this.body.nodes[nodeId];\n          var level = this.hierarchical.levels[nodeId] === undefined ? 0 : this.hierarchical.levels[nodeId];\n          this.direction.fix(node, level);\n\n          if (distribution[level] === undefined) {\n            distribution[level] = {};\n          }\n\n          distribution[level][nodeId] = node;\n        }\n      }\n\n      return distribution;\n    }\n    /**\n     * Return the active (i.e. visible) edges for this node\n     *\n     * @param {Node} node\n     * @returns {Array.<vis.Edge>} Array of edge instances\n     * @private\n     */\n\n  }, {\n    key: \"_getActiveEdges\",\n    value: function _getActiveEdges(node) {\n      var _this4 = this;\n\n      var result = [];\n      forEach$3(node.edges, function (edge) {\n        var _context3;\n\n        if (indexOf$3(_context3 = _this4.body.edgeIndices).call(_context3, edge.id) !== -1) {\n          result.push(edge);\n        }\n      });\n      return result;\n    }\n    /**\n     * Get the hubsizes for all active nodes.\n     *\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"_getHubSizes\",\n    value: function _getHubSizes() {\n      var _this5 = this;\n\n      var hubSizes = {};\n      var nodeIds = this.body.nodeIndices;\n      forEach$3(nodeIds, function (nodeId) {\n        var node = _this5.body.nodes[nodeId];\n\n        var hubSize = _this5._getActiveEdges(node).length;\n\n        hubSizes[hubSize] = true;\n      }); // Make an array of the size sorted descending\n\n      var result = [];\n      forEach$3(hubSizes, function (size) {\n        result.push(Number(size));\n      });\n      sort$2(timsort$1).call(timsort$1, result, function (a, b) {\n        return b - a;\n      });\n      return result;\n    }\n    /**\n     * this function allocates nodes in levels based on the recursive branching from the largest hubs.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_determineLevelsByHubsize\",\n    value: function _determineLevelsByHubsize() {\n      var _this6 = this;\n\n      var levelDownstream = function levelDownstream(nodeA, nodeB) {\n        _this6.hierarchical.levelDownstream(nodeA, nodeB);\n      };\n\n      var hubSizes = this._getHubSizes();\n\n      var _loop = function _loop(i) {\n        var hubSize = hubSizes[i];\n        if (hubSize === 0) return \"break\";\n        forEach$3(_this6.body.nodeIndices, function (nodeId) {\n          var node = _this6.body.nodes[nodeId];\n\n          if (hubSize === _this6._getActiveEdges(node).length) {\n            _this6._crawlNetwork(levelDownstream, nodeId);\n          }\n        });\n      };\n\n      for (var i = 0; i < hubSizes.length; ++i) {\n        var _ret = _loop(i);\n\n        if (_ret === \"break\") break;\n      }\n    }\n    /**\n     * TODO: release feature\n     * TODO: Determine if this feature is needed at all\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_determineLevelsCustomCallback\",\n    value: function _determineLevelsCustomCallback() {\n      var _this7 = this;\n\n      var minLevel = 100000; // TODO: this should come from options.\n      // eslint-disable-next-line no-unused-vars -- This should eventually be implemented with these parameters used.\n\n      var customCallback = function customCallback(nodeA, nodeB, edge) {}; // TODO: perhaps move to HierarchicalStatus.\n      //       But I currently don't see the point, this method is not used.\n\n\n      var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {\n        var levelA = _this7.hierarchical.levels[nodeA.id]; // set initial level\n\n        if (levelA === undefined) {\n          levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;\n        }\n\n        var diff = customCallback(NetworkUtil.cloneOptions(nodeA, \"node\"), NetworkUtil.cloneOptions(nodeB, \"node\"), NetworkUtil.cloneOptions(edge, \"edge\"));\n        _this7.hierarchical.levels[nodeB.id] = levelA + diff;\n      };\n\n      this._crawlNetwork(levelByDirection);\n\n      this.hierarchical.setMinLevelToZero(this.body.nodes);\n    }\n    /**\n     * Allocate nodes in levels based on the direction of the edges.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_determineLevelsDirected\",\n    value: function _determineLevelsDirected() {\n      var _context4,\n          _this8 = this;\n\n      var nodes = reduce$2(_context4 = this.body.nodeIndices).call(_context4, function (acc, id) {\n        acc.set(id, _this8.body.nodes[id]);\n        return acc;\n      }, new map$5());\n\n      if (this.options.hierarchical.shakeTowards === \"roots\") {\n        this.hierarchical.levels = fillLevelsByDirectionRoots(nodes);\n      } else {\n        this.hierarchical.levels = fillLevelsByDirectionLeaves(nodes);\n      }\n\n      this.hierarchical.setMinLevelToZero(this.body.nodes);\n    }\n    /**\n     * Update the bookkeeping of parent and child.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_generateMap\",\n    value: function _generateMap() {\n      var _this9 = this;\n\n      var fillInRelations = function fillInRelations(parentNode, childNode) {\n        if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {\n          _this9.hierarchical.addRelation(parentNode.id, childNode.id);\n        }\n      };\n\n      this._crawlNetwork(fillInRelations);\n\n      this.hierarchical.checkIfTree();\n    }\n    /**\n     * Crawl over the entire network and use a callback on each node couple that is connected to each other.\n     *\n     * @param {Function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.\n     * @param {Node.id} startingNodeId\n     * @private\n     */\n\n  }, {\n    key: \"_crawlNetwork\",\n    value: function _crawlNetwork() {\n      var _this10 = this;\n\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      var startingNodeId = arguments.length > 1 ? arguments[1] : undefined;\n      var progress = {};\n\n      var crawler = function crawler(node, tree) {\n        if (progress[node.id] === undefined) {\n          _this10.hierarchical.setTreeIndex(node, tree);\n\n          progress[node.id] = true;\n          var childNode;\n\n          var edges = _this10._getActiveEdges(node);\n\n          for (var i = 0; i < edges.length; i++) {\n            var edge = edges[i];\n\n            if (edge.connected === true) {\n              if (edge.toId == node.id) {\n                // Not '===' because id's can be string and numeric\n                childNode = edge.from;\n              } else {\n                childNode = edge.to;\n              }\n\n              if (node.id != childNode.id) {\n                // Not '!==' because id's can be string and numeric\n                callback(node, childNode, edge);\n                crawler(childNode, tree);\n              }\n            }\n          }\n        }\n      };\n\n      if (startingNodeId === undefined) {\n        // Crawl over all nodes\n        var treeIndex = 0; // Serves to pass a unique id for the current distinct tree\n\n        for (var i = 0; i < this.body.nodeIndices.length; i++) {\n          var nodeId = this.body.nodeIndices[i];\n\n          if (progress[nodeId] === undefined) {\n            var node = this.body.nodes[nodeId];\n            crawler(node, treeIndex);\n            treeIndex += 1;\n          }\n        }\n      } else {\n        // Crawl from the given starting node\n        var _node2 = this.body.nodes[startingNodeId];\n\n        if (_node2 === undefined) {\n          console.error(\"Node not found:\", startingNodeId);\n          return;\n        }\n\n        crawler(_node2);\n      }\n    }\n    /**\n     * Shift a branch a certain distance\n     *\n     * @param {Node.id} parentId\n     * @param {number} diff\n     * @private\n     */\n\n  }, {\n    key: \"_shiftBlock\",\n    value: function _shiftBlock(parentId, diff) {\n      var _this11 = this;\n\n      var progress = {};\n\n      var shifter = function shifter(parentId) {\n        if (progress[parentId]) {\n          return;\n        }\n\n        progress[parentId] = true;\n\n        _this11.direction.shift(parentId, diff);\n\n        var childRef = _this11.hierarchical.childrenReference[parentId];\n\n        if (childRef !== undefined) {\n          for (var i = 0; i < childRef.length; i++) {\n            shifter(childRef[i]);\n          }\n        }\n      };\n\n      shifter(parentId);\n    }\n    /**\n     * Find a common parent between branches.\n     *\n     * @param {Node.id} childA\n     * @param {Node.id} childB\n     * @returns {{foundParent, withChild}}\n     * @private\n     */\n\n  }, {\n    key: \"_findCommonParent\",\n    value: function _findCommonParent(childA, childB) {\n      var _this12 = this;\n\n      var parents = {};\n\n      var iterateParents = function iterateParents(parents, child) {\n        var parentRef = _this12.hierarchical.parentReference[child];\n\n        if (parentRef !== undefined) {\n          for (var i = 0; i < parentRef.length; i++) {\n            var parent = parentRef[i];\n            parents[parent] = true;\n            iterateParents(parents, parent);\n          }\n        }\n      };\n\n      var findParent = function findParent(parents, child) {\n        var parentRef = _this12.hierarchical.parentReference[child];\n\n        if (parentRef !== undefined) {\n          for (var i = 0; i < parentRef.length; i++) {\n            var parent = parentRef[i];\n\n            if (parents[parent] !== undefined) {\n              return {\n                foundParent: parent,\n                withChild: child\n              };\n            }\n\n            var branch = findParent(parents, parent);\n\n            if (branch.foundParent !== null) {\n              return branch;\n            }\n          }\n        }\n\n        return {\n          foundParent: null,\n          withChild: child\n        };\n      };\n\n      iterateParents(parents, childA);\n      return findParent(parents, childB);\n    }\n    /**\n     * Set the strategy pattern for handling the coordinates given the current direction.\n     *\n     * The individual instances contain all the operations and data specific to a layout direction.\n     *\n     * @param {Node} node\n     * @param {{x: number, y: number}} position\n     * @param {number} level\n     * @param {boolean} [doNotUpdate=false]\n     * @private\n     */\n\n  }, {\n    key: \"setDirectionStrategy\",\n    value: function setDirectionStrategy() {\n      var isVertical = this.options.hierarchical.direction === \"UD\" || this.options.hierarchical.direction === \"DU\";\n\n      if (isVertical) {\n        this.direction = new VerticalStrategy(this);\n      } else {\n        this.direction = new HorizontalStrategy(this);\n      }\n    }\n    /**\n     * Determine the center position of a branch from the passed list of child nodes\n     *\n     * This takes into account the positions of all the child nodes.\n     *\n     * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"_getCenterPosition\",\n    value: function _getCenterPosition(childNodes) {\n      var minPos = 1e9;\n      var maxPos = -1e9;\n\n      for (var i = 0; i < childNodes.length; i++) {\n        var childNode = void 0;\n\n        if (childNodes[i].id !== undefined) {\n          childNode = childNodes[i];\n        } else {\n          var childNodeId = childNodes[i];\n          childNode = this.body.nodes[childNodeId];\n        }\n\n        var position = this.direction.getPosition(childNode);\n        minPos = Math.min(minPos, position);\n        maxPos = Math.max(maxPos, position);\n      }\n\n      return 0.5 * (minPos + maxPos);\n    }\n  }]);\n  return LayoutEngine;\n}();\n/**\n * Clears the toolbar div element of children\n *\n * @private\n */\n\n\nvar ManipulationSystem = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   * @param {SelectionHandler} selectionHandler\n   * @param {InteractionHandler} interactionHandler\n   */\n  function ManipulationSystem(body, canvas, selectionHandler, interactionHandler) {\n    var _this = this,\n        _context,\n        _context2;\n\n    classCallCheck(this, ManipulationSystem);\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionHandler = selectionHandler;\n    this.interactionHandler = interactionHandler;\n    this.editMode = false;\n    this.manipulationDiv = undefined;\n    this.editModeDiv = undefined;\n    this.closeDiv = undefined;\n    this.manipulationHammers = [];\n    this.temporaryUIFunctions = {};\n    this.temporaryEventFunctions = [];\n    this.touchTime = 0;\n    this.temporaryIds = {\n      nodes: [],\n      edges: []\n    };\n    this.guiEnabled = false;\n    this.inMode = false;\n    this.selectedControlNode = undefined;\n    this.options = {};\n    this.defaultOptions = {\n      enabled: false,\n      initiallyActive: false,\n      addNode: true,\n      addEdge: true,\n      editNode: undefined,\n      editEdge: true,\n      deleteNode: true,\n      deleteEdge: true,\n      controlNodeStyle: {\n        shape: \"dot\",\n        size: 6,\n        color: {\n          background: \"#ff0000\",\n          border: \"#3c3c3c\",\n          highlight: {\n            background: \"#07f968\",\n            border: \"#3c3c3c\"\n          }\n        },\n        borderWidth: 2,\n        borderWidthSelected: 2\n      }\n    };\n    assign$2(this.options, this.defaultOptions);\n    this.body.emitter.on(\"destroy\", function () {\n      _this._clean();\n    });\n    this.body.emitter.on(\"_dataChanged\", bind$2(_context = this._restore).call(_context, this));\n    this.body.emitter.on(\"_resetData\", bind$2(_context2 = this._restore).call(_context2, this));\n  }\n  /**\n   * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.\n   *\n   * @private\n   */\n\n\n  createClass(ManipulationSystem, [{\n    key: \"_restore\",\n    value: function _restore() {\n      if (this.inMode !== false) {\n        if (this.options.initiallyActive === true) {\n          this.enableEditMode();\n        } else {\n          this.disableEditMode();\n        }\n      }\n    }\n    /**\n     * Set the Options\n     *\n     * @param {object} options\n     * @param {object} allOptions\n     * @param {object} globalOptions\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options, allOptions, globalOptions) {\n      if (allOptions !== undefined) {\n        if (allOptions.locale !== undefined) {\n          this.options.locale = allOptions.locale;\n        } else {\n          this.options.locale = globalOptions.locale;\n        }\n\n        if (allOptions.locales !== undefined) {\n          this.options.locales = allOptions.locales;\n        } else {\n          this.options.locales = globalOptions.locales;\n        }\n      }\n\n      if (options !== undefined) {\n        if (typeof options === \"boolean\") {\n          this.options.enabled = options;\n        } else {\n          this.options.enabled = true;\n          deepExtend(this.options, options);\n        }\n\n        if (this.options.initiallyActive === true) {\n          this.editMode = true;\n        }\n\n        this._setup();\n      }\n    }\n    /**\n     * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"toggleEditMode\",\n    value: function toggleEditMode() {\n      if (this.editMode === true) {\n        this.disableEditMode();\n      } else {\n        this.enableEditMode();\n      }\n    }\n    /**\n     * Enables Edit Mode\n     */\n\n  }, {\n    key: \"enableEditMode\",\n    value: function enableEditMode() {\n      this.editMode = true;\n\n      this._clean();\n\n      if (this.guiEnabled === true) {\n        this.manipulationDiv.style.display = \"block\";\n        this.closeDiv.style.display = \"block\";\n        this.editModeDiv.style.display = \"none\";\n        this.showManipulatorToolbar();\n      }\n    }\n    /**\n     * Disables Edit Mode\n     */\n\n  }, {\n    key: \"disableEditMode\",\n    value: function disableEditMode() {\n      this.editMode = false;\n\n      this._clean();\n\n      if (this.guiEnabled === true) {\n        this.manipulationDiv.style.display = \"none\";\n        this.closeDiv.style.display = \"none\";\n        this.editModeDiv.style.display = \"block\";\n\n        this._createEditButton();\n      }\n    }\n    /**\n     * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"showManipulatorToolbar\",\n    value: function showManipulatorToolbar() {\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean(); // reset global variables\n\n\n      this.manipulationDOM = {}; // if the gui is enabled, draw all elements.\n\n      if (this.guiEnabled === true) {\n        var _context3, _context4; // a _restore will hide these menus\n\n\n        this.editMode = true;\n        this.manipulationDiv.style.display = \"block\";\n        this.closeDiv.style.display = \"block\";\n        var selectedNodeCount = this.selectionHandler.getSelectedNodeCount();\n        var selectedEdgeCount = this.selectionHandler.getSelectedEdgeCount();\n        var selectedTotalCount = selectedNodeCount + selectedEdgeCount;\n        var locale = this.options.locales[this.options.locale];\n        var needSeperator = false;\n\n        if (this.options.addNode !== false) {\n          this._createAddNodeButton(locale);\n\n          needSeperator = true;\n        }\n\n        if (this.options.addEdge !== false) {\n          if (needSeperator === true) {\n            this._createSeperator(1);\n          } else {\n            needSeperator = true;\n          }\n\n          this._createAddEdgeButton(locale);\n        }\n\n        if (selectedNodeCount === 1 && typeof this.options.editNode === \"function\") {\n          if (needSeperator === true) {\n            this._createSeperator(2);\n          } else {\n            needSeperator = true;\n          }\n\n          this._createEditNodeButton(locale);\n        } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {\n          if (needSeperator === true) {\n            this._createSeperator(3);\n          } else {\n            needSeperator = true;\n          }\n\n          this._createEditEdgeButton(locale);\n        } // remove buttons\n\n\n        if (selectedTotalCount !== 0) {\n          if (selectedNodeCount > 0 && this.options.deleteNode !== false) {\n            if (needSeperator === true) {\n              this._createSeperator(4);\n            }\n\n            this._createDeleteButton(locale);\n          } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {\n            if (needSeperator === true) {\n              this._createSeperator(4);\n            }\n\n            this._createDeleteButton(locale);\n          }\n        } // bind the close button\n\n\n        this._bindHammerToDiv(this.closeDiv, bind$2(_context3 = this.toggleEditMode).call(_context3, this)); // refresh this bar based on what has been selected\n\n\n        this._temporaryBindEvent(\"select\", bind$2(_context4 = this.showManipulatorToolbar).call(_context4, this));\n      } // redraw to show any possible changes\n\n\n      this.body.emitter.emit(\"_redraw\");\n    }\n    /**\n     * Create the toolbar for adding Nodes\n     */\n\n  }, {\n    key: \"addNodeMode\",\n    value: function addNodeMode() {\n      var _context6; // when using the gui, enable edit mode if it wasnt already.\n\n\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      } // restore the state of any bound functions or events, remove control nodes, restore physics\n\n\n      this._clean();\n\n      this.inMode = \"addNode\";\n\n      if (this.guiEnabled === true) {\n        var _context5;\n\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n\n        this._createBackButton(locale);\n\n        this._createSeperator();\n\n        this._createDescription(locale[\"addDescription\"] || this.options.locales[\"en\"][\"addDescription\"]); // bind the close button\n\n\n        this._bindHammerToDiv(this.closeDiv, bind$2(_context5 = this.toggleEditMode).call(_context5, this));\n      }\n\n      this._temporaryBindEvent(\"click\", bind$2(_context6 = this._performAddNode).call(_context6, this));\n    }\n    /**\n     * call the bound function to handle the editing of the node. The node has to be selected.\n     */\n\n  }, {\n    key: \"editNode\",\n    value: function editNode() {\n      var _this2 = this; // when using the gui, enable edit mode if it wasnt already.\n\n\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      } // restore the state of any bound functions or events, remove control nodes, restore physics\n\n\n      this._clean();\n\n      var node = this.selectionHandler.getSelectedNodes()[0];\n\n      if (node !== undefined) {\n        this.inMode = \"editNode\";\n\n        if (typeof this.options.editNode === \"function\") {\n          if (node.isCluster !== true) {\n            var data = deepExtend({}, node.options, false);\n            data.x = node.x;\n            data.y = node.y;\n\n            if (this.options.editNode.length === 2) {\n              this.options.editNode(data, function (finalizedData) {\n                if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === \"editNode\") {\n                  // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n                  _this2.body.data.nodes.getDataSet().update(finalizedData);\n                }\n\n                _this2.showManipulatorToolbar();\n              });\n            } else {\n              throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n            }\n          } else {\n            alert(this.options.locales[this.options.locale][\"editClusterError\"] || this.options.locales[\"en\"][\"editClusterError\"]);\n          }\n        } else {\n          throw new Error(\"No function has been configured to handle the editing of nodes.\");\n        }\n      } else {\n        this.showManipulatorToolbar();\n      }\n    }\n    /**\n     * create the toolbar to connect nodes\n     */\n\n  }, {\n    key: \"addEdgeMode\",\n    value: function addEdgeMode() {\n      var _context8, _context9, _context10, _context11, _context12; // when using the gui, enable edit mode if it wasnt already.\n\n\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      } // restore the state of any bound functions or events, remove control nodes, restore physics\n\n\n      this._clean();\n\n      this.inMode = \"addEdge\";\n\n      if (this.guiEnabled === true) {\n        var _context7;\n\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n\n        this._createBackButton(locale);\n\n        this._createSeperator();\n\n        this._createDescription(locale[\"edgeDescription\"] || this.options.locales[\"en\"][\"edgeDescription\"]); // bind the close button\n\n\n        this._bindHammerToDiv(this.closeDiv, bind$2(_context7 = this.toggleEditMode).call(_context7, this));\n      } // temporarily overload functions\n\n\n      this._temporaryBindUI(\"onTouch\", bind$2(_context8 = this._handleConnect).call(_context8, this));\n\n      this._temporaryBindUI(\"onDragEnd\", bind$2(_context9 = this._finishConnect).call(_context9, this));\n\n      this._temporaryBindUI(\"onDrag\", bind$2(_context10 = this._dragControlNode).call(_context10, this));\n\n      this._temporaryBindUI(\"onRelease\", bind$2(_context11 = this._finishConnect).call(_context11, this));\n\n      this._temporaryBindUI(\"onDragStart\", bind$2(_context12 = this._dragStartEdge).call(_context12, this));\n\n      this._temporaryBindUI(\"onHold\", function () {});\n    }\n    /**\n     * create the toolbar to edit edges\n     */\n\n  }, {\n    key: \"editEdgeMode\",\n    value: function editEdgeMode() {\n      // when using the gui, enable edit mode if it wasn't already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      } // restore the state of any bound functions or events, remove control nodes, restore physics\n\n\n      this._clean();\n\n      this.inMode = \"editEdge\";\n\n      if (_typeof_1(this.options.editEdge) === \"object\" && typeof this.options.editEdge.editWithoutDrag === \"function\") {\n        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];\n\n        if (this.edgeBeingEditedId !== undefined) {\n          var edge = this.body.edges[this.edgeBeingEditedId];\n\n          this._performEditEdge(edge.from.id, edge.to.id);\n\n          return;\n        }\n      }\n\n      if (this.guiEnabled === true) {\n        var _context13;\n\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n\n        this._createBackButton(locale);\n\n        this._createSeperator();\n\n        this._createDescription(locale[\"editEdgeDescription\"] || this.options.locales[\"en\"][\"editEdgeDescription\"]); // bind the close button\n\n\n        this._bindHammerToDiv(this.closeDiv, bind$2(_context13 = this.toggleEditMode).call(_context13, this));\n      }\n\n      this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];\n\n      if (this.edgeBeingEditedId !== undefined) {\n        var _context14, _context15, _context16, _context17;\n\n        var _edge = this.body.edges[this.edgeBeingEditedId]; // create control nodes\n\n        var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);\n\n        var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);\n\n        this.temporaryIds.nodes.push(controlNodeFrom.id);\n        this.temporaryIds.nodes.push(controlNodeTo.id);\n        this.body.nodes[controlNodeFrom.id] = controlNodeFrom;\n        this.body.nodeIndices.push(controlNodeFrom.id);\n        this.body.nodes[controlNodeTo.id] = controlNodeTo;\n        this.body.nodeIndices.push(controlNodeTo.id); // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI\n\n        this._temporaryBindUI(\"onTouch\", bind$2(_context14 = this._controlNodeTouch).call(_context14, this)); // used to get the position\n\n\n        this._temporaryBindUI(\"onTap\", function () {}); // disabled\n\n\n        this._temporaryBindUI(\"onHold\", function () {}); // disabled\n\n\n        this._temporaryBindUI(\"onDragStart\", bind$2(_context15 = this._controlNodeDragStart).call(_context15, this)); // used to select control node\n\n\n        this._temporaryBindUI(\"onDrag\", bind$2(_context16 = this._controlNodeDrag).call(_context16, this)); // used to drag control node\n\n\n        this._temporaryBindUI(\"onDragEnd\", bind$2(_context17 = this._controlNodeDragEnd).call(_context17, this)); // used to connect or revert control nodes\n\n\n        this._temporaryBindUI(\"onMouseMove\", function () {}); // disabled\n        // create function to position control nodes correctly on movement\n        // automatically cleaned up because we use the temporary bind\n\n\n        this._temporaryBindEvent(\"beforeDrawing\", function (ctx) {\n          var positions = _edge.edgeType.findBorderPositions(ctx);\n\n          if (controlNodeFrom.selected === false) {\n            controlNodeFrom.x = positions.from.x;\n            controlNodeFrom.y = positions.from.y;\n          }\n\n          if (controlNodeTo.selected === false) {\n            controlNodeTo.x = positions.to.x;\n            controlNodeTo.y = positions.to.y;\n          }\n        });\n\n        this.body.emitter.emit(\"_redraw\");\n      } else {\n        this.showManipulatorToolbar();\n      }\n    }\n    /**\n     * delete everything in the selection\n     */\n\n  }, {\n    key: \"deleteSelected\",\n    value: function deleteSelected() {\n      var _this3 = this; // when using the gui, enable edit mode if it wasnt already.\n\n\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      } // restore the state of any bound functions or events, remove control nodes, restore physics\n\n\n      this._clean();\n\n      this.inMode = \"delete\";\n      var selectedNodes = this.selectionHandler.getSelectedNodeIds();\n      var selectedEdges = this.selectionHandler.getSelectedEdgeIds();\n      var deleteFunction = undefined;\n\n      if (selectedNodes.length > 0) {\n        for (var i = 0; i < selectedNodes.length; i++) {\n          if (this.body.nodes[selectedNodes[i]].isCluster === true) {\n            alert(this.options.locales[this.options.locale][\"deleteClusterError\"] || this.options.locales[\"en\"][\"deleteClusterError\"]);\n            return;\n          }\n        }\n\n        if (typeof this.options.deleteNode === \"function\") {\n          deleteFunction = this.options.deleteNode;\n        }\n      } else if (selectedEdges.length > 0) {\n        if (typeof this.options.deleteEdge === \"function\") {\n          deleteFunction = this.options.deleteEdge;\n        }\n      }\n\n      if (typeof deleteFunction === \"function\") {\n        var data = {\n          nodes: selectedNodes,\n          edges: selectedEdges\n        };\n\n        if (deleteFunction.length === 2) {\n          deleteFunction(data, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this3.inMode === \"delete\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n              _this3.body.data.edges.getDataSet().remove(finalizedData.edges);\n\n              _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);\n\n              _this3.body.emitter.emit(\"startSimulation\");\n\n              _this3.showManipulatorToolbar();\n            } else {\n              _this3.body.emitter.emit(\"startSimulation\");\n\n              _this3.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for delete does not support two arguments (data, callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().remove(selectedEdges);\n        this.body.data.nodes.getDataSet().remove(selectedNodes);\n        this.body.emitter.emit(\"startSimulation\");\n        this.showManipulatorToolbar();\n      }\n    } //********************************************** PRIVATE ***************************************//\n\n    /**\n     * draw or remove the DOM\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setup\",\n    value: function _setup() {\n      if (this.options.enabled === true) {\n        // Enable the GUI\n        this.guiEnabled = true;\n\n        this._createWrappers();\n\n        if (this.editMode === false) {\n          this._createEditButton();\n        } else {\n          this.showManipulatorToolbar();\n        }\n      } else {\n        this._removeManipulationDOM(); // disable the gui\n\n\n        this.guiEnabled = false;\n      }\n    }\n    /**\n     * create the div overlays that contain the DOM\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_createWrappers\",\n    value: function _createWrappers() {\n      // load the manipulator HTML elements. All styling done in css.\n      if (this.manipulationDiv === undefined) {\n        this.manipulationDiv = document.createElement(\"div\");\n        this.manipulationDiv.className = \"vis-manipulation\";\n\n        if (this.editMode === true) {\n          this.manipulationDiv.style.display = \"block\";\n        } else {\n          this.manipulationDiv.style.display = \"none\";\n        }\n\n        this.canvas.frame.appendChild(this.manipulationDiv);\n      } // container for the edit button.\n\n\n      if (this.editModeDiv === undefined) {\n        this.editModeDiv = document.createElement(\"div\");\n        this.editModeDiv.className = \"vis-edit-mode\";\n\n        if (this.editMode === true) {\n          this.editModeDiv.style.display = \"none\";\n        } else {\n          this.editModeDiv.style.display = \"block\";\n        }\n\n        this.canvas.frame.appendChild(this.editModeDiv);\n      } // container for the close div button\n\n\n      if (this.closeDiv === undefined) {\n        this.closeDiv = document.createElement(\"div\");\n        this.closeDiv.className = \"vis-close\";\n        this.closeDiv.style.display = this.manipulationDiv.style.display;\n        this.canvas.frame.appendChild(this.closeDiv);\n      }\n    }\n    /**\n     * generate a new target node. Used for creating new edges and editing edges\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {Node}\n     * @private\n     */\n\n  }, {\n    key: \"_getNewTargetNode\",\n    value: function _getNewTargetNode(x, y) {\n      var controlNodeStyle = deepExtend({}, this.options.controlNodeStyle);\n      controlNodeStyle.id = \"targetNode\" + v4();\n      controlNodeStyle.hidden = false;\n      controlNodeStyle.physics = false;\n      controlNodeStyle.x = x;\n      controlNodeStyle.y = y; // we have to define the bounding box in order for the nodes to be drawn immediately\n\n      var node = this.body.functions.createNode(controlNodeStyle);\n      node.shape.boundingBox = {\n        left: x,\n        right: x,\n        top: y,\n        bottom: y\n      };\n      return node;\n    }\n    /**\n     * Create the edit button\n     */\n\n  }, {\n    key: \"_createEditButton\",\n    value: function _createEditButton() {\n      var _context18; // restore everything to it's original state (if applicable)\n\n\n      this._clean(); // reset the manipulationDOM\n\n\n      this.manipulationDOM = {}; // empty the editModeDiv\n\n      recursiveDOMDelete(this.editModeDiv); // create the contents for the editMode button\n\n      var locale = this.options.locales[this.options.locale];\n\n      var button = this._createButton(\"editMode\", \"vis-button vis-edit vis-edit-mode\", locale[\"edit\"] || this.options.locales[\"en\"][\"edit\"]);\n\n      this.editModeDiv.appendChild(button); // bind a hammer listener to the button, calling the function toggleEditMode.\n\n      this._bindHammerToDiv(button, bind$2(_context18 = this.toggleEditMode).call(_context18, this));\n    }\n    /**\n     * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      // not in mode\n      this.inMode = false; // _clean the divs\n\n      if (this.guiEnabled === true) {\n        recursiveDOMDelete(this.editModeDiv);\n        recursiveDOMDelete(this.manipulationDiv); // removes all the bindings and overloads\n\n        this._cleanManipulatorHammers();\n      } // remove temporary nodes and edges\n\n\n      this._cleanupTemporaryNodesAndEdges(); // restore overloaded UI functions\n\n\n      this._unbindTemporaryUIs(); // remove the temporaryEventFunctions\n\n\n      this._unbindTemporaryEvents(); // restore the physics if required\n\n\n      this.body.emitter.emit(\"restorePhysics\");\n    }\n    /**\n     * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_cleanManipulatorHammers\",\n    value: function _cleanManipulatorHammers() {\n      // _clean hammer bindings\n      if (this.manipulationHammers.length != 0) {\n        for (var i = 0; i < this.manipulationHammers.length; i++) {\n          this.manipulationHammers[i].destroy();\n        }\n\n        this.manipulationHammers = [];\n      }\n    }\n    /**\n     * Remove all DOM elements created by this module.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_removeManipulationDOM\",\n    value: function _removeManipulationDOM() {\n      // removes all the bindings and overloads\n      this._clean(); // empty the manipulation divs\n\n\n      recursiveDOMDelete(this.manipulationDiv);\n      recursiveDOMDelete(this.editModeDiv);\n      recursiveDOMDelete(this.closeDiv); // remove the manipulation divs\n\n      if (this.manipulationDiv) {\n        this.canvas.frame.removeChild(this.manipulationDiv);\n      }\n\n      if (this.editModeDiv) {\n        this.canvas.frame.removeChild(this.editModeDiv);\n      }\n\n      if (this.closeDiv) {\n        this.canvas.frame.removeChild(this.closeDiv);\n      } // set the references to undefined\n\n\n      this.manipulationDiv = undefined;\n      this.editModeDiv = undefined;\n      this.closeDiv = undefined;\n    }\n    /**\n     * create a seperator line. the index is to differentiate in the manipulation dom\n     *\n     * @param {number} [index=1]\n     * @private\n     */\n\n  }, {\n    key: \"_createSeperator\",\n    value: function _createSeperator() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      this.manipulationDOM[\"seperatorLineDiv\" + index] = document.createElement(\"div\");\n      this.manipulationDOM[\"seperatorLineDiv\" + index].className = \"vis-separator-line\";\n      this.manipulationDiv.appendChild(this.manipulationDOM[\"seperatorLineDiv\" + index]);\n    } // ----------------------    DOM functions for buttons    --------------------------//\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: \"_createAddNodeButton\",\n    value: function _createAddNodeButton(locale) {\n      var _context19;\n\n      var button = this._createButton(\"addNode\", \"vis-button vis-add\", locale[\"addNode\"] || this.options.locales[\"en\"][\"addNode\"]);\n\n      this.manipulationDiv.appendChild(button);\n\n      this._bindHammerToDiv(button, bind$2(_context19 = this.addNodeMode).call(_context19, this));\n    }\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: \"_createAddEdgeButton\",\n    value: function _createAddEdgeButton(locale) {\n      var _context20;\n\n      var button = this._createButton(\"addEdge\", \"vis-button vis-connect\", locale[\"addEdge\"] || this.options.locales[\"en\"][\"addEdge\"]);\n\n      this.manipulationDiv.appendChild(button);\n\n      this._bindHammerToDiv(button, bind$2(_context20 = this.addEdgeMode).call(_context20, this));\n    }\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: \"_createEditNodeButton\",\n    value: function _createEditNodeButton(locale) {\n      var _context21;\n\n      var button = this._createButton(\"editNode\", \"vis-button vis-edit\", locale[\"editNode\"] || this.options.locales[\"en\"][\"editNode\"]);\n\n      this.manipulationDiv.appendChild(button);\n\n      this._bindHammerToDiv(button, bind$2(_context21 = this.editNode).call(_context21, this));\n    }\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: \"_createEditEdgeButton\",\n    value: function _createEditEdgeButton(locale) {\n      var _context22;\n\n      var button = this._createButton(\"editEdge\", \"vis-button vis-edit\", locale[\"editEdge\"] || this.options.locales[\"en\"][\"editEdge\"]);\n\n      this.manipulationDiv.appendChild(button);\n\n      this._bindHammerToDiv(button, bind$2(_context22 = this.editEdgeMode).call(_context22, this));\n    }\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: \"_createDeleteButton\",\n    value: function _createDeleteButton(locale) {\n      var _context23;\n\n      var deleteBtnClass;\n\n      if (this.options.rtl) {\n        deleteBtnClass = \"vis-button vis-delete-rtl\";\n      } else {\n        deleteBtnClass = \"vis-button vis-delete\";\n      }\n\n      var button = this._createButton(\"delete\", deleteBtnClass, locale[\"del\"] || this.options.locales[\"en\"][\"del\"]);\n\n      this.manipulationDiv.appendChild(button);\n\n      this._bindHammerToDiv(button, bind$2(_context23 = this.deleteSelected).call(_context23, this));\n    }\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n\n  }, {\n    key: \"_createBackButton\",\n    value: function _createBackButton(locale) {\n      var _context24;\n\n      var button = this._createButton(\"back\", \"vis-button vis-back\", locale[\"back\"] || this.options.locales[\"en\"][\"back\"]);\n\n      this.manipulationDiv.appendChild(button);\n\n      this._bindHammerToDiv(button, bind$2(_context24 = this.showManipulatorToolbar).call(_context24, this));\n    }\n    /**\n     *\n     * @param {number|string} id\n     * @param {string} className\n     * @param {label} label\n     * @param {string} labelClassName\n     * @returns {HTMLElement}\n     * @private\n     */\n\n  }, {\n    key: \"_createButton\",\n    value: function _createButton(id, className, label) {\n      var labelClassName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"vis-label\";\n      this.manipulationDOM[id + \"Div\"] = document.createElement(\"div\");\n      this.manipulationDOM[id + \"Div\"].className = className;\n      this.manipulationDOM[id + \"Label\"] = document.createElement(\"div\");\n      this.manipulationDOM[id + \"Label\"].className = labelClassName;\n      this.manipulationDOM[id + \"Label\"].innerHTML = label;\n      this.manipulationDOM[id + \"Div\"].appendChild(this.manipulationDOM[id + \"Label\"]);\n      return this.manipulationDOM[id + \"Div\"];\n    }\n    /**\n     *\n     * @param {Label} label\n     * @private\n     */\n\n  }, {\n    key: \"_createDescription\",\n    value: function _createDescription(label) {\n      this.manipulationDiv.appendChild(this._createButton(\"description\", \"vis-button vis-none\", label));\n    } // -------------------------- End of DOM functions for buttons ------------------------------//\n\n    /**\n     * this binds an event until cleanup by the clean functions.\n     *\n     * @param {Event}  event   The event\n     * @param {Function} newFunction\n     * @private\n     */\n\n  }, {\n    key: \"_temporaryBindEvent\",\n    value: function _temporaryBindEvent(event, newFunction) {\n      this.temporaryEventFunctions.push({\n        event: event,\n        boundFunction: newFunction\n      });\n      this.body.emitter.on(event, newFunction);\n    }\n    /**\n     * this overrides an UI function until cleanup by the clean function\n     *\n     * @param {string} UIfunctionName\n     * @param {Function} newFunction\n     * @private\n     */\n\n  }, {\n    key: \"_temporaryBindUI\",\n    value: function _temporaryBindUI(UIfunctionName, newFunction) {\n      if (this.body.eventListeners[UIfunctionName] !== undefined) {\n        this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];\n        this.body.eventListeners[UIfunctionName] = newFunction;\n      } else {\n        throw new Error(\"This UI function does not exist. Typo? You tried: \" + UIfunctionName + \" possible are: \" + stringify$2(keys$3(this.body.eventListeners)));\n      }\n    }\n    /**\n     * Restore the overridden UI functions to their original state.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_unbindTemporaryUIs\",\n    value: function _unbindTemporaryUIs() {\n      for (var functionName in this.temporaryUIFunctions) {\n        if (Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, functionName)) {\n          this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];\n          delete this.temporaryUIFunctions[functionName];\n        }\n      }\n\n      this.temporaryUIFunctions = {};\n    }\n    /**\n     * Unbind the events created by _temporaryBindEvent\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_unbindTemporaryEvents\",\n    value: function _unbindTemporaryEvents() {\n      for (var i = 0; i < this.temporaryEventFunctions.length; i++) {\n        var eventName = this.temporaryEventFunctions[i].event;\n        var boundFunction = this.temporaryEventFunctions[i].boundFunction;\n        this.body.emitter.off(eventName, boundFunction);\n      }\n\n      this.temporaryEventFunctions = [];\n    }\n    /**\n     * Bind an hammer instance to a DOM element.\n     *\n     * @param {Element} domElement\n     * @param {Function} boundFunction\n     */\n\n  }, {\n    key: \"_bindHammerToDiv\",\n    value: function _bindHammerToDiv(domElement, boundFunction) {\n      var hammer = new Hammer$1(domElement, {});\n      onTouch(hammer, boundFunction);\n      this.manipulationHammers.push(hammer);\n    }\n    /**\n     * Neatly clean up temporary edges and nodes\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_cleanupTemporaryNodesAndEdges\",\n    value: function _cleanupTemporaryNodesAndEdges() {\n      // _clean temporary edges\n      for (var i = 0; i < this.temporaryIds.edges.length; i++) {\n        var _context25;\n\n        this.body.edges[this.temporaryIds.edges[i]].disconnect();\n        delete this.body.edges[this.temporaryIds.edges[i]];\n        var indexTempEdge = indexOf$3(_context25 = this.body.edgeIndices).call(_context25, this.temporaryIds.edges[i]);\n\n        if (indexTempEdge !== -1) {\n          var _context26;\n\n          splice$2(_context26 = this.body.edgeIndices).call(_context26, indexTempEdge, 1);\n        }\n      } // _clean temporary nodes\n\n\n      for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {\n        var _context27;\n\n        delete this.body.nodes[this.temporaryIds.nodes[_i]];\n        var indexTempNode = indexOf$3(_context27 = this.body.nodeIndices).call(_context27, this.temporaryIds.nodes[_i]);\n\n        if (indexTempNode !== -1) {\n          var _context28;\n\n          splice$2(_context28 = this.body.nodeIndices).call(_context28, indexTempNode, 1);\n        }\n      }\n\n      this.temporaryIds = {\n        nodes: [],\n        edges: []\n      };\n    } // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//\n\n    /**\n     * the touch is used to get the position of the initial click\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: \"_controlNodeTouch\",\n    value: function _controlNodeTouch(event) {\n      this.selectionHandler.unselectAll();\n      this.lastTouch = this.body.functions.getPointer(event.center);\n      this.lastTouch.translation = assign$2({}, this.body.view.translation); // copy the object\n    }\n    /**\n     * the drag start is used to mark one of the control nodes as selected.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_controlNodeDragStart\",\n    value: function _controlNodeDragStart() {\n      var pointer = this.lastTouch;\n\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n\n      var from = this.body.nodes[this.temporaryIds.nodes[0]];\n      var to = this.body.nodes[this.temporaryIds.nodes[1]];\n      var edge = this.body.edges[this.edgeBeingEditedId];\n      this.selectedControlNode = undefined;\n      var fromSelect = from.isOverlappingWith(pointerObj);\n      var toSelect = to.isOverlappingWith(pointerObj);\n\n      if (fromSelect === true) {\n        this.selectedControlNode = from;\n        edge.edgeType.from = from;\n      } else if (toSelect === true) {\n        this.selectedControlNode = to;\n        edge.edgeType.to = to;\n      } // we use the selection to find the node that is being dragged. We explicitly select it here.\n\n\n      if (this.selectedControlNode !== undefined) {\n        this.selectionHandler.selectObject(this.selectedControlNode);\n      }\n\n      this.body.emitter.emit(\"_redraw\");\n    }\n    /**\n     * dragging the control nodes or the canvas\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: \"_controlNodeDrag\",\n    value: function _controlNodeDrag(event) {\n      this.body.emitter.emit(\"disablePhysics\");\n      var pointer = this.body.functions.getPointer(event.center);\n      var pos = this.canvas.DOMtoCanvas(pointer);\n\n      if (this.selectedControlNode !== undefined) {\n        this.selectedControlNode.x = pos.x;\n        this.selectedControlNode.y = pos.y;\n      } else {\n        this.interactionHandler.onDrag(event);\n      }\n\n      this.body.emitter.emit(\"_redraw\");\n    }\n    /**\n     * connecting or restoring the control nodes.\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: \"_controlNodeDragEnd\",\n    value: function _controlNodeDragEnd(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n\n      var edge = this.body.edges[this.edgeBeingEditedId]; // if the node that was dragged is not a control node, return\n\n      if (this.selectedControlNode === undefined) {\n        return;\n      } // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.\n\n\n      this.selectionHandler.unselectAll();\n\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n\n      var node = undefined;\n\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        if (overlappingNodeIds[i] !== this.selectedControlNode.id) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      } // perform the connection\n\n\n      if (node !== undefined && this.selectedControlNode !== undefined) {\n        if (node.isCluster === true) {\n          alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n        } else {\n          var from = this.body.nodes[this.temporaryIds.nodes[0]];\n\n          if (this.selectedControlNode.id === from.id) {\n            this._performEditEdge(node.id, edge.to.id);\n          } else {\n            this._performEditEdge(edge.from.id, node.id);\n          }\n        }\n      } else {\n        edge.updateEdgeType();\n        this.body.emitter.emit(\"restorePhysics\");\n      }\n\n      this.body.emitter.emit(\"_redraw\");\n    } // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//\n    // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//\n\n    /**\n     * the function bound to the selection event. It checks if you want to connect a cluster and changes the description\n     * to walk the user through the process.\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"_handleConnect\",\n    value: function _handleConnect(event) {\n      // check to avoid double fireing of this function.\n      if (new Date().valueOf() - this.touchTime > 100) {\n        this.lastTouch = this.body.functions.getPointer(event.center);\n        this.lastTouch.translation = assign$2({}, this.body.view.translation); // copy the object\n\n        this.interactionHandler.drag.pointer = this.lastTouch; // Drag pointer is not updated when adding edges\n\n        this.interactionHandler.drag.translation = this.lastTouch.translation;\n        var pointer = this.lastTouch;\n        var node = this.selectionHandler.getNodeAt(pointer);\n\n        if (node !== undefined) {\n          if (node.isCluster === true) {\n            alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n          } else {\n            // create a node the temporary line can look at\n            var targetNode = this._getNewTargetNode(node.x, node.y);\n\n            this.body.nodes[targetNode.id] = targetNode;\n            this.body.nodeIndices.push(targetNode.id); // create a temporary edge\n\n            var connectionEdge = this.body.functions.createEdge({\n              id: \"connectionEdge\" + v4(),\n              from: node.id,\n              to: targetNode.id,\n              physics: false,\n              smooth: {\n                enabled: true,\n                type: \"continuous\",\n                roundness: 0.5\n              }\n            });\n            this.body.edges[connectionEdge.id] = connectionEdge;\n            this.body.edgeIndices.push(connectionEdge.id);\n            this.temporaryIds.nodes.push(targetNode.id);\n            this.temporaryIds.edges.push(connectionEdge.id);\n          }\n        }\n\n        this.touchTime = new Date().valueOf();\n      }\n    }\n    /**\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"_dragControlNode\",\n    value: function _dragControlNode(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer); // remember the edge id\n\n\n      var connectFromId = undefined;\n\n      if (this.temporaryIds.edges[0] !== undefined) {\n        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;\n      } // get the overlapping node but NOT the temporary node;\n\n\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n\n      var node = undefined;\n\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        var _context29; // if the node id is NOT a temporary node, accept the node.\n\n\n        if (indexOf$3(_context29 = this.temporaryIds.nodes).call(_context29, overlappingNodeIds[i]) === -1) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n\n      event.controlEdge = {\n        from: connectFromId,\n        to: node ? node.id : undefined\n      };\n      this.selectionHandler.generateClickEvent(\"controlNodeDragging\", event, pointer);\n\n      if (this.temporaryIds.nodes[0] !== undefined) {\n        var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.\n\n        targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);\n        targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);\n        this.body.emitter.emit(\"_redraw\");\n      } else {\n        this.interactionHandler.onDrag(event);\n      }\n    }\n    /**\n     * Connect the new edge to the target if one exists, otherwise remove temp line\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: \"_finishConnect\",\n    value: function _finishConnect(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer); // remember the edge id\n\n\n      var connectFromId = undefined;\n\n      if (this.temporaryIds.edges[0] !== undefined) {\n        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;\n      } // get the overlapping node but NOT the temporary node;\n\n\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n\n      var node = undefined;\n\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        var _context30; // if the node id is NOT a temporary node, accept the node.\n\n\n        if (indexOf$3(_context30 = this.temporaryIds.nodes).call(_context30, overlappingNodeIds[i]) === -1) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      } // clean temporary nodes and edges.\n\n\n      this._cleanupTemporaryNodesAndEdges(); // perform the connection\n\n\n      if (node !== undefined) {\n        if (node.isCluster === true) {\n          alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n        } else {\n          if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {\n            this._performAddEdge(connectFromId, node.id);\n          }\n        }\n      }\n\n      event.controlEdge = {\n        from: connectFromId,\n        to: node ? node.id : undefined\n      };\n      this.selectionHandler.generateClickEvent(\"controlNodeDragEnd\", event, pointer); // No need to do _generateclickevent('dragEnd') here, the regular dragEnd event fires.\n\n      this.body.emitter.emit(\"_redraw\");\n    }\n    /**\n     *\n     * @param {Event} event\n     * @private\n     */\n\n  }, {\n    key: \"_dragStartEdge\",\n    value: function _dragStartEdge(event) {\n      var pointer = this.lastTouch;\n      this.selectionHandler.generateClickEvent(\"dragStart\", event, pointer, undefined, true);\n    } // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//\n    // ------------------------------ Performing all the actual data manipulation ------------------------//\n\n    /**\n     * Adds a node on the specified location\n     *\n     * @param {object} clickData\n     * @private\n     */\n\n  }, {\n    key: \"_performAddNode\",\n    value: function _performAddNode(clickData) {\n      var _this4 = this;\n\n      var defaultData = {\n        id: v4(),\n        x: clickData.pointer.canvas.x,\n        y: clickData.pointer.canvas.y,\n        label: \"new\"\n      };\n\n      if (typeof this.options.addNode === \"function\") {\n        if (this.options.addNode.length === 2) {\n          this.options.addNode(defaultData, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === \"addNode\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback\n              _this4.body.data.nodes.getDataSet().add(finalizedData);\n            }\n\n            _this4.showManipulatorToolbar();\n          });\n        } else {\n          this.showManipulatorToolbar();\n          throw new Error(\"The function for add does not support two arguments (data,callback)\");\n        }\n      } else {\n        this.body.data.nodes.getDataSet().add(defaultData);\n        this.showManipulatorToolbar();\n      }\n    }\n    /**\n     * connect two nodes with a new edge.\n     *\n     * @param {Node.id} sourceNodeId\n     * @param {Node.id} targetNodeId\n     * @private\n     */\n\n  }, {\n    key: \"_performAddEdge\",\n    value: function _performAddEdge(sourceNodeId, targetNodeId) {\n      var _this5 = this;\n\n      var defaultData = {\n        from: sourceNodeId,\n        to: targetNodeId\n      };\n\n      if (typeof this.options.addEdge === \"function\") {\n        if (this.options.addEdge.length === 2) {\n          this.options.addEdge(defaultData, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === \"addEdge\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback\n              _this5.body.data.edges.getDataSet().add(finalizedData);\n\n              _this5.selectionHandler.unselectAll();\n\n              _this5.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for connect does not support two arguments (data,callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().add(defaultData);\n        this.selectionHandler.unselectAll();\n        this.showManipulatorToolbar();\n      }\n    }\n    /**\n     * connect two nodes with a new edge.\n     *\n     * @param {Node.id} sourceNodeId\n     * @param {Node.id} targetNodeId\n     * @private\n     */\n\n  }, {\n    key: \"_performEditEdge\",\n    value: function _performEditEdge(sourceNodeId, targetNodeId) {\n      var _this6 = this;\n\n      var defaultData = {\n        id: this.edgeBeingEditedId,\n        from: sourceNodeId,\n        to: targetNodeId,\n        label: this.body.data.edges.get(this.edgeBeingEditedId).label\n      };\n      var eeFunct = this.options.editEdge;\n\n      if (_typeof_1(eeFunct) === \"object\") {\n        eeFunct = eeFunct.editWithoutDrag;\n      }\n\n      if (typeof eeFunct === \"function\") {\n        if (eeFunct.length === 2) {\n          eeFunct(defaultData, function (finalizedData) {\n            if (finalizedData === null || finalizedData === undefined || _this6.inMode !== \"editEdge\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n              _this6.body.edges[defaultData.id].updateEdgeType();\n\n              _this6.body.emitter.emit(\"_redraw\");\n\n              _this6.showManipulatorToolbar();\n            } else {\n              _this6.body.data.edges.getDataSet().update(finalizedData);\n\n              _this6.selectionHandler.unselectAll();\n\n              _this6.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().update(defaultData);\n        this.selectionHandler.unselectAll();\n        this.showManipulatorToolbar();\n      }\n    }\n  }]);\n  return ManipulationSystem;\n}();\n\nvar htmlColors = {\n  black: \"#000000\",\n  navy: \"#000080\",\n  darkblue: \"#00008B\",\n  mediumblue: \"#0000CD\",\n  blue: \"#0000FF\",\n  darkgreen: \"#006400\",\n  green: \"#008000\",\n  teal: \"#008080\",\n  darkcyan: \"#008B8B\",\n  deepskyblue: \"#00BFFF\",\n  darkturquoise: \"#00CED1\",\n  mediumspringgreen: \"#00FA9A\",\n  lime: \"#00FF00\",\n  springgreen: \"#00FF7F\",\n  aqua: \"#00FFFF\",\n  cyan: \"#00FFFF\",\n  midnightblue: \"#191970\",\n  dodgerblue: \"#1E90FF\",\n  lightseagreen: \"#20B2AA\",\n  forestgreen: \"#228B22\",\n  seagreen: \"#2E8B57\",\n  darkslategray: \"#2F4F4F\",\n  limegreen: \"#32CD32\",\n  mediumseagreen: \"#3CB371\",\n  turquoise: \"#40E0D0\",\n  royalblue: \"#4169E1\",\n  steelblue: \"#4682B4\",\n  darkslateblue: \"#483D8B\",\n  mediumturquoise: \"#48D1CC\",\n  indigo: \"#4B0082\",\n  darkolivegreen: \"#556B2F\",\n  cadetblue: \"#5F9EA0\",\n  cornflowerblue: \"#6495ED\",\n  mediumaquamarine: \"#66CDAA\",\n  dimgray: \"#696969\",\n  slateblue: \"#6A5ACD\",\n  olivedrab: \"#6B8E23\",\n  slategray: \"#708090\",\n  lightslategray: \"#778899\",\n  mediumslateblue: \"#7B68EE\",\n  lawngreen: \"#7CFC00\",\n  chartreuse: \"#7FFF00\",\n  aquamarine: \"#7FFFD4\",\n  maroon: \"#800000\",\n  purple: \"#800080\",\n  olive: \"#808000\",\n  gray: \"#808080\",\n  skyblue: \"#87CEEB\",\n  lightskyblue: \"#87CEFA\",\n  blueviolet: \"#8A2BE2\",\n  darkred: \"#8B0000\",\n  darkmagenta: \"#8B008B\",\n  saddlebrown: \"#8B4513\",\n  darkseagreen: \"#8FBC8F\",\n  lightgreen: \"#90EE90\",\n  mediumpurple: \"#9370D8\",\n  darkviolet: \"#9400D3\",\n  palegreen: \"#98FB98\",\n  darkorchid: \"#9932CC\",\n  yellowgreen: \"#9ACD32\",\n  sienna: \"#A0522D\",\n  brown: \"#A52A2A\",\n  darkgray: \"#A9A9A9\",\n  lightblue: \"#ADD8E6\",\n  greenyellow: \"#ADFF2F\",\n  paleturquoise: \"#AFEEEE\",\n  lightsteelblue: \"#B0C4DE\",\n  powderblue: \"#B0E0E6\",\n  firebrick: \"#B22222\",\n  darkgoldenrod: \"#B8860B\",\n  mediumorchid: \"#BA55D3\",\n  rosybrown: \"#BC8F8F\",\n  darkkhaki: \"#BDB76B\",\n  silver: \"#C0C0C0\",\n  mediumvioletred: \"#C71585\",\n  indianred: \"#CD5C5C\",\n  peru: \"#CD853F\",\n  chocolate: \"#D2691E\",\n  tan: \"#D2B48C\",\n  lightgrey: \"#D3D3D3\",\n  palevioletred: \"#D87093\",\n  thistle: \"#D8BFD8\",\n  orchid: \"#DA70D6\",\n  goldenrod: \"#DAA520\",\n  crimson: \"#DC143C\",\n  gainsboro: \"#DCDCDC\",\n  plum: \"#DDA0DD\",\n  burlywood: \"#DEB887\",\n  lightcyan: \"#E0FFFF\",\n  lavender: \"#E6E6FA\",\n  darksalmon: \"#E9967A\",\n  violet: \"#EE82EE\",\n  palegoldenrod: \"#EEE8AA\",\n  lightcoral: \"#F08080\",\n  khaki: \"#F0E68C\",\n  aliceblue: \"#F0F8FF\",\n  honeydew: \"#F0FFF0\",\n  azure: \"#F0FFFF\",\n  sandybrown: \"#F4A460\",\n  wheat: \"#F5DEB3\",\n  beige: \"#F5F5DC\",\n  whitesmoke: \"#F5F5F5\",\n  mintcream: \"#F5FFFA\",\n  ghostwhite: \"#F8F8FF\",\n  salmon: \"#FA8072\",\n  antiquewhite: \"#FAEBD7\",\n  linen: \"#FAF0E6\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  oldlace: \"#FDF5E6\",\n  red: \"#FF0000\",\n  fuchsia: \"#FF00FF\",\n  magenta: \"#FF00FF\",\n  deeppink: \"#FF1493\",\n  orangered: \"#FF4500\",\n  tomato: \"#FF6347\",\n  hotpink: \"#FF69B4\",\n  coral: \"#FF7F50\",\n  darkorange: \"#FF8C00\",\n  lightsalmon: \"#FFA07A\",\n  orange: \"#FFA500\",\n  lightpink: \"#FFB6C1\",\n  pink: \"#FFC0CB\",\n  gold: \"#FFD700\",\n  peachpuff: \"#FFDAB9\",\n  navajowhite: \"#FFDEAD\",\n  moccasin: \"#FFE4B5\",\n  bisque: \"#FFE4C4\",\n  mistyrose: \"#FFE4E1\",\n  blanchedalmond: \"#FFEBCD\",\n  papayawhip: \"#FFEFD5\",\n  lavenderblush: \"#FFF0F5\",\n  seashell: \"#FFF5EE\",\n  cornsilk: \"#FFF8DC\",\n  lemonchiffon: \"#FFFACD\",\n  floralwhite: \"#FFFAF0\",\n  snow: \"#FFFAFA\",\n  yellow: \"#FFFF00\",\n  lightyellow: \"#FFFFE0\",\n  ivory: \"#FFFFF0\",\n  white: \"#FFFFFF\"\n};\n/**\n * @param {number} [pixelRatio=1]\n */\n\nvar ColorPicker = /*#__PURE__*/function () {\n  /**\n   * @param {number} [pixelRatio=1]\n   */\n  function ColorPicker() {\n    var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    classCallCheck(this, ColorPicker);\n    this.pixelRatio = pixelRatio;\n    this.generated = false;\n    this.centerCoordinates = {\n      x: 289 / 2,\n      y: 289 / 2\n    };\n    this.r = 289 * 0.49;\n    this.color = {\n      r: 255,\n      g: 255,\n      b: 255,\n      a: 1.0\n    };\n    this.hueCircle = undefined;\n    this.initialColor = {\n      r: 255,\n      g: 255,\n      b: 255,\n      a: 1.0\n    };\n    this.previousColor = undefined;\n    this.applied = false; // bound by\n\n    this.updateCallback = function () {};\n\n    this.closeCallback = function () {}; // create all DOM elements\n\n\n    this._create();\n  }\n  /**\n   * this inserts the colorPicker into a div from the DOM\n   *\n   * @param {Element} container\n   */\n\n\n  createClass(ColorPicker, [{\n    key: \"insertTo\",\n    value: function insertTo(container) {\n      if (this.hammer !== undefined) {\n        this.hammer.destroy();\n        this.hammer = undefined;\n      }\n\n      this.container = container;\n      this.container.appendChild(this.frame);\n\n      this._bindHammer();\n\n      this._setSize();\n    }\n    /**\n     * the callback is executed on apply and save. Bind it to the application\n     *\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"setUpdateCallback\",\n    value: function setUpdateCallback(callback) {\n      if (typeof callback === \"function\") {\n        this.updateCallback = callback;\n      } else {\n        throw new Error(\"Function attempted to set as colorPicker update callback is not a function.\");\n      }\n    }\n    /**\n     * the callback is executed on apply and save. Bind it to the application\n     *\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"setCloseCallback\",\n    value: function setCloseCallback(callback) {\n      if (typeof callback === \"function\") {\n        this.closeCallback = callback;\n      } else {\n        throw new Error(\"Function attempted to set as colorPicker closing callback is not a function.\");\n      }\n    }\n    /**\n     *\n     * @param {string} color\n     * @returns {string}\n     * @private\n     */\n\n  }, {\n    key: \"_isColorString\",\n    value: function _isColorString(color) {\n      if (typeof color === \"string\") {\n        return htmlColors[color];\n      }\n    }\n    /**\n     * Set the color of the colorPicker\n     * Supported formats:\n     * 'red'                   --> HTML color string\n     * '#ffffff'               --> hex string\n     * 'rgb(255,255,255)'      --> rgb string\n     * 'rgba(255,255,255,1.0)' --> rgba string\n     * {r:255,g:255,b:255}     --> rgb object\n     * {r:255,g:255,b:255,a:1.0} --> rgba object\n     *\n     * @param {string | object} color\n     * @param {boolean} [setInitial=true]\n     */\n\n  }, {\n    key: \"setColor\",\n    value: function setColor(color) {\n      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (color === \"none\") {\n        return;\n      }\n\n      var rgba; // if a html color shorthand is used, convert to hex\n\n      var htmlColor = this._isColorString(color);\n\n      if (htmlColor !== undefined) {\n        color = htmlColor;\n      } // check format\n\n\n      if (isString(color) === true) {\n        if (isValidRGB(color) === true) {\n          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(\",\");\n          rgba = {\n            r: rgbaArray[0],\n            g: rgbaArray[1],\n            b: rgbaArray[2],\n            a: 1.0\n          };\n        } else if (isValidRGBA(color) === true) {\n          var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(\",\");\n\n          rgba = {\n            r: _rgbaArray[0],\n            g: _rgbaArray[1],\n            b: _rgbaArray[2],\n            a: _rgbaArray[3]\n          };\n        } else if (isValidHex(color) === true) {\n          var rgbObj = hexToRGB(color);\n          rgba = {\n            r: rgbObj.r,\n            g: rgbObj.g,\n            b: rgbObj.b,\n            a: 1.0\n          };\n        }\n      } else {\n        if (color instanceof Object) {\n          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {\n            var alpha = color.a !== undefined ? color.a : \"1.0\";\n            rgba = {\n              r: color.r,\n              g: color.g,\n              b: color.b,\n              a: alpha\n            };\n          }\n        }\n      } // set color\n\n\n      if (rgba === undefined) {\n        throw new Error(\"Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: \" + stringify$2(color));\n      } else {\n        this._setColor(rgba, setInitial);\n      }\n    }\n    /**\n     * this shows the color picker.\n     * The hue circle is constructed once and stored.\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.closeCallback !== undefined) {\n        this.closeCallback();\n        this.closeCallback = undefined;\n      }\n\n      this.applied = false;\n      this.frame.style.display = \"block\";\n\n      this._generateHueCircle();\n    } // ------------------------------------------ PRIVATE ----------------------------- //\n\n    /**\n     * Hide the picker. Is called by the cancel button.\n     * Optional boolean to store the previous color for easy access later on.\n     *\n     * @param {boolean} [storePrevious=true]\n     * @private\n     */\n\n  }, {\n    key: \"_hide\",\n    value: function _hide() {\n      var _this = this;\n\n      var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true; // store the previous color for next time;\n\n      if (storePrevious === true) {\n        this.previousColor = assign$2({}, this.color);\n      }\n\n      if (this.applied === true) {\n        this.updateCallback(this.initialColor);\n      }\n\n      this.frame.style.display = \"none\"; // call the closing callback, restoring the onclick method.\n      // this is in a setTimeout because it will trigger the show again before the click is done.\n\n      setTimeout$2(function () {\n        if (_this.closeCallback !== undefined) {\n          _this.closeCallback();\n\n          _this.closeCallback = undefined;\n        }\n      }, 0);\n    }\n    /**\n     * bound to the save button. Saves and hides.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_save\",\n    value: function _save() {\n      this.updateCallback(this.color);\n      this.applied = false;\n\n      this._hide();\n    }\n    /**\n     * Bound to apply button. Saves but does not close. Is undone by the cancel button.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_apply\",\n    value: function _apply() {\n      this.applied = true;\n      this.updateCallback(this.color);\n\n      this._updatePicker(this.color);\n    }\n    /**\n     * load the color from the previous session.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_loadLast\",\n    value: function _loadLast() {\n      if (this.previousColor !== undefined) {\n        this.setColor(this.previousColor, false);\n      } else {\n        alert(\"There is no last color to load...\");\n      }\n    }\n    /**\n     * set the color, place the picker\n     *\n     * @param {object} rgba\n     * @param {boolean} [setInitial=true]\n     * @private\n     */\n\n  }, {\n    key: \"_setColor\",\n    value: function _setColor(rgba) {\n      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true; // store the initial color\n\n      if (setInitial === true) {\n        this.initialColor = assign$2({}, rgba);\n      }\n\n      this.color = rgba;\n      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);\n      var angleConvert = 2 * Math.PI;\n      var radius = this.r * hsv.s;\n      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);\n      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);\n      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + \"px\";\n      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + \"px\";\n\n      this._updatePicker(rgba);\n    }\n    /**\n     * bound to opacity control\n     *\n     * @param {number} value\n     * @private\n     */\n\n  }, {\n    key: \"_setOpacity\",\n    value: function _setOpacity(value) {\n      this.color.a = value / 100;\n\n      this._updatePicker(this.color);\n    }\n    /**\n     * bound to brightness control\n     *\n     * @param {number} value\n     * @private\n     */\n\n  }, {\n    key: \"_setBrightness\",\n    value: function _setBrightness(value) {\n      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);\n      hsv.v = value / 100;\n      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);\n      rgba[\"a\"] = this.color.a;\n      this.color = rgba;\n\n      this._updatePicker();\n    }\n    /**\n     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.\n     *\n     * @param {object} rgba\n     * @private\n     */\n\n  }, {\n    key: \"_updatePicker\",\n    value: function _updatePicker() {\n      var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;\n      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);\n      var ctx = this.colorPickerCanvas.getContext(\"2d\");\n\n      if (this.pixelRation === undefined) {\n        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n      }\n\n      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); // clear the canvas\n\n      var w = this.colorPickerCanvas.clientWidth;\n      var h = this.colorPickerCanvas.clientHeight;\n      ctx.clearRect(0, 0, w, h);\n      ctx.putImageData(this.hueCircle, 0, 0);\n      ctx.fillStyle = \"rgba(0,0,0,\" + (1 - hsv.v) + \")\";\n      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);\n      fill$2(ctx).call(ctx);\n      this.brightnessRange.value = 100 * hsv.v;\n      this.opacityRange.value = 100 * rgba.a;\n      this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\";\n      this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n    }\n    /**\n     * used by create to set the size of the canvas.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setSize\",\n    value: function _setSize() {\n      this.colorPickerCanvas.style.width = \"100%\";\n      this.colorPickerCanvas.style.height = \"100%\";\n      this.colorPickerCanvas.width = 289 * this.pixelRatio;\n      this.colorPickerCanvas.height = 289 * this.pixelRatio;\n    }\n    /**\n     * create all dom elements\n     * TODO: cleanup, lots of similar dom elements\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      var _context, _context2, _context3, _context4;\n\n      this.frame = document.createElement(\"div\");\n      this.frame.className = \"vis-color-picker\";\n      this.colorPickerDiv = document.createElement(\"div\");\n      this.colorPickerSelector = document.createElement(\"div\");\n      this.colorPickerSelector.className = \"vis-selector\";\n      this.colorPickerDiv.appendChild(this.colorPickerSelector);\n      this.colorPickerCanvas = document.createElement(\"canvas\");\n      this.colorPickerDiv.appendChild(this.colorPickerCanvas);\n\n      if (!this.colorPickerCanvas.getContext) {\n        var noCanvas = document.createElement(\"DIV\");\n        noCanvas.style.color = \"red\";\n        noCanvas.style.fontWeight = \"bold\";\n        noCanvas.style.padding = \"10px\";\n        noCanvas.innerHTML = \"Error: your browser does not support HTML canvas\";\n        this.colorPickerCanvas.appendChild(noCanvas);\n      } else {\n        var ctx = this.colorPickerCanvas.getContext(\"2d\");\n        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n        this.colorPickerCanvas.getContext(\"2d\").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n      }\n\n      this.colorPickerDiv.className = \"vis-color\";\n      this.opacityDiv = document.createElement(\"div\");\n      this.opacityDiv.className = \"vis-opacity\";\n      this.brightnessDiv = document.createElement(\"div\");\n      this.brightnessDiv.className = \"vis-brightness\";\n      this.arrowDiv = document.createElement(\"div\");\n      this.arrowDiv.className = \"vis-arrow\";\n      this.opacityRange = document.createElement(\"input\");\n\n      try {\n        this.opacityRange.type = \"range\"; // Not supported on IE9\n\n        this.opacityRange.min = \"0\";\n        this.opacityRange.max = \"100\";\n      } catch (err) {// TODO: Add some error handling.\n      }\n\n      this.opacityRange.value = \"100\";\n      this.opacityRange.className = \"vis-range\";\n      this.brightnessRange = document.createElement(\"input\");\n\n      try {\n        this.brightnessRange.type = \"range\"; // Not supported on IE9\n\n        this.brightnessRange.min = \"0\";\n        this.brightnessRange.max = \"100\";\n      } catch (err) {// TODO: Add some error handling.\n      }\n\n      this.brightnessRange.value = \"100\";\n      this.brightnessRange.className = \"vis-range\";\n      this.opacityDiv.appendChild(this.opacityRange);\n      this.brightnessDiv.appendChild(this.brightnessRange);\n      var me = this;\n\n      this.opacityRange.onchange = function () {\n        me._setOpacity(this.value);\n      };\n\n      this.opacityRange.oninput = function () {\n        me._setOpacity(this.value);\n      };\n\n      this.brightnessRange.onchange = function () {\n        me._setBrightness(this.value);\n      };\n\n      this.brightnessRange.oninput = function () {\n        me._setBrightness(this.value);\n      };\n\n      this.brightnessLabel = document.createElement(\"div\");\n      this.brightnessLabel.className = \"vis-label vis-brightness\";\n      this.brightnessLabel.innerHTML = \"brightness:\";\n      this.opacityLabel = document.createElement(\"div\");\n      this.opacityLabel.className = \"vis-label vis-opacity\";\n      this.opacityLabel.innerHTML = \"opacity:\";\n      this.newColorDiv = document.createElement(\"div\");\n      this.newColorDiv.className = \"vis-new-color\";\n      this.newColorDiv.innerHTML = \"new\";\n      this.initialColorDiv = document.createElement(\"div\");\n      this.initialColorDiv.className = \"vis-initial-color\";\n      this.initialColorDiv.innerHTML = \"initial\";\n      this.cancelButton = document.createElement(\"div\");\n      this.cancelButton.className = \"vis-button vis-cancel\";\n      this.cancelButton.innerHTML = \"cancel\";\n      this.cancelButton.onclick = bind$2(_context = this._hide).call(_context, this, false);\n      this.applyButton = document.createElement(\"div\");\n      this.applyButton.className = \"vis-button vis-apply\";\n      this.applyButton.innerHTML = \"apply\";\n      this.applyButton.onclick = bind$2(_context2 = this._apply).call(_context2, this);\n      this.saveButton = document.createElement(\"div\");\n      this.saveButton.className = \"vis-button vis-save\";\n      this.saveButton.innerHTML = \"save\";\n      this.saveButton.onclick = bind$2(_context3 = this._save).call(_context3, this);\n      this.loadButton = document.createElement(\"div\");\n      this.loadButton.className = \"vis-button vis-load\";\n      this.loadButton.innerHTML = \"load last\";\n      this.loadButton.onclick = bind$2(_context4 = this._loadLast).call(_context4, this);\n      this.frame.appendChild(this.colorPickerDiv);\n      this.frame.appendChild(this.arrowDiv);\n      this.frame.appendChild(this.brightnessLabel);\n      this.frame.appendChild(this.brightnessDiv);\n      this.frame.appendChild(this.opacityLabel);\n      this.frame.appendChild(this.opacityDiv);\n      this.frame.appendChild(this.newColorDiv);\n      this.frame.appendChild(this.initialColorDiv);\n      this.frame.appendChild(this.cancelButton);\n      this.frame.appendChild(this.applyButton);\n      this.frame.appendChild(this.saveButton);\n      this.frame.appendChild(this.loadButton);\n    }\n    /**\n     * bind hammer to the color picker\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_bindHammer\",\n    value: function _bindHammer() {\n      var _this2 = this;\n\n      this.drag = {};\n      this.pinch = {};\n      this.hammer = new Hammer$1(this.colorPickerCanvas);\n      this.hammer.get(\"pinch\").set({\n        enable: true\n      });\n      onTouch(this.hammer, function (event) {\n        _this2._moveSelector(event);\n      });\n      this.hammer.on(\"tap\", function (event) {\n        _this2._moveSelector(event);\n      });\n      this.hammer.on(\"panstart\", function (event) {\n        _this2._moveSelector(event);\n      });\n      this.hammer.on(\"panmove\", function (event) {\n        _this2._moveSelector(event);\n      });\n      this.hammer.on(\"panend\", function (event) {\n        _this2._moveSelector(event);\n      });\n    }\n    /**\n     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_generateHueCircle\",\n    value: function _generateHueCircle() {\n      if (this.generated === false) {\n        var ctx = this.colorPickerCanvas.getContext(\"2d\");\n\n        if (this.pixelRation === undefined) {\n          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n        }\n\n        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0); // clear the canvas\n\n        var w = this.colorPickerCanvas.clientWidth;\n        var h = this.colorPickerCanvas.clientHeight;\n        ctx.clearRect(0, 0, w, h); // draw hue circle\n\n        var x, y, hue, sat;\n        this.centerCoordinates = {\n          x: w * 0.5,\n          y: h * 0.5\n        };\n        this.r = 0.49 * w;\n        var angleConvert = 2 * Math.PI / 360;\n        var hfac = 1 / 360;\n        var sfac = 1 / this.r;\n        var rgb;\n\n        for (hue = 0; hue < 360; hue++) {\n          for (sat = 0; sat < this.r; sat++) {\n            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);\n            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);\n            rgb = HSVToRGB(hue * hfac, sat * sfac, 1);\n            ctx.fillStyle = \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \")\";\n            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);\n          }\n        }\n\n        ctx.strokeStyle = \"rgba(0,0,0,1)\";\n        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);\n        ctx.stroke();\n        this.hueCircle = ctx.getImageData(0, 0, w, h);\n      }\n\n      this.generated = true;\n    }\n    /**\n     * move the selector. This is called by hammer functions.\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n\n  }, {\n    key: \"_moveSelector\",\n    value: function _moveSelector(event) {\n      var rect = this.colorPickerDiv.getBoundingClientRect();\n      var left = event.center.x - rect.left;\n      var top = event.center.y - rect.top;\n      var centerY = 0.5 * this.colorPickerDiv.clientHeight;\n      var centerX = 0.5 * this.colorPickerDiv.clientWidth;\n      var x = left - centerX;\n      var y = top - centerY;\n      var angle = Math.atan2(x, y);\n      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);\n      var newTop = Math.cos(angle) * radius + centerY;\n      var newLeft = Math.sin(angle) * radius + centerX;\n      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + \"px\";\n      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + \"px\"; // set color\n\n      var h = angle / (2 * Math.PI);\n      h = h < 0 ? h + 1 : h;\n      var s = radius / this.r;\n      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);\n      hsv.h = h;\n      hsv.s = s;\n      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);\n      rgba[\"a\"] = this.color.a;\n      this.color = rgba; // update previews\n\n      this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\";\n      this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n    }\n  }]);\n  return ColorPicker;\n}();\n/**\n * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.\n * Boolean options are recognised as Boolean\n * Number options should be written as array: [default value, min value, max value, stepsize]\n * Colors should be written as array: ['color', '#ffffff']\n * Strings with should be written as array: [option1, option2, option3, ..]\n *\n * The options are matched with their counterparts in each of the modules and the values used in the configuration are\n */\n\n\nvar Configurator = /*#__PURE__*/function () {\n  /**\n   * @param {object} parentModule        | the location where parentModule.setOptions() can be called\n   * @param {object} defaultContainer    | the default container of the module\n   * @param {object} configureOptions    | the fully configured and predefined options set found in allOptions.js\n   * @param {number} pixelRatio          | canvas pixel ratio\n   */\n  function Configurator(parentModule, defaultContainer, configureOptions) {\n    var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    classCallCheck(this, Configurator);\n    this.parent = parentModule;\n    this.changedOptions = [];\n    this.container = defaultContainer;\n    this.allowCreation = false;\n    this.options = {};\n    this.initialized = false;\n    this.popupCounter = 0;\n    this.defaultOptions = {\n      enabled: false,\n      filter: true,\n      container: undefined,\n      showButton: true\n    };\n    assign$2(this.options, this.defaultOptions);\n    this.configureOptions = configureOptions;\n    this.moduleOptions = {};\n    this.domElements = [];\n    this.popupDiv = {};\n    this.popupLimit = 5;\n    this.popupHistory = {};\n    this.colorPicker = new ColorPicker(pixelRatio);\n    this.wrapper = undefined;\n  }\n  /**\n   * refresh all options.\n   * Because all modules parse their options by themselves, we just use their options. We copy them here.\n   *\n   * @param {object} options\n   */\n\n\n  createClass(Configurator, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // reset the popup history because the indices may have been changed.\n        this.popupHistory = {};\n\n        this._removePopup();\n\n        var enabled = true;\n\n        if (typeof options === \"string\") {\n          this.options.filter = options;\n        } else if (isArray$5(options)) {\n          this.options.filter = options.join();\n        } else if (_typeof_1(options) === \"object\") {\n          if (options == null) {\n            throw new TypeError(\"options cannot be null\");\n          }\n\n          if (options.container !== undefined) {\n            this.options.container = options.container;\n          }\n\n          if (filter$2(options) !== undefined) {\n            this.options.filter = filter$2(options);\n          }\n\n          if (options.showButton !== undefined) {\n            this.options.showButton = options.showButton;\n          }\n\n          if (options.enabled !== undefined) {\n            enabled = options.enabled;\n          }\n        } else if (typeof options === \"boolean\") {\n          this.options.filter = true;\n          enabled = options;\n        } else if (typeof options === \"function\") {\n          this.options.filter = options;\n          enabled = true;\n        }\n\n        if (filter$2(this.options) === false) {\n          enabled = false;\n        }\n\n        this.options.enabled = enabled;\n      }\n\n      this._clean();\n    }\n    /**\n     *\n     * @param {object} moduleOptions\n     */\n\n  }, {\n    key: \"setModuleOptions\",\n    value: function setModuleOptions(moduleOptions) {\n      this.moduleOptions = moduleOptions;\n\n      if (this.options.enabled === true) {\n        this._clean();\n\n        if (this.options.container !== undefined) {\n          this.container = this.options.container;\n        }\n\n        this._create();\n      }\n    }\n    /**\n     * Create all DOM elements\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      this._clean();\n\n      this.changedOptions = [];\n      var filter = filter$2(this.options);\n      var counter = 0;\n      var show = false;\n\n      for (var option in this.configureOptions) {\n        if (Object.prototype.hasOwnProperty.call(this.configureOptions, option)) {\n          this.allowCreation = false;\n          show = false;\n\n          if (typeof filter === \"function\") {\n            show = filter(option, []);\n            show = show || this._handleObject(this.configureOptions[option], [option], true);\n          } else if (filter === true || indexOf$3(filter).call(filter, option) !== -1) {\n            show = true;\n          }\n\n          if (show !== false) {\n            this.allowCreation = true; // linebreak between categories\n\n            if (counter > 0) {\n              this._makeItem([]);\n            } // a header for the category\n\n\n            this._makeHeader(option); // get the sub options\n\n\n            this._handleObject(this.configureOptions[option], [option]);\n          }\n\n          counter++;\n        }\n      }\n\n      this._makeButton();\n\n      this._push(); //~ this.colorPicker.insertTo(this.container);\n\n    }\n    /**\n     * draw all DOM elements on the screen\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_push\",\n    value: function _push() {\n      this.wrapper = document.createElement(\"div\");\n      this.wrapper.className = \"vis-configuration-wrapper\";\n      this.container.appendChild(this.wrapper);\n\n      for (var i = 0; i < this.domElements.length; i++) {\n        this.wrapper.appendChild(this.domElements[i]);\n      }\n\n      this._showPopupIfNeeded();\n    }\n    /**\n     * delete all DOM elements\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      for (var i = 0; i < this.domElements.length; i++) {\n        this.wrapper.removeChild(this.domElements[i]);\n      }\n\n      if (this.wrapper !== undefined) {\n        this.container.removeChild(this.wrapper);\n        this.wrapper = undefined;\n      }\n\n      this.domElements = [];\n\n      this._removePopup();\n    }\n    /**\n     * get the value from the actualOptions if it exists\n     *\n     * @param {Array} path    | where to look for the actual option\n     * @returns {*}\n     * @private\n     */\n\n  }, {\n    key: \"_getValue\",\n    value: function _getValue(path) {\n      var base = this.moduleOptions;\n\n      for (var i = 0; i < path.length; i++) {\n        if (base[path[i]] !== undefined) {\n          base = base[path[i]];\n        } else {\n          base = undefined;\n          break;\n        }\n      }\n\n      return base;\n    }\n    /**\n     * all option elements are wrapped in an item\n     *\n     * @param {Array} path    | where to look for the actual option\n     * @param {Array.<Element>} domElements\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"_makeItem\",\n    value: function _makeItem(path) {\n      if (this.allowCreation === true) {\n        var item = document.createElement(\"div\");\n        item.className = \"vis-configuration vis-config-item vis-config-s\" + path.length;\n\n        for (var _len = arguments.length, domElements = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          domElements[_key - 1] = arguments[_key];\n        }\n\n        forEach$2(domElements).call(domElements, function (element) {\n          item.appendChild(element);\n        });\n        this.domElements.push(item);\n        return this.domElements.length;\n      }\n\n      return 0;\n    }\n    /**\n     * header for major subjects\n     *\n     * @param {string} name\n     * @private\n     */\n\n  }, {\n    key: \"_makeHeader\",\n    value: function _makeHeader(name) {\n      var div = document.createElement(\"div\");\n      div.className = \"vis-configuration vis-config-header\";\n      div.innerHTML = name;\n\n      this._makeItem([], div);\n    }\n    /**\n     * make a label, if it is an object label, it gets different styling.\n     *\n     * @param {string} name\n     * @param {Array} path    | where to look for the actual option\n     * @param {string} objectLabel\n     * @returns {HTMLElement}\n     * @private\n     */\n\n  }, {\n    key: \"_makeLabel\",\n    value: function _makeLabel(name, path) {\n      var objectLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var div = document.createElement(\"div\");\n      div.className = \"vis-configuration vis-config-label vis-config-s\" + path.length;\n\n      if (objectLabel === true) {\n        div.innerHTML = \"<i><b>\" + name + \":</b></i>\";\n      } else {\n        div.innerHTML = name + \":\";\n      }\n\n      return div;\n    }\n    /**\n     * make a dropdown list for multiple possible string optoins\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: \"_makeDropdown\",\n    value: function _makeDropdown(arr, value, path) {\n      var select = document.createElement(\"select\");\n      select.className = \"vis-configuration vis-config-select\";\n      var selectedValue = 0;\n\n      if (value !== undefined) {\n        if (indexOf$3(arr).call(arr, value) !== -1) {\n          selectedValue = indexOf$3(arr).call(arr, value);\n        }\n      }\n\n      for (var i = 0; i < arr.length; i++) {\n        var option = document.createElement(\"option\");\n        option.value = arr[i];\n\n        if (i === selectedValue) {\n          option.selected = \"selected\";\n        }\n\n        option.innerHTML = arr[i];\n        select.appendChild(option);\n      }\n\n      var me = this;\n\n      select.onchange = function () {\n        me._update(this.value, path);\n      };\n\n      var label = this._makeLabel(path[path.length - 1], path);\n\n      this._makeItem(path, label, select);\n    }\n    /**\n     * make a range object for numeric options\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: \"_makeRange\",\n    value: function _makeRange(arr, value, path) {\n      var defaultValue = arr[0];\n      var min = arr[1];\n      var max = arr[2];\n      var step = arr[3];\n      var range = document.createElement(\"input\");\n      range.className = \"vis-configuration vis-config-range\";\n\n      try {\n        range.type = \"range\"; // not supported on IE9\n\n        range.min = min;\n        range.max = max;\n      } catch (err) {// TODO: Add some error handling.\n      }\n\n      range.step = step; // set up the popup settings in case they are needed.\n\n      var popupString = \"\";\n      var popupValue = 0;\n\n      if (value !== undefined) {\n        var factor = 1.2;\n\n        if (value < 0 && value * factor < min) {\n          range.min = Math.ceil(value * factor);\n          popupValue = range.min;\n          popupString = \"range increased\";\n        } else if (value / factor < min) {\n          range.min = Math.ceil(value / factor);\n          popupValue = range.min;\n          popupString = \"range increased\";\n        }\n\n        if (value * factor > max && max !== 1) {\n          range.max = Math.ceil(value * factor);\n          popupValue = range.max;\n          popupString = \"range increased\";\n        }\n\n        range.value = value;\n      } else {\n        range.value = defaultValue;\n      }\n\n      var input = document.createElement(\"input\");\n      input.className = \"vis-configuration vis-config-rangeinput\";\n      input.value = range.value;\n      var me = this;\n\n      range.onchange = function () {\n        input.value = this.value;\n\n        me._update(Number(this.value), path);\n      };\n\n      range.oninput = function () {\n        input.value = this.value;\n      };\n\n      var label = this._makeLabel(path[path.length - 1], path);\n\n      var itemIndex = this._makeItem(path, label, range, input); // if a popup is needed AND it has not been shown for this value, show it.\n\n\n      if (popupString !== \"\" && this.popupHistory[itemIndex] !== popupValue) {\n        this.popupHistory[itemIndex] = popupValue;\n\n        this._setupPopup(popupString, itemIndex);\n      }\n    }\n    /**\n     * make a button object\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_makeButton\",\n    value: function _makeButton() {\n      var _this = this;\n\n      if (this.options.showButton === true) {\n        var generateButton = document.createElement(\"div\");\n        generateButton.className = \"vis-configuration vis-config-button\";\n        generateButton.innerHTML = \"generate options\";\n\n        generateButton.onclick = function () {\n          _this._printOptions();\n        };\n\n        generateButton.onmouseover = function () {\n          generateButton.className = \"vis-configuration vis-config-button hover\";\n        };\n\n        generateButton.onmouseout = function () {\n          generateButton.className = \"vis-configuration vis-config-button\";\n        };\n\n        this.optionsContainer = document.createElement(\"div\");\n        this.optionsContainer.className = \"vis-configuration vis-config-option-container\";\n        this.domElements.push(this.optionsContainer);\n        this.domElements.push(generateButton);\n      }\n    }\n    /**\n     * prepare the popup\n     *\n     * @param {string} string\n     * @param {number} index\n     * @private\n     */\n\n  }, {\n    key: \"_setupPopup\",\n    value: function _setupPopup(string, index) {\n      var _this2 = this;\n\n      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {\n        var div = document.createElement(\"div\");\n        div.id = \"vis-configuration-popup\";\n        div.className = \"vis-configuration-popup\";\n        div.innerHTML = string;\n\n        div.onclick = function () {\n          _this2._removePopup();\n        };\n\n        this.popupCounter += 1;\n        this.popupDiv = {\n          html: div,\n          index: index\n        };\n      }\n    }\n    /**\n     * remove the popup from the dom\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_removePopup\",\n    value: function _removePopup() {\n      if (this.popupDiv.html !== undefined) {\n        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);\n        clearTimeout(this.popupDiv.hideTimeout);\n        clearTimeout(this.popupDiv.deleteTimeout);\n        this.popupDiv = {};\n      }\n    }\n    /**\n     * Show the popup if it is needed.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_showPopupIfNeeded\",\n    value: function _showPopupIfNeeded() {\n      var _this3 = this;\n\n      if (this.popupDiv.html !== undefined) {\n        var correspondingElement = this.domElements[this.popupDiv.index];\n        var rect = correspondingElement.getBoundingClientRect();\n        this.popupDiv.html.style.left = rect.left + \"px\";\n        this.popupDiv.html.style.top = rect.top - 30 + \"px\"; // 30 is the height;\n\n        document.body.appendChild(this.popupDiv.html);\n        this.popupDiv.hideTimeout = setTimeout$2(function () {\n          _this3.popupDiv.html.style.opacity = 0;\n        }, 1500);\n        this.popupDiv.deleteTimeout = setTimeout$2(function () {\n          _this3._removePopup();\n        }, 1800);\n      }\n    }\n    /**\n     * make a checkbox for boolean options.\n     *\n     * @param {number} defaultValue\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: \"_makeCheckbox\",\n    value: function _makeCheckbox(defaultValue, value, path) {\n      var checkbox = document.createElement(\"input\");\n      checkbox.type = \"checkbox\";\n      checkbox.className = \"vis-configuration vis-config-checkbox\";\n      checkbox.checked = defaultValue;\n\n      if (value !== undefined) {\n        checkbox.checked = value;\n\n        if (value !== defaultValue) {\n          if (_typeof_1(defaultValue) === \"object\") {\n            if (value !== defaultValue.enabled) {\n              this.changedOptions.push({\n                path: path,\n                value: value\n              });\n            }\n          } else {\n            this.changedOptions.push({\n              path: path,\n              value: value\n            });\n          }\n        }\n      }\n\n      var me = this;\n\n      checkbox.onchange = function () {\n        me._update(this.checked, path);\n      };\n\n      var label = this._makeLabel(path[path.length - 1], path);\n\n      this._makeItem(path, label, checkbox);\n    }\n    /**\n     * make a text input field for string options.\n     *\n     * @param {number} defaultValue\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: \"_makeTextInput\",\n    value: function _makeTextInput(defaultValue, value, path) {\n      var checkbox = document.createElement(\"input\");\n      checkbox.type = \"text\";\n      checkbox.className = \"vis-configuration vis-config-text\";\n      checkbox.value = value;\n\n      if (value !== defaultValue) {\n        this.changedOptions.push({\n          path: path,\n          value: value\n        });\n      }\n\n      var me = this;\n\n      checkbox.onchange = function () {\n        me._update(this.value, path);\n      };\n\n      var label = this._makeLabel(path[path.length - 1], path);\n\n      this._makeItem(path, label, checkbox);\n    }\n    /**\n     * make a color field with a color picker for color fields\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: \"_makeColorField\",\n    value: function _makeColorField(arr, value, path) {\n      var _this4 = this;\n\n      var defaultColor = arr[1];\n      var div = document.createElement(\"div\");\n      value = value === undefined ? defaultColor : value;\n\n      if (value !== \"none\") {\n        div.className = \"vis-configuration vis-config-colorBlock\";\n        div.style.backgroundColor = value;\n      } else {\n        div.className = \"vis-configuration vis-config-colorBlock none\";\n      }\n\n      value = value === undefined ? defaultColor : value;\n\n      div.onclick = function () {\n        _this4._showColorPicker(value, div, path);\n      };\n\n      var label = this._makeLabel(path[path.length - 1], path);\n\n      this._makeItem(path, label, div);\n    }\n    /**\n     * used by the color buttons to call the color picker.\n     *\n     * @param {number} value\n     * @param {HTMLElement} div\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: \"_showColorPicker\",\n    value: function _showColorPicker(value, div, path) {\n      var _this5 = this; // clear the callback from this div\n\n\n      div.onclick = function () {};\n\n      this.colorPicker.insertTo(div);\n      this.colorPicker.show();\n      this.colorPicker.setColor(value);\n      this.colorPicker.setUpdateCallback(function (color) {\n        var colorString = \"rgba(\" + color.r + \",\" + color.g + \",\" + color.b + \",\" + color.a + \")\";\n        div.style.backgroundColor = colorString;\n\n        _this5._update(colorString, path);\n      }); // on close of the colorpicker, restore the callback.\n\n      this.colorPicker.setCloseCallback(function () {\n        div.onclick = function () {\n          _this5._showColorPicker(value, div, path);\n        };\n      });\n    }\n    /**\n     * parse an object and draw the correct items\n     *\n     * @param {object} obj\n     * @param {Array} [path=[]]    | where to look for the actual option\n     * @param {boolean} [checkOnly=false]\n     * @returns {boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_handleObject\",\n    value: function _handleObject(obj) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var checkOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var show = false;\n      var filter = filter$2(this.options);\n      var visibleInSet = false;\n\n      for (var subObj in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, subObj)) {\n          show = true;\n          var item = obj[subObj];\n          var newPath = copyAndExtendArray(path, subObj);\n\n          if (typeof filter === \"function\") {\n            show = filter(subObj, path); // if needed we must go deeper into the object.\n\n            if (show === false) {\n              if (!isArray$5(item) && typeof item !== \"string\" && typeof item !== \"boolean\" && item instanceof Object) {\n                this.allowCreation = false;\n                show = this._handleObject(item, newPath, true);\n                this.allowCreation = checkOnly === false;\n              }\n            }\n          }\n\n          if (show !== false) {\n            visibleInSet = true;\n\n            var value = this._getValue(newPath);\n\n            if (isArray$5(item)) {\n              this._handleArray(item, value, newPath);\n            } else if (typeof item === \"string\") {\n              this._makeTextInput(item, value, newPath);\n            } else if (typeof item === \"boolean\") {\n              this._makeCheckbox(item, value, newPath);\n            } else if (item instanceof Object) {\n              // collapse the physics options that are not enabled\n              var draw = true;\n\n              if (indexOf$3(path).call(path, \"physics\") !== -1) {\n                if (this.moduleOptions.physics.solver !== subObj && subObj !== \"wind\") {\n                  draw = false;\n                }\n              }\n\n              if (draw === true) {\n                // initially collapse options with an disabled enabled option.\n                if (item.enabled !== undefined) {\n                  var enabledPath = copyAndExtendArray(newPath, \"enabled\");\n\n                  var enabledValue = this._getValue(enabledPath);\n\n                  if (enabledValue === true) {\n                    var label = this._makeLabel(subObj, newPath, true);\n\n                    this._makeItem(newPath, label);\n\n                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;\n                  } else {\n                    this._makeCheckbox(item, enabledValue, newPath);\n                  }\n                } else {\n                  var _label = this._makeLabel(subObj, newPath, true);\n\n                  this._makeItem(newPath, _label);\n\n                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;\n                }\n              }\n            } else {\n              console.error(\"dont know how to handle\", item, subObj, newPath);\n            }\n          }\n        }\n      }\n\n      return visibleInSet;\n    }\n    /**\n     * handle the array type of option\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: \"_handleArray\",\n    value: function _handleArray(arr, value, path) {\n      if (typeof arr[0] === \"string\" && arr[0] === \"color\") {\n        this._makeColorField(arr, value, path);\n\n        if (arr[1] !== value) {\n          this.changedOptions.push({\n            path: path,\n            value: value\n          });\n        }\n      } else if (typeof arr[0] === \"string\") {\n        this._makeDropdown(arr, value, path);\n\n        if (arr[0] !== value) {\n          this.changedOptions.push({\n            path: path,\n            value: value\n          });\n        }\n      } else if (typeof arr[0] === \"number\") {\n        this._makeRange(arr, value, path);\n\n        if (arr[0] !== value) {\n          this.changedOptions.push({\n            path: path,\n            value: Number(value)\n          });\n        }\n      }\n    }\n    /**\n     * called to update the network with the new settings.\n     *\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update(value, path) {\n      var options = this._constructOptions(value, path);\n\n      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {\n        this.parent.body.emitter.emit(\"configChange\", options);\n      }\n\n      this.initialized = true;\n      this.parent.setOptions(options);\n    }\n    /**\n     *\n     * @param {string | boolean} value\n     * @param {Array.<string>} path\n     * @param {{}} optionsObj\n     * @returns {{}}\n     * @private\n     */\n\n  }, {\n    key: \"_constructOptions\",\n    value: function _constructOptions(value, path) {\n      var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var pointer = optionsObj; // when dropdown boxes can be string or boolean, we typecast it into correct types\n\n      value = value === \"true\" ? true : value;\n      value = value === \"false\" ? false : value;\n\n      for (var i = 0; i < path.length; i++) {\n        if (path[i] !== \"global\") {\n          if (pointer[path[i]] === undefined) {\n            pointer[path[i]] = {};\n          }\n\n          if (i !== path.length - 1) {\n            pointer = pointer[path[i]];\n          } else {\n            pointer[path[i]] = value;\n          }\n        }\n      }\n\n      return optionsObj;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_printOptions\",\n    value: function _printOptions() {\n      var options = this.getOptions();\n      this.optionsContainer.innerHTML = \"<pre>var options = \" + stringify$2(options, null, 2) + \"</pre>\";\n    }\n    /**\n     *\n     * @returns {{}} options\n     */\n\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      var options = {};\n\n      for (var i = 0; i < this.changedOptions.length; i++) {\n        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);\n      }\n\n      return options;\n    }\n  }]);\n  return Configurator;\n}();\n/**\n * This object contains all possible options. It will check if the types are correct, if required if the option is one\n * of the allowed values.\n *\n * __any__ means that the name of the property does not matter.\n * __type__ is a required field for all objects and contains the allowed types of all objects\n */\n\n\nvar string = \"string\";\nvar bool = \"boolean\";\nvar number = \"number\";\nvar array = \"array\";\nvar object = \"object\"; // should only be in a __type__ property\n\nvar dom = \"dom\";\nvar any = \"any\"; // List of endpoints\n\nvar endPoints = [\"arrow\", \"bar\", \"box\", \"circle\", \"crow\", \"curve\", \"diamond\", \"image\", \"inv_curve\", \"inv_triangle\", \"triangle\", \"vee\"];\nvar allOptions$1 = {\n  configure: {\n    enabled: {\n      boolean: bool\n    },\n    filter: {\n      boolean: bool,\n      string: string,\n      array: array,\n      function: \"function\"\n    },\n    container: {\n      dom: dom\n    },\n    showButton: {\n      boolean: bool\n    },\n    __type__: {\n      object: object,\n      boolean: bool,\n      string: string,\n      array: array,\n      function: \"function\"\n    }\n  },\n  edges: {\n    arrows: {\n      to: {\n        enabled: {\n          boolean: bool\n        },\n        scaleFactor: {\n          number: number\n        },\n        type: {\n          string: endPoints\n        },\n        imageHeight: {\n          number: number\n        },\n        imageWidth: {\n          number: number\n        },\n        src: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      middle: {\n        enabled: {\n          boolean: bool\n        },\n        scaleFactor: {\n          number: number\n        },\n        type: {\n          string: endPoints\n        },\n        imageWidth: {\n          number: number\n        },\n        imageHeight: {\n          number: number\n        },\n        src: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      from: {\n        enabled: {\n          boolean: bool\n        },\n        scaleFactor: {\n          number: number\n        },\n        type: {\n          string: endPoints\n        },\n        imageWidth: {\n          number: number\n        },\n        imageHeight: {\n          number: number\n        },\n        src: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      __type__: {\n        string: [\"from\", \"to\", \"middle\"],\n        object: object\n      }\n    },\n    endPointOffset: {\n      from: {\n        number: number\n      },\n      to: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        number: number\n      }\n    },\n    arrowStrikethrough: {\n      boolean: bool\n    },\n    background: {\n      enabled: {\n        boolean: bool\n      },\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      dashes: {\n        boolean: bool,\n        array: array\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    chosen: {\n      label: {\n        boolean: bool,\n        function: \"function\"\n      },\n      edge: {\n        boolean: bool,\n        function: \"function\"\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    color: {\n      color: {\n        string: string\n      },\n      highlight: {\n        string: string\n      },\n      hover: {\n        string: string\n      },\n      inherit: {\n        string: [\"from\", \"to\", \"both\"],\n        boolean: bool\n      },\n      opacity: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    dashes: {\n      boolean: bool,\n      array: array\n    },\n    font: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      // px\n      face: {\n        string: string\n      },\n      background: {\n        string: string\n      },\n      strokeWidth: {\n        number: number\n      },\n      // px\n      strokeColor: {\n        string: string\n      },\n      align: {\n        string: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n      },\n      vadjust: {\n        number: number\n      },\n      multi: {\n        boolean: bool,\n        string: string\n      },\n      bold: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        // px\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      boldital: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        // px\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      ital: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        // px\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      mono: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        // px\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    hidden: {\n      boolean: bool\n    },\n    hoverWidth: {\n      function: \"function\",\n      number: number\n    },\n    label: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    labelHighlightBold: {\n      boolean: bool\n    },\n    length: {\n      number: number,\n      undefined: \"undefined\"\n    },\n    physics: {\n      boolean: bool\n    },\n    scaling: {\n      min: {\n        number: number\n      },\n      max: {\n        number: number\n      },\n      label: {\n        enabled: {\n          boolean: bool\n        },\n        min: {\n          number: number\n        },\n        max: {\n          number: number\n        },\n        maxVisible: {\n          number: number\n        },\n        drawThreshold: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      customScalingFunction: {\n        function: \"function\"\n      },\n      __type__: {\n        object: object\n      }\n    },\n    selectionWidth: {\n      function: \"function\",\n      number: number\n    },\n    selfReferenceSize: {\n      number: number\n    },\n    selfReference: {\n      size: {\n        number: number\n      },\n      angle: {\n        number: number\n      },\n      renderBehindTheNode: {\n        boolean: bool\n      },\n      __type__: {\n        object: object\n      }\n    },\n    shadow: {\n      enabled: {\n        boolean: bool\n      },\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      x: {\n        number: number\n      },\n      y: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    smooth: {\n      enabled: {\n        boolean: bool\n      },\n      type: {\n        string: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"]\n      },\n      roundness: {\n        number: number\n      },\n      forceDirection: {\n        string: [\"horizontal\", \"vertical\", \"none\"],\n        boolean: bool\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    title: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    width: {\n      number: number\n    },\n    widthConstraint: {\n      maximum: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        boolean: bool,\n        number: number\n      }\n    },\n    value: {\n      number: number,\n      undefined: \"undefined\"\n    },\n    __type__: {\n      object: object\n    }\n  },\n  groups: {\n    useDefaultGroups: {\n      boolean: bool\n    },\n    __any__: \"get from nodes, will be overwritten below\",\n    __type__: {\n      object: object\n    }\n  },\n  interaction: {\n    dragNodes: {\n      boolean: bool\n    },\n    dragView: {\n      boolean: bool\n    },\n    hideEdgesOnDrag: {\n      boolean: bool\n    },\n    hideEdgesOnZoom: {\n      boolean: bool\n    },\n    hideNodesOnDrag: {\n      boolean: bool\n    },\n    hover: {\n      boolean: bool\n    },\n    keyboard: {\n      enabled: {\n        boolean: bool\n      },\n      speed: {\n        x: {\n          number: number\n        },\n        y: {\n          number: number\n        },\n        zoom: {\n          number: number\n        },\n        __type__: {\n          object: object\n        }\n      },\n      bindToWindow: {\n        boolean: bool\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    multiselect: {\n      boolean: bool\n    },\n    navigationButtons: {\n      boolean: bool\n    },\n    selectable: {\n      boolean: bool\n    },\n    selectConnectedEdges: {\n      boolean: bool\n    },\n    hoverConnectedEdges: {\n      boolean: bool\n    },\n    tooltipDelay: {\n      number: number\n    },\n    zoomView: {\n      boolean: bool\n    },\n    zoomSpeed: {\n      number: number\n    },\n    __type__: {\n      object: object\n    }\n  },\n  layout: {\n    randomSeed: {\n      undefined: \"undefined\",\n      number: number,\n      string: string\n    },\n    improvedLayout: {\n      boolean: bool\n    },\n    clusterThreshold: {\n      number: number\n    },\n    hierarchical: {\n      enabled: {\n        boolean: bool\n      },\n      levelSeparation: {\n        number: number\n      },\n      nodeSpacing: {\n        number: number\n      },\n      treeSpacing: {\n        number: number\n      },\n      blockShifting: {\n        boolean: bool\n      },\n      edgeMinimization: {\n        boolean: bool\n      },\n      parentCentralization: {\n        boolean: bool\n      },\n      direction: {\n        string: [\"UD\", \"DU\", \"LR\", \"RL\"]\n      },\n      // UD, DU, LR, RL\n      sortMethod: {\n        string: [\"hubsize\", \"directed\"]\n      },\n      // hubsize, directed\n      shakeTowards: {\n        string: [\"leaves\", \"roots\"]\n      },\n      // leaves, roots\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    __type__: {\n      object: object\n    }\n  },\n  manipulation: {\n    enabled: {\n      boolean: bool\n    },\n    initiallyActive: {\n      boolean: bool\n    },\n    addNode: {\n      boolean: bool,\n      function: \"function\"\n    },\n    addEdge: {\n      boolean: bool,\n      function: \"function\"\n    },\n    editNode: {\n      function: \"function\"\n    },\n    editEdge: {\n      editWithoutDrag: {\n        function: \"function\"\n      },\n      __type__: {\n        object: object,\n        boolean: bool,\n        function: \"function\"\n      }\n    },\n    deleteNode: {\n      boolean: bool,\n      function: \"function\"\n    },\n    deleteEdge: {\n      boolean: bool,\n      function: \"function\"\n    },\n    controlNodeStyle: \"get from nodes, will be overwritten below\",\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  nodes: {\n    borderWidth: {\n      number: number\n    },\n    borderWidthSelected: {\n      number: number,\n      undefined: \"undefined\"\n    },\n    brokenImage: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    chosen: {\n      label: {\n        boolean: bool,\n        function: \"function\"\n      },\n      node: {\n        boolean: bool,\n        function: \"function\"\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    color: {\n      border: {\n        string: string\n      },\n      background: {\n        string: string\n      },\n      highlight: {\n        border: {\n          string: string\n        },\n        background: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      hover: {\n        border: {\n          string: string\n        },\n        background: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    opacity: {\n      number: number,\n      undefined: \"undefined\"\n    },\n    fixed: {\n      x: {\n        boolean: bool\n      },\n      y: {\n        boolean: bool\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    font: {\n      align: {\n        string: string\n      },\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      // px\n      face: {\n        string: string\n      },\n      background: {\n        string: string\n      },\n      strokeWidth: {\n        number: number\n      },\n      // px\n      strokeColor: {\n        string: string\n      },\n      vadjust: {\n        number: number\n      },\n      multi: {\n        boolean: bool,\n        string: string\n      },\n      bold: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        // px\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      boldital: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        // px\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      ital: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        // px\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      mono: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        // px\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    group: {\n      string: string,\n      number: number,\n      undefined: \"undefined\"\n    },\n    heightConstraint: {\n      minimum: {\n        number: number\n      },\n      valign: {\n        string: string\n      },\n      __type__: {\n        object: object,\n        boolean: bool,\n        number: number\n      }\n    },\n    hidden: {\n      boolean: bool\n    },\n    icon: {\n      face: {\n        string: string\n      },\n      code: {\n        string: string\n      },\n      //'\\uf007',\n      size: {\n        number: number\n      },\n      //50,\n      color: {\n        string: string\n      },\n      weight: {\n        string: string,\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    id: {\n      string: string,\n      number: number\n    },\n    image: {\n      selected: {\n        string: string,\n        undefined: \"undefined\"\n      },\n      // --> URL\n      unselected: {\n        string: string,\n        undefined: \"undefined\"\n      },\n      // --> URL\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    imagePadding: {\n      top: {\n        number: number\n      },\n      right: {\n        number: number\n      },\n      bottom: {\n        number: number\n      },\n      left: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        number: number\n      }\n    },\n    label: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    labelHighlightBold: {\n      boolean: bool\n    },\n    level: {\n      number: number,\n      undefined: \"undefined\"\n    },\n    margin: {\n      top: {\n        number: number\n      },\n      right: {\n        number: number\n      },\n      bottom: {\n        number: number\n      },\n      left: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        number: number\n      }\n    },\n    mass: {\n      number: number\n    },\n    physics: {\n      boolean: bool\n    },\n    scaling: {\n      min: {\n        number: number\n      },\n      max: {\n        number: number\n      },\n      label: {\n        enabled: {\n          boolean: bool\n        },\n        min: {\n          number: number\n        },\n        max: {\n          number: number\n        },\n        maxVisible: {\n          number: number\n        },\n        drawThreshold: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      customScalingFunction: {\n        function: \"function\"\n      },\n      __type__: {\n        object: object\n      }\n    },\n    shadow: {\n      enabled: {\n        boolean: bool\n      },\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      x: {\n        number: number\n      },\n      y: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    shape: {\n      string: [\"custom\", \"ellipse\", \"circle\", \"database\", \"box\", \"text\", \"image\", \"circularImage\", \"diamond\", \"dot\", \"star\", \"triangle\", \"triangleDown\", \"square\", \"icon\", \"hexagon\"]\n    },\n    ctxRenderer: {\n      function: \"function\"\n    },\n    shapeProperties: {\n      borderDashes: {\n        boolean: bool,\n        array: array\n      },\n      borderRadius: {\n        number: number\n      },\n      interpolation: {\n        boolean: bool\n      },\n      useImageSize: {\n        boolean: bool\n      },\n      useBorderWithImage: {\n        boolean: bool\n      },\n      coordinateOrigin: {\n        string: [\"center\", \"top-left\"]\n      },\n      __type__: {\n        object: object\n      }\n    },\n    size: {\n      number: number\n    },\n    title: {\n      string: string,\n      dom: dom,\n      undefined: \"undefined\"\n    },\n    value: {\n      number: number,\n      undefined: \"undefined\"\n    },\n    widthConstraint: {\n      minimum: {\n        number: number\n      },\n      maximum: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        boolean: bool,\n        number: number\n      }\n    },\n    x: {\n      number: number\n    },\n    y: {\n      number: number\n    },\n    __type__: {\n      object: object\n    }\n  },\n  physics: {\n    enabled: {\n      boolean: bool\n    },\n    barnesHut: {\n      theta: {\n        number: number\n      },\n      gravitationalConstant: {\n        number: number\n      },\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      avoidOverlap: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    forceAtlas2Based: {\n      theta: {\n        number: number\n      },\n      gravitationalConstant: {\n        number: number\n      },\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      avoidOverlap: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    repulsion: {\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      nodeDistance: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    hierarchicalRepulsion: {\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      nodeDistance: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      avoidOverlap: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    maxVelocity: {\n      number: number\n    },\n    minVelocity: {\n      number: number\n    },\n    // px/s\n    solver: {\n      string: [\"barnesHut\", \"repulsion\", \"hierarchicalRepulsion\", \"forceAtlas2Based\"]\n    },\n    stabilization: {\n      enabled: {\n        boolean: bool\n      },\n      iterations: {\n        number: number\n      },\n      // maximum number of iteration to stabilize\n      updateInterval: {\n        number: number\n      },\n      onlyDynamicEdges: {\n        boolean: bool\n      },\n      fit: {\n        boolean: bool\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    timestep: {\n      number: number\n    },\n    adaptiveTimestep: {\n      boolean: bool\n    },\n    wind: {\n      x: {\n        number: number\n      },\n      y: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  //globals :\n  autoResize: {\n    boolean: bool\n  },\n  clickToUse: {\n    boolean: bool\n  },\n  locale: {\n    string: string\n  },\n  locales: {\n    __any__: {\n      any: any\n    },\n    __type__: {\n      object: object\n    }\n  },\n  height: {\n    string: string\n  },\n  width: {\n    string: string\n  },\n  __type__: {\n    object: object\n  }\n};\nallOptions$1.groups.__any__ = allOptions$1.nodes;\nallOptions$1.manipulation.controlNodeStyle = allOptions$1.nodes;\n/**\n * This provides ranges, initial values, steps and dropdown menu choices for the\n * configuration.\n *\n * @remarks\n * Checkbox: `boolean`\n *   The value supllied will be used as the initial value.\n *\n * Text field: `string`\n *   The passed text will be used as the initial value. Any text will be\n *   accepted afterwards.\n *\n * Number range: `[number, number, number, number]`\n *   The meanings are `[initial value, min, max, step]`.\n *\n * Dropdown: `[Exclude<string, \"color\">, ...(string | number | boolean)[]]`\n *   Translations for people with poor understanding of TypeScript: the first\n *   value always has to be a string but never `\"color\"`, the rest can be any\n *   combination of strings, numbers and booleans.\n *\n * Color picker: `[\"color\", string]`\n *   The first value says this will be a color picker not a dropdown menu. The\n *   next value is the initial color.\n */\n\nvar configureOptions = {\n  nodes: {\n    borderWidth: [1, 0, 10, 1],\n    borderWidthSelected: [2, 0, 10, 1],\n    color: {\n      border: [\"color\", \"#2B7CE9\"],\n      background: [\"color\", \"#97C2FC\"],\n      highlight: {\n        border: [\"color\", \"#2B7CE9\"],\n        background: [\"color\", \"#D2E5FF\"]\n      },\n      hover: {\n        border: [\"color\", \"#2B7CE9\"],\n        background: [\"color\", \"#D2E5FF\"]\n      }\n    },\n    opacity: [0, 0, 1, 0.1],\n    fixed: {\n      x: false,\n      y: false\n    },\n    font: {\n      color: [\"color\", \"#343434\"],\n      size: [14, 0, 100, 1],\n      // px\n      face: [\"arial\", \"verdana\", \"tahoma\"],\n      background: [\"color\", \"none\"],\n      strokeWidth: [0, 0, 50, 1],\n      // px\n      strokeColor: [\"color\", \"#ffffff\"]\n    },\n    //group: 'string',\n    hidden: false,\n    labelHighlightBold: true,\n    //icon: {\n    //  face: 'string',  //'FontAwesome',\n    //  code: 'string',  //'\\uf007',\n    //  size: [50, 0, 200, 1],  //50,\n    //  color: ['color','#2B7CE9']   //'#aa00ff'\n    //},\n    //image: 'string', // --> URL\n    physics: true,\n    scaling: {\n      min: [10, 0, 200, 1],\n      max: [30, 0, 200, 1],\n      label: {\n        enabled: false,\n        min: [14, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        maxVisible: [30, 0, 200, 1],\n        drawThreshold: [5, 0, 20, 1]\n      }\n    },\n    shadow: {\n      enabled: false,\n      color: \"rgba(0,0,0,0.5)\",\n      size: [10, 0, 20, 1],\n      x: [5, -30, 30, 1],\n      y: [5, -30, 30, 1]\n    },\n    shape: [\"ellipse\", \"box\", \"circle\", \"database\", \"diamond\", \"dot\", \"square\", \"star\", \"text\", \"triangle\", \"triangleDown\", \"hexagon\"],\n    shapeProperties: {\n      borderDashes: false,\n      borderRadius: [6, 0, 20, 1],\n      interpolation: true,\n      useImageSize: false\n    },\n    size: [25, 0, 200, 1]\n  },\n  edges: {\n    arrows: {\n      to: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      },\n      middle: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      },\n      from: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      }\n    },\n    endPointOffset: {\n      from: [0, -10, 10, 1],\n      to: [0, -10, 10, 1]\n    },\n    arrowStrikethrough: true,\n    color: {\n      color: [\"color\", \"#848484\"],\n      highlight: [\"color\", \"#848484\"],\n      hover: [\"color\", \"#848484\"],\n      inherit: [\"from\", \"to\", \"both\", true, false],\n      opacity: [1, 0, 1, 0.05]\n    },\n    dashes: false,\n    font: {\n      color: [\"color\", \"#343434\"],\n      size: [14, 0, 100, 1],\n      // px\n      face: [\"arial\", \"verdana\", \"tahoma\"],\n      background: [\"color\", \"none\"],\n      strokeWidth: [2, 0, 50, 1],\n      // px\n      strokeColor: [\"color\", \"#ffffff\"],\n      align: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n    },\n    hidden: false,\n    hoverWidth: [1.5, 0, 5, 0.1],\n    labelHighlightBold: true,\n    physics: true,\n    scaling: {\n      min: [1, 0, 100, 1],\n      max: [15, 0, 100, 1],\n      label: {\n        enabled: true,\n        min: [14, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        maxVisible: [30, 0, 200, 1],\n        drawThreshold: [5, 0, 20, 1]\n      }\n    },\n    selectionWidth: [1.5, 0, 5, 0.1],\n    selfReferenceSize: [20, 0, 200, 1],\n    selfReference: {\n      size: [20, 0, 200, 1],\n      angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],\n      renderBehindTheNode: true\n    },\n    shadow: {\n      enabled: false,\n      color: \"rgba(0,0,0,0.5)\",\n      size: [10, 0, 20, 1],\n      x: [5, -30, 30, 1],\n      y: [5, -30, 30, 1]\n    },\n    smooth: {\n      enabled: true,\n      type: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"],\n      forceDirection: [\"horizontal\", \"vertical\", \"none\"],\n      roundness: [0.5, 0, 1, 0.05]\n    },\n    width: [1, 0, 30, 1]\n  },\n  layout: {\n    //randomSeed: [0, 0, 500, 1],\n    //improvedLayout: true,\n    hierarchical: {\n      enabled: false,\n      levelSeparation: [150, 20, 500, 5],\n      nodeSpacing: [100, 20, 500, 5],\n      treeSpacing: [200, 20, 500, 5],\n      blockShifting: true,\n      edgeMinimization: true,\n      parentCentralization: true,\n      direction: [\"UD\", \"DU\", \"LR\", \"RL\"],\n      // UD, DU, LR, RL\n      sortMethod: [\"hubsize\", \"directed\"],\n      // hubsize, directed\n      shakeTowards: [\"leaves\", \"roots\"] // leaves, roots\n\n    }\n  },\n  interaction: {\n    dragNodes: true,\n    dragView: true,\n    hideEdgesOnDrag: false,\n    hideEdgesOnZoom: false,\n    hideNodesOnDrag: false,\n    hover: false,\n    keyboard: {\n      enabled: false,\n      speed: {\n        x: [10, 0, 40, 1],\n        y: [10, 0, 40, 1],\n        zoom: [0.02, 0, 0.1, 0.005]\n      },\n      bindToWindow: true\n    },\n    multiselect: false,\n    navigationButtons: false,\n    selectable: true,\n    selectConnectedEdges: true,\n    hoverConnectedEdges: true,\n    tooltipDelay: [300, 0, 1000, 25],\n    zoomView: true,\n    zoomSpeed: [1, 0.1, 2, 0.1]\n  },\n  manipulation: {\n    enabled: false,\n    initiallyActive: false\n  },\n  physics: {\n    enabled: true,\n    barnesHut: {\n      theta: [0.5, 0.1, 1, 0.05],\n      gravitationalConstant: [-2000, -30000, 0, 50],\n      centralGravity: [0.3, 0, 10, 0.05],\n      springLength: [95, 0, 500, 5],\n      springConstant: [0.04, 0, 1.2, 0.005],\n      damping: [0.09, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    forceAtlas2Based: {\n      theta: [0.5, 0.1, 1, 0.05],\n      gravitationalConstant: [-50, -500, 0, 1],\n      centralGravity: [0.01, 0, 1, 0.005],\n      springLength: [95, 0, 500, 5],\n      springConstant: [0.08, 0, 1.2, 0.005],\n      damping: [0.4, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    repulsion: {\n      centralGravity: [0.2, 0, 10, 0.05],\n      springLength: [200, 0, 500, 5],\n      springConstant: [0.05, 0, 1.2, 0.005],\n      nodeDistance: [100, 0, 500, 5],\n      damping: [0.09, 0, 1, 0.01]\n    },\n    hierarchicalRepulsion: {\n      centralGravity: [0.2, 0, 10, 0.05],\n      springLength: [100, 0, 500, 5],\n      springConstant: [0.01, 0, 1.2, 0.005],\n      nodeDistance: [120, 0, 500, 5],\n      damping: [0.09, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    maxVelocity: [50, 0, 150, 1],\n    minVelocity: [0.1, 0.01, 0.5, 0.01],\n    solver: [\"barnesHut\", \"forceAtlas2Based\", \"repulsion\", \"hierarchicalRepulsion\"],\n    timestep: [0.5, 0.01, 1, 0.01],\n    wind: {\n      x: [0, -10, 10, 0.1],\n      y: [0, -10, 10, 0.1]\n    } //adaptiveTimestep: true\n\n  }\n};\nvar options = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  allOptions: allOptions$1,\n  configureOptions: configureOptions\n});\n/**\n *  The Floyd–Warshall algorithm is an algorithm for finding shortest paths in\n *  a weighted graph with positive or negative edge weights (but with no negative\n *  cycles). - https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm\n */\n\nvar FloydWarshall = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function FloydWarshall() {\n    classCallCheck(this, FloydWarshall);\n  }\n  /**\n   *\n   * @param {object} body\n   * @param {Array.<Node>} nodesArray\n   * @param {Array.<Edge>} edgesArray\n   * @returns {{}}\n   */\n\n\n  createClass(FloydWarshall, [{\n    key: \"getDistances\",\n    value: function getDistances(body, nodesArray, edgesArray) {\n      var D_matrix = {};\n      var edges = body.edges; // prepare matrix with large numbers\n\n      for (var i = 0; i < nodesArray.length; i++) {\n        var node = nodesArray[i];\n        var cell = {};\n        D_matrix[node] = cell;\n\n        for (var j = 0; j < nodesArray.length; j++) {\n          cell[nodesArray[j]] = i == j ? 0 : 1e9;\n        }\n      } // put the weights for the edges in. This assumes unidirectionality.\n\n\n      for (var _i = 0; _i < edgesArray.length; _i++) {\n        var edge = edges[edgesArray[_i]]; // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix\n\n        if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {\n          D_matrix[edge.fromId][edge.toId] = 1;\n          D_matrix[edge.toId][edge.fromId] = 1;\n        }\n      }\n\n      var nodeCount = nodesArray.length; // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.\n\n      for (var k = 0; k < nodeCount; k++) {\n        var knode = nodesArray[k];\n        var kcolm = D_matrix[knode];\n\n        for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {\n          var inode = nodesArray[_i2];\n          var icolm = D_matrix[inode];\n\n          for (var _j = _i2 + 1; _j < nodeCount; _j++) {\n            var jnode = nodesArray[_j];\n            var jcolm = D_matrix[jnode];\n            var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);\n            icolm[jnode] = val;\n            jcolm[inode] = val;\n          }\n        }\n      }\n\n      return D_matrix;\n    }\n  }]);\n  return FloydWarshall;\n}();\n/**\n * KamadaKawai positions the nodes initially based on\n *\n * \"AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS\"\n * -- Tomihisa KAMADA and Satoru KAWAI in 1989\n *\n * Possible optimizations in the distance calculation can be implemented.\n */\n\n\nvar KamadaKawai = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {number} edgeLength\n   * @param {number} edgeStrength\n   */\n  function KamadaKawai(body, edgeLength, edgeStrength) {\n    classCallCheck(this, KamadaKawai);\n    this.body = body;\n    this.springLength = edgeLength;\n    this.springConstant = edgeStrength;\n    this.distanceSolver = new FloydWarshall();\n  }\n  /**\n   * Not sure if needed but can be used to update the spring length and spring constant\n   *\n   * @param {object} options\n   */\n\n\n  createClass(KamadaKawai, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options) {\n        if (options.springLength) {\n          this.springLength = options.springLength;\n        }\n\n        if (options.springConstant) {\n          this.springConstant = options.springConstant;\n        }\n      }\n    }\n    /**\n     * Position the system\n     *\n     * @param {Array.<Node>} nodesArray\n     * @param {Array.<vis.Edge>} edgesArray\n     * @param {boolean} [ignoreClusters=false]\n     */\n\n  }, {\n    key: \"solve\",\n    value: function solve(nodesArray, edgesArray) {\n      var ignoreClusters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // get distance matrix\n\n      var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix\n      // get the L Matrix\n\n      this._createL_matrix(D_matrix); // get the K Matrix\n\n\n      this._createK_matrix(D_matrix); // initial E Matrix\n\n\n      this._createE_matrix(); // calculate positions\n\n\n      var threshold = 0.01;\n      var innerThreshold = 1;\n      var iterations = 0;\n      var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));\n      var maxInnerIterations = 5;\n      var maxEnergy = 1e9;\n      var highE_nodeId = 0,\n          dE_dx = 0,\n          dE_dy = 0,\n          delta_m = 0,\n          subIterations = 0;\n\n      while (maxEnergy > threshold && iterations < maxIterations) {\n        iterations += 1;\n\n        var _this$_getHighestEner = this._getHighestEnergyNode(ignoreClusters);\n\n        var _this$_getHighestEner2 = slicedToArray(_this$_getHighestEner, 4);\n\n        highE_nodeId = _this$_getHighestEner2[0];\n        maxEnergy = _this$_getHighestEner2[1];\n        dE_dx = _this$_getHighestEner2[2];\n        dE_dy = _this$_getHighestEner2[3];\n        delta_m = maxEnergy;\n        subIterations = 0;\n\n        while (delta_m > innerThreshold && subIterations < maxInnerIterations) {\n          subIterations += 1;\n\n          this._moveNode(highE_nodeId, dE_dx, dE_dy);\n\n          var _this$_getEnergy = this._getEnergy(highE_nodeId);\n\n          var _this$_getEnergy2 = slicedToArray(_this$_getEnergy, 3);\n\n          delta_m = _this$_getEnergy2[0];\n          dE_dx = _this$_getEnergy2[1];\n          dE_dy = _this$_getEnergy2[2];\n        }\n      }\n    }\n    /**\n     * get the node with the highest energy\n     *\n     * @param {boolean} ignoreClusters\n     * @returns {number[]}\n     * @private\n     */\n\n  }, {\n    key: \"_getHighestEnergyNode\",\n    value: function _getHighestEnergyNode(ignoreClusters) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var maxEnergy = 0;\n      var maxEnergyNodeId = nodesArray[0];\n      var dE_dx_max = 0,\n          dE_dy_max = 0;\n\n      for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {\n        var m = nodesArray[nodeIdx]; // by not evaluating nodes with predefined positions we should only move nodes that have no positions.\n\n        if (nodes[m].predefinedPosition !== true || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x !== true || nodes[m].options.fixed.y !== true) {\n          var _this$_getEnergy3 = this._getEnergy(m),\n              _this$_getEnergy4 = slicedToArray(_this$_getEnergy3, 3),\n              delta_m = _this$_getEnergy4[0],\n              dE_dx = _this$_getEnergy4[1],\n              dE_dy = _this$_getEnergy4[2];\n\n          if (maxEnergy < delta_m) {\n            maxEnergy = delta_m;\n            maxEnergyNodeId = m;\n            dE_dx_max = dE_dx;\n            dE_dy_max = dE_dy;\n          }\n        }\n      }\n\n      return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];\n    }\n    /**\n     * calculate the energy of a single node\n     *\n     * @param {Node.id} m\n     * @returns {number[]}\n     * @private\n     */\n\n  }, {\n    key: \"_getEnergy\",\n    value: function _getEnergy(m) {\n      var _this$E_sums$m = slicedToArray(this.E_sums[m], 2),\n          dE_dx = _this$E_sums$m[0],\n          dE_dy = _this$E_sums$m[1];\n\n      var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));\n      return [delta_m, dE_dx, dE_dy];\n    }\n    /**\n     * move the node based on it's energy\n     * the dx and dy are calculated from the linear system proposed by Kamada and Kawai\n     *\n     * @param {number} m\n     * @param {number} dE_dx\n     * @param {number} dE_dy\n     * @private\n     */\n\n  }, {\n    key: \"_moveNode\",\n    value: function _moveNode(m, dE_dx, dE_dy) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var d2E_dx2 = 0;\n      var d2E_dxdy = 0;\n      var d2E_dy2 = 0;\n      var x_m = nodes[m].x;\n      var y_m = nodes[m].y;\n      var km = this.K_matrix[m];\n      var lm = this.L_matrix[m];\n\n      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {\n        var i = nodesArray[iIdx];\n\n        if (i !== m) {\n          var x_i = nodes[i].x;\n          var y_i = nodes[i].y;\n          var kmat = km[i];\n          var lmat = lm[i];\n          var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);\n          d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);\n          d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);\n          d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);\n        }\n      } // make the variable names easier to make the solving of the linear system easier to read\n\n\n      var A = d2E_dx2,\n          B = d2E_dxdy,\n          C = dE_dx,\n          D = d2E_dy2,\n          E = dE_dy; // solve the linear system for dx and dy\n\n      var dy = (C / A + E / B) / (B / A - D / B);\n      var dx = -(B * dy + C) / A; // move the node\n\n      nodes[m].x += dx;\n      nodes[m].y += dy; // Recalculate E_matrix (should be incremental)\n\n      this._updateE_matrix(m);\n    }\n    /**\n     * Create the L matrix: edge length times shortest path\n     *\n     * @param {object} D_matrix\n     * @private\n     */\n\n  }, {\n    key: \"_createL_matrix\",\n    value: function _createL_matrix(D_matrix) {\n      var nodesArray = this.body.nodeIndices;\n      var edgeLength = this.springLength;\n      this.L_matrix = [];\n\n      for (var i = 0; i < nodesArray.length; i++) {\n        this.L_matrix[nodesArray[i]] = {};\n\n        for (var j = 0; j < nodesArray.length; j++) {\n          this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];\n        }\n      }\n    }\n    /**\n     * Create the K matrix: spring constants times shortest path\n     *\n     * @param {object} D_matrix\n     * @private\n     */\n\n  }, {\n    key: \"_createK_matrix\",\n    value: function _createK_matrix(D_matrix) {\n      var nodesArray = this.body.nodeIndices;\n      var edgeStrength = this.springConstant;\n      this.K_matrix = [];\n\n      for (var i = 0; i < nodesArray.length; i++) {\n        this.K_matrix[nodesArray[i]] = {};\n\n        for (var j = 0; j < nodesArray.length; j++) {\n          this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);\n        }\n      }\n    }\n    /**\n     *  Create matrix with all energies between nodes\n     *\n     *  @private\n     */\n\n  }, {\n    key: \"_createE_matrix\",\n    value: function _createE_matrix() {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      this.E_matrix = {};\n      this.E_sums = {};\n\n      for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {\n        this.E_matrix[nodesArray[mIdx]] = [];\n      }\n\n      for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {\n        var m = nodesArray[_mIdx];\n        var x_m = nodes[m].x;\n        var y_m = nodes[m].y;\n        var dE_dx = 0;\n        var dE_dy = 0;\n\n        for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {\n          var i = nodesArray[iIdx];\n\n          if (i !== m) {\n            var x_i = nodes[i].x;\n            var y_i = nodes[i].y;\n            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));\n            this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];\n            this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];\n            dE_dx += this.E_matrix[m][iIdx][0];\n            dE_dy += this.E_matrix[m][iIdx][1];\n          }\n        } //Store sum\n\n\n        this.E_sums[m] = [dE_dx, dE_dy];\n      }\n    }\n    /**\n     * Update method, just doing single column (rows are auto-updated) (update all sums)\n     *\n     * @param {number} m\n     * @private\n     */\n\n  }, {\n    key: \"_updateE_matrix\",\n    value: function _updateE_matrix(m) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var colm = this.E_matrix[m];\n      var kcolm = this.K_matrix[m];\n      var lcolm = this.L_matrix[m];\n      var x_m = nodes[m].x;\n      var y_m = nodes[m].y;\n      var dE_dx = 0;\n      var dE_dy = 0;\n\n      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {\n        var i = nodesArray[iIdx];\n\n        if (i !== m) {\n          //Keep old energy value for sum modification below\n          var cell = colm[iIdx];\n          var oldDx = cell[0];\n          var oldDy = cell[1]; //Calc new energy:\n\n          var x_i = nodes[i].x;\n          var y_i = nodes[i].y;\n          var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));\n          var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);\n          var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);\n          colm[iIdx] = [dx, dy];\n          dE_dx += dx;\n          dE_dy += dy; //add new energy to sum of each column\n\n          var sum = this.E_sums[i];\n          sum[0] += dx - oldDx;\n          sum[1] += dy - oldDy;\n        }\n      } //Store sum at -1 index\n\n\n      this.E_sums[m] = [dE_dx, dE_dy];\n    }\n  }]);\n  return KamadaKawai;\n}();\n/**\n * Create a network visualization, displaying nodes and edges.\n *\n * @param {Element} container   The DOM element in which the Network will\n *                                  be created. Normally a div element.\n * @param {object} data         An object containing parameters\n *                              {Array} nodes\n *                              {Array} edges\n * @param {object} options      Options\n * @class Network\n */\n\n\nfunction Network(container, data, options) {\n  var _context,\n      _context2,\n      _context3,\n      _context4,\n      _this = this;\n\n  if (!(this instanceof Network)) {\n    throw new SyntaxError(\"Constructor must be called with the new operator\");\n  } // set constant values\n\n\n  this.options = {};\n  this.defaultOptions = {\n    locale: \"en\",\n    locales: locales,\n    clickToUse: false\n  };\n  assign$2(this.options, this.defaultOptions);\n  /**\n   * Containers for nodes and edges.\n   *\n   * 'edges' and 'nodes' contain the full definitions of all the network elements.\n   * 'nodeIndices' and 'edgeIndices' contain the id's of the active elements.\n   *\n   * The distinction is important, because a defined node need not be active, i.e.\n   * visible on the canvas. This happens in particular when clusters are defined, in\n   * that case there will be nodes and edges not displayed.\n   * The bottom line is that all code with actions related to visibility, *must* use\n   * 'nodeIndices' and 'edgeIndices', not 'nodes' and 'edges' directly.\n   */\n\n  this.body = {\n    container: container,\n    // See comment above for following fields\n    nodes: {},\n    nodeIndices: [],\n    edges: {},\n    edgeIndices: [],\n    emitter: {\n      on: bind$2(_context = this.on).call(_context, this),\n      off: bind$2(_context2 = this.off).call(_context2, this),\n      emit: bind$2(_context3 = this.emit).call(_context3, this),\n      once: bind$2(_context4 = this.once).call(_context4, this)\n    },\n    eventListeners: {\n      onTap: function onTap() {},\n      onTouch: function onTouch() {},\n      onDoubleTap: function onDoubleTap() {},\n      onHold: function onHold() {},\n      onDragStart: function onDragStart() {},\n      onDrag: function onDrag() {},\n      onDragEnd: function onDragEnd() {},\n      onMouseWheel: function onMouseWheel() {},\n      onPinch: function onPinch() {},\n      onMouseMove: function onMouseMove() {},\n      onRelease: function onRelease() {},\n      onContext: function onContext() {}\n    },\n    data: {\n      nodes: null,\n      // A DataSet or DataView\n      edges: null // A DataSet or DataView\n\n    },\n    functions: {\n      createNode: function createNode() {},\n      createEdge: function createEdge() {},\n      getPointer: function getPointer() {}\n    },\n    modules: {},\n    view: {\n      scale: 1,\n      translation: {\n        x: 0,\n        y: 0\n      }\n    },\n    selectionBox: {\n      show: false,\n      position: {\n        start: {\n          x: 0,\n          y: 0\n        },\n        end: {\n          x: 0,\n          y: 0\n        }\n      }\n    }\n  }; // bind the event listeners\n\n  this.bindEventListeners(); // setting up all modules\n\n  this.images = new Images(function () {\n    return _this.body.emitter.emit(\"_requestRedraw\");\n  }); // object with images\n\n  this.groups = new Groups(); // object with groups\n\n  this.canvas = new Canvas(this.body); // DOM handler\n\n  this.selectionHandler = new SelectionHandler(this.body, this.canvas); // Selection handler\n\n  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key\n\n  this.view = new View(this.body, this.canvas); // camera handler, does animations and zooms\n\n  this.renderer = new CanvasRenderer(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into\n\n  this.physics = new PhysicsEngine(this.body); // physics engine, does all the simulations\n\n  this.layoutEngine = new LayoutEngine(this.body); // layout engine for inital layout and hierarchical layout\n\n  this.clustering = new ClusterEngine(this.body); // clustering api\n\n  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler, this.interactionHandler); // data manipulation system\n\n  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options\n\n  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options\n\n  this.body.modules[\"kamadaKawai\"] = new KamadaKawai(this.body, 150, 0.05); // Layouting algorithm.\n\n  this.body.modules[\"clustering\"] = this.clustering; // create the DOM elements\n\n  this.canvas._create(); // apply options\n\n\n  this.setOptions(options); // load data (the disable start variable will be the same as the enabled clustering)\n\n  this.setData(data);\n} // Extend Network with an Emitter mixin\n\n\ncomponentEmitter(Network.prototype);\n/**\n * Set options\n *\n * @param {object} options\n */\n\nNetwork.prototype.setOptions = function (options) {\n  var _this2 = this;\n\n  if (options === null) {\n    options = undefined; // This ensures that options handling doesn't crash in the handling\n  }\n\n  if (options !== undefined) {\n    var errorFound = Validator.validate(options, allOptions$1);\n\n    if (errorFound === true) {\n      console.error(\"%cErrors have been found in the supplied options object.\", printStyle);\n    } // copy the global fields over\n\n\n    var fields = [\"locale\", \"locales\", \"clickToUse\"];\n    selectiveDeepExtend(fields, this.options, options); // normalize the locale or use English\n\n    if (options.locale !== undefined) {\n      options.locale = normalizeLanguageCode(options.locales || this.options.locales, options.locale);\n    } // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.\n\n\n    options = this.layoutEngine.setOptions(options.layout, options);\n    this.canvas.setOptions(options); // options for canvas are in globals\n    // pass the options to the modules\n\n    this.groups.setOptions(options.groups);\n    this.nodesHandler.setOptions(options.nodes);\n    this.edgesHandler.setOptions(options.edges);\n    this.physics.setOptions(options.physics);\n    this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals\n\n    this.interactionHandler.setOptions(options.interaction);\n    this.renderer.setOptions(options.interaction); // options for rendering are in interaction\n\n    this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction\n    // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.\n\n    if (options.groups !== undefined) {\n      this.body.emitter.emit(\"refreshNodes\");\n    } // these two do not have options at the moment, here for completeness\n    //this.view.setOptions(options.view);\n    //this.clustering.setOptions(options.clustering);\n\n\n    if (\"configure\" in options) {\n      if (!this.configurator) {\n        this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio);\n      }\n\n      this.configurator.setOptions(options.configure);\n    } // if the configuration system is enabled, copy all options and put them into the config system\n\n\n    if (this.configurator && this.configurator.options.enabled === true) {\n      var networkOptions = {\n        nodes: {},\n        edges: {},\n        layout: {},\n        interaction: {},\n        manipulation: {},\n        physics: {},\n        global: {}\n      };\n      deepExtend(networkOptions.nodes, this.nodesHandler.options);\n      deepExtend(networkOptions.edges, this.edgesHandler.options);\n      deepExtend(networkOptions.layout, this.layoutEngine.options); // load the selectionHandler and render default options in to the interaction group\n\n      deepExtend(networkOptions.interaction, this.selectionHandler.options);\n      deepExtend(networkOptions.interaction, this.renderer.options);\n      deepExtend(networkOptions.interaction, this.interactionHandler.options);\n      deepExtend(networkOptions.manipulation, this.manipulation.options);\n      deepExtend(networkOptions.physics, this.physics.options); // load globals into the global object\n\n      deepExtend(networkOptions.global, this.canvas.options);\n      deepExtend(networkOptions.global, this.options);\n      this.configurator.setModuleOptions(networkOptions);\n    } // handle network global options\n\n\n    if (options.clickToUse !== undefined) {\n      if (options.clickToUse === true) {\n        if (this.activator === undefined) {\n          this.activator = new Activator(this.canvas.frame);\n          this.activator.on(\"change\", function () {\n            _this2.body.emitter.emit(\"activate\");\n          });\n        }\n      } else {\n        if (this.activator !== undefined) {\n          this.activator.destroy();\n          delete this.activator;\n        }\n\n        this.body.emitter.emit(\"activate\");\n      }\n    } else {\n      this.body.emitter.emit(\"activate\");\n    }\n\n    this.canvas.setSize(); // start the physics simulation. Can be safely called multiple times.\n\n    this.body.emitter.emit(\"startSimulation\");\n  }\n};\n/**\n * Update the visible nodes and edges list with the most recent node state.\n *\n * Visible nodes are stored in this.body.nodeIndices.\n * Visible edges are stored in this.body.edgeIndices.\n * A node or edges is visible if it is not hidden or clustered.\n *\n * @private\n */\n\n\nNetwork.prototype._updateVisibleIndices = function () {\n  var nodes = this.body.nodes;\n  var edges = this.body.edges;\n  this.body.nodeIndices = [];\n  this.body.edgeIndices = [];\n\n  for (var nodeId in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n      if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {\n        this.body.nodeIndices.push(nodes[nodeId].id);\n      }\n    }\n  }\n\n  for (var edgeId in edges) {\n    if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {\n      var edge = edges[edgeId]; // It can happen that this is executed *after* a node edge has been removed,\n      // but *before* the edge itself has been removed. Taking this into account.\n\n      var fromNode = nodes[edge.fromId];\n      var toNode = nodes[edge.toId];\n      var edgeNodesPresent = fromNode !== undefined && toNode !== undefined;\n      var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && // Also hidden if any of its connecting nodes are hidden\n      toNode.options.hidden === false; // idem\n\n      if (isVisible) {\n        this.body.edgeIndices.push(edge.id);\n      }\n    }\n  }\n};\n/**\n * Bind all events\n */\n\n\nNetwork.prototype.bindEventListeners = function () {\n  var _this3 = this; // This event will trigger a rebuilding of the cache everything.\n  // Used when nodes or edges have been added or removed.\n\n\n  this.body.emitter.on(\"_dataChanged\", function () {\n    _this3.edgesHandler._updateState();\n\n    _this3.body.emitter.emit(\"_dataUpdated\");\n  }); // this is called when options of EXISTING nodes or edges have changed.\n\n  this.body.emitter.on(\"_dataUpdated\", function () {\n    // Order important in following block\n    _this3.clustering._updateState();\n\n    _this3._updateVisibleIndices();\n\n    _this3._updateValueRange(_this3.body.nodes);\n\n    _this3._updateValueRange(_this3.body.edges); // start simulation (can be called safely, even if already running)\n\n\n    _this3.body.emitter.emit(\"startSimulation\");\n\n    _this3.body.emitter.emit(\"_requestRedraw\");\n  });\n};\n/**\n * Set nodes and edges, and optionally options as well.\n *\n * @param {object} data              Object containing parameters:\n *                                   {Array | DataSet | DataView} [nodes] Array with nodes\n *                                   {Array | DataSet | DataView} [edges] Array with edges\n *                                   {String} [dot] String containing data in DOT format\n *                                   {String} [gephi] String containing data in gephi JSON format\n *                                   {Options} [options] Object with options\n */\n\n\nNetwork.prototype.setData = function (data) {\n  // reset the physics engine.\n  this.body.emitter.emit(\"resetPhysics\");\n  this.body.emitter.emit(\"_resetData\"); // unselect all to ensure no selections from old data are carried over.\n\n  this.selectionHandler.unselectAll();\n\n  if (data && data.dot && (data.nodes || data.edges)) {\n    throw new SyntaxError('Data must contain either parameter \"dot\" or ' + ' parameter pair \"nodes\" and \"edges\", but not both.');\n  } // set options\n\n\n  this.setOptions(data && data.options); // set all data\n\n  if (data && data.dot) {\n    console.warn(\"The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);\"); // parse DOT file\n\n    var dotData = DOTToGraph(data.dot);\n    this.setData(dotData);\n    return;\n  } else if (data && data.gephi) {\n    // parse DOT file\n    console.warn(\"The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);\");\n    var gephiData = parseGephi(data.gephi);\n    this.setData(gephiData);\n    return;\n  } else {\n    this.nodesHandler.setData(data && data.nodes, true);\n    this.edgesHandler.setData(data && data.edges, true);\n  } // emit change in data\n\n\n  this.body.emitter.emit(\"_dataChanged\"); // emit data loaded\n\n  this.body.emitter.emit(\"_dataLoaded\"); // find a stable position or start animating to a stable position\n\n  this.body.emitter.emit(\"initPhysics\");\n};\n/**\n * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.\n * var network = new vis.Network(..);\n * network.destroy();\n * network = null;\n */\n\n\nNetwork.prototype.destroy = function () {\n  this.body.emitter.emit(\"destroy\"); // clear events\n\n  this.body.emitter.off();\n  this.off(); // delete modules\n\n  delete this.groups;\n  delete this.canvas;\n  delete this.selectionHandler;\n  delete this.interactionHandler;\n  delete this.view;\n  delete this.renderer;\n  delete this.physics;\n  delete this.layoutEngine;\n  delete this.clustering;\n  delete this.manipulation;\n  delete this.nodesHandler;\n  delete this.edgesHandler;\n  delete this.configurator;\n  delete this.images;\n\n  for (var nodeId in this.body.nodes) {\n    if (!Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) continue;\n    delete this.body.nodes[nodeId];\n  }\n\n  for (var edgeId in this.body.edges) {\n    if (!Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) continue;\n    delete this.body.edges[edgeId];\n  } // remove the container and everything inside it recursively\n\n\n  recursiveDOMDelete(this.body.container);\n};\n/**\n * Update the values of all object in the given array according to the current\n * value range of the objects in the array.\n *\n * @param {object} obj    An object containing a set of Edges or Nodes\n *                        The objects must have a method getValue() and\n *                        setValueRange(min, max).\n * @private\n */\n\n\nNetwork.prototype._updateValueRange = function (obj) {\n  var id; // determine the range of the objects\n\n  var valueMin = undefined;\n  var valueMax = undefined;\n  var valueTotal = 0;\n\n  for (id in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, id)) {\n      var value = obj[id].getValue();\n\n      if (value !== undefined) {\n        valueMin = valueMin === undefined ? value : Math.min(value, valueMin);\n        valueMax = valueMax === undefined ? value : Math.max(value, valueMax);\n        valueTotal += value;\n      }\n    }\n  } // adjust the range of all objects\n\n\n  if (valueMin !== undefined && valueMax !== undefined) {\n    for (id in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, id)) {\n        obj[id].setValueRange(valueMin, valueMax, valueTotal);\n      }\n    }\n  }\n};\n/**\n * Returns true when the Network is active.\n *\n * @returns {boolean}\n */\n\n\nNetwork.prototype.isActive = function () {\n  return !this.activator || this.activator.active;\n};\n\nNetwork.prototype.setSize = function () {\n  return this.canvas.setSize.apply(this.canvas, arguments);\n};\n\nNetwork.prototype.canvasToDOM = function () {\n  return this.canvas.canvasToDOM.apply(this.canvas, arguments);\n};\n\nNetwork.prototype.DOMtoCanvas = function () {\n  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);\n};\n/**\n * Nodes can be in clusters. Clusters can also be in clusters. This function returns and array of\n * nodeIds showing where the node is.\n *\n * If any nodeId in the chain, especially the first passed in as a parameter, is not present in\n * the current nodes list, an empty array is returned.\n *\n * Example:\n * cluster 'A' contains cluster 'B',\n * cluster 'B' contains cluster 'C',\n * cluster 'C' contains node 'fred'.\n * `jsnetwork.clustering.findNode('fred')` will return `['A','B','C','fred']`.\n *\n * @param {string|number} nodeId\n * @returns {Array}\n */\n\n\nNetwork.prototype.findNode = function () {\n  return this.clustering.findNode.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.isCluster = function () {\n  return this.clustering.isCluster.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.openCluster = function () {\n  return this.clustering.openCluster.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.cluster = function () {\n  return this.clustering.cluster.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.getNodesInCluster = function () {\n  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.clusterByConnection = function () {\n  return this.clustering.clusterByConnection.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.clusterByHubsize = function () {\n  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.updateClusteredNode = function () {\n  return this.clustering.updateClusteredNode.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.getClusteredEdges = function () {\n  return this.clustering.getClusteredEdges.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.getBaseEdge = function () {\n  return this.clustering.getBaseEdge.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.getBaseEdges = function () {\n  return this.clustering.getBaseEdges.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.updateEdge = function () {\n  return this.clustering.updateEdge.apply(this.clustering, arguments);\n};\n/**\n * This method will cluster all nodes with 1 edge with their respective connected node.\n * The options object is explained in full <a data-scroll=\"\" data-options=\"{ &quot;easing&quot;: &quot;easeInCubic&quot; }\" href=\"#optionsObject\">below</a>.\n *\n * @param {object} [options]\n * @returns {undefined}\n */\n\n\nNetwork.prototype.clusterOutliers = function () {\n  return this.clustering.clusterOutliers.apply(this.clustering, arguments);\n};\n\nNetwork.prototype.getSeed = function () {\n  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);\n};\n\nNetwork.prototype.enableEditMode = function () {\n  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);\n};\n\nNetwork.prototype.disableEditMode = function () {\n  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);\n};\n\nNetwork.prototype.addNodeMode = function () {\n  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);\n};\n\nNetwork.prototype.editNode = function () {\n  return this.manipulation.editNode.apply(this.manipulation, arguments);\n};\n\nNetwork.prototype.editNodeMode = function () {\n  console.warn(\"Deprecated: Please use editNode instead of editNodeMode.\");\n  return this.manipulation.editNode.apply(this.manipulation, arguments);\n};\n\nNetwork.prototype.addEdgeMode = function () {\n  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);\n};\n\nNetwork.prototype.editEdgeMode = function () {\n  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);\n};\n\nNetwork.prototype.deleteSelected = function () {\n  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);\n};\n\nNetwork.prototype.getPositions = function () {\n  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);\n};\n\nNetwork.prototype.getPosition = function () {\n  return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);\n};\n\nNetwork.prototype.storePositions = function () {\n  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);\n};\n\nNetwork.prototype.moveNode = function () {\n  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);\n};\n\nNetwork.prototype.getBoundingBox = function () {\n  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);\n};\n\nNetwork.prototype.getConnectedNodes = function (objectId) {\n  if (this.body.nodes[objectId] !== undefined) {\n    return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);\n  } else {\n    return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);\n  }\n};\n\nNetwork.prototype.getConnectedEdges = function () {\n  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);\n};\n\nNetwork.prototype.startSimulation = function () {\n  return this.physics.startSimulation.apply(this.physics, arguments);\n};\n\nNetwork.prototype.stopSimulation = function () {\n  return this.physics.stopSimulation.apply(this.physics, arguments);\n};\n\nNetwork.prototype.stabilize = function () {\n  return this.physics.stabilize.apply(this.physics, arguments);\n};\n\nNetwork.prototype.getSelection = function () {\n  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);\n};\n\nNetwork.prototype.setSelection = function () {\n  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);\n};\n\nNetwork.prototype.getSelectedNodes = function () {\n  return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler, arguments);\n};\n\nNetwork.prototype.getSelectedEdges = function () {\n  return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler, arguments);\n};\n\nNetwork.prototype.getNodeAt = function () {\n  var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);\n\n  if (node !== undefined && node.id !== undefined) {\n    return node.id;\n  }\n\n  return node;\n};\n\nNetwork.prototype.getEdgeAt = function () {\n  var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);\n\n  if (edge !== undefined && edge.id !== undefined) {\n    return edge.id;\n  }\n\n  return edge;\n};\n\nNetwork.prototype.selectNodes = function () {\n  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);\n};\n\nNetwork.prototype.selectEdges = function () {\n  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);\n};\n\nNetwork.prototype.unselectAll = function () {\n  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);\n  this.redraw();\n};\n\nNetwork.prototype.redraw = function () {\n  return this.renderer.redraw.apply(this.renderer, arguments);\n};\n\nNetwork.prototype.getScale = function () {\n  return this.view.getScale.apply(this.view, arguments);\n};\n\nNetwork.prototype.getViewPosition = function () {\n  return this.view.getViewPosition.apply(this.view, arguments);\n};\n\nNetwork.prototype.fit = function () {\n  return this.view.fit.apply(this.view, arguments);\n};\n\nNetwork.prototype.moveTo = function () {\n  return this.view.moveTo.apply(this.view, arguments);\n};\n\nNetwork.prototype.focus = function () {\n  return this.view.focus.apply(this.view, arguments);\n};\n\nNetwork.prototype.releaseNode = function () {\n  return this.view.releaseNode.apply(this.view, arguments);\n};\n\nNetwork.prototype.getOptionsFromConfigurator = function () {\n  var options = {};\n\n  if (this.configurator) {\n    options = this.configurator.getOptions.apply(this.configurator);\n  }\n\n  return options;\n};\n\nvar parseDOTNetwork = DOTToGraph; // overflow in UMD builds. They all export vis namespace therefore reexporting\n// leads to loading vis to load vis to load vis…\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmlzLW5ldHdvcmsvcGVlci9lc20vdmlzLW5ldHdvcmsuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBOztBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQVJBOztBQVdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBREE7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBOztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUEE7QUFTQTtBQURBOztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQURBOztBQUlBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFIQTtBQUtBO0FBTEE7QUFPQTtBQVBBO0FBU0E7QUFUQTtBQVdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFIQTtBQUtBO0FBTEE7QUFPQTtBQVBBO0FBU0E7QUFUQTtBQVdBO0FBWEE7QUFhQTtBQWJBO0FBZUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFEQTs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQURBOztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBZkE7O0FBa0JBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7O0FBTUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBREE7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFFQTtBQURBO0FBREE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFJQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTs7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFkQTs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvQkE7QUFrQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBS0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQVJBOztBQVdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQURBOztBQUlBO0FBRUE7QUFFQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFEQTs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBR0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBWUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUhBOztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQURBOztBQUlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTs7QUFJQTtBQUVBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7O0FBUUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUFBO0FBRUE7QUFOQTs7QUFTQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQURBOztBQUlBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUF4QkE7OztBQTZCQTs7QUFJQTs7QUFJQTs7QUFJQTs7QUFJQTtBQUVBOztBQUlBOztBQUlBOztBQUlBOztBQUlBOztBQUlBOztBQUlBOztBQUlBOztBQUlBO0FBRUE7O0FBSUE7O0FBSUE7O0FBSUE7O0FBSUE7QUFFQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQTlCQTs7QUFpQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBRUE7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7O0FBUUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQURBOztBQUlBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUVBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFwQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFQQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFiQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQWJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBdkJBOztBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5SUE7QUFpSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUF2REE7O0FBMERBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUxBOzs7QUFRQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7O0FBUUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVdBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUhBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBSEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUhBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFIQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQUhBO0FBZUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQUhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFIQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBSEE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBSEE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQUhBO0FBY0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBSEE7QUFVQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQUhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFIQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFIQTtBQWNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQUhBO0FBVUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFKQTs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFKQTtBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbERBO0FBbERBO0FBdUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFUQTtBQVdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBOztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBOztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBOztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUJBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQkE7QUF3QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTVCQTtBQStCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQTtBQTZCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2QkE7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFDQTtBQTZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFIQTtBQURBO0FBUUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0RBO0FBNkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQTVMQTs7QUFrTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFwT0E7QUFpUEE7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWJBO0FBZ0JBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2Q0E7QUEwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBYkE7QUFnQkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7O0FBU0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBTEE7O0FBUUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTs7QUFJQTtBQUVBO0FBRUE7O0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBREE7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTs7QUFJQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMUNBO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVpBO0FBZUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMUJBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTNCQTtBQThCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsREE7QUFxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQWJBO0FBZ0JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckJBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckJBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaEJBO0FBbUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2QkE7QUEwQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBdkJBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF4RUE7QUEyRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBakJBO0FBb0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQ0E7QUF3Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsREE7QUFxREE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFiQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdEJBO0FBeUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF6QkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUEvQ0E7QUFrREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQ0E7QUFzQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqQ0E7QUFvQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcEVBO0FBdUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWJBO0FBZ0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFkQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWRBO0FBaUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF4REE7QUEyREE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0NBO0FBOENBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXRCQTtBQXlCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdENBO0FBeUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTNCQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzRUE7QUE4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxDQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE3Q0E7QUFnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0JBO0FBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBOztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeERBO0FBMkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBYkE7QUFnQkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBN0JBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBZEE7OztBQWtCQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZDQTs7QUEwQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTs7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBREE7O0FBSUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQU9BO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBS0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTs7O0FBSUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBWUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzQkE7QUE4QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWRBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdkJBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaEJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckJBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZCQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFyQkE7QUF3QkE7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQkE7QUFzQkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFUQTtBQVlBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhDQTtBQW1DQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpDQTtBQW9DQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBckJBO0FBd0JBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXhCQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaEJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQVJBO0FBV0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE1QkE7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeENBO0FBMkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeEJBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQVJBO0FBV0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaENBO0FBbUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExQ0E7QUE2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZ0JBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBVkE7O0FBYUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsREE7QUFxREE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFSQTtBQVdBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWVBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZCQTtBQTBCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBNUJBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2QkE7QUEwQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0JBO0FBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXpEQTtBQTREQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTdCQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFWQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFWQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTs7QUFFQTtBQUNBO0FBREE7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTlCQTtBQWlDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeERBO0FBMkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEvQkE7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwREE7QUF1REE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsQ0E7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFsQ0E7QUFxQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWJBO0FBZ0JBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsQkE7QUFxQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaEZBO0FBbUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXRDQTtBQXlDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpFQTtBQW9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcENBO0FBdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQW5FQTtBQXFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxGQTtBQXFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzQkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFWQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzQkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFiQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFWQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQS9DQTtBQWtEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUEvREE7QUFpRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFnQkE7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQXJCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFQQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoSUE7O0FBbUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF4QkE7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeERBO0FBMkRBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhEQTtBQW1EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE1QkE7QUErQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE3Q0E7QUFnREE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBWUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE3QkE7QUFnQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTlDQTtBQWlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdkNBO0FBMENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5DQTtBQXNDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZCQTtBQTBCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWtCQTtBQUNBOztBQUVBO0FBRUE7O0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTs7QUFJQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQXZCQTs7QUEwQkE7QUFFQTtBQUVBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJDQTtBQXdDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBMUJBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQTlCQTtBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBOUJBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUJBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUJBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQTNCQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQXZDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUE1QkE7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBNUJBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUE5QkE7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQXJDQTtBQXVDQTtBQXpEQTtBQTREQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVJBO0FBV0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXRCQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF4QkE7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1BO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTNEQTtBQThEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUkE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXhDQTtBQTJDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeEJBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhFQTtBQW1FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTNDQTtBQThDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhEQTtBQW1EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTVCQTtBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUF6QkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOztBQXpIQTtBQTRIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeEJBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBb0JBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF6RUE7QUE0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQ0E7QUF3Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeEJBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBOztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQTVCQTtBQStCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBdkJBO0FBMEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF0QkE7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFMQTtBQVFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBeEJBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBOztBQWhLQTtBQW1LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTkE7QUFTQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVhBO0FBY0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBN0JBO0FBZ0NBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBYkE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQS9CQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7O0FBTUE7QUFDQTtBQUNBOztBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQWhCQTtBQW1CQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7O0FBdkJBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuREE7QUFzREE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBOztBQXNDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJHQTtBQXdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2Q0E7QUEwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBekJBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXpCQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQkE7QUF3QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckJBO0FBd0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5GQTtBQXNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdERBO0FBeURBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsQ0E7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2QkE7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBN0NBO0FBZ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFQQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWEE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzSkE7QUE4SkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBWkE7QUFrQkE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQXJCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFqSEE7QUFtSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpGQTtBQW9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXRDQTtBQXlDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBEQTtBQXVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXRDQTtBQXlDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckJBO0FBd0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExQkE7QUE2QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF0QkE7QUF5QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBY0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXhCQTtBQTJCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQXJCQTtBQXdCQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWJBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE1QkE7QUErQkE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJDQTtBQXdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0JBO0FBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQW5CQTtBQURBOztBQXdCQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpHQTtBQW9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckJBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwQ0E7QUF1Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBN0JBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0NBO0FBOENBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBDQTtBQXVDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNCQTs7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQW5CQTtBQXFCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqRUE7QUFvRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeENBO0FBMkNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdDQTtBQWdEQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1Q0E7QUErQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBekNBO0FBNENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdEZBO0FBeUZBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzQkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFZQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFqREE7QUF1REE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5EQTtBQXNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEvQ0E7QUFrREE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaENBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF6QkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdEJBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeEJBO0FBMkJBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXRCQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWRBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0JBO0FBOEJBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMUNBO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbkRBO0FBc0RBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQ0E7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXhCQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQS9CQTtBQWtDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2QkE7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE1Q0E7QUErQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZCQTtBQTBCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwQkE7QUF1QkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0NBO0FBOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXpDQTtBQTRDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFsQ0E7QUFxQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBUUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcERBO0FBdURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpEQTtBQW9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWZBO0FBa0JBO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakRBO0FBb0RBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQS9CQTtBQWtDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJDQTtBQXdDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbklBO0FBc0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWEE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWkE7QUFlQTtBQUNBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhHQTtBQW1HQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTVHQTtBQStHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF0QkE7QUF5QkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuSEE7QUFzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBYkE7QUFnQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoQkE7QUFtQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUJBO0FBaUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0tBO0FBOEtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF4QkE7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE3QkE7QUFnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2QkE7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBN0JBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXhCQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQS9DQTtBQWtEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMUNBO0FBNkNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEvQkE7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJFQTtBQXdFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBNU1BO0FBK01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbkVBO0FBc0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBakJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxDQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2QkE7QUEwQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBY0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoRkE7QUFtRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTlCQTtBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBHQTtBQXVHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbkJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF6QkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFrQkE7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzQkE7QUE4QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFEQTtBQTZEQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBY0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBDQTtBQXVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBakJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUNBO0FBaURBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTs7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBFQTtBQXVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpGQTtBQW9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFWQTtBQWFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXhCQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFQQTtBQVVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVBBO0FBVUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWEE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFFQTtBQTZFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdkJBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhIQTtBQW1IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBFQTtBQXVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF6QkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUJBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVBBO0FBVUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMUJBO0FBNkJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTVDQTtBQStDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBYkE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWZBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWZBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVJBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZCQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUF0QkE7QUF5QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1SEE7QUErSEE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFWQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFHQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdEVBO0FBeUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFtQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBYkE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0JBO0FBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWJBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaEJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWJBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBNUJBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaEZBO0FBbUZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTVFQTtBQStFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2REE7QUEwREE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQS9EQTtBQWtFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBN0JBO0FBZ0NBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeERBO0FBMkRBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpHQTtBQW9HQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlCQTtBQWlDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBakVBO0FBb0VBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFwQ0E7QUFzQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBVEE7QUFXQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBdkNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTs7QUFDQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFiQTtBQWdCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2QkE7QUEwQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE5QkE7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBekJBO0FBNEJBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJDQTtBQXdDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdEJBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBakJBO0FBb0JBO0FBQ0E7QUFDQTs7QUFHQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTVCQTtBQStCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbkJBO0FBc0JBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTNDQTtBQThDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWRBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBakJBO0FBb0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF6QkE7QUE0QkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTlCQTtBQWlDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF4RUE7QUEyRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTNDQTtBQThDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVEE7QUFZQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWJBO0FBZ0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFkQTtBQWlCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJFQTtBQXdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdkNBO0FBMENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUE1QkE7QUErQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFMQTs7QUFRQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWZBOztBQW1CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWZBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTEE7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTEE7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7QUFUQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFMQTs7QUFRQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWRBO0FBaUJBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbENBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpCQTtBQW9CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE1QkE7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFKQTtBQW1CQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQS9CQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbERBO0FBcURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTNGQTtBQThGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7QUFQQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTs7QUFEQTtBQVBBO0FBYkE7QUEwQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFEQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5JQTtBQXNJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZCQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFWQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuRUE7QUFzRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWphQTtBQW9hQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUNBO0FBaURBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwQ0E7QUF1Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEvQ0E7QUFrREE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0RBO0FBOERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBL0JBO0FBa0NBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUJBO0FBaUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTlCQTtBQWlDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsQ0E7QUFxQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQS9CQTtBQWtDQTtBQUNBO0FBQ0E7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZCQTtBQTBCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckJBO0FBd0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXRFQTtBQXlFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxDQTtBQXFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE1REE7QUErREE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQXRCQTtBQXlCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUhBO0FBUUE7QUFDQTtBQVpBO0FBVEE7QUF5QkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBakJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBDQTtBQXVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBY0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyRkE7QUF3RkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5DQTtBQXNDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaERBO0FBbURBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUNBO0FBaURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2R0E7QUEwR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXpFQTtBQTRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXpCQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUNBO0FBaURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF6QkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTdCQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFiQTtBQWdCQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWZBO0FBa0JBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdkJBO0FBMEJBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFkQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE3Q0E7QUFnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFYQTtBQWNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxDQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZEQTtBQTBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqREE7QUFvREE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxEQTtBQXFEQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXZEQTtBQTBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWJBO0FBZ0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJDQTtBQXdDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJDQTtBQXdDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0NBO0FBOENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUlBO0FBOElBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBYkE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFkQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQkE7QUFzQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJFQTtBQXdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBL0JBO0FBa0NBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBZkE7QUFrQkE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMUJBO0FBNkJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEvQkE7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBYkE7QUFnQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzSEE7QUE4SEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEvQkE7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxEQTtBQXFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQTdCQTtBQWdDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2REE7QUEwREE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbkJBO0FBc0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbkRBO0FBc0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpCQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF0QkE7QUF5QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdkJBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBakJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF0QkE7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExQ0E7QUE2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBN0VBO0FBZ0ZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsQ0E7QUFxQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFkQTtBQWlCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTNCQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBN0NBO0FBZ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhDQTtBQW1DQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBakNBO0FBb0NBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExRkE7QUE2RkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF0Q0E7QUF5Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzQkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBWUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBVkE7QUFhQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQWhCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQW5CQTtBQXdCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBbkJBO0FBd0JBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFuQkE7QUF3QkE7QUFDQTtBQUNBO0FBRkE7QUF6RUE7QUE4RUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQVBBO0FBWUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBZEE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFUQTtBQWNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQWpCQTtBQXNCQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBakJBO0FBc0JBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQWpCQTtBQXNCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFqQkE7QUFzQkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBakJBO0FBc0JBO0FBQ0E7QUFDQTtBQUZBO0FBdkhBO0FBNEhBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQWhCQTtBQXFCQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUEvQkE7QUFtQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQVZBO0FBY0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQWhCQTtBQXFCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFkQTtBQW1CQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUpBO0FBVUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUEvWkE7QUFtYUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUxBO0FBU0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBVkE7QUFjQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQXJCQTtBQTBCQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFyRUE7QUF5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQWxDQTtBQXVDQTtBQUNBO0FBREE7QUFuREE7QUF1REE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSkE7QUFVQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQXJDQTtBQTBDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQVRBO0FBY0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUNBO0FBQ0E7QUFGQTtBQS9CQTtBQW9DQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFQQTtBQVlBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBakJBO0FBc0JBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQWpCQTtBQXNCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFqQkE7QUFzQkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBakJBO0FBc0JBO0FBQ0E7QUFDQTtBQUZBO0FBdkhBO0FBNEhBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFQQTtBQWFBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBbkJBO0FBdUJBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBWEE7QUFnQkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQWJBO0FBa0JBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBYkE7QUFrQkE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBaEJBO0FBcUJBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQS9CQTtBQW1DQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBaEJBO0FBcUJBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFwQkE7QUF3QkE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBUEE7QUFhQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFwYkE7QUF3YkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQXRCQTtBQTBCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQXRCQTtBQTBCQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQWhCQTtBQW9CQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQW5CQTtBQXVCQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQWpCQTtBQXNCQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQVBBO0FBV0E7QUFDQTtBQUNBO0FBRkE7QUFwSkE7QUF5SkE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBUUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBeHRDQTtBQTR0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFQQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUhBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBbEVBO0FBb0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFYQTtBQWlCQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBSEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUE3RUE7QUErRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWkE7QUFIQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2QkE7QUF5QkE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUF2Q0E7QUFwTUE7QUFtUEE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUEvQ0E7QUFrREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1BO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaEVBO0FBbUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckNBO0FBd0NBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoREE7QUFtREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFDQTtBQTZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUF2Q0E7QUEwQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFGQTtBQTlDQTs7QUE2REE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3Zpcy1uZXR3b3JrL3BlZXIvZXNtL3Zpcy1uZXR3b3JrLmpzP2ExOTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB2aXMtbmV0d29ya1xuICogaHR0cHM6Ly92aXNqcy5naXRodWIuaW8vdmlzLW5ldHdvcmsvXG4gKlxuICogQSBkeW5hbWljLCBicm93c2VyLWJhc2VkIHZpc3VhbGl6YXRpb24gbGlicmFyeS5cbiAqXG4gKiBAdmVyc2lvbiA4LjUuNFxuICogQGRhdGUgICAgMjAyMC0xMS0yM1QxOTo1MDozMi44ODNaXG4gKlxuICogQGNvcHlyaWdodCAoYykgMjAxMS0yMDE3IEFsbWVuZGUgQi5WLCBodHRwOi8vYWxtZW5kZS5jb21cbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTctMjAxOSB2aXNqcyBjb250cmlidXRvcnMsIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNqc1xuICpcbiAqIEBsaWNlbnNlXG4gKiB2aXMuanMgaXMgZHVhbCBsaWNlbnNlZCB1bmRlciBib3RoXG4gKlxuICogICAxLiBUaGUgQXBhY2hlIDIuMCBMaWNlbnNlXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICAgYW5kXG4gKlxuICogICAyLiBUaGUgTUlUIExpY2Vuc2VcbiAqICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIHZpcy5qcyBtYXkgYmUgZGlzdHJpYnV0ZWQgdW5kZXIgZWl0aGVyIGxpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaXNEYXRhVmlld0xpa2UsIERhdGFTZXQgfSBmcm9tICd2aXMtZGF0YS9wZWVyL2VzbS92aXMtZGF0YS5qcyc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgYmFzZWRpciwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7XG5cdFx0cGF0aDogYmFzZWRpcixcblx0XHRleHBvcnRzOiB7fSxcblx0XHRyZXF1aXJlOiBmdW5jdGlvbiAocGF0aCwgYmFzZSkge1xuXHRcdFx0cmV0dXJuIGNvbW1vbmpzUmVxdWlyZShwYXRoLCAoYmFzZSA9PT0gdW5kZWZpbmVkIHx8IGJhc2UgPT09IG51bGwpID8gbW9kdWxlLnBhdGggOiBiYXNlKTtcblx0XHR9XG5cdH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlICgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBAcm9sbHVwL3BsdWdpbi1jb21tb25qcycpO1xufVxuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5cblxudmFyIGdsb2JhbF8xID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5jaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fCBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHwgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHwgY2hlY2sodHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsKSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbmZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIGZhaWxzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiA3O1xuICAgIH1cbiAgfSlbMV0gIT0gNztcbn0pO1xuXG52YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyAvLyBOYXNob3JuIH4gSkRLOCBidWdcblxudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICFuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHtcbiAgMTogMlxufSwgMSk7IC8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcblxudmFyIGYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge1xuICBmOiBmXG59O1xuXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgY2xhc3NvZlJhdyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxudmFyIHNwbGl0ID0gJycuc3BsaXQ7IC8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5cbnZhciBpbmRleGVkT2JqZWN0ID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgcmV0dXJuICFPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mUmF3KGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0LmNhbGwoaXQsICcnKSA6IE9iamVjdChpdCk7XG59IDogT2JqZWN0O1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcblxudmFyIHRvUHJpbWl0aXZlID0gZnVuY3Rpb24gKGlucHV0LCBQUkVGRVJSRURfU1RSSU5HKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpbnB1dC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbnZhciBoYXMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cbnZhciBkb2N1bWVudCQxID0gZ2xvYmFsXzEuZG9jdW1lbnQ7IC8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxuXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQkMSkgJiYgaXNPYmplY3QoZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KTtcblxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIGllOERvbURlZmluZSA9ICFkZXNjcmlwdG9ycyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDc7XG4gICAgfVxuICB9KS5hICE9IDc7XG59KTtcblxudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcblxudmFyIGYkMSA9IGRlc2NyaXB0b3JzID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoaWU4RG9tRGVmaW5lKSB0cnkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7XG4gIGY6IGYkMVxufTtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWUgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZSA6IHR5cGVvZiBkZXRlY3Rpb24gPT0gJ2Z1bmN0aW9uJyA/IGZhaWxzKGRldGVjdGlvbikgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcbnZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQ7XG5cbnZhciBwYXRoID0ge307XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgZnVuY3Rpb25CaW5kQ29udGV4dCA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcblxuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQpO1xuICAgICAgfTtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgICB9O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKVxuICAvKiAuLi5hcmdzICovXG4gIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciBhbk9iamVjdCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7IC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5cbnZhciBmJDIgPSBkZXNjcmlwdG9ycyA/IG5hdGl2ZURlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKGllOERvbURlZmluZSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7XG4gIGY6IGYkMlxufTtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGRlc2NyaXB0b3JzID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0RGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG5cbnZhciB3cmFwQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoTmF0aXZlQ29uc3RydWN0b3IpIHtcbiAgdmFyIFdyYXBwZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTmF0aXZlQ29uc3RydWN0b3IpIHtcbiAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEpO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEsIGIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEsIGIsIGMpO1xuICAgIH1cblxuICAgIHJldHVybiBOYXRpdmVDb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFdyYXBwZXIucHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICByZXR1cm4gV3JhcHBlcjtcbn07XG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLm5vVGFyZ2V0R2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuKi9cblxuXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBQUk9UTyA9IG9wdGlvbnMucHJvdG87XG4gIHZhciBuYXRpdmVTb3VyY2UgPSBHTE9CQUwgPyBnbG9iYWxfMSA6IFNUQVRJQyA/IGdsb2JhbF8xW1RBUkdFVF0gOiAoZ2xvYmFsXzFbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB2YXIgdGFyZ2V0ID0gR0xPQkFMID8gcGF0aCA6IHBhdGhbVEFSR0VUXSB8fCAocGF0aFtUQVJHRVRdID0ge30pO1xuICB2YXIgdGFyZ2V0UHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgdmFyIEZPUkNFRCwgVVNFX05BVElWRSwgVklSVFVBTF9QUk9UT1RZUEU7XG4gIHZhciBrZXksIHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSwgbmF0aXZlUHJvcGVydHksIHJlc3VsdFByb3BlcnR5LCBkZXNjcmlwdG9yO1xuXG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkXzEoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTsgLy8gY29udGFpbnMgaW4gbmF0aXZlXG5cbiAgICBVU0VfTkFUSVZFID0gIUZPUkNFRCAmJiBuYXRpdmVTb3VyY2UgJiYgaGFzKG5hdGl2ZVNvdXJjZSwga2V5KTtcbiAgICB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIGlmIChVU0VfTkFUSVZFKSBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKG5hdGl2ZVNvdXJjZSwga2V5KTtcbiAgICAgIG5hdGl2ZVByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSBuYXRpdmVQcm9wZXJ0eSA9IG5hdGl2ZVNvdXJjZVtrZXldOyAvLyBleHBvcnQgbmF0aXZlIG9yIGltcGxlbWVudGF0aW9uXG5cbiAgICBzb3VyY2VQcm9wZXJ0eSA9IFVTRV9OQVRJVkUgJiYgbmF0aXZlUHJvcGVydHkgPyBuYXRpdmVQcm9wZXJ0eSA6IHNvdXJjZVtrZXldO1xuICAgIGlmIChVU0VfTkFUSVZFICYmIHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSA9PT0gdHlwZW9mIHNvdXJjZVByb3BlcnR5KSBjb250aW51ZTsgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcblxuICAgIGlmIChvcHRpb25zLmJpbmQgJiYgVVNFX05BVElWRSkgcmVzdWx0UHJvcGVydHkgPSBmdW5jdGlvbkJpbmRDb250ZXh0KHNvdXJjZVByb3BlcnR5LCBnbG9iYWxfMSk7IC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ3MgaW4gdGhpcyB2ZXJzaW9uXG4gICAgZWxzZSBpZiAob3B0aW9ucy53cmFwICYmIFVTRV9OQVRJVkUpIHJlc3VsdFByb3BlcnR5ID0gd3JhcENvbnN0cnVjdG9yKHNvdXJjZVByb3BlcnR5KTsgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgICBlbHNlIGlmIChQUk9UTyAmJiB0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gJ2Z1bmN0aW9uJykgcmVzdWx0UHJvcGVydHkgPSBmdW5jdGlvbkJpbmRDb250ZXh0KEZ1bmN0aW9uLmNhbGwsIHNvdXJjZVByb3BlcnR5KTsgLy8gZGVmYXVsdCBjYXNlXG4gICAgICAgIGVsc2UgcmVzdWx0UHJvcGVydHkgPSBzb3VyY2VQcm9wZXJ0eTsgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCBzb3VyY2VQcm9wZXJ0eSAmJiBzb3VyY2VQcm9wZXJ0eS5zaGFtIHx8IHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShyZXN1bHRQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0YXJnZXRba2V5XSA9IHJlc3VsdFByb3BlcnR5O1xuXG4gICAgaWYgKFBST1RPKSB7XG4gICAgICBWSVJUVUFMX1BST1RPVFlQRSA9IFRBUkdFVCArICdQcm90b3R5cGUnO1xuXG4gICAgICBpZiAoIWhhcyhwYXRoLCBWSVJUVUFMX1BST1RPVFlQRSkpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHBhdGgsIFZJUlRVQUxfUFJPVE9UWVBFLCB7fSk7XG4gICAgICB9IC8vIGV4cG9ydCB2aXJ0dWFsIHByb3RvdHlwZSBtZXRob2RzXG5cblxuICAgICAgcGF0aFtWSVJUVUFMX1BST1RPVFlQRV1ba2V5XSA9IHNvdXJjZVByb3BlcnR5OyAvLyBleHBvcnQgcmVhbCBwcm90b3R5cGUgbWV0aG9kc1xuXG4gICAgICBpZiAob3B0aW9ucy5yZWFsICYmIHRhcmdldFByb3RvdHlwZSAmJiAhdGFyZ2V0UHJvdG90eXBlW2tleV0pIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldFByb3RvdHlwZSwga2V5LCBzb3VyY2VQcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChDLCBhcmdzTGVuZ3RoLCBhcmdzKSB7XG4gIGlmICghKGFyZ3NMZW5ndGggaW4gZmFjdG9yaWVzKSkge1xuICAgIGZvciAodmFyIGxpc3QgPSBbXSwgaSA9IDA7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIGxpc3RbaV0gPSAnYVsnICsgaSArICddJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG5cblxuICAgIGZhY3Rvcmllc1thcmdzTGVuZ3RoXSA9IEZ1bmN0aW9uKCdDLGEnLCAncmV0dXJuIG5ldyBDKCcgKyBsaXN0LmpvaW4oJywnKSArICcpJyk7XG4gIH1cblxuICByZXR1cm4gZmFjdG9yaWVzW2FyZ3NMZW5ndGhdKEMsIGFyZ3MpO1xufTsgLy8gYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5cblxudmFyIGZ1bmN0aW9uQmluZCA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0XG4vKiAsIC4uLmFyZ3MgKi9cbikge1xuICB2YXIgZm4gPSBhRnVuY3Rpb24odGhpcyk7XG4gIHZhciBwYXJ0QXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICB2YXIgYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uIGJvdW5kKClcbiAgLyogYXJncy4uLiAqL1xuICB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kRnVuY3Rpb24gPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9O1xuXG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZEZ1bmN0aW9uLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kRnVuY3Rpb247XG59O1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXG5fZXhwb3J0KHtcbiAgdGFyZ2V0OiAnRnVuY3Rpb24nLFxuICBwcm90bzogdHJ1ZVxufSwge1xuICBiaW5kOiBmdW5jdGlvbkJpbmRcbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SKSB7XG4gIHJldHVybiBwYXRoW0NPTlNUUlVDVE9SICsgJ1Byb3RvdHlwZSddO1xufTtcblxudmFyIGJpbmQgPSBlbnRyeVZpcnR1YWwoJ0Z1bmN0aW9uJykuYmluZDtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG52YXIgYmluZF8xID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5iaW5kO1xuICByZXR1cm4gaXQgPT09IEZ1bmN0aW9uUHJvdG90eXBlIHx8IGl0IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb3duID09PSBGdW5jdGlvblByb3RvdHlwZS5iaW5kID8gYmluZCA6IG93bjtcbn07XG5cbnZhciBiaW5kJDEgPSBiaW5kXzE7XG5cbnZhciBiaW5kJDIgPSBiaW5kJDE7XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjsgLy8gYFRvSW50ZWdlcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2ludGVnZXJcblxudmFyIHRvSW50ZWdlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG5cbnZhciBtaW4gPSBNYXRoLm1pbjsgLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5cbnZhciB0b0xlbmd0aCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiQxID0gTWF0aC5taW47IC8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDEoaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlOyAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlOyAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxudmFyIGhpZGRlbktleXMgPSB7fTtcblxudmFyIGluZGV4T2YgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcblxuICBmb3IgKGtleSBpbiBPKSAhaGFzKGhpZGRlbktleXMsIGtleSkgJiYgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTsgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuXG5cbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBlbnVtQnVnS2V5cyA9IFsnY29uc3RydWN0b3InLCAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICd0b0xvY2FsZVN0cmluZycsICd0b1N0cmluZycsICd2YWx1ZU9mJ107XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBvYmplY3RLZXlzSW50ZXJuYWwoTywgZW51bUJ1Z0tleXMpO1xufTtcblxudmFyIGYkMyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge1xuICBmOiBmJDNcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5cbnZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG5cbnZhciBuYXRpdmVBc3NpZ24gPSBPYmplY3QuYXNzaWduO1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5OyAvLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG5cbnZhciBvYmplY3RBc3NpZ24gPSAhbmF0aXZlQXNzaWduIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gc2hvdWxkIGhhdmUgY29ycmVjdCBvcmRlciBvZiBvcGVyYXRpb25zIChFZGdlIGJ1ZylcbiAgaWYgKGRlc2NyaXB0b3JzICYmIG5hdGl2ZUFzc2lnbih7XG4gICAgYjogMVxuICB9LCBuYXRpdmVBc3NpZ24oZGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYicsIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCB7XG4gICAgYjogMlxuICB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7IC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuXG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikge1xuICAgIEJbY2hyXSA9IGNocjtcbiAgfSk7XG4gIHJldHVybiBuYXRpdmVBc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKG5hdGl2ZUFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmY7XG5cbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBpbmRleGVkT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBvYmplY3RLZXlzKFMpLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG5cbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFkZXNjcmlwdG9ycyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVDtcbn0gOiBuYXRpdmVBc3NpZ247XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gb2JqZWN0QXNzaWduXG59LCB7XG4gIGFzc2lnbjogb2JqZWN0QXNzaWduXG59KTtcblxudmFyIGFzc2lnbiA9IHBhdGguT2JqZWN0LmFzc2lnbjtcblxudmFyIGFzc2lnbiQxID0gYXNzaWduO1xuXG52YXIgYXNzaWduJDIgPSBhc3NpZ24kMTtcblxuLyoqXHJcbiAqIERyYXcgYSBjaXJjbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICovXG5mdW5jdGlvbiBkcmF3Q2lyY2xlKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgciwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYSBzcXVhcmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIEhhbGYgb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNxdWFyZS5cclxuICovXG5cbmZ1bmN0aW9uIGRyYXdTcXVhcmUoY3R4LCB4LCB5LCByKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoeCAtIHIsIHkgLSByLCByICogMiwgciAqIDIpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhbiBlcXVpbGF0ZXJhbCB0cmlhbmdsZSBzdGFuZGluZyBvbiBhIHNpZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIEhhbGYgb2YgdGhlIGxlbmd0aCBvZiB0aGUgc2lkZXMuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXF1aWxhdGVyYWxfdHJpYW5nbGVcclxuICovXG5cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZShjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpOyAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcblxuICByICo9IDEuMTU7XG4gIHkgKz0gMC4yNzUgKiByO1xuICB2YXIgcyA9IHIgKiAyO1xuICB2YXIgczIgPSBzIC8gMjtcbiAgdmFyIGlyID0gTWF0aC5zcXJ0KDMpIC8gNiAqIHM7IC8vIHJhZGl1cyBvZiBpbm5lciBjaXJjbGVcblxuICB2YXIgaCA9IE1hdGguc3FydChzICogcyAtIHMyICogczIpOyAvLyBoZWlnaHRcblxuICBjdHgubW92ZVRvKHgsIHkgLSAoaCAtIGlyKSk7XG4gIGN0eC5saW5lVG8oeCArIHMyLCB5ICsgaXIpO1xuICBjdHgubGluZVRvKHggLSBzMiwgeSArIGlyKTtcbiAgY3R4LmxpbmVUbyh4LCB5IC0gKGggLSBpcikpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhbiBlcXVpbGF0ZXJhbCB0cmlhbmdsZSBzdGFuZGluZyBvbiBhIHZlcnRleC5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gSGFsZiBvZiB0aGUgbGVuZ3RoIG9mIHRoZSBzaWRlcy5cclxuICpcclxuICogQHJlbWFya3NcclxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpbGF0ZXJhbF90cmlhbmdsZVxyXG4gKi9cblxuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlRG93bihjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpOyAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcblxuICByICo9IDEuMTU7XG4gIHkgLT0gMC4yNzUgKiByO1xuICB2YXIgcyA9IHIgKiAyO1xuICB2YXIgczIgPSBzIC8gMjtcbiAgdmFyIGlyID0gTWF0aC5zcXJ0KDMpIC8gNiAqIHM7IC8vIHJhZGl1cyBvZiBpbm5lciBjaXJjbGVcblxuICB2YXIgaCA9IE1hdGguc3FydChzICogcyAtIHMyICogczIpOyAvLyBoZWlnaHRcblxuICBjdHgubW92ZVRvKHgsIHkgKyAoaCAtIGlyKSk7XG4gIGN0eC5saW5lVG8oeCArIHMyLCB5IC0gaXIpO1xuICBjdHgubGluZVRvKHggLSBzMiwgeSAtIGlyKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgKGggLSBpcikpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhIHN0YXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHN0YXIuXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3U3RhcihjdHgsIHgsIHksIHIpIHtcbiAgLy8gaHR0cDovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vbGFicy9odG1sNS1jYW52YXMtc3Rhci1zcGlubmVyL1xuICBjdHguYmVnaW5QYXRoKCk7IC8vIHRoZSBjaGFuZ2UgaW4gcmFkaXVzIGFuZCB0aGUgb2Zmc2V0IGlzIGhlcmUgdG8gY2VudGVyIHRoZSBzaGFwZVxuXG4gIHIgKj0gMC44MjtcbiAgeSArPSAwLjEgKiByO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMTA7IG4rKykge1xuICAgIHZhciByYWRpdXMgPSBuICUgMiA9PT0gMCA/IHIgKiAxLjMgOiByICogMC41O1xuICAgIGN0eC5saW5lVG8oeCArIHJhZGl1cyAqIE1hdGguc2luKG4gKiAyICogTWF0aC5QSSAvIDEwKSwgeSAtIHJhZGl1cyAqIE1hdGguY29zKG4gKiAyICogTWF0aC5QSSAvIDEwKSk7XG4gIH1cblxuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhIGRpYW1vbmQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIEhhbGYgb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGRpYW1vbmQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2xhYnMvaHRtbDUtY2FudmFzLXN0YXItc3Bpbm5lci9cclxuICovXG5cbmZ1bmN0aW9uIGRyYXdEaWFtb25kKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5saW5lVG8oeCwgeSArIHIpO1xuICBjdHgubGluZVRvKHggKyByLCB5KTtcbiAgY3R4LmxpbmVUbyh4LCB5IC0gcik7XG4gIGN0eC5saW5lVG8oeCAtIHIsIHkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycy5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXHJcbiAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gKiBAcGFyYW0gciAtIFRoZSByYWRpdXMgb2YgdGhlIGNvcm5lcnMuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI1NTUxMi9ob3ctdG8tZHJhdy1hLXJvdW5kZWQtcmVjdGFuZ2xlLW9uLWh0bWwtY2FudmFzXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3Um91bmRSZWN0KGN0eCwgeCwgeSwgdywgaCwgcikge1xuICB2YXIgcjJkID0gTWF0aC5QSSAvIDE4MDtcblxuICBpZiAodyAtIDIgKiByIDwgMCkge1xuICAgIHIgPSB3IC8gMjtcbiAgfSAvL2Vuc3VyZSB0aGF0IHRoZSByYWRpdXMgaXNuJ3QgdG9vIGxhcmdlIGZvciB4XG5cblxuICBpZiAoaCAtIDIgKiByIDwgMCkge1xuICAgIHIgPSBoIC8gMjtcbiAgfSAvL2Vuc3VyZSB0aGF0IHRoZSByYWRpdXMgaXNuJ3QgdG9vIGxhcmdlIGZvciB5XG5cblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oeCArIHIsIHkpO1xuICBjdHgubGluZVRvKHggKyB3IC0gciwgeSk7XG4gIGN0eC5hcmMoeCArIHcgLSByLCB5ICsgciwgciwgcjJkICogMjcwLCByMmQgKiAzNjAsIGZhbHNlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByKTtcbiAgY3R4LmFyYyh4ICsgdyAtIHIsIHkgKyBoIC0gciwgciwgMCwgcjJkICogOTAsIGZhbHNlKTtcbiAgY3R4LmxpbmVUbyh4ICsgciwgeSArIGgpO1xuICBjdHguYXJjKHggKyByLCB5ICsgaCAtIHIsIHIsIHIyZCAqIDkwLCByMmQgKiAxODAsIGZhbHNlKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcik7XG4gIGN0eC5hcmMoeCArIHIsIHkgKyByLCByLCByMmQgKiAxODAsIHIyZCAqIDI3MCwgZmFsc2UpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhbiBlbGxpcHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIGVsbGlwc2UuXHJcbiAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgZWxsaXBzZS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXHJcbiAqXHJcbiAqIFBvc3RmaXggJ192aXMnIGFkZGVkIHRvIGRpc2Nlcm4gaXQgZnJvbSBzdGFuZGFyZCBtZXRob2QgZWxsaXBzZSgpLlxyXG4gKi9cblxuZnVuY3Rpb24gZHJhd0VsbGlwc2UoY3R4LCB4LCB5LCB3LCBoKSB7XG4gIHZhciBrYXBwYSA9IDAuNTUyMjg0OCxcbiAgICAgIG94ID0gdyAvIDIgKiBrYXBwYSxcbiAgICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgb3kgPSBoIC8gMiAqIGthcHBhLFxuICAgICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgeGUgPSB4ICsgdyxcbiAgICAgIC8vIHgtZW5kXG4gIHllID0geSArIGgsXG4gICAgICAvLyB5LWVuZFxuICB4bSA9IHggKyB3IC8gMixcbiAgICAgIC8vIHgtbWlkZGxlXG4gIHltID0geSArIGggLyAyOyAvLyB5LW1pZGRsZVxuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4LCB5bSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gKyBveCwgeSwgeGUsIHltIC0gb3ksIHhlLCB5bSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYW4gaXNvbWV0cmljIGN5bGluZGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIGRhdGFiYXNlLlxyXG4gKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIGRhdGFiYXNlLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcclxuICovXG5cbmZ1bmN0aW9uIGRyYXdEYXRhYmFzZShjdHgsIHgsIHksIHcsIGgpIHtcbiAgdmFyIGYgPSAxIC8gMztcbiAgdmFyIHdFbGxpcHNlID0gdztcbiAgdmFyIGhFbGxpcHNlID0gaCAqIGY7XG4gIHZhciBrYXBwYSA9IDAuNTUyMjg0OCxcbiAgICAgIG94ID0gd0VsbGlwc2UgLyAyICoga2FwcGEsXG4gICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gIG95ID0gaEVsbGlwc2UgLyAyICoga2FwcGEsXG4gICAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICB4ZSA9IHggKyB3RWxsaXBzZSxcbiAgICAgIC8vIHgtZW5kXG4gIHllID0geSArIGhFbGxpcHNlLFxuICAgICAgLy8geS1lbmRcbiAgeG0gPSB4ICsgd0VsbGlwc2UgLyAyLFxuICAgICAgLy8geC1taWRkbGVcbiAgeW0gPSB5ICsgaEVsbGlwc2UgLyAyLFxuICAgICAgLy8geS1taWRkbGVcbiAgeW1iID0geSArIChoIC0gaEVsbGlwc2UgLyAyKSxcbiAgICAgIC8vIHktbWlkbGxlLCBib3R0b20gZWxsaXBzZVxuICB5ZWIgPSB5ICsgaDsgLy8geS1lbmQsIGJvdHRvbSBlbGxpcHNlXG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHhlLCB5bSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgY3R4LmxpbmVUbyh4ZSwgeW1iKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeGUsIHltYiArIG95LCB4bSArIG94LCB5ZWIsIHhtLCB5ZWIpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZWIsIHgsIHltYiArIG95LCB4LCB5bWIpO1xuICBjdHgubGluZVRvKHgsIHltKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGEgZGFzaGVkIGxpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSB4MiAtIFRoZSBlbmQgcG9zaXRpb24gb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkyIC0gVGhlIGVuZCBwb3NpdGlvbiBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gcGF0dGVybiAtIExpc3Qgb2YgbGVuZ3RocyBzdGFydGluZyB3aXRoIGxpbmUgYW5kIHRoZW4gYWx0ZXJuYXRpbmcgYmV0d2VlbiBzcGFjZSBhbmQgbGluZS5cclxuICpcclxuICogQGF1dGhvciBEYXZpZCBKb3JkYW5cclxuICogQHJlbWFya3NcclxuICogZGF0ZSAyMDEyLTA4LTA4XHJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1xyXG4gKi9cblxuZnVuY3Rpb24gZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5LCB4MiwgeTIsIHBhdHRlcm4pIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHgsIHkpO1xuICB2YXIgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICB2YXIgZHggPSB4MiAtIHg7XG4gIHZhciBkeSA9IHkyIC0geTtcbiAgdmFyIHNsb3BlID0gZHkgLyBkeDtcbiAgdmFyIGRpc3RSZW1haW5pbmcgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB2YXIgcGF0dGVybkluZGV4ID0gMDtcbiAgdmFyIGRyYXcgPSB0cnVlO1xuICB2YXIgeFN0ZXAgPSAwO1xuICB2YXIgZGFzaExlbmd0aCA9ICtwYXR0ZXJuWzBdO1xuXG4gIHdoaWxlIChkaXN0UmVtYWluaW5nID49IDAuMSkge1xuICAgIGRhc2hMZW5ndGggPSArcGF0dGVybltwYXR0ZXJuSW5kZXgrKyAlIHBhdHRlcm5MZW5ndGhdO1xuXG4gICAgaWYgKGRhc2hMZW5ndGggPiBkaXN0UmVtYWluaW5nKSB7XG4gICAgICBkYXNoTGVuZ3RoID0gZGlzdFJlbWFpbmluZztcbiAgICB9XG5cbiAgICB4U3RlcCA9IE1hdGguc3FydChkYXNoTGVuZ3RoICogZGFzaExlbmd0aCAvICgxICsgc2xvcGUgKiBzbG9wZSkpO1xuICAgIHhTdGVwID0gZHggPCAwID8gLXhTdGVwIDogeFN0ZXA7XG4gICAgeCArPSB4U3RlcDtcbiAgICB5ICs9IHNsb3BlICogeFN0ZXA7XG5cbiAgICBpZiAoZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICB9XG5cbiAgICBkaXN0UmVtYWluaW5nIC09IGRhc2hMZW5ndGg7XG4gICAgZHJhdyA9ICFkcmF3O1xuICB9XG59XG4vKipcclxuICogRHJhdyBhIGhleGFnb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIFRoZSByYWRpdXMgb2YgdGhlIGhleGFnb24uXHJcbiAqL1xuXG5mdW5jdGlvbiBkcmF3SGV4YWdvbihjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICB2YXIgc2lkZXMgPSA2O1xuICB2YXIgYSA9IE1hdGguUEkgKiAyIC8gc2lkZXM7XG4gIGN0eC5tb3ZlVG8oeCArIHIsIHkpO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgc2lkZXM7IGkrKykge1xuICAgIGN0eC5saW5lVG8oeCArIHIgKiBNYXRoLmNvcyhhICogaSksIHkgKyByICogTWF0aC5zaW4oYSAqIGkpKTtcbiAgfVxuXG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbnZhciBzaGFwZU1hcCA9IHtcbiAgY2lyY2xlOiBkcmF3Q2lyY2xlLFxuICBkYXNoZWRMaW5lOiBkcmF3RGFzaGVkTGluZSxcbiAgZGF0YWJhc2U6IGRyYXdEYXRhYmFzZSxcbiAgZGlhbW9uZDogZHJhd0RpYW1vbmQsXG4gIGVsbGlwc2U6IGRyYXdFbGxpcHNlLFxuICBlbGxpcHNlX3ZpczogZHJhd0VsbGlwc2UsXG4gIGhleGFnb246IGRyYXdIZXhhZ29uLFxuICByb3VuZFJlY3Q6IGRyYXdSb3VuZFJlY3QsXG4gIHNxdWFyZTogZHJhd1NxdWFyZSxcbiAgc3RhcjogZHJhd1N0YXIsXG4gIHRyaWFuZ2xlOiBkcmF3VHJpYW5nbGUsXG4gIHRyaWFuZ2xlRG93bjogZHJhd1RyaWFuZ2xlRG93blxufTtcbi8qKlxyXG4gKiBSZXR1cm5zIGVpdGhlciBjdXN0b20gb3IgbmF0aXZlIGRyYXdpbmcgZnVuY3Rpb24gYmFzZSBvbiBzdXBwbGllZCBuYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi4gRWl0aGVyIHRoZSBuYW1lIG9mIGFcclxuICogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHByb3BlcnR5IG9yIGFuIGV4cG9ydCBmcm9tIHNoYXBlcy50cyB3aXRob3V0IHRoZVxyXG4gKiBkcmF3IHByZWZpeC5cclxuICpcclxuICogQHJldHVybnMgVGhlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHJlbmRlcmluZy4gSW4gY2FzZSBvZiBuYXRpdmVcclxuICogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIGZ1bmN0aW9uIHRoZSBBUEkgaXMgbm9ybWFsaXplZCB0b1xyXG4gKiBgKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCAuLi5vcmlnaW5hbEFyZ3MpID0+IHZvaWRgLlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0U2hhcGUobmFtZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNoYXBlTWFwLCBuYW1lKSkge1xuICAgIHJldHVybiBzaGFwZU1hcFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZVtuYW1lXS5jYWxsKGN0eCwgYXJncyk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgY29tcG9uZW50RW1pdHRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgLyoqXHJcbiAgICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICAgKi9cbiAge1xuICAgIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICAgKlxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICAgIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xuICB9XG4gIC8qKlxyXG4gICAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqIEBhcGkgcHJpdmF0ZVxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1peGluKG9iaikge1xuICAgIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAgICogQHJldHVybiB7RW1pdHRlcn1cclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xuXG5cbiAgRW1pdHRlci5wcm90b3R5cGUub24gPSBFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pLnB1c2goZm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICAgKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXG5cblxuICBFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgb24uZm4gPSBmbjtcbiAgICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAgICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAgICogQGFwaSBwdWJsaWNcclxuICAgKi9cblxuXG4gIEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307IC8vIGFsbFxuXG4gICAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHNwZWNpZmljIGV2ZW50XG5cblxuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpczsgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXG4gICAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG5cblxuICAgIHZhciBjYjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYiA9IGNhbGxiYWNrc1tpXTtcblxuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXG4gICAgLy8gb25lIGlzIHN1YnNjcmliZWQgZm9yIHRvIGF2b2lkIG1lbW9yeSBsZWFrLlxuXG5cbiAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAgICogQHJldHVybiB7RW1pdHRlcn1cclxuICAgKi9cblxuXG4gIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxuICAgICAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgKiBAYXBpIHB1YmxpY1xyXG4gICAqL1xuXG5cbiAgRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xuICB9O1xuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqIEBhcGkgcHVibGljXHJcbiAgICovXG5cblxuICBFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gISF0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xuICB9O1xufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuXG5fZXhwb3J0KHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiAhZGVzY3JpcHRvcnMsXG4gIHNoYW06ICFkZXNjcmlwdG9yc1xufSwge1xuICBkZWZpbmVQcm9wZXJ0eTogb2JqZWN0RGVmaW5lUHJvcGVydHkuZlxufSk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgT2JqZWN0ID0gcGF0aC5PYmplY3Q7XG5cbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbiAgfTtcblxuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5LnNoYW0pIGRlZmluZVByb3BlcnR5LnNoYW0gPSB0cnVlO1xufSk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQxID0gZGVmaW5lUHJvcGVydHlfMTtcblxudmFyIGRlZmluZVByb3BlcnR5JDIgPSBkZWZpbmVQcm9wZXJ0eSQxO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IGRlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuXG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgb2JqZWN0RGVmaW5lUHJvcGVydHkuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBQcm9wZXJ0aWVzW2tleV0pO1xuXG4gIHJldHVybiBPO1xufTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogIWRlc2NyaXB0b3JzLFxuICBzaGFtOiAhZGVzY3JpcHRvcnNcbn0sIHtcbiAgZGVmaW5lUHJvcGVydGllczogb2JqZWN0RGVmaW5lUHJvcGVydGllc1xufSk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gIHZhciBPYmplY3QgPSBwYXRoLk9iamVjdDtcblxuICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhULCBEKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFQsIEQpO1xuICB9O1xuXG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydGllcy5zaGFtKSBkZWZpbmVQcm9wZXJ0aWVzLnNoYW0gPSB0cnVlO1xufSk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZGVmaW5lUHJvcGVydGllc18xO1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyQxID0gZGVmaW5lUHJvcGVydGllcztcblxudmFyIGFGdW5jdGlvbiQxID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT0gJ2Z1bmN0aW9uJyA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcblxudmFyIGdldEJ1aWx0SW4gPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uJDEocGF0aFtuYW1lc3BhY2VdKSB8fCBhRnVuY3Rpb24kMShnbG9iYWxfMVtuYW1lc3BhY2VdKSA6IHBhdGhbbmFtZXNwYWNlXSAmJiBwYXRoW25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWxfMVtuYW1lc3BhY2VdICYmIGdsb2JhbF8xW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG5cbnZhciBoaWRkZW5LZXlzJDEgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTsgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG5cbnZhciBmJDQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIG9iamVjdEtleXNJbnRlcm5hbChPLCBoaWRkZW5LZXlzJDEpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5TmFtZXMgPSB7XG4gIGY6IGYkNFxufTtcblxudmFyIG93bktleXMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciBjcmVhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgb2JqZWN0RGVmaW5lUHJvcGVydHkuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG5cbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBzaGFtOiAhZGVzY3JpcHRvcnNcbn0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGtleSwgZGVzY3JpcHRvcjtcblxuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSA9IGtleXNbaW5kZXgrK10pO1xuICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IHBhdGguT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDEgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQyID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQxO1xuXG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSgxKTtcbn0pO1xudmFyIEZPUkNFRCA9ICFkZXNjcmlwdG9ycyB8fCBGQUlMU19PTl9QUklNSVRJVkVTOyAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5cbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IEZPUkNFRCxcbiAgc2hhbTogIWRlc2NyaXB0b3JzXG59LCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEodG9JbmRleGVkT2JqZWN0KGl0KSwga2V5KTtcbiAgfVxufSk7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgdmFyIE9iamVjdCA9IHBhdGguT2JqZWN0O1xuXG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG4gIH07XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iuc2hhbSkgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLnNoYW0gPSB0cnVlO1xufSk7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcl8xO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMjtcblxudmFyIG5hdGl2ZVN5bWJvbCA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcmV0dXJuICFTdHJpbmcoU3ltYm9sKCkpO1xufSk7XG5cbnZhciB1c2VTeW1ib2xBc1VpZCA9IG5hdGl2ZVN5bWJvbCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiYmICFTeW1ib2wuc2hhbSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzYXJyYXlcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjbGFzc29mUmF3KGFyZykgPT0gJ0FycmF5Jztcbn07XG5cbnZhciBodG1sID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbnZhciBzZXRHbG9iYWwgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShnbG9iYWxfMSwga2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsXzFba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsXzFbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG52YXIgc2hhcmVkU3RvcmUgPSBzdG9yZTtcblxudmFyIHNoYXJlZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc2hhcmVkU3RvcmVba2V5XSB8fCAoc2hhcmVkU3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbiAgfSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICAgIHZlcnNpb246ICczLjcuMCcsXG4gICAgbW9kZTogICdwdXJlJyAsXG4gICAgY29weXJpZ2h0OiAnwqkgMjAyMCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbiAgfSk7XG59KTtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxudmFyIHVpZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIFN0cmluZyhrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyAoKytpZCArIHBvc3RmaXgpLnRvU3RyaW5nKDM2KTtcbn07XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbnZhciBzaGFyZWRLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8qIGVtcHR5ICovXG59O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07IC8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG5cblxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG5cbiAgcmV0dXJuIHRlbXA7XG59OyAvLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG5cblxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XG5cbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59OyAvLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcblxuXG52YXIgYWN0aXZlWERvY3VtZW50O1xuXG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG4gICAgYWN0aXZlWERvY3VtZW50ID0gZG9jdW1lbnQuZG9tYWluICYmIG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGlnbm9yZSAqL1xuICB9XG5cbiAgTnVsbFByb3RvT2JqZWN0ID0gYWN0aXZlWERvY3VtZW50ID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKCk7XG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG5cbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlOyAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7IC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcblxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG5cbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IG9iamVjdERlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xudmFyIHRvU3RyaW5nJDEgPSB7fS50b1N0cmluZztcbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07IC8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcblxuXG52YXIgZiQ1ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmckMS5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KGl0KSk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0ge1xuICBmOiBmJDVcbn07XG5cbnZhciByZWRlZmluZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbnVtZXJhYmxlKSB0YXJnZXRba2V5XSA9IHZhbHVlO2Vsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldCwga2V5LCB2YWx1ZSk7XG59O1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbF8xLlN5bWJvbDtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSB1c2VTeW1ib2xBc1VpZCA/IFN5bWJvbCQxIDogU3ltYm9sJDEgJiYgU3ltYm9sJDEud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhcyhXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpKSB7XG4gICAgaWYgKG5hdGl2ZVN5bWJvbCAmJiBoYXMoU3ltYm9sJDEsIG5hbWUpKSBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2wkMVtuYW1lXTtlbHNlIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbCgnU3ltYm9sLicgKyBuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgZiQ2ID0gd2VsbEtub3duU3ltYm9sO1xudmFyIHdlbGxLbm93blN5bWJvbFdyYXBwZWQgPSB7XG4gIGY6IGYkNlxufTtcblxudmFyIGRlZmluZVByb3BlcnR5JDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgdmFyIFN5bWJvbCA9IHBhdGguU3ltYm9sIHx8IChwYXRoLlN5bWJvbCA9IHt9KTtcbiAgaWYgKCFoYXMoU3ltYm9sLCBOQU1FKSkgZGVmaW5lUHJvcGVydHkkMyhTeW1ib2wsIE5BTUUsIHtcbiAgICB2YWx1ZTogd2VsbEtub3duU3ltYm9sV3JhcHBlZC5mKE5BTUUpXG4gIH0pO1xufTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcbnZhciB0b1N0cmluZ1RhZ1N1cHBvcnQgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcblxudmFyIFRPX1NUUklOR19UQUckMSA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTsgLy8gRVMzIHdyb25nIGhlcmVcblxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhcmd1bWVudHM7XG59KCkpID09ICdBcmd1bWVudHMnOyAvLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxuXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG59OyAvLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5cblxudmFyIGNsYXNzb2YgPSB0b1N0cmluZ1RhZ1N1cHBvcnQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHJDEpKSA9PSAnc3RyaW5nJyA/IHRhZyAvLyBidWlsdGluVGFnIGNhc2VcbiAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTykgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuXG5cbnZhciBvYmplY3RUb1N0cmluZyA9IHRvU3RyaW5nVGFnU3VwcG9ydCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBzZXRUb1N0cmluZ1RhZyA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMsIFNFVF9NRVRIT0QpIHtcbiAgaWYgKGl0KSB7XG4gICAgdmFyIHRhcmdldCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlO1xuXG4gICAgaWYgKCFoYXModGFyZ2V0LCBUT19TVFJJTkdfVEFHJDIpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSQ0KHRhcmdldCwgVE9fU1RSSU5HX1RBRyQyLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFRBR1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKFNFVF9NRVRIT0QgJiYgIXRvU3RyaW5nVGFnU3VwcG9ydCkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldCwgJ3RvU3RyaW5nJywgb2JqZWN0VG9TdHJpbmcpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi50b1N0cmluZzsgLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGAzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcblxuaWYgKHR5cGVvZiBzaGFyZWRTdG9yZS5pbnNwZWN0U291cmNlICE9ICdmdW5jdGlvbicpIHtcbiAgc2hhcmVkU3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSA9IHNoYXJlZFN0b3JlLmluc3BlY3RTb3VyY2U7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsXzEuV2Vha01hcDtcbnZhciBuYXRpdmVXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UoV2Vha01hcCkpO1xuXG52YXIgV2Vha01hcCQxID0gZ2xvYmFsXzEuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzJDE7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMkMShpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcblxuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAobmF0aXZlV2Vha01hcCkge1xuICB2YXIgc3RvcmUkMSA9IHNoYXJlZFN0b3JlLnN0YXRlIHx8IChzaGFyZWRTdG9yZS5zdGF0ZSA9IG5ldyBXZWFrTWFwJDEoKSk7XG4gIHZhciB3bWdldCA9IHN0b3JlJDEuZ2V0O1xuICB2YXIgd21oYXMgPSBzdG9yZSQxLmhhcztcbiAgdmFyIHdtc2V0ID0gc3RvcmUkMS5zZXQ7XG5cbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHdtc2V0LmNhbGwoc3RvcmUkMSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG5cbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0LmNhbGwoc3RvcmUkMSwgaXQpIHx8IHt9O1xuICB9O1xuXG4gIGhhcyQxID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUkMSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG5cbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG5cbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhcyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG5cbiAgaGFzJDEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzKGl0LCBTVEFURSk7XG4gIH07XG59XG5cbnZhciBpbnRlcm5hbFN0YXRlID0ge1xuICBzZXQ6IHNldCxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzJDEsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpOyAvLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxuXG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICB2YXIgQztcblxuICBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xuICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yOyAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtlbHNlIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IChDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEMpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcblxudmFyIHB1c2ggPSBbXS5wdXNoOyAvLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXggfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgY3JlYXRlTWV0aG9kJDEgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBpbmRleGVkT2JqZWN0KE8pO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gZnVuY3Rpb25CaW5kQ29udGV4dChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWUsIHJlc3VsdDtcblxuICAgIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XG4gICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG5cbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHNvbWVcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBmaW5kXG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgLy8gZmluZEluZGV4XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcHVzaC5jYWxsKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJdGVyYXRpb24gPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCQxKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbiAgbWFwOiBjcmVhdGVNZXRob2QkMSgxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kJDEoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCQxKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QkMSg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgZmluZDogY3JlYXRlTWV0aG9kJDEoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCQxKDYpXG59O1xuXG52YXIgJGZvckVhY2ggPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xudmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG52YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG52YXIgUFJPVE9UWVBFJDEgPSAncHJvdG90eXBlJztcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlLmdldHRlckZvcihTWU1CT0wpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdFtQUk9UT1RZUEUkMV07XG52YXIgJFN5bWJvbCA9IGdsb2JhbF8xLlN5bWJvbDtcbnZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbignSlNPTicsICdzdHJpbmdpZnknKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5JDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMkMSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlJDEgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90b3R5cGVTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeScpO1xudmFyIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC10by1zdHJpbmctcmVnaXN0cnknKTtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUkMSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgUU9iamVjdCA9IGdsb2JhbF8xLlFPYmplY3Q7IC8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xuXG52YXIgVVNFX1NFVFRFUiA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRSQxXSB8fCAhUU9iamVjdFtQUk9UT1RZUEUkMV0uZmluZENoaWxkOyAvLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcblxudmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBkZXNjcmlwdG9ycyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBvYmplY3RDcmVhdGUobmF0aXZlRGVmaW5lUHJvcGVydHkkMSh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkkMSh0aGlzLCAnYScsIHtcbiAgICAgICAgdmFsdWU6IDdcbiAgICAgIH0pLmE7XG4gICAgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciQyKE9iamVjdFByb3RvdHlwZSwgUCk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKSBkZWxldGUgT2JqZWN0UHJvdG90eXBlW1BdO1xuICBuYXRpdmVEZWZpbmVQcm9wZXJ0eSQxKE8sIFAsIEF0dHJpYnV0ZXMpO1xuXG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5JDEoT2JqZWN0UHJvdG90eXBlLCBQLCBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKTtcbiAgfVxufSA6IG5hdGl2ZURlZmluZVByb3BlcnR5JDE7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZywgZGVzY3JpcHRpb24pIHtcbiAgdmFyIHN5bWJvbCA9IEFsbFN5bWJvbHNbdGFnXSA9IG9iamVjdENyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRSQxXSk7XG4gIHNldEludGVybmFsU3RhdGUoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFkZXNjcmlwdG9ycykgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgaXNTeW1ib2wgPSB1c2VTeW1ib2xBc1VpZCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGl0KSBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuXG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghQXR0cmlidXRlcy5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhPLCBISURERU4pKSBuYXRpdmVEZWZpbmVQcm9wZXJ0eSQxKE8sIEhJRERFTiwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHt9KSk7XG4gICAgICBPW0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoTywgSElEREVOKSAmJiBPW0hJRERFTl1ba2V5XSkgT1tISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSBvYmplY3RDcmVhdGUoQXR0cmlidXRlcywge1xuICAgICAgICBlbnVtZXJhYmxlOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgZmFsc2UpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5JDEoTywga2V5LCBBdHRyaWJ1dGVzKTtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIHByb3BlcnRpZXMgPSB0b0luZGV4ZWRPYmplY3QoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwcm9wZXJ0aWVzKS5jb25jYXQoJGdldE93blByb3BlcnR5U3ltYm9scyhwcm9wZXJ0aWVzKSk7XG4gICRmb3JFYWNoKGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWRlc2NyaXB0b3JzIHx8ICRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHByb3BlcnRpZXMsIGtleSkpICRkZWZpbmVQcm9wZXJ0eShPLCBrZXksIHByb3BlcnRpZXNba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gTztcbn07XG5cbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IG9iamVjdENyZWF0ZShPKSA6ICRkZWZpbmVQcm9wZXJ0aWVzKG9iamVjdENyZWF0ZShPKSwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgUCA9IHRvUHJpbWl0aXZlKFYsIHRydWUpO1xuICB2YXIgZW51bWVyYWJsZSA9IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlJDEuY2FsbCh0aGlzLCBQKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywgUCkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZW51bWVyYWJsZSB8fCAhaGFzKHRoaXMsIFApIHx8ICFoYXMoQWxsU3ltYm9scywgUCkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW1BdID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMihpdCwga2V5KTtcblxuICBpZiAoZGVzY3JpcHRvciAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSB7XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMkMSh0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKGhpZGRlbktleXMsIGtleSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTykge1xuICB2YXIgSVNfT0JKRUNUX1BST1RPVFlQRSA9IE8gPT09IE9iamVjdFByb3RvdHlwZTtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyQxKElTX09CSkVDVF9QUk9UT1RZUEUgPyBPYmplY3RQcm90b3R5cGVTeW1ib2xzIDogdG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSAmJiAoIUlTX09CSkVDVF9QUk9UT1RZUEUgfHwgaGFzKE9iamVjdFByb3RvdHlwZSwga2V5KSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07IC8vIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wtY29uc3RydWN0b3JcblxuXG5pZiAoIW5hdGl2ZVN5bWJvbCkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAhYXJndW1lbnRzLmxlbmd0aCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciB0YWcgPSB1aWQoZGVzY3JpcHRpb24pO1xuXG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSkgc2V0dGVyLmNhbGwoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGlmIChkZXNjcmlwdG9ycyAmJiBVU0VfU0VUVEVSKSBzZXRTeW1ib2xEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgdGFnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IHNldHRlclxuICAgIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFJDFdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS50YWc7XG4gIH0pO1xuICByZWRlZmluZSgkU3ltYm9sLCAnd2l0aG91dFNldHRlcicsIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiB3cmFwKHVpZChkZXNjcmlwdGlvbiksIGRlc2NyaXB0aW9uKTtcbiAgfSk7XG4gIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIG9iamVjdERlZmluZVByb3BlcnR5LmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIHdlbGxLbm93blN5bWJvbFdyYXBwZWQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2VsbEtub3duU3ltYm9sKG5hbWUpLCBuYW1lKTtcbiAgfTtcblxuICBpZiAoZGVzY3JpcHRvcnMpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1TeW1ib2wtZGVzY3JpcHRpb25cbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eSQxKCRTeW1ib2xbUFJPVE9UWVBFJDFdLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5fZXhwb3J0KHtcbiAgZ2xvYmFsOiB0cnVlLFxuICB3cmFwOiB0cnVlLFxuICBmb3JjZWQ6ICFuYXRpdmVTeW1ib2wsXG4gIHNoYW06ICFuYXRpdmVTeW1ib2xcbn0sIHtcbiAgU3ltYm9sOiAkU3ltYm9sXG59KTtcbiRmb3JFYWNoKG9iamVjdEtleXMoV2VsbEtub3duU3ltYm9sc1N0b3JlJDEpLCBmdW5jdGlvbiAobmFtZSkge1xuICBkZWZpbmVXZWxsS25vd25TeW1ib2wobmFtZSk7XG59KTtcbl9leHBvcnQoe1xuICB0YXJnZXQ6IFNZTUJPTCxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiAhbmF0aXZlU3ltYm9sXG59LCB7XG4gIC8vIGBTeW1ib2wuZm9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLmZvclxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcoa2V5KTtcbiAgICBpZiAoaGFzKFN0cmluZ1RvU3ltYm9sUmVnaXN0cnksIHN0cmluZykpIHJldHVybiBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ107XG4gICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woc3RyaW5nKTtcbiAgICBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ10gPSBzeW1ib2w7XG4gICAgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1ib2xdID0gc3RyaW5nO1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH0sXG4gIC8vIGBTeW1ib2wua2V5Rm9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLmtleWZvclxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuICAgIGlmIChoYXMoU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSwgc3ltKSkgcmV0dXJuIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltXTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgVVNFX1NFVFRFUiA9IHRydWU7XG4gIH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkge1xuICAgIFVTRV9TRVRURVIgPSBmYWxzZTtcbiAgfVxufSk7XG5fZXhwb3J0KHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiAhbmF0aXZlU3ltYm9sLFxuICBzaGFtOiAhZGVzY3JpcHRvcnNcbn0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcbn0pO1xuX2V4cG9ydCh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogIW5hdGl2ZVN5bWJvbFxufSwge1xuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlzeW1ib2xzXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7IC8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mKDEpO1xuICB9KVxufSwge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHJldHVybiBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZih0b09iamVjdChpdCkpO1xuICB9XG59KTsgLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeVxuXG5pZiAoJHN0cmluZ2lmeSkge1xuICB2YXIgRk9SQ0VEX0pTT05fU1RSSU5HSUZZID0gIW5hdGl2ZVN5bWJvbCB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woKTsgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cblxuICAgIHJldHVybiAkc3RyaW5naWZ5KFtzeW1ib2xdKSAhPSAnW251bGxdJyAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgICB8fCAkc3RyaW5naWZ5KHtcbiAgICAgIGE6IHN5bWJvbFxuICAgIH0pICE9ICd7fScgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgICB8fCAkc3RyaW5naWZ5KE9iamVjdChzeW1ib2wpKSAhPSAne30nO1xuICB9KTtcbiAgX2V4cG9ydCh7XG4gICAgdGFyZ2V0OiAnSlNPTicsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6IEZPUkNFRF9KU09OX1NUUklOR0lGWVxuICB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgICAgdmFyIGluZGV4ID0gMTtcbiAgICAgIHZhciAkcmVwbGFjZXI7XG5cbiAgICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaW5kZXgpIGFyZ3MucHVzaChhcmd1bWVudHNbaW5kZXgrK10pO1xuXG4gICAgICAkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcblxuICAgICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICAgIHJldHVybiAkc3RyaW5naWZ5LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgfSk7XG59IC8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuXG5cbmlmICghJFN5bWJvbFtQUk9UT1RZUEUkMV1bVE9fUFJJTUlUSVZFXSkge1xuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoJFN5bWJvbFtQUk9UT1RZUEUkMV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEUkMV0udmFsdWVPZik7XG59IC8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5cblxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgU1lNQk9MKTtcbmhpZGRlbktleXNbSElEREVOXSA9IHRydWU7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBwYXRoLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMSA9IGdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIGdldE93blByb3BlcnR5U3ltYm9scyQyID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzJDE7XG5cbnZhciBpdGVyYXRvcnMgPSB7fTtcblxudmFyIGNvcnJlY3RQcm90b3R5cGVHZXR0ZXIgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xufSk7XG5cbnZhciBJRV9QUk9UTyQxID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvdHlwZSQxID0gT2JqZWN0LnByb3RvdHlwZTsgLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcblxudmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gY29ycmVjdFByb3RvdHlwZUdldHRlciA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTyQxKSkgcmV0dXJuIE9bSUVfUFJPVE8kMV07XG5cbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH1cblxuICByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSQxIDogbnVsbDtcbn07XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxuXG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpOyAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcblxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO2Vsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IG9iamVjdEdldFByb3RvdHlwZU9mKG9iamVjdEdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTtcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG5pZiAoSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyAvLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuXG52YXIgaXRlcmF0b3JzQ29yZSA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMSA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gb2JqZWN0Q3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlJDEsIHtcbiAgICBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dClcbiAgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgaXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpICYmIGl0ICE9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiICsgU3RyaW5nKGl0KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbiAgfVxuXG4gIHJldHVybiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbnZhciBvYmplY3RTZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuXG4gIHRyeSB7XG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlci5jYWxsKE8sIHByb3RvKTtlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUkMiA9IGl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gaXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SJDEgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xuXG52YXIgcmV0dXJuVGhpcyQxID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBkZWZpbmVJdGVyYXRvciA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuXG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTtcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBWQUxVRVM6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpO1xuICAgICAgICB9O1xuXG4gICAgICBjYXNlIEVOVFJJRVM6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQxXSB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7IC8vIGZpeCBuYXRpdmVcblxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBvYmplY3RHZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG5cbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUkMiAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuXG5cbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzJDE7XG4gICAgfVxuICB9IC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcblxuXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuXG4gICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfSAvLyBkZWZpbmUgaXRlcmF0b3JcblxuXG4gIGlmICgoIEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkMV0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkMSwgZGVmYXVsdEl0ZXJhdG9yKTtcbiAgfVxuXG4gIGl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjsgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBfZXhwb3J0KHtcbiAgICAgIHRhcmdldDogTkFNRSxcbiAgICAgIHByb3RvOiB0cnVlLFxuICAgICAgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FXG4gICAgfSwgbWV0aG9kcyk7XG4gIH1cblxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gaW50ZXJuYWxTdGF0ZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQxID0gaW50ZXJuYWxTdGF0ZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpOyAvLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxuXG52YXIgZXNfYXJyYXlfaXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG4gICAgdHlwZTogQVJSQVlfSVRFUkFUT1IsXG4gICAgdGFyZ2V0OiB0b0luZGV4ZWRPYmplY3QoaXRlcmF0ZWQpLFxuICAgIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLFxuICAgIC8vIG5leHQgaW5kZXhcbiAgICBraW5kOiBraW5kIC8vIGtpbmRcblxuICB9KTsgLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG5cbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4ge1xuICAgIHZhbHVlOiBpbmRleCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHtcbiAgICB2YWx1ZTogdGFyZ2V0W2luZGV4XSxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG59LCAndmFsdWVzJyk7IC8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuXG5pdGVyYXRvcnMuQXJndW1lbnRzID0gaXRlcmF0b3JzLkFycmF5OyAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuXG4vLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbnZhciBkb21JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuXG52YXIgVE9fU1RSSU5HX1RBRyQzID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gZG9tSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsXzFbQ09MTEVDVElPTl9OQU1FXTtcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuXG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlICYmIGNsYXNzb2YoQ29sbGVjdGlvblByb3RvdHlwZSkgIT09IFRPX1NUUklOR19UQUckMykge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHJDMsIENPTExFQ1RJT05fTkFNRSk7XG4gIH1cblxuICBpdGVyYXRvcnNbQ09MTEVDVElPTl9OQU1FXSA9IGl0ZXJhdG9ycy5BcnJheTtcbn1cblxudmFyIGNyZWF0ZU1ldGhvZCQyID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemUgfHwgKHNlY29uZCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkYgPyBDT05WRVJUX1RPX1NUUklORyA/IFMuY2hhckF0KHBvc2l0aW9uKSA6IGZpcnN0IDogQ09OVkVSVF9UT19TVFJJTkcgPyBTLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cbnZhciBzdHJpbmdNdWx0aWJ5dGUgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZCQyKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kJDIodHJ1ZSlcbn07XG5cbnZhciBjaGFyQXQgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUkMiA9IGludGVybmFsU3RhdGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUkMiA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7IC8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMsIHtcbiAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG4gICAgc3RyaW5nOiBTdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pOyAvLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDIodGhpcyk7XG4gIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4O1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4ge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZG9uZTogdHJ1ZVxuICB9O1xuICBwb2ludCA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBwb2ludCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xufSk7XG5cbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SJDJdIHx8IGl0WydAQGl0ZXJhdG9yJ10gfHwgaXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cbnZhciBnZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChpdCk7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvck1ldGhvZCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXQpKTtcbn07XG5cbnZhciBnZXRJdGVyYXRvcl8xID0gZ2V0SXRlcmF0b3I7XG5cbnZhciBnZXRJdGVyYXRvciQxID0gZ2V0SXRlcmF0b3JfMTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kXzEgPSBnZXRJdGVyYXRvck1ldGhvZDtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZF8xO1xuXG52YXIgaXRlcmF0b3JDbG9zZSA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICB2YXIgcmV0dXJuTWV0aG9kID0gaXRlcmF0b3JbJ3JldHVybiddO1xuXG4gIGlmIChyZXR1cm5NZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhbk9iamVjdChyZXR1cm5NZXRob2QuY2FsbChpdGVyYXRvcikpLnZhbHVlO1xuICB9XG59O1xuXG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTsgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxudmFyIElURVJBVE9SJDMgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7IC8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcblxudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoaXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUiQzXSA9PT0gaXQpO1xufTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuXG5cbnZhciBhcnJheUZyb20gPSBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZVxuLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqL1xuKSB7XG4gIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChPKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7XG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGZ1bmN0aW9uQmluZENvbnRleHQobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpOyAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxuXG4gIGlmIChpdGVyYXRvck1ldGhvZCAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyYXRvck1ldGhvZCkpKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvck1ldGhvZC5jYWxsKE8pO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIHJlc3VsdCA9IG5ldyBDKCk7XG5cbiAgICBmb3IgKDsgIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7XG5cbiAgICBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogISFjYWxsZWQrK1xuICAgICAgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1IkNF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG5cblxuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkge1xuICAgIHRocm93IDI7XG4gIH0pO1xufSBjYXRjaCAoZXJyb3IpIHtcbiAgLyogZW1wdHkgKi9cbn1cblxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcblxuICAgIG9iamVjdFtJVEVSQVRPUiQ0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xufSk7IC8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OXG59LCB7XG4gIGZyb206IGFycmF5RnJvbVxufSk7XG5cbnZhciBmcm9tXzEgPSBwYXRoLkFycmF5LmZyb207XG5cbnZhciBmcm9tXzEkMSA9IGZyb21fMTtcblxudmFyIGZyb21fMSQyID0gZnJvbV8xJDE7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIHNoYW06ICFkZXNjcmlwdG9yc1xufSwge1xuICBjcmVhdGU6IG9iamVjdENyZWF0ZVxufSk7XG5cbnZhciBPYmplY3QkMSA9IHBhdGguT2JqZWN0O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcbiAgcmV0dXJuIE9iamVjdCQxLmNyZWF0ZShQLCBEKTtcbn07XG5cbnZhciBjcmVhdGUkMSA9IGNyZWF0ZTtcblxudmFyIGNyZWF0ZSQyID0gY3JlYXRlJDE7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ1ID0gZGVmaW5lUHJvcGVydHlfMTtcblxudmFyIGRlZmluZVByb3BlcnR5JDYgPSBkZWZpbmVQcm9wZXJ0eSQ1O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNihvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ3ID0gX2RlZmluZVByb3BlcnR5O1xuXG4vLyBhIHN0cmluZyBvZiBhbGwgdmFsaWQgdW5pY29kZSB3aGl0ZXNwYWNlc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbnZhciB3aGl0ZXNwYWNlcyA9ICdcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxudmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyArICddJztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAod2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKiQnKTsgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltLCB0cmltU3RhcnQsIHRyaW1FbmQsIHRyaW1MZWZ0LCB0cmltUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgY3JlYXRlTWV0aG9kJDMgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xufTtcblxudmFyIHN0cmluZ1RyaW0gPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbXN0YXJ0XG4gIHN0YXJ0OiBjcmVhdGVNZXRob2QkMygxKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcbiAgZW5kOiBjcmVhdGVNZXRob2QkMygyKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICB0cmltOiBjcmVhdGVNZXRob2QkMygzKVxufTtcblxudmFyIG5vbiA9ICdcXHUyMDBCXFx1MDA4NVxcdTE4MEUnOyAvLyBjaGVjayB0aGF0IGEgbWV0aG9kIHdvcmtzIHdpdGggdGhlIGNvcnJlY3QgbGlzdFxuLy8gb2Ygd2hpdGVzcGFjZXMgYW5kIGhhcyBhIGNvcnJlY3QgbmFtZVxuXG52YXIgc3RyaW5nVHJpbUZvcmNlZCA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICByZXR1cm4gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpIHx8IG5vbltNRVRIT0RfTkFNRV0oKSAhPSBub24gfHwgd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FO1xuICB9KTtcbn07XG5cbnZhciAkdHJpbSA9IHN0cmluZ1RyaW0udHJpbTsgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ1N0cmluZycsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IHN0cmluZ1RyaW1Gb3JjZWQoJ3RyaW0nKVxufSwge1xuICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzKTtcbiAgfVxufSk7XG5cbnZhciB0cmltID0gZW50cnlWaXJ0dWFsKCdTdHJpbmcnKS50cmltO1xuXG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsLG5vLXRocm93LWxpdGVyYWxcbiAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyAxO1xuICAgIH0sIDEpO1xuICB9KTtcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ4ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNhY2hlID0ge307XG5cbnZhciB0aHJvd2VyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRocm93IGl0O1xufTtcblxudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBvcHRpb25zKSB7XG4gIGlmIChoYXMoY2FjaGUsIE1FVEhPRF9OQU1FKSkgcmV0dXJuIGNhY2hlW01FVEhPRF9OQU1FXTtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHZhciBBQ0NFU1NPUlMgPSBoYXMob3B0aW9ucywgJ0FDQ0VTU09SUycpID8gb3B0aW9ucy5BQ0NFU1NPUlMgOiBmYWxzZTtcbiAgdmFyIGFyZ3VtZW50MCA9IGhhcyhvcHRpb25zLCAwKSA/IG9wdGlvbnNbMF0gOiB0aHJvd2VyO1xuICB2YXIgYXJndW1lbnQxID0gaGFzKG9wdGlvbnMsIDEpID8gb3B0aW9uc1sxXSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGNhY2hlW01FVEhPRF9OQU1FXSA9ICEhbWV0aG9kICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKEFDQ0VTU09SUyAmJiAhZGVzY3JpcHRvcnMpIHJldHVybiB0cnVlO1xuICAgIHZhciBPID0ge1xuICAgICAgbGVuZ3RoOiAtMVxuICAgIH07XG4gICAgaWYgKEFDQ0VTU09SUykgZGVmaW5lUHJvcGVydHkkOChPLCAxLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiB0aHJvd2VyXG4gICAgfSk7ZWxzZSBPWzFdID0gMTtcbiAgICBtZXRob2QuY2FsbChPLCBhcmd1bWVudDAsIGFyZ3VtZW50MSk7XG4gIH0pO1xufTtcblxudmFyICRmb3JFYWNoJDEgPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdmb3JFYWNoJyk7XG52YXIgVVNFU19UT19MRU5HVEggPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCgnZm9yRWFjaCcpOyAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcblxudmFyIGFycmF5Rm9yRWFjaCA9ICFTVFJJQ1RfTUVUSE9EIHx8ICFVU0VTX1RPX0xFTkdUSCA/IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmblxuLyogLCB0aGlzQXJnICovXG4pIHtcbiAgcmV0dXJuICRmb3JFYWNoJDEodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSA6IFtdLmZvckVhY2g7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5cblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogW10uZm9yRWFjaCAhPSBhcnJheUZvckVhY2hcbn0sIHtcbiAgZm9yRWFjaDogYXJyYXlGb3JFYWNoXG59KTtcblxudmFyIGZvckVhY2ggPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykuZm9yRWFjaDtcblxudmFyIGZvckVhY2gkMSA9IGZvckVhY2g7XG5cbnZhciBBcnJheVByb3RvdHlwZSQxID0gQXJyYXkucHJvdG90eXBlO1xudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBOb2RlTGlzdDogdHJ1ZVxufTtcblxudmFyIGZvckVhY2hfMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZm9yRWFjaDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQxIHx8IGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQxLmZvckVhY2ggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICB8fCBET01JdGVyYWJsZXMuaGFzT3duUHJvcGVydHkoY2xhc3NvZihpdCkpID8gZm9yRWFjaCQxIDogb3duO1xufTtcblxudmFyIGZvckVhY2gkMiA9IGZvckVhY2hfMTtcblxudmFyIHRyaW0kMSA9IHN0cmluZ1RyaW0udHJpbTtcbnZhciAkcGFyc2VJbnQgPSBnbG9iYWxfMS5wYXJzZUludDtcbnZhciBoZXggPSAvXlsrLV0/MFtYeF0vO1xudmFyIEZPUkNFRCQxID0gJHBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzB4MTYnKSAhPT0gMjI7IC8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcblxudmFyIG51bWJlclBhcnNlSW50ID0gRk9SQ0VEJDEgPyBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4KSB7XG4gIHZhciBTID0gdHJpbSQxKFN0cmluZyhzdHJpbmcpKTtcbiAgcmV0dXJuICRwYXJzZUludChTLCByYWRpeCA+Pj4gMCB8fCAoaGV4LnRlc3QoUykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50O1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcblxuX2V4cG9ydCh7XG4gIGdsb2JhbDogdHJ1ZSxcbiAgZm9yY2VkOiBwYXJzZUludCAhPSBudW1iZXJQYXJzZUludFxufSwge1xuICBwYXJzZUludDogbnVtYmVyUGFyc2VJbnRcbn0pO1xuXG52YXIgX3BhcnNlSW50ID0gcGF0aC5wYXJzZUludDtcblxudmFyIF9wYXJzZUludCQxID0gX3BhcnNlSW50O1xuXG52YXIgX3BhcnNlSW50JDIgPSBfcGFyc2VJbnQkMTtcblxudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZjsgLy8gYE9iamVjdC57IGVudHJpZXMsIHZhbHVlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cbnZhciBjcmVhdGVNZXRob2QkNCA9IGZ1bmN0aW9uIChUT19FTlRSSUVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKE8pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG5cbiAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAga2V5ID0ga2V5c1tpKytdO1xuXG4gICAgICBpZiAoIWRlc2NyaXB0b3JzIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoTywga2V5KSkge1xuICAgICAgICByZXN1bHQucHVzaChUT19FTlRSSUVTID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cbnZhciBvYmplY3RUb0FycmF5ID0ge1xuICAvLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZW50cmllc1xuICBlbnRyaWVzOiBjcmVhdGVNZXRob2QkNCh0cnVlKSxcbiAgLy8gYE9iamVjdC52YWx1ZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QudmFsdWVzXG4gIHZhbHVlczogY3JlYXRlTWV0aG9kJDQoZmFsc2UpXG59O1xuXG52YXIgJHZhbHVlcyA9IG9iamVjdFRvQXJyYXkudmFsdWVzOyAvLyBgT2JqZWN0LnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QudmFsdWVzXG5cbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlXG59LCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKE8pIHtcbiAgICByZXR1cm4gJHZhbHVlcyhPKTtcbiAgfVxufSk7XG5cbnZhciB2YWx1ZXMgPSBwYXRoLk9iamVjdC52YWx1ZXM7XG5cbnZhciBlbmdpbmVVc2VyQWdlbnQgPSBnZXRCdWlsdEluKCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsXzEucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gKyBtYXRjaFsxXTtcbn0gZWxzZSBpZiAoZW5naW5lVXNlckFnZW50KSB7XG4gIG1hdGNoID0gZW5naW5lVXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG5cbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gZW5naW5lVXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSBtYXRjaFsxXTtcbiAgfVxufVxuXG52YXIgZW5naW5lVjhWZXJzaW9uID0gdmVyc2lvbiAmJiArdmVyc2lvbjtcblxudmFyIFNQRUNJRVMkMSA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3N1xuICByZXR1cm4gZW5naW5lVjhWZXJzaW9uID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcblxuICAgIGNvbnN0cnVjdG9yW1NQRUNJRVMkMV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb286IDFcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBhcnJheVtNRVRIT0RfTkFNRV0oQm9vbGVhbikuZm9vICE9PSAxO1xuICB9KTtcbn07XG5cbnZhciAkZmlsdGVyID0gYXJyYXlJdGVyYXRpb24uZmlsdGVyO1xudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdmaWx0ZXInKTsgLy8gRWRnZSAxNC0gaXNzdWVcblxudmFyIFVTRVNfVE9fTEVOR1RIJDEgPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCgnZmlsdGVyJyk7IC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG5cbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIHx8ICFVU0VTX1RPX0xFTkdUSCQxXG59LCB7XG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBmaWx0ZXIgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykuZmlsdGVyO1xuXG52YXIgQXJyYXlQcm90b3R5cGUkMiA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIGZpbHRlcl8xID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5maWx0ZXI7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkMiB8fCBpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkMi5maWx0ZXIgPyBmaWx0ZXIgOiBvd247XG59O1xuXG52YXIgZmlsdGVyJDEgPSBmaWx0ZXJfMTtcblxudmFyIGZpbHRlciQyID0gZmlsdGVyJDE7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTJDEgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIG9iamVjdEdldFByb3RvdHlwZU9mKDEpO1xufSk7IC8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG5cbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMkMSxcbiAgc2hhbTogIWNvcnJlY3RQcm90b3R5cGVHZXR0ZXJcbn0sIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBwYXRoLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIGdldFByb3RvdHlwZU9mJDEgPSBnZXRQcm90b3R5cGVPZjtcblxudmFyIGdldFByb3RvdHlwZU9mJDIgPSBnZXRQcm90b3R5cGVPZiQxO1xuXG52YXIgJGluZGV4T2YgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG52YXIgbmF0aXZlSW5kZXhPZiA9IFtdLmluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhbmF0aXZlSW5kZXhPZiAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcbnZhciBTVFJJQ1RfTUVUSE9EJDEgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdpbmRleE9mJyk7XG52YXIgVVNFU19UT19MRU5HVEgkMiA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdpbmRleE9mJywge1xuICBBQ0NFU1NPUlM6IHRydWUsXG4gIDE6IDBcbn0pOyAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogTkVHQVRJVkVfWkVSTyB8fCAhU1RSSUNUX01FVEhPRCQxIHx8ICFVU0VTX1RPX0xFTkdUSCQyXG59LCB7XG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudFxuICAvKiAsIGZyb21JbmRleCA9IDAgKi9cbiAgKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk8gLy8gY29udmVydCAtMCB0byArMFxuICAgID8gbmF0aXZlSW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgaW5kZXhPZiQxID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLmluZGV4T2Y7XG5cbnZhciBBcnJheVByb3RvdHlwZSQzID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgaW5kZXhPZl8xID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5pbmRleE9mO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDMgfHwgaXQgaW5zdGFuY2VvZiBBcnJheSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDMuaW5kZXhPZiA/IGluZGV4T2YkMSA6IG93bjtcbn07XG5cbnZhciBpbmRleE9mJDIgPSBpbmRleE9mXzE7XG5cbnZhciBpbmRleE9mJDMgPSBpbmRleE9mJDI7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LmlzYXJyYXlcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBpc0FycmF5OiBpc0FycmF5XG59KTtcblxudmFyIGlzQXJyYXkkMSA9IHBhdGguQXJyYXkuaXNBcnJheTtcblxudmFyIGlzQXJyYXkkMiA9IGlzQXJyYXkkMTtcblxudmFyIGlzQXJyYXkkMyA9IGlzQXJyYXkkMjtcblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoaXNBcnJheSQzKGFycikpIHJldHVybiBhcnI7XG59XG5cbnZhciBhcnJheVdpdGhIb2xlcyA9IF9hcnJheVdpdGhIb2xlcztcblxudmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbnZhciBpc0l0ZXJhYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1IkNV0gIT09IHVuZGVmaW5lZCB8fCAnQEBpdGVyYXRvcicgaW4gTyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIHx8IGl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG5cbnZhciBpc0l0ZXJhYmxlXzEgPSBpc0l0ZXJhYmxlO1xuXG52YXIgaXNJdGVyYWJsZSQxID0gaXNJdGVyYWJsZV8xO1xuXG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSB3ZWxsS25vd25TeW1ib2woJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGO1xudmFyIE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnOyAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbi8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUID0gZW5naW5lVjhWZXJzaW9uID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTtcbiAgcmV0dXJuIGFycmF5LmNvbmNhdCgpWzBdICE9PSBhcnJheTtcbn0pO1xudmFyIFNQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2NvbmNhdCcpO1xuXG52YXIgaXNDb25jYXRTcHJlYWRhYmxlID0gZnVuY3Rpb24gKE8pIHtcbiAgaWYgKCFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3ByZWFkYWJsZSA9IE9bSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICByZXR1cm4gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheShPKTtcbn07XG5cbnZhciBGT1JDRUQkMiA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFTUEVDSUVTX1NVUFBPUlQ7IC8vIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXRcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBpc0NvbmNhdFNwcmVhZGFibGUgYW5kIEBAc3BlY2llc1xuXG5fZXhwb3J0KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiBGT1JDRUQkMlxufSwge1xuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuXG4gICAgZm9yIChpID0gLTEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgRSA9IGkgPT09IC0xID8gTyA6IGFyZ3VtZW50c1tpXTtcblxuICAgICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xuICAgICAgICBsZW4gPSB0b0xlbmd0aChFLmxlbmd0aCk7XG4gICAgICAgIGlmIChuICsgbGVuID4gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrLCBuKyspIGlmIChrIGluIEUpIGNyZWF0ZVByb3BlcnR5KEEsIG4sIEVba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG4gPj0gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KEEsIG4rKywgRSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLmFzeW5jaXRlcmF0b3JcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdhc3luY0l0ZXJhdG9yJyk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5oYXNpbnN0YW5jZVxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2hhc0luc3RhbmNlJyk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5pc2NvbmNhdHNwcmVhZGFibGVcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLml0ZXJhdG9yXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLm1hdGNoXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdtYXRjaEFsbCcpO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wucmVwbGFjZVxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3JlcGxhY2UnKTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnNlYXJjaFxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3NlYXJjaCcpO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuc3BlY2llc1xuXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnNwbGl0XG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCgnc3BsaXQnKTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnRvcHJpbWl0aXZlXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnRvc3RyaW5ndGFnXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnVuc2NvcGFibGVzXG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtanNvbi1AQHRvc3RyaW5ndGFnXG5cbnNldFRvU3RyaW5nVGFnKGdsb2JhbF8xLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cbnZhciBzeW1ib2wgPSBwYXRoLlN5bWJvbDtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdXNpbmctc3RhdGVtZW50XG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCgnYXN5bmNEaXNwb3NlJyk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXVzaW5nLXN0YXRlbWVudFxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2Rpc3Bvc2UnKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ29ic2VydmFibGUnKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcGF0dGVybi1tYXRjaGluZ1xuXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3BhdHRlcm5NYXRjaCcpO1xuXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3JlcGxhY2VBbGwnKTtcblxudmFyIHN5bWJvbCQxID0gc3ltYm9sO1xuXG52YXIgc3ltYm9sJDIgPSBzeW1ib2wkMTtcblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIHN5bWJvbCQyID09PSBcInVuZGVmaW5lZFwiIHx8ICFpc0l0ZXJhYmxlJDEoT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGdldEl0ZXJhdG9yJDEoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7XG5cbnZhciBmcm9tXzEkMyA9IGZyb21fMTtcblxudmFyIGZyb21fMSQ0ID0gZnJvbV8xJDM7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUJDEgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdzbGljZScpO1xudmFyIFVTRVNfVE9fTEVOR1RIJDMgPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCgnc2xpY2UnLCB7XG4gIEFDQ0VTU09SUzogdHJ1ZSxcbiAgMDogMCxcbiAgMTogMlxufSk7XG52YXIgU1BFQ0lFUyQyID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgbmF0aXZlU2xpY2UgPSBbXS5zbGljZTtcbnZhciBtYXgkMSA9IE1hdGgubWF4OyAvLyBgQXJyYXkucHJvdG90eXBlLnNsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zbGljZVxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuXG5fZXhwb3J0KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCQxIHx8ICFVU0VTX1RPX0xFTkdUSCQzXG59LCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpOyAvLyBpbmxpbmUgYEFycmF5U3BlY2llc0NyZWF0ZWAgZm9yIHVzYWdlIG5hdGl2ZSBgQXJyYXkjc2xpY2VgIHdoZXJlIGl0J3MgcG9zc2libGVcblxuICAgIHZhciBDb25zdHJ1Y3RvciwgcmVzdWx0LCBuO1xuXG4gICAgaWYgKGlzQXJyYXkoTykpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gTy5jb25zdHJ1Y3RvcjsgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcblxuICAgICAgaWYgKHR5cGVvZiBDb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgaXNBcnJheShDb25zdHJ1Y3Rvci5wcm90b3R5cGUpKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3JbU1BFQ0lFUyQyXTtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBudWxsKSBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVTbGljZS5jYWxsKE8sIGssIGZpbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gbmV3IChDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDb25zdHJ1Y3RvcikobWF4JDEoZmluIC0gaywgMCkpO1xuXG4gICAgZm9yIChuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGlmIChrIGluIE8pIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxudmFyIHNsaWNlJDEgPSBlbnRyeVZpcnR1YWwoJ0FycmF5Jykuc2xpY2U7XG5cbnZhciBBcnJheVByb3RvdHlwZSQ0ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc2xpY2VfMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuc2xpY2U7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNCB8fCBpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNC5zbGljZSA/IHNsaWNlJDEgOiBvd247XG59O1xuXG52YXIgc2xpY2UkMiA9IHNsaWNlXzE7XG5cbnZhciBzbGljZSQzID0gc2xpY2UkMjtcblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG52YXIgYXJyYXlMaWtlVG9BcnJheSA9IF9hcnJheUxpa2VUb0FycmF5O1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIHZhciBfY29udGV4dDtcblxuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuXG4gIHZhciBuID0gc2xpY2UkMyhfY29udGV4dCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dCwgOCwgLTEpO1xuXG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tXzEkNChvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTtcblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IF9ub25JdGVyYWJsZVJlc3Q7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbnZhciBzbGljZWRUb0FycmF5ID0gX3NsaWNlZFRvQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRhdGUubm93XG5cbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdEYXRlJyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBub3c6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cbn0pO1xuXG52YXIgbm93ID0gcGF0aC5EYXRlLm5vdztcblxudmFyIG5vdyQxID0gbm93O1xuXG52YXIgbm93JDIgPSBub3ckMTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMkMiA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgb2JqZWN0S2V5cygxKTtcbn0pOyAvLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ09iamVjdCcsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyQyXG59LCB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyh0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxudmFyIGtleXMkMSA9IHBhdGguT2JqZWN0LmtleXM7XG5cbnZhciBrZXlzJDIgPSBrZXlzJDE7XG5cbnZhciBrZXlzJDMgPSBrZXlzJDI7XG5cbnZhciAkbWFwID0gYXJyYXlJdGVyYXRpb24ubWFwO1xudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQkMiA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ21hcCcpOyAvLyBGRjQ5LSBpc3N1ZVxuXG52YXIgVVNFU19UT19MRU5HVEgkNCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdtYXAnKTsgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQkMiB8fCAhVVNFU19UT19MRU5HVEgkNFxufSwge1xuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgbWFwID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLm1hcDtcblxudmFyIEFycmF5UHJvdG90eXBlJDUgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBtYXBfMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQubWFwO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDUgfHwgaXQgaW5zdGFuY2VvZiBBcnJheSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDUubWFwID8gbWFwIDogb3duO1xufTtcblxudmFyIG1hcCQxID0gbWFwXzE7XG5cbnZhciBtYXAkMiA9IG1hcCQxO1xuXG52YXIgaXNBcnJheSQ0ID0gaXNBcnJheSQxO1xuXG52YXIgaXNBcnJheSQ1ID0gaXNBcnJheSQ0O1xuXG52YXIgaXRlcmF0b3IgPSB3ZWxsS25vd25TeW1ib2xXcmFwcGVkLmYoJ2l0ZXJhdG9yJyk7XG5cbnZhciBpdGVyYXRvciQxID0gaXRlcmF0b3I7XG5cbnZhciBpdGVyYXRvciQyID0gaXRlcmF0b3IkMTtcblxudmFyIF90eXBlb2ZfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgICBpZiAodHlwZW9mIHN5bWJvbCQyID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGl0ZXJhdG9yJDIgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygc3ltYm9sJDIgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IHN5bWJvbCQyICYmIG9iaiAhPT0gc3ltYm9sJDIucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfdHlwZW9mKG9iaik7XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVmbGVjdC5vd25rZXlzXG5cbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdSZWZsZWN0JyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBvd25LZXlzOiBvd25LZXlzXG59KTtcblxudmFyIG93bktleXMkMSA9IHBhdGguUmVmbGVjdC5vd25LZXlzO1xuXG52YXIgc2xpY2UkNCA9IHNsaWNlXzE7XG5cbnZhciBzbGljZSQ1ID0gc2xpY2UkNDtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoaXNBcnJheSQzKGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbnZhciBhcnJheVdpdGhvdXRIb2xlcyA9IF9hcnJheVdpdGhvdXRIb2xlcztcblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2Ygc3ltYm9sJDIgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJdGVyYWJsZSQxKE9iamVjdChpdGVyKSkpIHJldHVybiBmcm9tXzEkNChpdGVyKTtcbn1cblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IF9pdGVyYWJsZVRvQXJyYXk7XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IF9ub25JdGVyYWJsZVNwcmVhZDtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IF90b0NvbnN1bWFibGVBcnJheTtcblxudmFyIGNvbmNhdCA9IGVudHJ5VmlydHVhbCgnQXJyYXknKS5jb25jYXQ7XG5cbnZhciBBcnJheVByb3RvdHlwZSQ2ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgY29uY2F0XzEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmNvbmNhdDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ2IHx8IGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ2LmNvbmNhdCA/IGNvbmNhdCA6IG93bjtcbn07XG5cbnZhciBjb25jYXQkMSA9IGNvbmNhdF8xO1xuXG52YXIgY29uY2F0JDIgPSBjb25jYXQkMTtcblxudmFyIHN5bWJvbCQzID0gc3ltYm9sO1xuXG52YXIgc3ltYm9sJDQgPSBzeW1ib2wkMztcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIHN5bWJvbCQ0ID09PSBcInVuZGVmaW5lZFwiIHx8IGdldEl0ZXJhdG9yTWV0aG9kJDEobykgPT0gbnVsbCkgeyBpZiAoaXNBcnJheSQ1KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gZ2V0SXRlcmF0b3IkMShvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobywgbWluTGVuKSB7IHZhciBfY29udGV4dDEzOyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlJDUoX2NvbnRleHQxMyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDEzLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tXzEkMihvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiB2aXMtdXRpbFxuICogaHR0cHM6Ly9naXRodWIuY29tL3Zpc2pzL3Zpcy11dGlsXG4gKlxuICogdXRpbGl0aWUgY29sbGVjdGlvbiBmb3IgdmlzanNcbiAqXG4gKiBAdmVyc2lvbiA0LjMuNFxuICogQGRhdGUgICAgMjAyMC0wOC0wMVQxNToxMTo1My41MjRaXG4gKlxuICogQGNvcHlyaWdodCAoYykgMjAxMS0yMDE3IEFsbWVuZGUgQi5WLCBodHRwOi8vYWxtZW5kZS5jb21cbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTctMjAxOSB2aXNqcyBjb250cmlidXRvcnMsIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNqc1xuICpcbiAqIEBsaWNlbnNlXG4gKiB2aXMuanMgaXMgZHVhbCBsaWNlbnNlZCB1bmRlciBib3RoXG4gKlxuICogICAxLiBUaGUgQXBhY2hlIDIuMCBMaWNlbnNlXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICAgYW5kXG4gKlxuICogICAyLiBUaGUgTUlUIExpY2Vuc2VcbiAqICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIHZpcy5qcyBtYXkgYmUgZGlzdHJpYnV0ZWQgdW5kZXIgZWl0aGVyIGxpY2Vuc2UuXG4gKi9cblxuLyoqXHJcbiAqIFVzZSB0aGlzIHN5bWJvbCB0byBkZWxldGUgcHJvcGVyaWVzIGluIGRlZXBPYmplY3RBc3NpZ24uXHJcbiAqL1xudmFyIERFTEVURSA9IHN5bWJvbCQ0KFwiREVMRVRFXCIpO1xuLyoqXHJcbiAqIFNlZWRhYmxlLCBmYXN0IGFuZCByZWFzb25hYmx5IGdvb2QgKG5vdCBjcnlwdG8gYnV0IG1vcmUgdGhhbiBva2F5IGZvciBvdXJcclxuICogbmVlZHMpIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBBZGFwdGVkIGZyb20ge0BsaW5rIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDExMDQyOTEwMDczNi9odHRwOi8vYmFhZ29lLmNvbTo4MC9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHR9LlxyXG4gKiBPcmlnaW5hbCBhbGdvcml0aG0gY3JlYXRlZCBieSBKb2hhbm5lcyBCYWFnw7hlIFxcPGJhYWdvZVxcQGJhYWdvZS5jb21cXD4gaW4gMjAxMC5cclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGUgYSBzZWVkZWQgcHNldWRvIHJhbmRvbSBnZW5lcmF0b3IgYmFzZWQgb24gQWxlYSBieSBKb2hhbm5lcyBCYWFnw7hlLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2VlZCAtIEFsbCBzdXBwbGllZCBhcmd1bWVudHMgd2lsbCBiZSB1c2VkIGFzIGEgc2VlZC4gSW4gY2FzZSBub3RoaW5nXHJcbiAqIGlzIHN1cHBsaWVkIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkIHRvIHNlZWQgdGhlIGdlbmVyYXRvci5cclxuICpcclxuICogQHJldHVybnMgQSByZWFkeSB0byB1c2Ugc2VlZGVkIGdlbmVyYXRvci5cclxuICovXG5cblxuZnVuY3Rpb24gQWxlYSgpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBzZWVkID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgc2VlZFtfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIEFsZWFJbXBsZW1lbnRhdGlvbihzZWVkLmxlbmd0aCA/IHNlZWQgOiBbbm93JDIoKV0pO1xufVxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIFtbQWxlYV1dIHdpdGhvdXQgdXNlciBpbnB1dCB2YWxpZGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2VlZCAtIFRoZSBkYXRhIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHNlZWQgdGhlIGdlbmVyYXRvci5cclxuICpcclxuICogQHJldHVybnMgQSByZWFkeSB0byB1c2Ugc2VlZGVkIGdlbmVyYXRvci5cclxuICovXG5cblxuZnVuY3Rpb24gQWxlYUltcGxlbWVudGF0aW9uKHNlZWQpIHtcbiAgdmFyIF9tYXNoU2VlZCA9IG1hc2hTZWVkKHNlZWQpLFxuICAgICAgX21hc2hTZWVkMiA9IHNsaWNlZFRvQXJyYXkoX21hc2hTZWVkLCAzKSxcbiAgICAgIHMwID0gX21hc2hTZWVkMlswXSxcbiAgICAgIHMxID0gX21hc2hTZWVkMlsxXSxcbiAgICAgIHMyID0gX21hc2hTZWVkMlsyXTtcblxuICB2YXIgYyA9IDE7XG5cbiAgdmFyIHJhbmRvbSA9IGZ1bmN0aW9uIHJhbmRvbSgpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBzMCArIGMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuXG4gICAgczAgPSBzMTtcbiAgICBzMSA9IHMyO1xuICAgIHJldHVybiBzMiA9IHQgLSAoYyA9IHQgfCAwKTtcbiAgfTtcblxuICByYW5kb20udWludDMyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICB9OyAvLyAyXjMyXG5cblxuICByYW5kb20uZnJhY3Q1MyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmFuZG9tKCkgKyAocmFuZG9tKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjtcbiAgfTsgLy8gMl4tNTNcblxuXG4gIHJhbmRvbS5hbGdvcml0aG0gPSBcIkFsZWFcIjtcbiAgcmFuZG9tLnNlZWQgPSBzZWVkO1xuICByYW5kb20udmVyc2lvbiA9IFwiMC45XCI7XG4gIHJldHVybiByYW5kb207XG59XG4vKipcclxuICogVHVybiBhcmJpdHJhcnkgZGF0YSBpbnRvIHZhbHVlcyBbW0FsZWFJbXBsZW1lbnRhdGlvbl1dIGNhbiB1c2UgdG8gZ2VuZXJhdGVcclxuICogcmFuZG9tIG51bWJlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWVkIC0gQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIHNlZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRocmVlIG51bWJlcnMgdG8gdXNlIGFzIGluaXRpYWwgdmFsdWVzIGZvciBbW0FsZWFJbXBsZW1lbnRhdGlvbl1dLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXNoU2VlZCgpIHtcbiAgdmFyIG1hc2ggPSBNYXNoKCk7XG4gIHZhciBzMCA9IG1hc2goXCIgXCIpO1xuICB2YXIgczEgPSBtYXNoKFwiIFwiKTtcbiAgdmFyIHMyID0gbWFzaChcIiBcIik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBzMCAtPSBtYXNoKGkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpXSk7XG5cbiAgICBpZiAoczAgPCAwKSB7XG4gICAgICBzMCArPSAxO1xuICAgIH1cblxuICAgIHMxIC09IG1hc2goaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldKTtcblxuICAgIGlmIChzMSA8IDApIHtcbiAgICAgIHMxICs9IDE7XG4gICAgfVxuXG4gICAgczIgLT0gbWFzaChpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV0pO1xuXG4gICAgaWYgKHMyIDwgMCkge1xuICAgICAgczIgKz0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3MwLCBzMSwgczJdO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXNoIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIG5vbnB1cmUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhcmJpdHJhcnkgW1tNYXNoYWJsZV1dIGRhdGEgYW5kIHR1cm5zXHJcbiAqIHRoZW0gaW50byBudW1iZXJzLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBNYXNoKCkge1xuICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzdHJpbmcgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIGggKj0gbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICB9XG5cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcbn0gLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxudmFyIGZ1bGxIZXhSRSA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7XG52YXIgc2hvcnRIZXhSRSA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG52YXIgcmdiUkUgPSAvXnJnYlxcKCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqXFwpJC9pO1xudmFyIHJnYmFSRSA9IC9ecmdiYVxcKCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKFswMV18MD9cXC5cXGQrKSAqXFwpJC9pO1xuLyoqXHJcbiAqIFJlbW92ZSBldmVyeXRoaW5nIGluIHRoZSBET00gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gRE9Nb2JqZWN0IC0gTm9kZSB3aG9zZSBjaGlsZCBub2RlcyB3aWxsIGJlIHJlY3Vyc2l2ZWx5IGRlbGV0ZWQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZURPTURlbGV0ZShET01vYmplY3QpIHtcbiAgaWYgKERPTW9iamVjdCkge1xuICAgIHdoaWxlIChET01vYmplY3QuaGFzQ2hpbGROb2RlcygpID09PSB0cnVlKSB7XG4gICAgICB2YXIgY2hpbGQgPSBET01vYmplY3QuZmlyc3RDaGlsZDtcblxuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZShjaGlsZCk7XG4gICAgICAgIERPTW9iamVjdC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcclxuICogVGVzdCB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gSW5wdXQgdmFsdWUgb2YgdW5rbm93biB0eXBlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuLyoqXHJcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBvYmplY3QgKG5vdCBwcmltaXRpdmUgb3IgbnVsbCkuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIElucHV0IHZhbHVlIG9mIHVua25vd24gdHlwZS5cclxuICpcclxuICogQHJldHVybnMgVHJ1ZSBpZiBub3QgbnVsbCBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QkMSh2YWx1ZSkge1xuICByZXR1cm4gX3R5cGVvZl8xKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxyXG4gKiBDb3B5IHByb3BlcnR5IGZyb20gYiB0byBhIGlmIHByb3BlcnR5IHByZXNlbnQgaW4gYS5cclxuICogSWYgcHJvcGVydHkgaW4gYiBleHBsaWNpdGx5IHNldCB0byBudWxsLCBkZWxldGUgaXQgaWYgYGFsbG93RGVsZXRpb25gIHNldC5cclxuICpcclxuICogSW50ZXJuYWwgaGVscGVyIHJvdXRpbmUsIHNob3VsZCBub3QgYmUgZXhwb3J0ZWQuIE5vdCBhZGRlZCB0byBgZXhwb3J0c2AgZm9yIHRoYXQgcmVhc29uLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIFRhcmdldCBvYmplY3QuXHJcbiAqIEBwYXJhbSBiIC0gU291cmNlIG9iamVjdC5cclxuICogQHBhcmFtIHByb3AgLSBOYW1lIG9mIHByb3BlcnR5IHRvIGNvcHkgZnJvbSBiIHRvIGEuXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnR5IGluIGEgaWYgZXhwbGljaXRseSBzZXQgdG8gbnVsbCBpbiBiLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbikge1xuICB2YXIgZG9EZWxldGlvbiA9IGZhbHNlO1xuXG4gIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgZG9EZWxldGlvbiA9IGJbcHJvcF0gPT09IG51bGwgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGRvRGVsZXRpb24pIHtcbiAgICBkZWxldGUgYVtwcm9wXTtcbiAgfSBlbHNlIHtcbiAgICBhW3Byb3BdID0gYltwcm9wXTsgLy8gUmVtZW1iZXIsIHRoaXMgaXMgYSByZWZlcmVuY2UgY29weSFcbiAgfVxufVxuLyoqXHJcbiAqIEZpbGwgYW4gb2JqZWN0IHdpdGggYSBwb3NzaWJseSBwYXJ0aWFsbHkgZGVmaW5lZCBvdGhlciBvYmplY3QuXHJcbiAqXHJcbiAqIE9ubHkgY29waWVzIHZhbHVlcyBmb3IgdGhlIHByb3BlcnRpZXMgYWxyZWFkeSBwcmVzZW50IGluIGEuXHJcbiAqIFRoYXQgbWVhbnMgYW4gb2JqZWN0IGlzIG5vdCBjcmVhdGVkIG9uIGEgcHJvcGVydHkgaWYgb25seSB0aGUgYiBvYmplY3QgaGFzIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGhhdmUgaXQncyBwcm9wZXJ0aWVzIHVwZGF0ZWQuXHJcbiAqIEBwYXJhbSBiIC0gVGhlIG9iamVjdCB3aXRoIHByb3BlcnR5IHVwZGF0ZXMuXHJcbiAqIEBwYXJhbSBhbGxvd0RlbGV0aW9uIC0gSWYgdHJ1ZSwgZGVsZXRlIHByb3BlcnRpZXMgaW4gYSB0aGF0IGFyZSBleHBsaWNpdGx5IHNldCB0byBudWxsIGluIGIuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbGxJZkRlZmluZWQoYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogaXRlcmF0aW9uIG9mIHByb3BlcnRpZXMgb2YgYVxuICAvLyBOT1RFOiBwcm90b3R5cGUgcHJvcGVydGllcyBpdGVyYXRlZCBvdmVyIGFzIHdlbGxcbiAgZm9yICh2YXIgcHJvcCBpbiBhKSB7XG4gICAgaWYgKGJbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGJbcHJvcF0gPT09IG51bGwgfHwgX3R5cGVvZl8xKGJbcHJvcF0pICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIE5vdGU6IHR5cGVvZiBudWxsID09PSAnb2JqZWN0J1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYVByb3AgPSBhW3Byb3BdO1xuICAgICAgICB2YXIgYlByb3AgPSBiW3Byb3BdO1xuXG4gICAgICAgIGlmIChpc09iamVjdCQxKGFQcm9wKSAmJiBpc09iamVjdCQxKGJQcm9wKSkge1xuICAgICAgICAgIGZpbGxJZkRlZmluZWQoYVByb3AsIGJQcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHNlbGVjdGVkIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXHJcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyByb3V0aW5lIGltcGxpZWQgdGhhdCBtdWx0aXBsZSBzb3VyY2Ugb2JqZWN0cyBjb3VsZFxyXG4gKiBiZSB1c2VkOyBob3dldmVyLCB0aGUgaW1wbGVtZW50YXRpb24gd2FzICoqd3JvbmcqKi4gU2luY2UgbXVsdGlwbGUgKFxcPjEpXHJcbiAqIHNvdXJjZXMgd2VyZW4ndCB1c2VkIGFueXdoZXJlIGluIHRoZSBgdmlzLmpzYCBjb2RlLCB0aGlzIGhhcyBiZWVuIHJlbW92ZWRcclxuICpcclxuICogQHBhcmFtIHByb3BzIC0gTmFtZXMgb2YgZmlyc3QtbGV2ZWwgcHJvcGVydGllcyB0byBjb3B5IG92ZXIuXHJcbiAqIEBwYXJhbSBhIC0gVGFyZ2V0IG9iamVjdC5cclxuICogQHBhcmFtIGIgLSBTb3VyY2Ugb2JqZWN0LlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIGRlbGV0ZSBwcm9wZXJ0eSBpbiBhIGlmIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgaW4gYi5cclxuICpcclxuICogQHJldHVybnMgQXJndW1lbnQgYS5cclxuICovXG5cblxuZnVuY3Rpb24gc2VsZWN0aXZlRGVlcEV4dGVuZChwcm9wcywgYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIGlmIChpc0FycmF5JDUoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmRcIik7XG4gIH1cblxuICBmb3IgKHZhciBwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1twXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcHJvcCkpIHtcbiAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgIGRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSwgZmFsc2UsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5JDUoYltwcm9wXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhO1xufVxuLyoqXHJcbiAqIEV4dGVuZCBvYmplY3QgYGFgIHdpdGggcHJvcGVydGllcyBvZiBvYmplY3QgYGJgLCBpZ25vcmluZyBwcm9wZXJ0aWVzIHdoaWNoXHJcbiAqIGFyZSBleHBsaWNpdGx5IHNwZWNpZmllZCB0byBiZSBleGNsdWRlZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhlIHByb3BlcnRpZXMgb2YgYGJgIGFyZSBjb25zaWRlcmVkIGZvciBjb3B5aW5nLiBQcm9wZXJ0aWVzIHdoaWNoIGFyZVxyXG4gKiB0aGVtc2VsdmVzIG9iamVjdHMgYXJlIGFyZSBhbHNvIGV4dGVuZGVkLiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkXHJcbiAqIHZhbHVlcyBhcmUgY29waWVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gcHJvcHNUb0V4Y2x1ZGUgLSBOYW1lcyBvZiBwcm9wZXJ0aWVzIHdoaWNoIHNob3VsZCAqbm90KiBiZSBjb3BpZWQuXHJcbiAqIEBwYXJhbSBhIC0gT2JqZWN0IHRvIGV4dGVuZC5cclxuICogQHBhcmFtIGIgLSBPYmplY3QgdG8gdGFrZSBwcm9wZXJ0aWVzIGZyb20gZm9yIGV4dGVuc2lvbi5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCBkZWxldGUgcHJvcGVydGllcyBpbiBhIHRoYXQgYXJlIGV4cGxpY2l0bHlcclxuICogc2V0IHRvIG51bGwgaW4gYi5cclxuICpcclxuICogQHJldHVybnMgQXJndW1lbnQgYS5cclxuICovXG5cblxuZnVuY3Rpb24gc2VsZWN0aXZlTm90RGVlcEV4dGVuZChwcm9wc1RvRXhjbHVkZSwgYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIC8vIE5PVEU6IGFycmF5IHByb3BlcnRpZXMgaGF2ZSBhbiBlbHNlLWJlbG93OyBhcHBhcmVudGx5LCB0aGVyZSBpcyBhIHByb2JsZW0gaGVyZS5cbiAgaWYgKGlzQXJyYXkkNShiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZFwiKTtcbiAgfVxuXG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHByb3ApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIEhhbmRsZSBsb2NhbCBwcm9wZXJ0aWVzIG9ubHlcblxuXG4gICAgaWYgKGluZGV4T2YkMyhwcm9wc1RvRXhjbHVkZSkuY2FsbChwcm9wc1RvRXhjbHVkZSwgcHJvcCkgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIEluIGV4Y2x1c2lvbiBsaXN0LCBza2lwXG5cblxuICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgZGVlcEV4dGVuZChhW3Byb3BdLCBiW3Byb3BdKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkkNShiW3Byb3BdKSkge1xuICAgICAgYVtwcm9wXSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYVtwcm9wXS5wdXNoKGJbcHJvcF1baV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcclxuICogRGVlcCBleHRlbmQgYW4gb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cclxuICpcclxuICogQHBhcmFtIGEgLSBUYXJnZXQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gYiAtIFNvdXJjZSBvYmplY3QuXHJcbiAqIEBwYXJhbSBwcm90b0V4dGVuZCAtIElmIHRydWUsIHRoZSBwcm90b3R5cGUgdmFsdWVzIHdpbGwgYWxzbyBiZSBleHRlbmRlZC5cclxuICogKFRoYXQgaXMgdGhlIG9wdGlvbnMgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBvdGhlcnMgd2lsbCBhbHNvIGdldCB0aGVcclxuICogaW5oZXJpdGVkIG9wdGlvbnMpLlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIHRoZSB2YWx1ZXMgb2YgZmllbGRzIHRoYXQgYXJlIG51bGwgd2lsbCBiZSBkZWxldGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBcmd1bWVudCBhLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZWVwRXh0ZW5kKGEsIGIpIHtcbiAgdmFyIHByb3RvRXh0ZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcHJvcCkgfHwgcHJvdG9FeHRlbmQgPT09IHRydWUpIHtcbiAgICAgIGlmIChfdHlwZW9mXzEoYltwcm9wXSkgPT09IFwib2JqZWN0XCIgJiYgYltwcm9wXSAhPT0gbnVsbCAmJiBnZXRQcm90b3R5cGVPZiQyKGJbcHJvcF0pID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhW3Byb3BdID0gZGVlcEV4dGVuZCh7fSwgYltwcm9wXSwgcHJvdG9FeHRlbmQpOyAvLyBOT1RFOiBhbGxvd0RlbGV0aW9uIG5vdCBwcm9wYWdhdGVkIVxuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2ZfMShhW3Byb3BdKSA9PT0gXCJvYmplY3RcIiAmJiBhW3Byb3BdICE9PSBudWxsICYmIGdldFByb3RvdHlwZU9mJDIoYVtwcm9wXSkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIHByb3RvRXh0ZW5kKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQ1KGJbcHJvcF0pKSB7XG4gICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgYVtwcm9wXSA9IHNsaWNlJDUoX2NvbnRleHQzID0gYltwcm9wXSkuY2FsbChfY29udGV4dDMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhO1xufVxuLyoqXHJcbiAqIFVzZWQgdG8gZXh0ZW5kIGFuIGFycmF5IGFuZCBjb3B5IGl0LiBUaGlzIGlzIHVzZWQgdG8gcHJvcGFnYXRlIHBhdGhzIHJlY3Vyc2l2ZWx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyIC0gRmlyc3QgcGFydC5cclxuICogQHBhcmFtIG5ld1ZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIGFhZGRlZCBpbnRvIHRoZSBhcnJheS5cclxuICpcclxuICogQHJldHVybnMgQSBuZXcgYXJyYXkgd2l0aCBhbGwgaXRlbXMgZnJvbSBhcnIgYW5kIG5ld1ZhbHVlICh3aGljaCBpcyBsYXN0KS5cclxuICovXG5cblxuZnVuY3Rpb24gY29weUFuZEV4dGVuZEFycmF5KGFyciwgbmV3VmFsdWUpIHtcbiAgdmFyIF9jb250ZXh0NDtcblxuICByZXR1cm4gY29uY2F0JDIoX2NvbnRleHQ0ID0gW10pLmNhbGwoX2NvbnRleHQ0LCB0b0NvbnN1bWFibGVBcnJheShhcnIpLCBbbmV3VmFsdWVdKTtcbn1cbi8qKlxyXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cclxuICpcclxuICogQHBhcmFtIGFyciAtIFRoZSBhcnJheSB0byBiZSBjb3BpZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFNoYWxsb3cgY29weSBvZiBhcnIuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHlBcnJheShhcnIpIHtcbiAgcmV0dXJuIHNsaWNlJDUoYXJyKS5jYWxsKGFycik7XG59XG4vKipcclxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIGxlZnQgdmFsdWUgb2YgYSBET00gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIGVsZW0gLSBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdi5cclxuICpcclxuICogQHJldHVybnMgVGhlIGFic29sdXRlIGxlZnQgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50IGluIHRoZSBicm93c2VyIHBhZ2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEFic29sdXRlTGVmdChlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG59XG4vKipcclxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIHRvcCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbSAtIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgdG9wIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudCBpbiB0aGUgYnJvd3NlciBwYWdlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVRvcChlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbn1cbi8qKlxyXG4gKiBBZGQgYSBjbGFzc05hbWUgdG8gdGhlIGdpdmVuIGVsZW1lbnRzIHN0eWxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbSAtIFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBjbGFzc2VzIHdpbGwgYmUgYWRkZWQuXHJcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gU3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgY2xhc3Nlcy5cclxuICovXG5cblxuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lKGVsZW0sIGNsYXNzTmFtZXMpIHtcbiAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdChcIiBcIik7XG4gIHZhciBuZXdDbGFzc2VzID0gY2xhc3NOYW1lcy5zcGxpdChcIiBcIik7XG4gIGNsYXNzZXMgPSBjb25jYXQkMihjbGFzc2VzKS5jYWxsKGNsYXNzZXMsIGZpbHRlciQyKG5ld0NsYXNzZXMpLmNhbGwobmV3Q2xhc3NlcywgZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBpbmRleE9mJDMoY2xhc3NlcykuY2FsbChjbGFzc2VzLCBjbGFzc05hbWUpIDwgMDtcbiAgfSkpO1xuICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbihcIiBcIik7XG59XG4vKipcclxuICogUmVtb3ZlIGEgY2xhc3NOYW1lIGZyb20gdGhlIGdpdmVuIGVsZW1lbnRzIHN0eWxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbSAtIFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdGhlIGNsYXNzZXMgd2lsbCBiZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gY2xhc3NOYW1lcyAtIFNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzZXMuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZShlbGVtLCBjbGFzc05hbWVzKSB7XG4gIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoXCIgXCIpO1xuICB2YXIgb2xkQ2xhc3NlcyA9IGNsYXNzTmFtZXMuc3BsaXQoXCIgXCIpO1xuICBjbGFzc2VzID0gZmlsdGVyJDIoY2xhc3NlcykuY2FsbChjbGFzc2VzLCBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIGluZGV4T2YkMyhvbGRDbGFzc2VzKS5jYWxsKG9sZENsYXNzZXMsIGNsYXNzTmFtZSkgPCAwO1xuICB9KTtcbiAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpO1xufVxuLyoqXHJcbiAqIEZvciBlYWNoIG1ldGhvZCBmb3IgYm90aCBhcnJheXMgYW5kIG9iamVjdHMuXHJcbiAqIEluIGNhc2Ugb2YgYW4gYXJyYXksIHRoZSBidWlsdC1pbiBBcnJheS5mb3JFYWNoKCkgaXMgYXBwbGllZCAoKipObywgaXQncyBub3QhKiopLlxyXG4gKiBJbiBjYXNlIG9mIGFuIE9iamVjdCwgdGhlIG1ldGhvZCBsb29wcyBvdmVyIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmplY3QgLSBBbiBPYmplY3Qgb3IgQXJyYXkgdG8gYmUgaXRlcmF0ZWQgb3Zlci5cclxuICogQHBhcmFtIGNhbGxiYWNrIC0gQXJyYXkuZm9yRWFjaC1saWtlIGNhbGxiYWNrLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JFYWNoJDMob2JqZWN0LCBjYWxsYmFjaykge1xuICBpZiAoaXNBcnJheSQ1KG9iamVjdCkpIHtcbiAgICAvLyBhcnJheVxuICAgIHZhciBsZW4gPSBvYmplY3QubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBvYmplY3RcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIEFkZCBhbmQgZXZlbnQgbGlzdGVuZXIuIFdvcmtzIGZvciBhbGwgYnJvd3NlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gYmluZCB0aGUgZXZlbnQgbGlzdGVuZXIgdG8uXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBTYW1lIGFzIEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhY3Rpb24sIOKAlCwg4oCUKS5cclxuICogQHBhcmFtIGxpc3RlbmVyIC0gU2FtZSBhcyBFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIo4oCULCBsaXN0ZW5lciwg4oCUKS5cclxuICogQHBhcmFtIHVzZUNhcHR1cmUgLSBTYW1lIGFzIEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcijigJQsIOKAlCwgdXNlQ2FwdHVyZSkuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgdmFyIF9jb250ZXh0NTtcblxuICAgIGlmICh1c2VDYXB0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHVzZUNhcHR1cmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uID09PSBcIm1vdXNld2hlZWxcIiAmJiBpbmRleE9mJDMoX2NvbnRleHQ1ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCkuY2FsbChfY29udGV4dDUsIFwiRmlyZWZveFwiKSA+PSAwKSB7XG4gICAgICBhY3Rpb24gPSBcIkRPTU1vdXNlU2Nyb2xsXCI7IC8vIEZvciBGaXJlZm94XG4gICAgfVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIC8vIEBUT0RPOiBJRSB0eXBlcz8gRG9lcyBhbnlvbmUgY2FyZT9cbiAgICBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGFjdGlvbiwgbGlzdGVuZXIpOyAvLyBJRSBicm93c2Vyc1xuICB9XG59XG4vKipcclxuICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYW4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBiaW5kIHRoZSBldmVudCBsaXN0ZW5lciB0by5cclxuICogQHBhcmFtIGFjdGlvbiAtIFNhbWUgYXMgRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGFjdGlvbiwg4oCULCDigJQpLlxyXG4gKiBAcGFyYW0gbGlzdGVuZXIgLSBTYW1lIGFzIEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcijigJQsIGxpc3RlbmVyLCDigJQpLlxyXG4gKiBAcGFyYW0gdXNlQ2FwdHVyZSAtIFNhbWUgYXMgRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKOKAlCwg4oCULCB1c2VDYXB0dXJlKS5cclxuICovXG5cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICB2YXIgX2NvbnRleHQ2O1xuXG4gICAgLy8gbm9uLUlFIGJyb3dzZXJzXG4gICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24gPT09IFwibW91c2V3aGVlbFwiICYmIGluZGV4T2YkMyhfY29udGV4dDYgPSBuYXZpZ2F0b3IudXNlckFnZW50KS5jYWxsKF9jb250ZXh0NiwgXCJGaXJlZm94XCIpID49IDApIHtcbiAgICAgIGFjdGlvbiA9IFwiRE9NTW91c2VTY3JvbGxcIjsgLy8gRm9yIEZpcmVmb3hcbiAgICB9XG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQFRPRE86IElFIHR5cGVzPyBEb2VzIGFueW9uZSBjYXJlP1xuICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoXCJvblwiICsgYWN0aW9uLCBsaXN0ZW5lcik7IC8vIElFIGJyb3dzZXJzXG4gIH1cbn1cbi8qKlxyXG4gKiBDb252ZXJ0IGhleCBjb2xvciBzdHJpbmcgaW50byBSR0IgY29sb3Igb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiB7QGxpbmsgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2J9XHJcbiAqXHJcbiAqIEBwYXJhbSBoZXggLSBIZXggY29sb3Igc3RyaW5nICgzIG9yIDYgZGlnaXRzLCB3aXRoIG9yIHdpdGhvdXQgIykuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFJHQiBjb2xvciBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBoZXhUb1JHQihoZXgpIHtcbiAgdmFyIHJlc3VsdDtcblxuICBzd2l0Y2ggKGhleC5sZW5ndGgpIHtcbiAgICBjYXNlIDM6XG4gICAgY2FzZSA0OlxuICAgICAgcmVzdWx0ID0gc2hvcnRIZXhSRS5leGVjKGhleCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICByOiBfcGFyc2VJbnQkMihyZXN1bHRbMV0gKyByZXN1bHRbMV0sIDE2KSxcbiAgICAgICAgZzogX3BhcnNlSW50JDIocmVzdWx0WzJdICsgcmVzdWx0WzJdLCAxNiksXG4gICAgICAgIGI6IF9wYXJzZUludCQyKHJlc3VsdFszXSArIHJlc3VsdFszXSwgMTYpXG4gICAgICB9IDogbnVsbDtcblxuICAgIGNhc2UgNjpcbiAgICBjYXNlIDc6XG4gICAgICByZXN1bHQgPSBmdWxsSGV4UkUuZXhlYyhoZXgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAgICAgcjogX3BhcnNlSW50JDIocmVzdWx0WzFdLCAxNiksXG4gICAgICAgIGc6IF9wYXJzZUludCQyKHJlc3VsdFsyXSwgMTYpLFxuICAgICAgICBiOiBfcGFyc2VJbnQkMihyZXN1bHRbM10sIDE2KVxuICAgICAgfSA6IG51bGw7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHN0cmluZyBjb2xvciBpbiBoZXggb3IgUkdCIGZvcm1hdCBhbmQgYWRkcyB0aGUgb3BhY2l0eSwgUkdCQSBpcyBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciAtIFRoZSBjb2xvciBzdHJpbmcgKGhleCwgUkdCLCBSR0JBKS5cclxuICogQHBhcmFtIG9wYWNpdHkgLSBUaGUgbmV3IG9wYWNpdHkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFJHQkEgc3RyaW5nLCBmb3IgZXhhbXBsZSAncmdiYSgyNTUsIDAsIDEyNywgMC4zKScuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG92ZXJyaWRlT3BhY2l0eShjb2xvciwgb3BhY2l0eSkge1xuICBpZiAoaW5kZXhPZiQzKGNvbG9yKS5jYWxsKGNvbG9yLCBcInJnYmFcIikgIT09IC0xKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9IGVsc2UgaWYgKGluZGV4T2YkMyhjb2xvcikuY2FsbChjb2xvciwgXCJyZ2JcIikgIT09IC0xKSB7XG4gICAgdmFyIHJnYiA9IGNvbG9yLnN1YnN0cihpbmRleE9mJDMoY29sb3IpLmNhbGwoY29sb3IsIFwiKFwiKSArIDEpLnJlcGxhY2UoXCIpXCIsIFwiXCIpLnNwbGl0KFwiLFwiKTtcbiAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiWzBdICsgXCIsXCIgKyByZ2JbMV0gKyBcIixcIiArIHJnYlsyXSArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xuICB9IGVsc2Uge1xuICAgIHZhciBfcmdiID0gaGV4VG9SR0IoY29sb3IpO1xuXG4gICAgaWYgKF9yZ2IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJyZ2JhKFwiICsgX3JnYi5yICsgXCIsXCIgKyBfcmdiLmcgKyBcIixcIiArIF9yZ2IuYiArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiO1xuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIENvbnZlcnQgUkdCIFxcPDAsIDI1NVxcPiBpbnRvIGhleCBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWQgLSBSZWQgY2hhbm5lbC5cclxuICogQHBhcmFtIGdyZWVuIC0gR3JlZW4gY2hhbm5lbC5cclxuICogQHBhcmFtIGJsdWUgLSBCbHVlIGNoYW5uZWwuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEhleCBjb2xvciBzdHJpbmcgKGZvciBleGFtcGxlOiAnIzBhY2RjMCcpLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBSR0JUb0hleChyZWQsIGdyZWVuLCBibHVlKSB7XG4gIHZhciBfY29udGV4dDc7XG5cbiAgcmV0dXJuIFwiI1wiICsgc2xpY2UkNShfY29udGV4dDcgPSAoKDEgPDwgMjQpICsgKHJlZCA8PCAxNikgKyAoZ3JlZW4gPDwgOCkgKyBibHVlKS50b1N0cmluZygxNikpLmNhbGwoX2NvbnRleHQ3LCAxKTtcbn1cbi8qKlxyXG4gKiBQYXJzZSBhIGNvbG9yIHByb3BlcnR5IGludG8gYW4gb2JqZWN0IHdpdGggYm9yZGVyLCBiYWNrZ3JvdW5kLCBhbmQgaGlnaGxpZ2h0IGNvbG9ycy5cclxuICpcclxuICogQHBhcmFtIGlucHV0Q29sb3IgLSBTaG9ydGhhbmQgY29sb3Igc3RyaW5nIG9yIGlucHV0IGNvbG9yIG9iamVjdC5cclxuICogQHBhcmFtIGRlZmF1bHRDb2xvciAtIEZ1bGwgY29sb3Igb2JqZWN0IHRvIGZpbGwgaW4gbWlzc2luZyB2YWx1ZXMgaW4gaW5wdXRDb2xvci5cclxuICpcclxuICogQHJldHVybnMgQ29sb3Igb2JqZWN0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUNvbG9yKGlucHV0Q29sb3IsIGRlZmF1bHRDb2xvcikge1xuICBpZiAoaXNTdHJpbmcoaW5wdXRDb2xvcikpIHtcbiAgICB2YXIgY29sb3JTdHIgPSBpbnB1dENvbG9yO1xuXG4gICAgaWYgKGlzVmFsaWRSR0IoY29sb3JTdHIpKSB7XG4gICAgICB2YXIgX2NvbnRleHQ4O1xuXG4gICAgICB2YXIgcmdiID0gbWFwJDIoX2NvbnRleHQ4ID0gY29sb3JTdHIuc3Vic3RyKDQpLnN1YnN0cigwLCBjb2xvclN0ci5sZW5ndGggLSA1KS5zcGxpdChcIixcIikpLmNhbGwoX2NvbnRleHQ4LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9wYXJzZUludCQyKHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb2xvclN0ciA9IFJHQlRvSGV4KHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xuICAgIH1cblxuICAgIGlmIChpc1ZhbGlkSGV4KGNvbG9yU3RyKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIGhzdiA9IGhleFRvSFNWKGNvbG9yU3RyKTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIU1YgPSB7XG4gICAgICAgIGg6IGhzdi5oLFxuICAgICAgICBzOiBoc3YucyAqIDAuOCxcbiAgICAgICAgdjogTWF0aC5taW4oMSwgaHN2LnYgKiAxLjAyKVxuICAgICAgfTtcbiAgICAgIHZhciBkYXJrZXJDb2xvckhTViA9IHtcbiAgICAgICAgaDogaHN2LmgsXG4gICAgICAgIHM6IE1hdGgubWluKDEsIGhzdi5zICogMS4yNSksXG4gICAgICAgIHY6IGhzdi52ICogMC44XG4gICAgICB9O1xuICAgICAgdmFyIGRhcmtlckNvbG9ySGV4ID0gSFNWVG9IZXgoZGFya2VyQ29sb3JIU1YuaCwgZGFya2VyQ29sb3JIU1YucywgZGFya2VyQ29sb3JIU1Yudik7XG4gICAgICB2YXIgbGlnaHRlckNvbG9ySGV4ID0gSFNWVG9IZXgobGlnaHRlckNvbG9ySFNWLmgsIGxpZ2h0ZXJDb2xvckhTVi5zLCBsaWdodGVyQ29sb3JIU1Yudik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcbiAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleCxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogbGlnaHRlckNvbG9ySGV4LFxuICAgICAgICAgIGJvcmRlcjogZGFya2VyQ29sb3JIZXhcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcbiAgICAgICAgYm9yZGVyOiBjb2xvclN0cixcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3JTdHIsXG4gICAgICAgICAgYm9yZGVyOiBjb2xvclN0clxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU3RyLFxuICAgICAgICAgIGJvcmRlcjogY29sb3JTdHJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlZmF1bHRDb2xvcikge1xuICAgICAgdmFyIGNvbG9yID0ge1xuICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmJhY2tncm91bmQgfHwgZGVmYXVsdENvbG9yLmJhY2tncm91bmQsXG4gICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ib3JkZXIgfHwgZGVmYXVsdENvbG9yLmJvcmRlcixcbiAgICAgICAgaGlnaGxpZ2h0OiBpc1N0cmluZyhpbnB1dENvbG9yLmhpZ2hsaWdodCkgPyB7XG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhpZ2hsaWdodCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhpZ2hsaWdodFxuICAgICAgICB9IDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaGlnaGxpZ2h0ICYmIGlucHV0Q29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgfHwgZGVmYXVsdENvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kLFxuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYm9yZGVyIHx8IGRlZmF1bHRDb2xvci5oaWdobGlnaHQuYm9yZGVyXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiBpc1N0cmluZyhpbnB1dENvbG9yLmhvdmVyKSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaG92ZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlclxuICAgICAgICB9IDoge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJvcmRlciB8fCBkZWZhdWx0Q29sb3IuaG92ZXIuYm9yZGVyLFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaG92ZXIgJiYgaW5wdXRDb2xvci5ob3Zlci5iYWNrZ3JvdW5kIHx8IGRlZmF1bHRDb2xvci5ob3Zlci5iYWNrZ3JvdW5kXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY29sb3IgPSB7XG4gICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ib3JkZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgICBoaWdobGlnaHQ6IGlzU3RyaW5nKGlucHV0Q29sb3IuaGlnaGxpZ2h0KSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaGlnaGxpZ2h0LFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaGlnaGxpZ2h0XG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhpZ2hsaWdodCAmJiBpbnB1dENvbG9yLmhpZ2hsaWdodC5ib3JkZXIgfHwgdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiBpc1N0cmluZyhpbnB1dENvbG9yLmhvdmVyKSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaG92ZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlclxuICAgICAgICB9IDoge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJvcmRlciB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJhY2tncm91bmQgfHwgdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX2NvbG9yO1xuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIENvbnZlcnQgUkdCIFxcPDAsIDI1NVxcPiBpbnRvIEhTViBvYmplY3QuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIHtAbGluayBodHRwOi8vd3d3LmphdmFzY3JpcHRlci5uZXQvZmFxL3JnYjJoc3YuaHRtfVxyXG4gKlxyXG4gKiBAcGFyYW0gcmVkIC0gUmVkIGNoYW5uZWwuXHJcbiAqIEBwYXJhbSBncmVlbiAtIEdyZWVuIGNoYW5uZWwuXHJcbiAqIEBwYXJhbSBibHVlIC0gQmx1ZSBjaGFubmVsLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBIU1YgY29sb3Igb2JqZWN0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBSR0JUb0hTVihyZWQsIGdyZWVuLCBibHVlKSB7XG4gIHJlZCA9IHJlZCAvIDI1NTtcbiAgZ3JlZW4gPSBncmVlbiAvIDI1NTtcbiAgYmx1ZSA9IGJsdWUgLyAyNTU7XG4gIHZhciBtaW5SR0IgPSBNYXRoLm1pbihyZWQsIE1hdGgubWluKGdyZWVuLCBibHVlKSk7XG4gIHZhciBtYXhSR0IgPSBNYXRoLm1heChyZWQsIE1hdGgubWF4KGdyZWVuLCBibHVlKSk7IC8vIEJsYWNrLWdyYXktd2hpdGVcblxuICBpZiAobWluUkdCID09PSBtYXhSR0IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaDogMCxcbiAgICAgIHM6IDAsXG4gICAgICB2OiBtaW5SR0JcbiAgICB9O1xuICB9IC8vIENvbG9ycyBvdGhlciB0aGFuIGJsYWNrLWdyYXktd2hpdGU6XG5cblxuICB2YXIgZCA9IHJlZCA9PT0gbWluUkdCID8gZ3JlZW4gLSBibHVlIDogYmx1ZSA9PT0gbWluUkdCID8gcmVkIC0gZ3JlZW4gOiBibHVlIC0gcmVkO1xuICB2YXIgaCA9IHJlZCA9PT0gbWluUkdCID8gMyA6IGJsdWUgPT09IG1pblJHQiA/IDEgOiA1O1xuICB2YXIgaHVlID0gNjAgKiAoaCAtIGQgLyAobWF4UkdCIC0gbWluUkdCKSkgLyAzNjA7XG4gIHZhciBzYXR1cmF0aW9uID0gKG1heFJHQiAtIG1pblJHQikgLyBtYXhSR0I7XG4gIHZhciB2YWx1ZSA9IG1heFJHQjtcbiAgcmV0dXJuIHtcbiAgICBoOiBodWUsXG4gICAgczogc2F0dXJhdGlvbixcbiAgICB2OiB2YWx1ZVxuICB9O1xufVxuLyoqXHJcbiAqIENvbnZlcnQgSFNWIFxcPDAsIDFcXD4gaW50byBSR0IgY29sb3Igb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWppamFja3Nvbi81MzExMjU2fVxyXG4gKlxyXG4gKiBAcGFyYW0gaCAtIEh1ZS5cclxuICogQHBhcmFtIHMgLSBTYXR1cmF0aW9uLlxyXG4gKiBAcGFyYW0gdiAtIFZhbHVlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBSR0IgY29sb3Igb2JqZWN0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBIU1ZUb1JHQihoLCBzLCB2KSB7XG4gIHZhciByO1xuICB2YXIgZztcbiAgdmFyIGI7XG4gIHZhciBpID0gTWF0aC5mbG9vcihoICogNik7XG4gIHZhciBmID0gaCAqIDYgLSBpO1xuICB2YXIgcCA9IHYgKiAoMSAtIHMpO1xuICB2YXIgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgdmFyIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgc3dpdGNoIChpICUgNikge1xuICAgIGNhc2UgMDpcbiAgICAgIHIgPSB2LCBnID0gdCwgYiA9IHA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHIgPSBxLCBnID0gdiwgYiA9IHA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIHIgPSBwLCBnID0gdiwgYiA9IHQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMzpcbiAgICAgIHIgPSBwLCBnID0gcSwgYiA9IHY7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgNDpcbiAgICAgIHIgPSB0LCBnID0gcCwgYiA9IHY7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgNTpcbiAgICAgIHIgPSB2LCBnID0gcCwgYiA9IHE7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcjogTWF0aC5mbG9vcihyICogMjU1KSxcbiAgICBnOiBNYXRoLmZsb29yKGcgKiAyNTUpLFxuICAgIGI6IE1hdGguZmxvb3IoYiAqIDI1NSlcbiAgfTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IEhTViBcXDwwLCAxXFw+IGludG8gaGV4IGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIGggLSBIdWUuXHJcbiAqIEBwYXJhbSBzIC0gU2F0dXJhdGlvbi5cclxuICogQHBhcmFtIHYgLSBWYWx1ZS5cclxuICpcclxuICogQHJldHVybnMgSGV4IGNvbG9yIHN0cmluZy5cclxuICovXG5cblxuZnVuY3Rpb24gSFNWVG9IZXgoaCwgcywgdikge1xuICB2YXIgcmdiID0gSFNWVG9SR0IoaCwgcywgdik7XG4gIHJldHVybiBSR0JUb0hleChyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IGhleCBjb2xvciBzdHJpbmcgaW50byBIU1YgXFw8MCwgMVxcPi5cclxuICpcclxuICogQHBhcmFtIGhleCAtIEhleCBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEhTViBjb2xvciBvYmplY3QuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGhleFRvSFNWKGhleCkge1xuICB2YXIgcmdiID0gaGV4VG9SR0IoaGV4KTtcblxuICBpZiAoIXJnYikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInXCIuY29uY2F0KGhleCwgXCInIGlzIG5vdCBhIHZhbGlkIGNvbG9yLlwiKSk7XG4gIH1cblxuICByZXR1cm4gUkdCVG9IU1YocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59XG4vKipcclxuICogVmFsaWRhdGUgaGV4IGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIGhleCAtIFVua25vd24gc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gYSBjb2xvci5cclxuICpcclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRIZXgoaGV4KSB7XG4gIHZhciBpc09rID0gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoaGV4KTtcbiAgcmV0dXJuIGlzT2s7XG59XG4vKipcclxuICogVmFsaWRhdGUgUkdCIGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHJnYiAtIFVua25vd24gc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gYSBjb2xvci5cclxuICpcclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRSR0IocmdiKSB7XG4gIHJldHVybiByZ2JSRS50ZXN0KHJnYik7XG59XG4vKipcclxuICogVmFsaWRhdGUgUkdCQSBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSByZ2JhIC0gVW5rbm93biBzdHJpbmcgdGhhdCBtYXkgY29udGFpbiBhIGNvbG9yLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZFJHQkEocmdiYSkge1xuICByZXR1cm4gcmdiYVJFLnRlc3QocmdiYSk7XG59XG4vKipcclxuICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdC5cclxuICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWZlcmVuY2VPYmplY3QgLSBUaGUgb3JpZ2luYWwgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgRWxlbWVudCBpZiB0aGUgcmVmZXJlbmNlT2JqZWN0IGlzIGFuIEVsZW1lbnQsIG9yIGEgbmV3IG9iamVjdCBpbmhlcml0aW5nIGZyb20gdGhlIHJlZmVyZW5jZU9iamVjdC5cclxuICovXG5cblxuZnVuY3Rpb24gYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdCkge1xuICBpZiAocmVmZXJlbmNlT2JqZWN0ID09PSBudWxsIHx8IF90eXBlb2ZfMShyZWZlcmVuY2VPYmplY3QpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocmVmZXJlbmNlT2JqZWN0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIC8vIEF2b2lkIGJyaWRnaW5nIERPTSBvYmplY3RzXG4gICAgcmV0dXJuIHJlZmVyZW5jZU9iamVjdDtcbiAgfVxuXG4gIHZhciBvYmplY3RUbyA9IGNyZWF0ZSQyKHJlZmVyZW5jZU9iamVjdCk7XG5cbiAgZm9yICh2YXIgaSBpbiByZWZlcmVuY2VPYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZmVyZW5jZU9iamVjdCwgaSkpIHtcbiAgICAgIGlmIChfdHlwZW9mXzEocmVmZXJlbmNlT2JqZWN0W2ldKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG9iamVjdFRvW2ldID0gYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdFRvO1xufVxuLyoqXHJcbiAqIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIG9wdGlvbnMgb2Ygc3Vib2JqZWN0cyBpbiB0aGUgb3B0aW9ucyBvYmplY3QuXHJcbiAqXHJcbiAqIEEgcmVxdWlyZW1lbnQgb2YgdGhlc2Ugc3Vib2JqZWN0cyBpcyB0aGF0IHRoZXkgaGF2ZSBhbiAnZW5hYmxlZCcgZWxlbWVudFxyXG4gKiB3aGljaCBpcyBvcHRpb25hbCBmb3IgdGhlIHVzZXIgYnV0IG1hbmRhdG9yeSBmb3IgdGhlIHByb2dyYW0uXHJcbiAqXHJcbiAqIFRoZSBhZGRlZCB2YWx1ZSBoZXJlIG9mIHRoZSBtZXJnZSBpcyB0aGF0IG9wdGlvbiAnZW5hYmxlZCcgaXMgc2V0IGFzIHJlcXVpcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWVyZ2VUYXJnZXQgLSBFaXRoZXIgdGhpcy5vcHRpb25zIG9yIHRoZSBvcHRpb25zIHVzZWQgZm9yIHRoZSBncm91cHMuXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cclxuICogQHBhcmFtIG9wdGlvbiAtIE9wdGlvbiBrZXkgaW4gdGhlIG9wdGlvbnMgYXJndW1lbnQuXHJcbiAqIEBwYXJhbSBnbG9iYWxPcHRpb25zIC0gR2xvYmFsIG9wdGlvbnMsIHBhc3NlZCBpbiB0byBkZXRlcm1pbmUgdmFsdWUgb2Ygb3B0aW9uICdlbmFibGVkJy5cclxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG1lcmdlVGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pIHtcbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gIC8vIExvY2FsIGhlbHBlcnNcbiAgdmFyIGlzUHJlc2VudCA9IGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgX3R5cGVvZl8xKG9iaikgPT09IFwib2JqZWN0XCI7XG4gIH07IC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDQ5MTI4Ny8xMjIzNTMxXG5cblxuICB2YXIgaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgZm9yICh2YXIgeCBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCB4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07IC8vIEd1YXJkc1xuXG5cbiAgaWYgKCFpc09iamVjdChtZXJnZVRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbWVyZ2VUYXJnZXQgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH1cblxuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH1cblxuICBpZiAoIWlzUHJlc2VudChvcHRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG9wdGlvbiBtdXN0IGhhdmUgYSB2YWx1ZVwiKTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3QoZ2xvYmFsT3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgZ2xvYmFsT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgfSAvL1xuICAvLyBBY3R1YWwgbWVyZ2Ugcm91dGluZSwgc2VwYXJhdGVkIGZyb20gbWFpbiBsb2dpY1xuICAvLyBPbmx5IGEgc2luZ2xlIGxldmVsIG9mIG9wdGlvbnMgaXMgbWVyZ2VkLiBEZWVwZXIgbGV2ZWxzIGFyZSByZWYnZC4gVGhpcyBtYXkgYWN0dWFsbHkgYmUgYW4gaXNzdWUuXG4gIC8vXG5cblxuICB2YXIgZG9NZXJnZSA9IGZ1bmN0aW9uIGRvTWVyZ2UodGFyZ2V0LCBvcHRpb25zLCBvcHRpb24pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldFtvcHRpb25dKSkge1xuICAgICAgdGFyZ2V0W29wdGlvbl0gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgc3JjID0gb3B0aW9uc1tvcHRpb25dO1xuICAgIHZhciBkc3QgPSB0YXJnZXRbb3B0aW9uXTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gc3JjKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgcHJvcCkpIHtcbiAgICAgICAgZHN0W3Byb3BdID0gc3JjW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gTG9jYWwgaW5pdGlhbGl6YXRpb25cblxuXG4gIHZhciBzcmNPcHRpb24gPSBvcHRpb25zW29wdGlvbl07XG4gIHZhciBnbG9iYWxQYXNzZWQgPSBpc09iamVjdChnbG9iYWxPcHRpb25zKSAmJiAhaXNFbXB0eShnbG9iYWxPcHRpb25zKTtcbiAgdmFyIGdsb2JhbE9wdGlvbiA9IGdsb2JhbFBhc3NlZCA/IGdsb2JhbE9wdGlvbnNbb3B0aW9uXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGdsb2JhbEVuYWJsZWQgPSBnbG9iYWxPcHRpb24gPyBnbG9iYWxPcHRpb24uZW5hYmxlZCA6IHVuZGVmaW5lZDsgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTWFpbiByb3V0aW5lXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgaWYgKHNyY09wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvXG4gIH1cblxuICBpZiAodHlwZW9mIHNyY09wdGlvbiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBpZiAoIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dID0ge307XG4gICAgfVxuXG4gICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gc3JjT3B0aW9uO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzcmNPcHRpb24gPT09IG51bGwgJiYgIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIGV4cGxpY2l0IGNvcHkgZnJvbSBnbG9iYWxzXG4gICAgaWYgKGlzUHJlc2VudChnbG9iYWxPcHRpb24pKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dID0gY3JlYXRlJDIoZ2xvYmFsT3B0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvXG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc09iamVjdChzcmNPcHRpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vXG4gIC8vIEVuc3VyZSB0aGF0ICdlbmFibGVkJyBpcyBwcm9wZXJseSBzZXQuIEl0IGlzIHJlcXVpcmVkIGludGVybmFsbHlcbiAgLy8gTm90ZSB0aGF0IHRoZSB2YWx1ZSBmcm9tIG9wdGlvbnMgd2lsbCBhbHdheXMgb3ZlcndyaXRlIHRoZSBleGlzdGluZyB2YWx1ZVxuICAvL1xuXG5cbiAgdmFyIGVuYWJsZWQgPSB0cnVlOyAvLyBkZWZhdWx0IHZhbHVlXG5cbiAgaWYgKHNyY09wdGlvbi5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmFibGVkID0gc3JjT3B0aW9uLmVuYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGFrZSBmcm9tIGdsb2JhbHMsIGlmIHByZXNlbnRcbiAgICBpZiAoZ2xvYmFsRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmFibGVkID0gZ2xvYmFsT3B0aW9uLmVuYWJsZWQ7XG4gICAgfVxuICB9XG5cbiAgZG9NZXJnZShtZXJnZVRhcmdldCwgb3B0aW9ucywgb3B0aW9uKTtcbiAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gZW5hYmxlZDtcbn1cbi8qXHJcbiAqIEVhc2luZyBGdW5jdGlvbnMuXHJcbiAqIE9ubHkgY29uc2lkZXJpbmcgdGhlIHQgdmFsdWUgZm9yIHRoZSByYW5nZSBbMCwgMV0gPT4gWzAsIDFdLlxyXG4gKlxyXG4gKiBJbnNwaXJhdGlvbjogZnJvbSBodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cclxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcclxuICovXG5cblxudmFyIGVhc2luZ0Z1bmN0aW9ucyA9IHtcbiAgLyoqXHJcbiAgICogUHJvdmlkZXMgbm8gZWFzaW5nIGFuZCBubyBhY2NlbGVyYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIGZyb20gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluUXVhZDogZnVuY3Rpb24gZWFzZUluUXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlY2VsZXJhdGUgdG8gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqICgyIC0gdCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1YWQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSBmcm9tIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbkN1YmljOiBmdW5jdGlvbiBlYXNlSW5DdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gZWFzZU91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWModCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIGZyb20gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gZWFzZU91dFF1YXJ0KHQpIHtcbiAgICByZXR1cm4gMSAtIC0tdCAqIHQgKiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAtLXQgKiB0ICogdCAqIHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSBmcm9tIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJblF1aW50OiBmdW5jdGlvbiBlYXNlSW5RdWludCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlY2VsZXJhdGUgdG8gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZU91dFF1aW50OiBmdW5jdGlvbiBlYXNlT3V0UXVpbnQodCkge1xuICAgIHJldHVybiAxICsgLS10ICogdCAqIHQgKiB0ICogdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICB9XG59O1xuLy8gSXQgd29ya3Mgb25seSBmb3Igc2luZ2xlIHByb3BlcnR5IG9iamVjdHMsXG4vLyBvdGhlcndpc2UgaXQgY29tYmluZXMgYWxsIG9mIHRoZSB0eXBlcyBpbiBhIHVuaW9uLlxuLy8gZXhwb3J0IGZ1bmN0aW9uIHRvcE1vc3Q8SzEgZXh0ZW5kcyBzdHJpbmcsIFYxPiAoXG4vLyAgIHBpbGU6IFJlY29yZDxLMSwgdW5kZWZpbmVkIHwgVjE+W10sXG4vLyAgIGFjY2Vzc29yczogSzEgfCBbSzFdXG4vLyApOiB1bmRlZmluZWQgfCBWMVxuLy8gZXhwb3J0IGZ1bmN0aW9uIHRvcE1vc3Q8SzEgZXh0ZW5kcyBzdHJpbmcsIEsyIGV4dGVuZHMgc3RyaW5nLCBWMSwgVjI+IChcbi8vICAgcGlsZTogUmVjb3JkPEsxLCB1bmRlZmluZWQgfCBWMSB8IFJlY29yZDxLMiwgdW5kZWZpbmVkIHwgVjI+PltdLFxuLy8gICBhY2Nlc3NvcnM6IFtLMSwgSzJdXG4vLyApOiB1bmRlZmluZWQgfCBWMSB8IFYyXG4vLyBleHBvcnQgZnVuY3Rpb24gdG9wTW9zdDxLMSBleHRlbmRzIHN0cmluZywgSzIgZXh0ZW5kcyBzdHJpbmcsIEszIGV4dGVuZHMgc3RyaW5nLCBWMSwgVjIsIFYzPiAoXG4vLyAgIHBpbGU6IFJlY29yZDxLMSwgdW5kZWZpbmVkIHwgVjEgfCBSZWNvcmQ8SzIsIHVuZGVmaW5lZCB8IFYyIHwgUmVjb3JkPEszLCB1bmRlZmluZWQgfCBWMz4+PltdLFxuLy8gICBhY2Nlc3NvcnM6IFtLMSwgSzIsIEszXVxuLy8gKTogdW5kZWZpbmVkIHwgVjEgfCBWMiB8IFYzXG5cbi8qKlxyXG4gKiBHZXQgdGhlIHRvcCBtb3N0IHByb3BlcnR5IHZhbHVlIGZyb20gYSBwaWxlIG9mIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBwaWxlIC0gQXJyYXkgb2Ygb2JqZWN0cywgbm8gcmVxdWlyZWQgZm9ybWF0LlxyXG4gKiBAcGFyYW0gYWNjZXNzb3JzIC0gQXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAqIEZvciBleGFtcGxlIGBvYmplY3RbJ2ZvbyddWydiYXInXWAg4oaSIGBbJ2ZvbycsICdiYXInXWAuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB3aXRoIGdpdmVuIGFjY2Vzc29ycyBwYXRoIGZyb20gdGhlIGZpcnN0IHBpbGUgaXRlbSB3aGVyZSBpdCdzIG5vdCB1bmRlZmluZWQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvcE1vc3QocGlsZSwgYWNjZXNzb3JzKSB7XG4gIHZhciBjYW5kaWRhdGU7XG5cbiAgaWYgKCFpc0FycmF5JDUoYWNjZXNzb3JzKSkge1xuICAgIGFjY2Vzc29ycyA9IFthY2Nlc3NvcnNdO1xuICB9XG5cbiAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwaWxlKSxcbiAgICAgIF9zdGVwMjtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbWVtYmVyID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgIGNhbmRpZGF0ZSA9IG1lbWJlclthY2Nlc3NvcnNbMF1dO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYWNjZXNzb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlW2FjY2Vzc29yc1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMi5mKCk7XG4gIH1cblxuICByZXR1cm4gY2FuZGlkYXRlO1xufVxuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCQzID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc3BsaWNlJyk7XG52YXIgVVNFU19UT19MRU5HVEgkNSA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdzcGxpY2UnLCB7XG4gIEFDQ0VTU09SUzogdHJ1ZSxcbiAgMDogMCxcbiAgMTogMlxufSk7XG52YXIgbWF4JDIgPSBNYXRoLm1heDtcbnZhciBtaW4kMiA9IE1hdGgubWluO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIkMSA9IDB4MUZGRkZGRkZGRkZGRkY7XG52YXIgTUFYSU1VTV9BTExPV0VEX0xFTkdUSF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIGV4Y2VlZGVkJzsgLy8gYEFycmF5LnByb3RvdHlwZS5zcGxpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNwbGljZVxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQkMyB8fCAhVVNFU19UT19MRU5HVEgkNVxufSwge1xuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnRcbiAgLyogLCAuLi5pdGVtcyAqL1xuICApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGFjdHVhbFN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpbnNlcnRDb3VudCwgYWN0dWFsRGVsZXRlQ291bnQsIEEsIGssIGZyb20sIHRvO1xuXG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMCkge1xuICAgICAgaW5zZXJ0Q291bnQgPSBhY3R1YWxEZWxldGVDb3VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGluc2VydENvdW50ID0gMDtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbGVuIC0gYWN0dWFsU3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc2VydENvdW50ID0gYXJndW1lbnRzTGVuZ3RoIC0gMjtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbWluJDIobWF4JDIodG9JbnRlZ2VyKGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAobGVuICsgaW5zZXJ0Q291bnQgLSBhY3R1YWxEZWxldGVDb3VudCA+IE1BWF9TQUZFX0lOVEVHRVIkMSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9MRU5HVEhfRVhDRUVERUQpO1xuICAgIH1cblxuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgYWN0dWFsRGVsZXRlQ291bnQpO1xuXG4gICAgZm9yIChrID0gMDsgayA8IGFjdHVhbERlbGV0ZUNvdW50OyBrKyspIHtcbiAgICAgIGZyb20gPSBhY3R1YWxTdGFydCArIGs7XG4gICAgICBpZiAoZnJvbSBpbiBPKSBjcmVhdGVQcm9wZXJ0eShBLCBrLCBPW2Zyb21dKTtcbiAgICB9XG5cbiAgICBBLmxlbmd0aCA9IGFjdHVhbERlbGV0ZUNvdW50O1xuXG4gICAgaWYgKGluc2VydENvdW50IDwgYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGFjdHVhbFN0YXJ0OyBrIDwgbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudDtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO2Vsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGsgPSBsZW47IGsgPiBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50OyBrLS0pIGRlbGV0ZSBPW2sgLSAxXTtcbiAgICB9IGVsc2UgaWYgKGluc2VydENvdW50ID4gYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrID4gYWN0dWFsU3RhcnQ7IGstLSkge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50IC0gMTtcbiAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQgLSAxO1xuICAgICAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07ZWxzZSBkZWxldGUgT1t0b107XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrID0gMDsgayA8IGluc2VydENvdW50OyBrKyspIHtcbiAgICAgIE9bayArIGFjdHVhbFN0YXJ0XSA9IGFyZ3VtZW50c1trICsgMl07XG4gICAgfVxuXG4gICAgTy5sZW5ndGggPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50O1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxudmFyIHNwbGljZSA9IGVudHJ5VmlydHVhbCgnQXJyYXknKS5zcGxpY2U7XG5cbnZhciBBcnJheVByb3RvdHlwZSQ3ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc3BsaWNlXzEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNwbGljZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ3IHx8IGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ3LnNwbGljZSA/IHNwbGljZSA6IG93bjtcbn07XG5cbnZhciBzcGxpY2UkMSA9IHNwbGljZV8xO1xuXG52YXIgc3BsaWNlJDIgPSBzcGxpY2UkMTtcblxudmFyICRpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMuaW5jbHVkZXM7XG52YXIgVVNFU19UT19MRU5HVEgkNiA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdpbmRleE9mJywge1xuICBBQ0NFU1NPUlM6IHRydWUsXG4gIDE6IDBcbn0pOyAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuXG5fZXhwb3J0KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhVVNFU19UT19MRU5HVEgkNlxufSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWxcbiAgLyogLCBmcm9tSW5kZXggPSAwICovXG4gICkge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7IC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5cbnZhciBpbmNsdWRlcyA9IGVudHJ5VmlydHVhbCgnQXJyYXknKS5pbmNsdWRlcztcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpOyAvLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNyZWdleHBcblxudmFyIGlzUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2ZSYXcoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cbnZhciBub3RBUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ2V4cChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH1cblxuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgTUFUQ0gkMSA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxudmFyIGNvcnJlY3RJc1JlZ2V4cExvZ2ljID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHZhciByZWdleHAgPSAvLi87XG5cbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSCQxXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzXG5cblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ1N0cmluZycsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdleHBMb2dpYygnaW5jbHVkZXMnKVxufSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nXG4gIC8qICwgcG9zaXRpb24gPSAwICovXG4gICkge1xuICAgIHJldHVybiAhIX5TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSkuaW5kZXhPZihub3RBUmVnZXhwKHNlYXJjaFN0cmluZyksIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBpbmNsdWRlcyQxID0gZW50cnlWaXJ0dWFsKCdTdHJpbmcnKS5pbmNsdWRlcztcblxudmFyIEFycmF5UHJvdG90eXBlJDggPSBBcnJheS5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcblxudmFyIGluY2x1ZGVzJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmluY2x1ZGVzO1xuICBpZiAoaXQgPT09IEFycmF5UHJvdG90eXBlJDggfHwgaXQgaW5zdGFuY2VvZiBBcnJheSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDguaW5jbHVkZXMpIHJldHVybiBpbmNsdWRlcztcblxuICBpZiAodHlwZW9mIGl0ID09PSAnc3RyaW5nJyB8fCBpdCA9PT0gU3RyaW5nUHJvdG90eXBlIHx8IGl0IGluc3RhbmNlb2YgU3RyaW5nICYmIG93biA9PT0gU3RyaW5nUHJvdG90eXBlLmluY2x1ZGVzKSB7XG4gICAgcmV0dXJuIGluY2x1ZGVzJDE7XG4gIH1cblxuICByZXR1cm4gb3duO1xufTtcblxudmFyIGluY2x1ZGVzJDMgPSBpbmNsdWRlcyQyO1xuXG52YXIgaW5jbHVkZXMkNCA9IGluY2x1ZGVzJDM7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cblxuLyoqXG4gKiBQYXJzZSBhIHRleHQgc291cmNlIGNvbnRhaW5pbmcgZGF0YSBpbiBET1QgbGFuZ3VhZ2UgaW50byBhIEpTT04gb2JqZWN0LlxuICogVGhlIG9iamVjdCBjb250YWlucyB0d28gbGlzdHM6IG9uZSB3aXRoIG5vZGVzIGFuZCBvbmUgd2l0aCBlZGdlcy5cbiAqXG4gKiBET1QgbGFuZ3VhZ2UgcmVmZXJlbmNlOiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9kb2MvaW5mby9sYW5nLmh0bWxcbiAqXG4gKiBET1QgbGFuZ3VhZ2UgYXR0cmlidXRlczogaHR0cDovL2dyYXBodml6Lm9yZy9jb250ZW50L2F0dHJzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgICAgIFRleHQgY29udGFpbmluZyBhIGdyYXBoIGluIERPVC1ub3RhdGlvblxuICogQHJldHVybnMge29iamVjdH0gZ3JhcGggICBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0W119IG5vZGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdFtdfSBlZGdlc1xuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRPRE9cbiAqID09PT1cbiAqXG4gKiBGb3IgbGFiZWwgaGFuZGxpbmcsIHRoaXMgaXMgYW4gaW5jb21wbGV0ZSBpbXBsZW1lbnRhdGlvbi4gRnJvbSBkb2NzIChxdW90ZSAjMzAxNSk6XG4gKlxuICogPiB0aGUgZXNjYXBlIHNlcXVlbmNlcyBcIlxcblwiLCBcIlxcbFwiIGFuZCBcIlxcclwiIGRpdmlkZSB0aGUgbGFiZWwgaW50byBsaW5lcywgY2VudGVyZWQsXG4gKiA+IGxlZnQtanVzdGlmaWVkLCBhbmQgcmlnaHQtanVzdGlmaWVkLCByZXNwZWN0aXZlbHkuXG4gKlxuICogU291cmNlOiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9jb250ZW50L2F0dHJzI2tlc2NTdHJpbmdcbiAqXG4gKiA+IEFzIGFub3RoZXIgYWlkIGZvciByZWFkYWJpbGl0eSwgZG90IGFsbG93cyBkb3VibGUtcXVvdGVkIHN0cmluZ3MgdG8gc3BhbiBtdWx0aXBsZSBwaHlzaWNhbFxuICogPiBsaW5lcyB1c2luZyB0aGUgc3RhbmRhcmQgQyBjb252ZW50aW9uIG9mIGEgYmFja3NsYXNoIGltbWVkaWF0ZWx5IHByZWNlZGluZyBhIG5ld2xpbmVcbiAqID4gY2hhcmFjdGVyXG4gKiA+IEluIGFkZGl0aW9uLCBkb3VibGUtcXVvdGVkIHN0cmluZ3MgY2FuIGJlIGNvbmNhdGVuYXRlZCB1c2luZyBhICcrJyBvcGVyYXRvci5cbiAqID4gQXMgSFRNTCBzdHJpbmdzIGNhbiBjb250YWluIG5ld2xpbmUgY2hhcmFjdGVycywgd2hpY2ggYXJlIHVzZWQgc29sZWx5IGZvciBmb3JtYXR0aW5nLFxuICogPiB0aGUgbGFuZ3VhZ2UgZG9lcyBub3QgYWxsb3cgZXNjYXBlZCBuZXdsaW5lcyBvciBjb25jYXRlbmF0aW9uIG9wZXJhdG9ycyB0byBiZSB1c2VkXG4gKiA+IHdpdGhpbiB0aGVtLlxuICpcbiAqIC0gQ3VycmVudGx5LCBvbmx5ICdcXFxcbicgaXMgaGFuZGxlZFxuICogLSBOb3RlIHRoYXQgdGV4dCBleHBsaWNpdGx5IHNheXMgJ2xhYmVscyc7IHRoZSBkb3QgcGFyc2VyIGN1cnJlbnRseSBoYW5kbGVzIGVzY2FwZVxuICogICBzZXF1ZW5jZXMgaW4gKiphbGwqKiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBwYXJzZURPVChkYXRhKSB7XG4gIGRvdCA9IGRhdGE7XG4gIHJldHVybiBwYXJzZUdyYXBoKCk7XG59IC8vIG1hcHBpbmcgb2YgYXR0cmlidXRlcyBmcm9tIERPVCAodGhlIGtleXMpIHRvIHZpcy5qcyAodGhlIHZhbHVlcylcblxudmFyIE5PREVfQVRUUl9NQVBQSU5HID0ge1xuICBmb250c2l6ZTogXCJmb250LnNpemVcIixcbiAgZm9udGNvbG9yOiBcImZvbnQuY29sb3JcIixcbiAgbGFiZWxmb250Y29sb3I6IFwiZm9udC5jb2xvclwiLFxuICBmb250bmFtZTogXCJmb250LmZhY2VcIixcbiAgY29sb3I6IFtcImNvbG9yLmJvcmRlclwiLCBcImNvbG9yLmJhY2tncm91bmRcIl0sXG4gIGZpbGxjb2xvcjogXCJjb2xvci5iYWNrZ3JvdW5kXCIsXG4gIHRvb2x0aXA6IFwidGl0bGVcIixcbiAgbGFiZWx0b29sdGlwOiBcInRpdGxlXCJcbn07XG5cbnZhciBFREdFX0FUVFJfTUFQUElORyA9IGNyZWF0ZSQyKE5PREVfQVRUUl9NQVBQSU5HKTtcblxuRURHRV9BVFRSX01BUFBJTkcuY29sb3IgPSBcImNvbG9yLmNvbG9yXCI7XG5FREdFX0FUVFJfTUFQUElORy5zdHlsZSA9IFwiZGFzaGVzXCI7IC8vIHRva2VuIHR5cGVzIGVudW1lcmF0aW9uXG5cbnZhciBUT0tFTlRZUEUgPSB7XG4gIE5VTEw6IDAsXG4gIERFTElNSVRFUjogMSxcbiAgSURFTlRJRklFUjogMixcbiAgVU5LTk9XTjogM1xufTsgLy8gbWFwIHdpdGggYWxsIGRlbGltaXRlcnNcblxudmFyIERFTElNSVRFUlMgPSB7XG4gIFwie1wiOiB0cnVlLFxuICBcIn1cIjogdHJ1ZSxcbiAgXCJbXCI6IHRydWUsXG4gIFwiXVwiOiB0cnVlLFxuICBcIjtcIjogdHJ1ZSxcbiAgXCI9XCI6IHRydWUsXG4gIFwiLFwiOiB0cnVlLFxuICBcIi0+XCI6IHRydWUsXG4gIFwiLS1cIjogdHJ1ZVxufTtcbnZhciBkb3QgPSBcIlwiOyAvLyBjdXJyZW50IGRvdCBmaWxlXG5cbnZhciBpbmRleCA9IDA7IC8vIGN1cnJlbnQgaW5kZXggaW4gZG90IGZpbGVcblxudmFyIGMgPSBcIlwiOyAvLyBjdXJyZW50IHRva2VuIGNoYXJhY3RlciBpbiBleHByXG5cbnZhciB0b2tlbiA9IFwiXCI7IC8vIGN1cnJlbnQgdG9rZW5cblxudmFyIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5OVUxMOyAvLyB0eXBlIG9mIHRoZSB0b2tlblxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgY2hhcmFjdGVyIGZyb20gdGhlIGRvdCBmaWxlLlxuICogVGhlIGNoYXJhY3RlciBpcyBzdG9yZWQgaW50byB0aGUgY2hhciBjLiBJZiB0aGUgZW5kIG9mIHRoZSBkb3QgZmlsZSBpc1xuICogcmVhY2hlZCwgdGhlIGZ1bmN0aW9uIHB1dHMgYW4gZW1wdHkgc3RyaW5nIGluIGMuXG4gKi9cblxuZnVuY3Rpb24gZmlyc3QoKSB7XG4gIGluZGV4ID0gMDtcbiAgYyA9IGRvdC5jaGFyQXQoMCk7XG59XG4vKipcbiAqIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGRvdCBmaWxlIGlzXG4gKiByZWFjaGVkLCB0aGUgZnVuY3Rpb24gcHV0cyBhbiBlbXB0eSBzdHJpbmcgaW4gYy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG5leHQoKSB7XG4gIGluZGV4Kys7XG4gIGMgPSBkb3QuY2hhckF0KGluZGV4KTtcbn1cbi8qKlxuICogUHJldmlldyB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZG90IGZpbGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gY05leHRcbiAqL1xuXG5cbmZ1bmN0aW9uIG5leHRQcmV2aWV3KCkge1xuICByZXR1cm4gZG90LmNoYXJBdChpbmRleCArIDEpO1xufVxuXG52YXIgcmVnZXhBbHBoYU51bWVyaWMgPSAvW2EtekEtWl8wLTkuOiNdLztcbi8qKlxuICogVGVzdCB3aGV0aGVyIGdpdmVuIGNoYXJhY3RlciBpcyBhbHBoYWJldGljIG9yIG51bWVyaWNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY1xuICogQHJldHVybnMge2Jvb2xlYW59IGlzQWxwaGFOdW1lcmljXG4gKi9cblxuZnVuY3Rpb24gaXNBbHBoYU51bWVyaWMoYykge1xuICByZXR1cm4gcmVnZXhBbHBoYU51bWVyaWMudGVzdChjKTtcbn1cbi8qKlxuICogTWVyZ2UgYWxsIG9wdGlvbnMgb2Ygb2JqZWN0IGIgaW50byBvYmplY3QgYlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhXG4gKiBAcGFyYW0ge29iamVjdH0gYlxuICogQHJldHVybnMge29iamVjdH0gYVxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICBpZiAoIWEpIHtcbiAgICBhID0ge307XG4gIH1cblxuICBpZiAoYikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gYikge1xuICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgYVtuYW1lXSA9IGJbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGE7XG59XG4vKipcbiAqIFNldCBhIHZhbHVlIGluIGFuIG9iamVjdCwgd2hlcmUgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBuYW1lIGNhbiBiZSBhXG4gKiBwYXRoIHdpdGggbmVzdGVkIHBhcmFtZXRlcnMuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICB2YXIgb2JqID0ge2E6IDJ9O1xuICogICAgIHNldFZhbHVlKG9iaiwgJ2IuYycsIDMpOyAgICAgLy8gb2JqID0ge2E6IDIsIGI6IHtjOiAzfX1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAgQSBwYXJhbWV0ZXIgbmFtZSBvciBkb3Qtc2VwYXJhdGVkIHBhcmFtZXRlciBwYXRoLFxuICogICAgICAgICAgICAgICAgICAgICAgbGlrZSBcImNvbG9yLmhpZ2hsaWdodC5ib3JkZXJcIi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFZhbHVlKG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgdmFyIG8gPSBvYmo7XG5cbiAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IGtleXMuc2hpZnQoKTtcblxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgLy8gdGhpcyBpc24ndCB0aGUgZW5kIHBvaW50XG4gICAgICBpZiAoIW9ba2V5XSkge1xuICAgICAgICBvW2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgbyA9IG9ba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kIHBvaW50XG4gICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQWRkIGEgbm9kZSB0byBhIGdyYXBoIG9iamVjdC4gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5vZGUgd2l0aFxuICogdGhlIHNhbWUgaWQsIHRoZWlyIGF0dHJpYnV0ZXMgd2lsbCBiZSBtZXJnZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICovXG5cblxuZnVuY3Rpb24gYWRkTm9kZShncmFwaCwgbm9kZSkge1xuICB2YXIgaSwgbGVuO1xuICB2YXIgY3VycmVudCA9IG51bGw7IC8vIGZpbmQgcm9vdCBncmFwaCAoaW4gY2FzZSBvZiBzdWJncmFwaClcblxuICB2YXIgZ3JhcGhzID0gW2dyYXBoXTsgLy8gbGlzdCB3aXRoIGFsbCBncmFwaHMgZnJvbSBjdXJyZW50IGdyYXBoIHRvIHJvb3QgZ3JhcGhcblxuICB2YXIgcm9vdCA9IGdyYXBoO1xuXG4gIHdoaWxlIChyb290LnBhcmVudCkge1xuICAgIGdyYXBocy5wdXNoKHJvb3QucGFyZW50KTtcbiAgICByb290ID0gcm9vdC5wYXJlbnQ7XG4gIH0gLy8gZmluZCBleGlzdGluZyBub2RlIChhdCByb290IGxldmVsKSBieSBpdHMgaWRcblxuXG4gIGlmIChyb290Lm5vZGVzKSB7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcm9vdC5ub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG5vZGUuaWQgPT09IHJvb3Qubm9kZXNbaV0uaWQpIHtcbiAgICAgICAgY3VycmVudCA9IHJvb3Qubm9kZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghY3VycmVudCkge1xuICAgIC8vIHRoaXMgaXMgYSBuZXcgbm9kZVxuICAgIGN1cnJlbnQgPSB7XG4gICAgICBpZDogbm9kZS5pZFxuICAgIH07XG5cbiAgICBpZiAoZ3JhcGgubm9kZSkge1xuICAgICAgLy8gY2xvbmUgZGVmYXVsdCBhdHRyaWJ1dGVzXG4gICAgICBjdXJyZW50LmF0dHIgPSBtZXJnZShjdXJyZW50LmF0dHIsIGdyYXBoLm5vZGUpO1xuICAgIH1cbiAgfSAvLyBhZGQgbm9kZSB0byB0aGlzIChzdWIpZ3JhcGggYW5kIGFsbCBpdHMgcGFyZW50IGdyYXBoc1xuXG5cbiAgZm9yIChpID0gZ3JhcGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIF9jb250ZXh0O1xuXG4gICAgdmFyIGcgPSBncmFwaHNbaV07XG5cbiAgICBpZiAoIWcubm9kZXMpIHtcbiAgICAgIGcubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXhPZiQzKF9jb250ZXh0ID0gZy5ub2RlcykuY2FsbChfY29udGV4dCwgY3VycmVudCkgPT09IC0xKSB7XG4gICAgICBnLm5vZGVzLnB1c2goY3VycmVudCk7XG4gICAgfVxuICB9IC8vIG1lcmdlIGF0dHJpYnV0ZXNcblxuXG4gIGlmIChub2RlLmF0dHIpIHtcbiAgICBjdXJyZW50LmF0dHIgPSBtZXJnZShjdXJyZW50LmF0dHIsIG5vZGUuYXR0cik7XG4gIH1cbn1cbi8qKlxuICogQWRkIGFuIGVkZ2UgdG8gYSBncmFwaCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBlZGdlXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRFZGdlKGdyYXBoLCBlZGdlKSB7XG4gIGlmICghZ3JhcGguZWRnZXMpIHtcbiAgICBncmFwaC5lZGdlcyA9IFtdO1xuICB9XG5cbiAgZ3JhcGguZWRnZXMucHVzaChlZGdlKTtcblxuICBpZiAoZ3JhcGguZWRnZSkge1xuICAgIHZhciBhdHRyID0gbWVyZ2Uoe30sIGdyYXBoLmVkZ2UpOyAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcblxuICAgIGVkZ2UuYXR0ciA9IG1lcmdlKGF0dHIsIGVkZ2UuYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gZWRnZSB0byBhIGdyYXBoIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBvYmplY3R9IGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgb2JqZWN0fSB0b1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbH0gYXR0clxuICogQHJldHVybnMge29iamVjdH0gZWRnZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRWRnZShncmFwaCwgZnJvbSwgdG8sIHR5cGUsIGF0dHIpIHtcbiAgdmFyIGVkZ2UgPSB7XG4gICAgZnJvbTogZnJvbSxcbiAgICB0bzogdG8sXG4gICAgdHlwZTogdHlwZVxuICB9O1xuXG4gIGlmIChncmFwaC5lZGdlKSB7XG4gICAgZWRnZS5hdHRyID0gbWVyZ2Uoe30sIGdyYXBoLmVkZ2UpOyAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgfVxuXG4gIGVkZ2UuYXR0ciA9IG1lcmdlKGVkZ2UuYXR0ciB8fCB7fSwgYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcbiAgLy8gTW92ZSBhcnJvd3MgYXR0cmlidXRlIGZyb20gYXR0ciB0byBlZGdlIHRlbXBvcmFsbHkgY3JlYXRlZCBpblxuICAvLyBwYXJzZUF0dHJpYnV0ZUxpc3QoKS5cblxuICBpZiAoYXR0ciAhPSBudWxsKSB7XG4gICAgaWYgKGF0dHIuaGFzT3duUHJvcGVydHkoXCJhcnJvd3NcIikgJiYgYXR0cltcImFycm93c1wiXSAhPSBudWxsKSB7XG4gICAgICBlZGdlW1wiYXJyb3dzXCJdID0ge1xuICAgICAgICB0bzoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgdHlwZTogYXR0ci5hcnJvd3MudHlwZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYXR0cltcImFycm93c1wiXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVkZ2U7XG59XG4vKipcbiAqIEdldCBuZXh0IHRva2VuIGluIHRoZSBjdXJyZW50IGRvdCBmaWxlLlxuICogVGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIGFyZSBhdmFpbGFibGUgYXMgdG9rZW4gYW5kIHRva2VuVHlwZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VG9rZW4oKSB7XG4gIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5OVUxMO1xuICB0b2tlbiA9IFwiXCI7IC8vIHNraXAgb3ZlciB3aGl0ZXNwYWNlc1xuXG4gIHdoaWxlIChjID09PSBcIiBcIiB8fCBjID09PSBcIlxcdFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHJcIikge1xuICAgIC8vIHNwYWNlLCB0YWIsIGVudGVyXG4gICAgbmV4dCgpO1xuICB9XG5cbiAgZG8ge1xuICAgIHZhciBpc0NvbW1lbnQgPSBmYWxzZTsgLy8gc2tpcCBjb21tZW50XG5cbiAgICBpZiAoYyA9PT0gXCIjXCIpIHtcbiAgICAgIC8vIGZpbmQgdGhlIHByZXZpb3VzIG5vbi1zcGFjZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBpID0gaW5kZXggLSAxO1xuXG4gICAgICB3aGlsZSAoZG90LmNoYXJBdChpKSA9PT0gXCIgXCIgfHwgZG90LmNoYXJBdChpKSA9PT0gXCJcXHRcIikge1xuICAgICAgICBpLS07XG4gICAgICB9XG5cbiAgICAgIGlmIChkb3QuY2hhckF0KGkpID09PSBcIlxcblwiIHx8IGRvdC5jaGFyQXQoaSkgPT09IFwiXCIpIHtcbiAgICAgICAgLy8gdGhlICMgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZSwgdGhpcyBpcyBpbmRlZWQgYSBsaW5lIGNvbW1lbnRcbiAgICAgICAgd2hpbGUgKGMgIT0gXCJcIiAmJiBjICE9IFwiXFxuXCIpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0NvbW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjID09PSBcIi9cIiAmJiBuZXh0UHJldmlldygpID09PSBcIi9cIikge1xuICAgICAgLy8gc2tpcCBsaW5lIGNvbW1lbnRcbiAgICAgIHdoaWxlIChjICE9IFwiXCIgJiYgYyAhPSBcIlxcblwiKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cblxuICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gXCIvXCIgJiYgbmV4dFByZXZpZXcoKSA9PT0gXCIqXCIpIHtcbiAgICAgIC8vIHNraXAgYmxvY2sgY29tbWVudFxuICAgICAgd2hpbGUgKGMgIT0gXCJcIikge1xuICAgICAgICBpZiAoYyA9PT0gXCIqXCIgJiYgbmV4dFByZXZpZXcoKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAvLyBlbmQgb2YgYmxvY2sgY29tbWVudCBmb3VuZC4gc2tpcCB0aGVzZSBsYXN0IHR3byBjaGFyYWN0ZXJzXG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICB9IC8vIHNraXAgb3ZlciB3aGl0ZXNwYWNlc1xuXG5cbiAgICB3aGlsZSAoYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXHRcIiB8fCBjID09PSBcIlxcblwiIHx8IGMgPT09IFwiXFxyXCIpIHtcbiAgICAgIC8vIHNwYWNlLCB0YWIsIGVudGVyXG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9IHdoaWxlIChpc0NvbW1lbnQpOyAvLyBjaGVjayBmb3IgZW5kIG9mIGRvdCBmaWxlXG5cblxuICBpZiAoYyA9PT0gXCJcIikge1xuICAgIC8vIHRva2VuIGlzIHN0aWxsIGVtcHR5XG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICByZXR1cm47XG4gIH0gLy8gY2hlY2sgZm9yIGRlbGltaXRlcnMgY29uc2lzdGluZyBvZiAyIGNoYXJhY3RlcnNcblxuXG4gIHZhciBjMiA9IGMgKyBuZXh0UHJldmlldygpO1xuXG4gIGlmIChERUxJTUlURVJTW2MyXSkge1xuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgdG9rZW4gPSBjMjtcbiAgICBuZXh0KCk7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybjtcbiAgfSAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDEgY2hhcmFjdGVyXG5cblxuICBpZiAoREVMSU1JVEVSU1tjXSkge1xuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgdG9rZW4gPSBjO1xuICAgIG5leHQoKTtcbiAgICByZXR1cm47XG4gIH0gLy8gY2hlY2sgZm9yIGFuIGlkZW50aWZpZXIgKG51bWJlciBvciBzdHJpbmcpXG4gIC8vIFRPRE86IG1vcmUgcHJlY2lzZSBwYXJzaW5nIG9mIG51bWJlcnMvc3RyaW5ncyAoYW5kIHRoZSBwb3J0IHNlcGFyYXRvciAnOicpXG5cblxuICBpZiAoaXNBbHBoYU51bWVyaWMoYykgfHwgYyA9PT0gXCItXCIpIHtcbiAgICB0b2tlbiArPSBjO1xuICAgIG5leHQoKTtcblxuICAgIHdoaWxlIChpc0FscGhhTnVtZXJpYyhjKSkge1xuICAgICAgdG9rZW4gKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4gPT09IFwiZmFsc2VcIikge1xuICAgICAgdG9rZW4gPSBmYWxzZTsgLy8gY29udmVydCB0byBib29sZWFuXG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIHRva2VuID0gdHJ1ZTsgLy8gY29udmVydCB0byBib29sZWFuXG4gICAgfSBlbHNlIGlmICghaXNOYU4oTnVtYmVyKHRva2VuKSkpIHtcbiAgICAgIHRva2VuID0gTnVtYmVyKHRva2VuKTsgLy8gY29udmVydCB0byBudW1iZXJcbiAgICB9XG5cbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuSURFTlRJRklFUjtcbiAgICByZXR1cm47XG4gIH0gLy8gY2hlY2sgZm9yIGEgc3RyaW5nIGVuY2xvc2VkIGJ5IGRvdWJsZSBxdW90ZXNcblxuXG4gIGlmIChjID09PSAnXCInKSB7XG4gICAgbmV4dCgpO1xuXG4gICAgd2hpbGUgKGMgIT0gXCJcIiAmJiAoYyAhPSAnXCInIHx8IGMgPT09ICdcIicgJiYgbmV4dFByZXZpZXcoKSA9PT0gJ1wiJykpIHtcbiAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgIC8vIHNraXAgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIGlmIChjID09PSBcIlxcXFxcIiAmJiBuZXh0UHJldmlldygpID09PSBcIm5cIikge1xuICAgICAgICAvLyBIb25vciBhIG5ld2xpbmUgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIHRva2VuICs9IFwiXFxuXCI7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuICs9IGM7XG4gICAgICB9XG5cbiAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAoYyAhPSAnXCInKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignRW5kIG9mIHN0cmluZyBcIiBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIG5leHQoKTtcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuSURFTlRJRklFUjtcbiAgICByZXR1cm47XG4gIH0gLy8gc29tZXRoaW5nIHVua25vd24gaXMgZm91bmQsIHdyb25nIGNoYXJhY3RlcnMsIGEgc3ludGF4IGVycm9yXG5cblxuICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuVU5LTk9XTjtcblxuICB3aGlsZSAoYyAhPSBcIlwiKSB7XG4gICAgdG9rZW4gKz0gYztcbiAgICBuZXh0KCk7XG4gIH1cblxuICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1N5bnRheCBlcnJvciBpbiBwYXJ0IFwiJyArIGNob3AodG9rZW4sIDMwKSArICdcIicpO1xufVxuLyoqXG4gKiBQYXJzZSBhIGdyYXBoLlxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IGdyYXBoXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUdyYXBoKCkge1xuICB2YXIgZ3JhcGggPSB7fTtcbiAgZmlyc3QoKTtcbiAgZ2V0VG9rZW4oKTsgLy8gb3B0aW9uYWwgc3RyaWN0IGtleXdvcmRcblxuICBpZiAodG9rZW4gPT09IFwic3RyaWN0XCIpIHtcbiAgICBncmFwaC5zdHJpY3QgPSB0cnVlO1xuICAgIGdldFRva2VuKCk7XG4gIH0gLy8gZ3JhcGggb3IgZGlncmFwaCBrZXl3b3JkXG5cblxuICBpZiAodG9rZW4gPT09IFwiZ3JhcGhcIiB8fCB0b2tlbiA9PT0gXCJkaWdyYXBoXCIpIHtcbiAgICBncmFwaC50eXBlID0gdG9rZW47XG4gICAgZ2V0VG9rZW4oKTtcbiAgfSAvLyBvcHRpb25hbCBncmFwaCBpZFxuXG5cbiAgaWYgKHRva2VuVHlwZSA9PT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICBncmFwaC5pZCA9IHRva2VuO1xuICAgIGdldFRva2VuKCk7XG4gIH0gLy8gb3BlbiBhbmdsZSBicmFja2V0XG5cblxuICBpZiAodG9rZW4gIT0gXCJ7XCIpIHtcbiAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkFuZ2xlIGJyYWNrZXQgeyBleHBlY3RlZFwiKTtcbiAgfVxuXG4gIGdldFRva2VuKCk7IC8vIHN0YXRlbWVudHNcblxuICBwYXJzZVN0YXRlbWVudHMoZ3JhcGgpOyAvLyBjbG9zZSBhbmdsZSBicmFja2V0XG5cbiAgaWYgKHRva2VuICE9IFwifVwiKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJBbmdsZSBicmFja2V0IH0gZXhwZWN0ZWRcIik7XG4gIH1cblxuICBnZXRUb2tlbigpOyAvLyBlbmQgb2YgZmlsZVxuXG4gIGlmICh0b2tlbiAhPT0gXCJcIikge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiRW5kIG9mIGZpbGUgZXhwZWN0ZWRcIik7XG4gIH1cblxuICBnZXRUb2tlbigpOyAvLyByZW1vdmUgdGVtcG9yYXJ5IGRlZmF1bHQgb3B0aW9uc1xuXG4gIGRlbGV0ZSBncmFwaC5ub2RlO1xuICBkZWxldGUgZ3JhcGguZWRnZTtcbiAgZGVsZXRlIGdyYXBoLmdyYXBoO1xuICByZXR1cm4gZ3JhcGg7XG59XG4vKipcbiAqIFBhcnNlIGEgbGlzdCB3aXRoIHN0YXRlbWVudHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVN0YXRlbWVudHMoZ3JhcGgpIHtcbiAgd2hpbGUgKHRva2VuICE9PSBcIlwiICYmIHRva2VuICE9IFwifVwiKSB7XG4gICAgcGFyc2VTdGF0ZW1lbnQoZ3JhcGgpO1xuXG4gICAgaWYgKHRva2VuID09PSBcIjtcIikge1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LiBDYW4gYmUgYSBhbiBhdHRyaWJ1dGUgc3RhdGVtZW50LCBub2RlXG4gKiBzdGF0ZW1lbnQsIGEgc2VyaWVzIG9mIG5vZGUgc3RhdGVtZW50cyBhbmQgZWRnZSBzdGF0ZW1lbnRzLCBvciBhXG4gKiBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVN0YXRlbWVudChncmFwaCkge1xuICAvLyBwYXJzZSBzdWJncmFwaFxuICB2YXIgc3ViZ3JhcGggPSBwYXJzZVN1YmdyYXBoKGdyYXBoKTtcblxuICBpZiAoc3ViZ3JhcGgpIHtcbiAgICAvLyBlZGdlIHN0YXRlbWVudHNcbiAgICBwYXJzZUVkZ2UoZ3JhcGgsIHN1YmdyYXBoKTtcbiAgICByZXR1cm47XG4gIH0gLy8gcGFyc2UgYW4gYXR0cmlidXRlIHN0YXRlbWVudFxuXG5cbiAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCk7XG5cbiAgaWYgKGF0dHIpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gcGFyc2Ugbm9kZVxuXG5cbiAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiSWRlbnRpZmllciBleHBlY3RlZFwiKTtcbiAgfVxuXG4gIHZhciBpZCA9IHRva2VuOyAvLyBpZCBjYW4gYmUgYSBzdHJpbmcgb3IgYSBudW1iZXJcblxuICBnZXRUb2tlbigpO1xuXG4gIGlmICh0b2tlbiA9PT0gXCI9XCIpIHtcbiAgICAvLyBpZCBzdGF0ZW1lbnRcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJJZGVudGlmaWVyIGV4cGVjdGVkXCIpO1xuICAgIH1cblxuICAgIGdyYXBoW2lkXSA9IHRva2VuO1xuICAgIGdldFRva2VuKCk7IC8vIFRPRE86IGltcGxlbWVudCBjb21tYSBzZXBhcmF0ZWQgbGlzdCB3aXRoIFwiYV9saXN0OiBJRD1JRCBbJywnXSBbYV9saXN0XSBcIlxuICB9IGVsc2Uge1xuICAgIHBhcnNlTm9kZVN0YXRlbWVudChncmFwaCwgaWQpO1xuICB9XG59XG4vKipcbiAqIFBhcnNlIGEgc3ViZ3JhcGhcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGggICAgcGFyZW50IGdyYXBoIG9iamVjdFxuICogQHJldHVybnMge29iamVjdCB8IG51bGx9IHN1YmdyYXBoXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVN1YmdyYXBoKGdyYXBoKSB7XG4gIHZhciBzdWJncmFwaCA9IG51bGw7IC8vIG9wdGlvbmFsIHN1YmdyYXBoIGtleXdvcmRcblxuICBpZiAodG9rZW4gPT09IFwic3ViZ3JhcGhcIikge1xuICAgIHN1YmdyYXBoID0ge307XG4gICAgc3ViZ3JhcGgudHlwZSA9IFwic3ViZ3JhcGhcIjtcbiAgICBnZXRUb2tlbigpOyAvLyBvcHRpb25hbCBncmFwaCBpZFxuXG4gICAgaWYgKHRva2VuVHlwZSA9PT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgIHN1YmdyYXBoLmlkID0gdG9rZW47XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cbiAgfSAvLyBvcGVuIGFuZ2xlIGJyYWNrZXRcblxuXG4gIGlmICh0b2tlbiA9PT0gXCJ7XCIpIHtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgaWYgKCFzdWJncmFwaCkge1xuICAgICAgc3ViZ3JhcGggPSB7fTtcbiAgICB9XG5cbiAgICBzdWJncmFwaC5wYXJlbnQgPSBncmFwaDtcbiAgICBzdWJncmFwaC5ub2RlID0gZ3JhcGgubm9kZTtcbiAgICBzdWJncmFwaC5lZGdlID0gZ3JhcGguZWRnZTtcbiAgICBzdWJncmFwaC5ncmFwaCA9IGdyYXBoLmdyYXBoOyAvLyBzdGF0ZW1lbnRzXG5cbiAgICBwYXJzZVN0YXRlbWVudHMoc3ViZ3JhcGgpOyAvLyBjbG9zZSBhbmdsZSBicmFja2V0XG5cbiAgICBpZiAodG9rZW4gIT0gXCJ9XCIpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQW5nbGUgYnJhY2tldCB9IGV4cGVjdGVkXCIpO1xuICAgIH1cblxuICAgIGdldFRva2VuKCk7IC8vIHJlbW92ZSB0ZW1wb3JhcnkgZGVmYXVsdCBvcHRpb25zXG5cbiAgICBkZWxldGUgc3ViZ3JhcGgubm9kZTtcbiAgICBkZWxldGUgc3ViZ3JhcGguZWRnZTtcbiAgICBkZWxldGUgc3ViZ3JhcGguZ3JhcGg7XG4gICAgZGVsZXRlIHN1YmdyYXBoLnBhcmVudDsgLy8gcmVnaXN0ZXIgYXQgdGhlIHBhcmVudCBncmFwaFxuXG4gICAgaWYgKCFncmFwaC5zdWJncmFwaHMpIHtcbiAgICAgIGdyYXBoLnN1YmdyYXBocyA9IFtdO1xuICAgIH1cblxuICAgIGdyYXBoLnN1YmdyYXBocy5wdXNoKHN1YmdyYXBoKTtcbiAgfVxuXG4gIHJldHVybiBzdWJncmFwaDtcbn1cbi8qKlxuICogcGFyc2UgYW4gYXR0cmlidXRlIHN0YXRlbWVudCBsaWtlIFwibm9kZSBbc2hhcGU9Y2lyY2xlIGZvbnRTaXplPTE2XVwiLlxuICogQXZhaWxhYmxlIGtleXdvcmRzIGFyZSAnbm9kZScsICdlZGdlJywgJ2dyYXBoJy5cbiAqIFRoZSBwcmV2aW91cyBsaXN0IHdpdGggZGVmYXVsdCBhdHRyaWJ1dGVzIHdpbGwgYmUgcmVwbGFjZWRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfSBrZXl3b3JkIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHBhcnNlZCBhdHRyaWJ1dGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLCBlZGdlLCBncmFwaCksIG9yIG51bGwgaWYgbm90aGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcGFyc2VkLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVTdGF0ZW1lbnQoZ3JhcGgpIHtcbiAgLy8gYXR0cmlidXRlIHN0YXRlbWVudHNcbiAgaWYgKHRva2VuID09PSBcIm5vZGVcIikge1xuICAgIGdldFRva2VuKCk7IC8vIG5vZGUgYXR0cmlidXRlc1xuXG4gICAgZ3JhcGgubm9kZSA9IHBhcnNlQXR0cmlidXRlTGlzdCgpO1xuICAgIHJldHVybiBcIm5vZGVcIjtcbiAgfSBlbHNlIGlmICh0b2tlbiA9PT0gXCJlZGdlXCIpIHtcbiAgICBnZXRUb2tlbigpOyAvLyBlZGdlIGF0dHJpYnV0ZXNcblxuICAgIGdyYXBoLmVkZ2UgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgICByZXR1cm4gXCJlZGdlXCI7XG4gIH0gZWxzZSBpZiAodG9rZW4gPT09IFwiZ3JhcGhcIikge1xuICAgIGdldFRva2VuKCk7IC8vIGdyYXBoIGF0dHJpYnV0ZXNcblxuICAgIGdyYXBoLmdyYXBoID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgcmV0dXJuIFwiZ3JhcGhcIjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBwYXJzZSBhIG5vZGUgc3RhdGVtZW50XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gaWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlTm9kZVN0YXRlbWVudChncmFwaCwgaWQpIHtcbiAgLy8gbm9kZSBzdGF0ZW1lbnRcbiAgdmFyIG5vZGUgPSB7XG4gICAgaWQ6IGlkXG4gIH07XG4gIHZhciBhdHRyID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG5cbiAgaWYgKGF0dHIpIHtcbiAgICBub2RlLmF0dHIgPSBhdHRyO1xuICB9XG5cbiAgYWRkTm9kZShncmFwaCwgbm9kZSk7IC8vIGVkZ2Ugc3RhdGVtZW50c1xuXG4gIHBhcnNlRWRnZShncmFwaCwgaWQpO1xufVxuLyoqXG4gKiBQYXJzZSBhbiBlZGdlIG9yIGEgc2VyaWVzIG9mIGVkZ2VzXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gZnJvbSAgICAgICAgSWQgb2YgdGhlIGZyb20gbm9kZVxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VFZGdlKGdyYXBoLCBmcm9tKSB7XG4gIHdoaWxlICh0b2tlbiA9PT0gXCItPlwiIHx8IHRva2VuID09PSBcIi0tXCIpIHtcbiAgICB2YXIgdG87XG4gICAgdmFyIHR5cGUgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuICAgIHZhciBzdWJncmFwaCA9IHBhcnNlU3ViZ3JhcGgoZ3JhcGgpO1xuXG4gICAgaWYgKHN1YmdyYXBoKSB7XG4gICAgICB0byA9IHN1YmdyYXBoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiSWRlbnRpZmllciBvciBzdWJncmFwaCBleHBlY3RlZFwiKTtcbiAgICAgIH1cblxuICAgICAgdG8gPSB0b2tlbjtcbiAgICAgIGFkZE5vZGUoZ3JhcGgsIHtcbiAgICAgICAgaWQ6IHRvXG4gICAgICB9KTtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfSAvLyBwYXJzZSBlZGdlIGF0dHJpYnV0ZXNcblxuXG4gICAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTsgLy8gY3JlYXRlIGVkZ2VcblxuICAgIHZhciBlZGdlID0gY3JlYXRlRWRnZShncmFwaCwgZnJvbSwgdG8sIHR5cGUsIGF0dHIpO1xuICAgIGFkZEVkZ2UoZ3JhcGgsIGVkZ2UpO1xuICAgIGZyb20gPSB0bztcbiAgfVxufVxuLyoqXG4gKiBQYXJzZSBhIHNldCB3aXRoIGF0dHJpYnV0ZXMsXG4gKiBmb3IgZXhhbXBsZSBbbGFiZWw9XCIxLjAwMFwiLCBzaGFwZT1zb2xpZF1cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0IHwgbnVsbH0gYXR0clxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVMaXN0KCkge1xuICB2YXIgaTtcbiAgdmFyIGF0dHIgPSBudWxsOyAvLyBlZGdlIHN0eWxlcyBvZiBkb3QgYW5kIHZpc1xuXG4gIHZhciBlZGdlU3R5bGVzID0ge1xuICAgIGRhc2hlZDogdHJ1ZSxcbiAgICBzb2xpZDogZmFsc2UsXG4gICAgZG90dGVkOiBbMSwgNV1cbiAgfTtcbiAgLyoqXG4gICAqIERlZmluZSBhcnJvdyB0eXBlcy5cbiAgICogdmlzIGN1cnJlbnRseSBzdXBwb3J0cyB0eXBlcyBkZWZpbmVkIGluICdhcnJvd1R5cGVzJy5cbiAgICogRGV0YWlscyBvZiBhcnJvdyBzaGFwZXMgYXJlIGRlc2NyaWJlZCBpblxuICAgKiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9jb250ZW50L2Fycm93LXNoYXBlc1xuICAgKi9cblxuICB2YXIgYXJyb3dUeXBlcyA9IHtcbiAgICBkb3Q6IFwiY2lyY2xlXCIsXG4gICAgYm94OiBcImJveFwiLFxuICAgIGNyb3c6IFwiY3Jvd1wiLFxuICAgIGN1cnZlOiBcImN1cnZlXCIsXG4gICAgaWN1cnZlOiBcImludl9jdXJ2ZVwiLFxuICAgIG5vcm1hbDogXCJ0cmlhbmdsZVwiLFxuICAgIGludjogXCJpbnZfdHJpYW5nbGVcIixcbiAgICBkaWFtb25kOiBcImRpYW1vbmRcIixcbiAgICB0ZWU6IFwiYmFyXCIsXG4gICAgdmVlOiBcInZlZVwiXG4gIH07XG4gIC8qKlxuICAgKiAnYXR0cl9saXN0JyBjb250YWlucyBhdHRyaWJ1dGVzIGZvciBjaGVja2luZyBpZiBzb21lIG9mIHRoZW0gYXJlIGFmZmVjdGVkXG4gICAqIGxhdGVyLiBGb3IgaW5zdGFuY2UsIGJvdGggb2YgJ2Fycm93aGVhZCcgYW5kICdkaXInIChlZGdlIHN0eWxlIGRlZmluZWRcbiAgICogaW4gRE9UKSBtYWtlIGNoYW5nZXMgdG8gJ2Fycm93cycgYXR0cmlidXRlIGluIHZpcy5cbiAgICovXG5cbiAgdmFyIGF0dHJfbGlzdCA9IG5ldyBBcnJheSgpO1xuICB2YXIgYXR0cl9uYW1lcyA9IG5ldyBBcnJheSgpOyAvLyB1c2VkIGZvciBjaGVja2luZyB0aGUgY2FzZS5cbiAgLy8gcGFyc2UgYXR0cmlidXRlc1xuXG4gIHdoaWxlICh0b2tlbiA9PT0gXCJbXCIpIHtcbiAgICBnZXRUb2tlbigpO1xuICAgIGF0dHIgPSB7fTtcblxuICAgIHdoaWxlICh0b2tlbiAhPT0gXCJcIiAmJiB0b2tlbiAhPSBcIl1cIikge1xuICAgICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkF0dHJpYnV0ZSBuYW1lIGV4cGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRva2VuO1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgaWYgKHRva2VuICE9IFwiPVwiKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiRXF1YWwgc2lnbiA9IGV4cGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQXR0cmlidXRlIHZhbHVlIGV4cGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSB0b2tlbjsgLy8gY29udmVydCBmcm9tIGRvdCBzdHlsZSB0byB2aXNcblxuICAgICAgaWYgKG5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICB2YWx1ZSA9IGVkZ2VTdHlsZXNbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJyb3dUeXBlO1xuXG4gICAgICBpZiAobmFtZSA9PT0gXCJhcnJvd2hlYWRcIikge1xuICAgICAgICBhcnJvd1R5cGUgPSBhcnJvd1R5cGVzW3ZhbHVlXTtcbiAgICAgICAgbmFtZSA9IFwiYXJyb3dzXCI7XG4gICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogYXJyb3dUeXBlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gXCJhcnJvd3RhaWxcIikge1xuICAgICAgICBhcnJvd1R5cGUgPSBhcnJvd1R5cGVzW3ZhbHVlXTtcbiAgICAgICAgbmFtZSA9IFwiYXJyb3dzXCI7XG4gICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhcnJvd1R5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgYXR0cjogYXR0cixcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGF0dHJfbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgIGlmICh0b2tlbiA9PSBcIixcIikge1xuICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbiAhPSBcIl1cIikge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJCcmFja2V0IF0gZXhwZWN0ZWRcIik7XG4gICAgfVxuXG4gICAgZ2V0VG9rZW4oKTtcbiAgfVxuICAvKipcbiAgICogQXMgZXhwbGFpbmVkIGluIFsxXSwgZ3JhcGh2aXogaGFzIGxpbWl0YXRpb25zIGZvciBjb21iaW5hdGlvbiBvZlxuICAgKiBhcnJvd1toZWFkfHRhaWxdIGFuZCBkaXIuIElmIGF0dHJpYnV0ZSBsaXN0IGluY2x1ZGVzICdkaXInLFxuICAgKiBmb2xsb3dpbmcgY2FzZXMganVzdCBiZSBzdXBwb3J0ZWQuXG4gICAqICAgMS4gYm90aCBvciBub25lICsgYXJyb3doZWFkLCBhcnJvd3RhaWxcbiAgICogICAyLiBmb3J3YXJkICsgYXJyb3doZWFkIChhcnJvd3RhaWwgaXMgbm90IGFmZmVkdGVkKVxuICAgKiAgIDMuIGJhY2sgKyBhcnJvd3RhaWwgKGFycm93aGVhZCBpcyBub3QgYWZmZWN0ZWQpXG4gICAqIFsxXSBodHRwczovL3d3dy5ncmFwaHZpei5vcmcvZG9jL2luZm8vYXR0cnMuaHRtbCNoOnVuZGlyX25vdGVcbiAgICovXG5cblxuICBpZiAoaW5jbHVkZXMkNChhdHRyX25hbWVzKS5jYWxsKGF0dHJfbmFtZXMsIFwiZGlyXCIpKSB7XG4gICAgdmFyIGlkeCA9IHt9OyAvLyBnZXQgaW5kZXggb2YgJ2Fycm93cycgYW5kICdkaXInXG5cbiAgICBpZHguYXJyb3dzID0ge307XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cl9saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgPT09IFwiYXJyb3dzXCIpIHtcbiAgICAgICAgaWYgKGF0dHJfbGlzdFtpXS52YWx1ZS50byAhPSBudWxsKSB7XG4gICAgICAgICAgaWR4LmFycm93cy50byA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0cl9saXN0W2ldLnZhbHVlLmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJJbnZhbGlkIHZhbHVlIG9mIGFycm93c1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhdHRyX2xpc3RbaV0ubmFtZSA9PT0gXCJkaXJcIikge1xuICAgICAgICBpZHguZGlyID0gaTtcbiAgICAgIH1cbiAgICB9IC8vIGZpcnN0LCBhZGQgZGVmYXVsdCBhcnJvdyBzaGFwZSBpZiBpdCBpcyBub3QgYXNzaWduZWQgdG8gYXZvaWQgZXJyb3JcblxuXG4gICAgdmFyIGRpcl90eXBlID0gYXR0cl9saXN0W2lkeC5kaXJdLnZhbHVlO1xuXG4gICAgaWYgKCFpbmNsdWRlcyQ0KGF0dHJfbmFtZXMpLmNhbGwoYXR0cl9uYW1lcywgXCJhcnJvd3NcIikpIHtcbiAgICAgIGlmIChkaXJfdHlwZSA9PT0gXCJib3RoXCIpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IFwiYXJyb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLnRvID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiBcImFycm93c1wiLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLmZyb20gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiBcImFycm93c1wiLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy50byA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IFwiYXJyb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgYXR0cl9saXN0LnB1c2goe1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguZGlyXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IFwiYXJyb3dzXCIsXG4gICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJbnZhbGlkIGRpciB0eXBlIFwiJyArIGRpcl90eXBlICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb21fdHlwZTtcbiAgICB2YXIgdG9fdHlwZTsgLy8gdXBkYXRlICdhcnJvd3MnIGF0dHJpYnV0ZSBmcm9tICdkaXInLlxuXG4gICAgaWYgKGRpcl90eXBlID09PSBcImJvdGhcIikge1xuICAgICAgLy8gYm90aCBvZiBzaGFwZXMgb2YgJ2Zyb20nIGFuZCAndG8nIGFyZSBnaXZlblxuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0udmFsdWUuZnJvbS50eXBlO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzcGxpY2UkMihhdHRyX2xpc3QpLmNhbGwoYXR0cl9saXN0LCBpZHguYXJyb3dzLmZyb20sIDEpOyAvLyBzaGFwZSBvZiAndG8nIGlzIGFzc2lnbmVkIGFuZCB1c2UgZGVmYXVsdCB0byAnZnJvbSdcblxuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTsgLy8gb25seSBzaGFwZSBvZiAnZnJvbScgaXMgYXNzaWduZWQgYW5kIHVzZSBkZWZhdWx0IGZvciAndG8nXG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwiYmFja1wiKSB7XG4gICAgICAvLyBnaXZlbiBib3RoIG9mIHNoYXBlcywgYnV0IHVzZSBvbmx5ICdmcm9tJ1xuICAgICAgaWYgKGlkeC5hcnJvd3MudG8gJiYgaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcIlwiO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBnaXZlbiBzaGFwZSBvZiAndG8nLCBidXQgZG9lcyBub3QgdXNlIGl0XG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgdG9fdHlwZSA9IFwiXCI7XG4gICAgICAgIGZyb21fdHlwZSA9IFwiYXJyb3dcIjtcbiAgICAgICAgaWR4LmFycm93cy5mcm9tID0gaWR4LmFycm93cy50bztcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07IC8vIGFzc2lnbiBnaXZlbiAnZnJvbScgc2hhcGVcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcIlwiO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcIm5vbmVcIikge1xuICAgICAgdmFyIGlkeF9hcnJvdztcblxuICAgICAgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgaWR4X2Fycm93ID0gaWR4LmFycm93cy50bztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeF9hcnJvdyA9IGlkeC5hcnJvd3MuZnJvbTtcbiAgICAgIH1cblxuICAgICAgYXR0cl9saXN0W2lkeF9hcnJvd10gPSB7XG4gICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHhfYXJyb3ddLmF0dHIsXG4gICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHhfYXJyb3ddLm5hbWUsXG4gICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAvLyBnaXZlbiBib3RoIG9mIHNoYXBlcywgYnV0IHVzZSBvbmx5ICd0bydcbiAgICAgIGlmIChpZHguYXJyb3dzLnRvICYmIGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGU7XG4gICAgICAgIGZyb21fdHlwZSA9IFwiXCI7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBhc3NpZ24gZ2l2ZW4gJ3RvJyBzaGFwZVxuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gXCJcIjtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07IC8vIGdpdmVuIHNoYXBlIG9mICdmcm9tJywgYnV0IGRvZXMgbm90IHVzZSBpdFxuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9IFwiYXJyb3dcIjtcbiAgICAgICAgZnJvbV90eXBlID0gXCJcIjtcbiAgICAgICAgaWR4LmFycm93cy50byA9IGlkeC5hcnJvd3MuZnJvbTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS5uYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdJbnZhbGlkIGRpciB0eXBlIFwiJyArIGRpcl90eXBlICsgJ1wiJyk7XG4gICAgfSAvLyByZW1vdmUgJ2RpcicgYXR0cmlidXRlIG5vIG5lZWQgYW55bW9yZVxuXG5cbiAgICBzcGxpY2UkMihhdHRyX2xpc3QpLmNhbGwoYXR0cl9saXN0LCBpZHguZGlyLCAxKTtcbiAgfSAvLyBwYXJzZSAncGVud2lkdGgnXG5cblxuICB2YXIgbm9mX2F0dHJfbGlzdDtcblxuICBpZiAoaW5jbHVkZXMkNChhdHRyX25hbWVzKS5jYWxsKGF0dHJfbmFtZXMsIFwicGVud2lkdGhcIikpIHtcbiAgICB2YXIgdG1wX2F0dHJfbGlzdCA9IFtdO1xuICAgIG5vZl9hdHRyX2xpc3QgPSBhdHRyX2xpc3QubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5vZl9hdHRyX2xpc3Q7IGkrKykge1xuICAgICAgLy8gZXhjbHVkZSAnd2lkdGgnIGZyb20gYXR0cl9saXN0IGlmICdwZW53aWR0aCcgZXhpc3RzXG4gICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgIT09IFwid2lkdGhcIikge1xuICAgICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgPT09IFwicGVud2lkdGhcIikge1xuICAgICAgICAgIGF0dHJfbGlzdFtpXS5uYW1lID0gXCJ3aWR0aFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wX2F0dHJfbGlzdC5wdXNoKGF0dHJfbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cl9saXN0ID0gdG1wX2F0dHJfbGlzdDtcbiAgfVxuXG4gIG5vZl9hdHRyX2xpc3QgPSBhdHRyX2xpc3QubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBub2ZfYXR0cl9saXN0OyBpKyspIHtcbiAgICBzZXRWYWx1ZShhdHRyX2xpc3RbaV0uYXR0ciwgYXR0cl9saXN0W2ldLm5hbWUsIGF0dHJfbGlzdFtpXS52YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gYXR0cjtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3ludGF4IGVycm9yIHdpdGggZXh0cmEgaW5mb3JtYXRpb24gb24gY3VycmVudCB0b2tlbiBhbmQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtTeW50YXhFcnJvcn0gZXJyXG4gKi9cblxuXG5mdW5jdGlvbiBuZXdTeW50YXhFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSArICcsIGdvdCBcIicgKyBjaG9wKHRva2VuLCAzMCkgKyAnXCIgKGNoYXIgJyArIGluZGV4ICsgXCIpXCIpO1xufVxuLyoqXG4gKiBDaG9wIG9mZiB0ZXh0IGFmdGVyIGEgbWF4aW11bSBsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IG1heExlbmd0aFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGNob3AodGV4dCwgbWF4TGVuZ3RoKSB7XG4gIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSBtYXhMZW5ndGggPyB0ZXh0IDogdGV4dC5zdWJzdHIoMCwgMjcpICsgXCIuLi5cIjtcbn1cbi8qKlxuICogRXhlY3V0ZSBhIGZ1bmN0aW9uIGZuIGZvciBlYWNoIHBhaXIgb2YgZWxlbWVudHMgaW4gdHdvIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTFcbiAqIEBwYXJhbSB7QXJyYXkgfCAqfSBhcnJheTJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JFYWNoMihhcnJheTEsIGFycmF5MiwgZm4pIHtcbiAgaWYgKGlzQXJyYXkkNShhcnJheTEpKSB7XG4gICAgZm9yRWFjaCQyKGFycmF5MSkuY2FsbChhcnJheTEsIGZ1bmN0aW9uIChlbGVtMSkge1xuICAgICAgaWYgKGlzQXJyYXkkNShhcnJheTIpKSB7XG4gICAgICAgIGZvckVhY2gkMihhcnJheTIpLmNhbGwoYXJyYXkyLCBmdW5jdGlvbiAoZWxlbTIpIHtcbiAgICAgICAgICBmbihlbGVtMSwgZWxlbTIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuKGVsZW0xLCBhcnJheTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0FycmF5JDUoYXJyYXkyKSkge1xuICAgICAgZm9yRWFjaCQyKGFycmF5MikuY2FsbChhcnJheTIsIGZ1bmN0aW9uIChlbGVtMikge1xuICAgICAgICBmbihhcnJheTEsIGVsZW0yKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbihhcnJheTEsIGFycmF5Mik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFNldCBhIG5lc3RlZCBwcm9wZXJ0eSBvbiBhbiBvYmplY3RcbiAqIFdoZW4gbmVzdGVkIG9iamVjdHMgYXJlIG1pc3NpbmcsIHRoZXkgd2lsbCBiZSBjcmVhdGVkLlxuICogRm9yIGV4YW1wbGUgc2V0UHJvcCh7fSwgJ2ZvbnQuY29sb3InLCAncmVkJykgd2lsbCByZXR1cm4ge2ZvbnQ6IHtjb2xvcjogJ3JlZCd9fVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICAgQSBkb3Qgc2VwYXJhdGVkIHN0cmluZyBsaWtlICdmb250LmNvbG9yJ1xuICogQHBhcmFtIHsqfSB2YWx1ZSAgICAgICBWYWx1ZSBmb3IgdGhlIHByb3BlcnR5XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBSZXR1cm5zIHRoZSBvcmlnaW5hbCBvYmplY3QsIGFsbG93cyBmb3IgY2hhaW5pbmcuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRQcm9wKG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHZhciBwcm9wID0gbmFtZXMucG9wKCk7IC8vIHRyYXZlcnNlIG92ZXIgdGhlIG5lc3RlZCBvYmplY3RzXG5cbiAgdmFyIG9iaiA9IG9iamVjdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcblxuICAgIGlmICghKG5hbWUgaW4gb2JqKSkge1xuICAgICAgb2JqW25hbWVdID0ge307XG4gICAgfVxuXG4gICAgb2JqID0gb2JqW25hbWVdO1xuICB9IC8vIHNldCB0aGUgcHJvcGVydHkgdmFsdWVcblxuXG4gIG9ialtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufVxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCB3aXRoIERPVCBhdHRyaWJ1dGVzIHRvIHRoZWlyIHZpcy5qcyBlcXVpdmFsZW50cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0ciAgICAgT2JqZWN0IHdpdGggRE9UIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBwaW5nXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAgICAgICAgIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdmlzLmpzIGF0dHJpYnV0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbnZlcnRBdHRyKGF0dHIsIG1hcHBpbmcpIHtcbiAgdmFyIGNvbnZlcnRlZCA9IHt9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gYXR0cikge1xuICAgIGlmIChhdHRyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICB2YXIgdmlzUHJvcCA9IG1hcHBpbmdbcHJvcF07XG5cbiAgICAgIGlmIChpc0FycmF5JDUodmlzUHJvcCkpIHtcbiAgICAgICAgZm9yRWFjaCQyKHZpc1Byb3ApLmNhbGwodmlzUHJvcCwgZnVuY3Rpb24gKHZpc1Byb3BJKSB7XG4gICAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHZpc1Byb3BJLCBhdHRyW3Byb3BdKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2aXNQcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNldFByb3AoY29udmVydGVkLCB2aXNQcm9wLCBhdHRyW3Byb3BdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFByb3AoY29udmVydGVkLCBwcm9wLCBhdHRyW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udmVydGVkO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBncmFwaCBpbiBET1QgbGFuZ3VhZ2UgaW50byBhIG1hcCBjb250YWluaW5nXG4gKiB3aXRoIG5vZGVzIGFuZCBlZGdlcyBpbiB0aGUgZm9ybWF0IG9mIGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICAgICAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBncmFwaERhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIERPVFRvR3JhcGgoZGF0YSkge1xuICAvLyBwYXJzZSB0aGUgRE9UIGZpbGVcbiAgdmFyIGRvdERhdGEgPSBwYXJzZURPVChkYXRhKTtcbiAgdmFyIGdyYXBoRGF0YSA9IHtcbiAgICBub2RlczogW10sXG4gICAgZWRnZXM6IFtdLFxuICAgIG9wdGlvbnM6IHt9XG4gIH07IC8vIGNvcHkgdGhlIG5vZGVzXG5cbiAgaWYgKGRvdERhdGEubm9kZXMpIHtcbiAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgZm9yRWFjaCQyKF9jb250ZXh0MiA9IGRvdERhdGEubm9kZXMpLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAoZG90Tm9kZSkge1xuICAgICAgdmFyIGdyYXBoTm9kZSA9IHtcbiAgICAgICAgaWQ6IGRvdE5vZGUuaWQsXG4gICAgICAgIGxhYmVsOiBTdHJpbmcoZG90Tm9kZS5sYWJlbCB8fCBkb3ROb2RlLmlkKVxuICAgICAgfTtcbiAgICAgIG1lcmdlKGdyYXBoTm9kZSwgY29udmVydEF0dHIoZG90Tm9kZS5hdHRyLCBOT0RFX0FUVFJfTUFQUElORykpO1xuXG4gICAgICBpZiAoZ3JhcGhOb2RlLmltYWdlKSB7XG4gICAgICAgIGdyYXBoTm9kZS5zaGFwZSA9IFwiaW1hZ2VcIjtcbiAgICAgIH1cblxuICAgICAgZ3JhcGhEYXRhLm5vZGVzLnB1c2goZ3JhcGhOb2RlKTtcbiAgICB9KTtcbiAgfSAvLyBjb3B5IHRoZSBlZGdlc1xuXG5cbiAgaWYgKGRvdERhdGEuZWRnZXMpIHtcbiAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbiBlZGdlIGluIERPVCBmb3JtYXQgdG8gYW4gZWRnZSB3aXRoIFZpc0dyYXBoIGZvcm1hdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRvdEVkZ2VcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBncmFwaEVkZ2VcbiAgICAgKi9cbiAgICB2YXIgY29udmVydEVkZ2UgPSBmdW5jdGlvbiBjb252ZXJ0RWRnZShkb3RFZGdlKSB7XG4gICAgICB2YXIgZ3JhcGhFZGdlID0ge1xuICAgICAgICBmcm9tOiBkb3RFZGdlLmZyb20sXG4gICAgICAgIHRvOiBkb3RFZGdlLnRvXG4gICAgICB9O1xuICAgICAgbWVyZ2UoZ3JhcGhFZGdlLCBjb252ZXJ0QXR0cihkb3RFZGdlLmF0dHIsIEVER0VfQVRUUl9NQVBQSU5HKSk7IC8vIEFkZCBhcnJvd3MgYXR0cmlidXRlIHRvIGRlZmF1bHQgc3R5bGVkIGFycm93LlxuICAgICAgLy8gVGhlIHJlYXNvbiB3aHkgZGVmYXVsdCBzdHlsZSBpcyBub3QgYWRkZWQgaW4gcGFyc2VBdHRyaWJ1dGVMaXN0KCkgaXNcbiAgICAgIC8vIGJlY2F1c2Ugb25seSBkZWZhdWx0IGlzIGNsZWFyZWQgYmVmb3JlIGhlcmUuXG5cbiAgICAgIGlmIChncmFwaEVkZ2UuYXJyb3dzID09IG51bGwgJiYgZG90RWRnZS50eXBlID09PSBcIi0+XCIpIHtcbiAgICAgICAgZ3JhcGhFZGdlLmFycm93cyA9IFwidG9cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYXBoRWRnZTtcbiAgICB9O1xuXG4gICAgZm9yRWFjaCQyKF9jb250ZXh0MyA9IGRvdERhdGEuZWRnZXMpLmNhbGwoX2NvbnRleHQzLCBmdW5jdGlvbiAoZG90RWRnZSkge1xuICAgICAgdmFyIGZyb20sIHRvO1xuXG4gICAgICBpZiAoZG90RWRnZS5mcm9tIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGZyb20gPSBkb3RFZGdlLmZyb20ubm9kZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tID0ge1xuICAgICAgICAgIGlkOiBkb3RFZGdlLmZyb21cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvdEVkZ2UudG8gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgdG8gPSBkb3RFZGdlLnRvLm5vZGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG8gPSB7XG4gICAgICAgICAgaWQ6IGRvdEVkZ2UudG9cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvdEVkZ2UuZnJvbSBpbnN0YW5jZW9mIE9iamVjdCAmJiBkb3RFZGdlLmZyb20uZWRnZXMpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NDtcblxuICAgICAgICBmb3JFYWNoJDIoX2NvbnRleHQ0ID0gZG90RWRnZS5mcm9tLmVkZ2VzKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKHN1YkVkZ2UpIHtcbiAgICAgICAgICB2YXIgZ3JhcGhFZGdlID0gY29udmVydEVkZ2Uoc3ViRWRnZSk7XG4gICAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvckVhY2gyKGZyb20sIHRvLCBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIHN1YkVkZ2UgPSBjcmVhdGVFZGdlKGdyYXBoRGF0YSwgZnJvbS5pZCwgdG8uaWQsIGRvdEVkZ2UudHlwZSwgZG90RWRnZS5hdHRyKTtcbiAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICBncmFwaERhdGEuZWRnZXMucHVzaChncmFwaEVkZ2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChkb3RFZGdlLnRvIGluc3RhbmNlb2YgT2JqZWN0ICYmIGRvdEVkZ2UudG8uZWRnZXMpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NTtcblxuICAgICAgICBmb3JFYWNoJDIoX2NvbnRleHQ1ID0gZG90RWRnZS50by5lZGdlcykuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChzdWJFZGdlKSB7XG4gICAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICAgIGdyYXBoRGF0YS5lZGdlcy5wdXNoKGdyYXBoRWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIGNvcHkgdGhlIG9wdGlvbnNcblxuXG4gIGlmIChkb3REYXRhLmF0dHIpIHtcbiAgICBncmFwaERhdGEub3B0aW9ucyA9IGRvdERhdGEuYXR0cjtcbiAgfVxuXG4gIHJldHVybiBncmFwaERhdGE7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXZhciAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qIGVzbGludC1lbmFibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG5cbnZhciBkb3RwYXJzZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0cGFyc2VET1Q6IHBhcnNlRE9ULFxuXHRET1RUb0dyYXBoOiBET1RUb0dyYXBoXG59KTtcblxuLyoqXHJcbiAqIENvbnZlcnQgR2VwaGkgdG8gVmlzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZ2VwaGlKU09OIC0gVGhlIHBhcnNlZCBKU09OIGRhdGEgaW4gR2VwaGkgZm9ybWF0LlxyXG4gKiBAcGFyYW0gb3B0aW9uc09iaiAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICpcclxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBkYXRhIHJlYWR5IHRvIGJlIHVzZWQgaW4gVmlzLlxyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlR2VwaGkoZ2VwaGlKU09OLCBvcHRpb25zT2JqKSB7XG4gIHZhciBfY29udGV4dDtcblxuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBlZGdlczoge1xuICAgICAgaW5oZXJpdENvbG9yOiBmYWxzZVxuICAgIH0sXG4gICAgbm9kZXM6IHtcbiAgICAgIGZpeGVkOiBmYWxzZSxcbiAgICAgIHBhcnNlQ29sb3I6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIGlmIChvcHRpb25zT2JqICE9IG51bGwpIHtcbiAgICBpZiAob3B0aW9uc09iai5maXhlZCAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLm5vZGVzLmZpeGVkID0gb3B0aW9uc09iai5maXhlZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc09iai5wYXJzZUNvbG9yICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMubm9kZXMucGFyc2VDb2xvciA9IG9wdGlvbnNPYmoucGFyc2VDb2xvcjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc09iai5pbmhlcml0Q29sb3IgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5lZGdlcy5pbmhlcml0Q29sb3IgPSBvcHRpb25zT2JqLmluaGVyaXRDb2xvcjtcbiAgICB9XG4gIH1cblxuICB2YXIgZ0VkZ2VzID0gZ2VwaGlKU09OLmVkZ2VzO1xuXG4gIHZhciB2RWRnZXMgPSBtYXAkMihnRWRnZXMpLmNhbGwoZ0VkZ2VzLCBmdW5jdGlvbiAoZ0VkZ2UpIHtcbiAgICB2YXIgdkVkZ2UgPSB7XG4gICAgICBmcm9tOiBnRWRnZS5zb3VyY2UsXG4gICAgICBpZDogZ0VkZ2UuaWQsXG4gICAgICB0bzogZ0VkZ2UudGFyZ2V0XG4gICAgfTtcblxuICAgIGlmIChnRWRnZS5hdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgIHZFZGdlLmF0dHJpYnV0ZXMgPSBnRWRnZS5hdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIGlmIChnRWRnZS5sYWJlbCAhPSBudWxsKSB7XG4gICAgICB2RWRnZS5sYWJlbCA9IGdFZGdlLmxhYmVsO1xuICAgIH1cblxuICAgIGlmIChnRWRnZS5hdHRyaWJ1dGVzICE9IG51bGwgJiYgZ0VkZ2UuYXR0cmlidXRlcy50aXRsZSAhPSBudWxsKSB7XG4gICAgICB2RWRnZS50aXRsZSA9IGdFZGdlLmF0dHJpYnV0ZXMudGl0bGU7XG4gICAgfVxuXG4gICAgaWYgKGdFZGdlLnR5cGUgPT09IFwiRGlyZWN0ZWRcIikge1xuICAgICAgdkVkZ2UuYXJyb3dzID0gXCJ0b1wiO1xuICAgIH0gLy8gZWRnZVsndmFsdWUnXSA9IGdFZGdlLmF0dHJpYnV0ZXMgIT0gbnVsbCA/IGdFZGdlLmF0dHJpYnV0ZXMuV2VpZ2h0IDogdW5kZWZpbmVkO1xuICAgIC8vIGVkZ2VbJ3dpZHRoJ10gPSBlZGdlWyd2YWx1ZSddICE9IG51bGwgPyB1bmRlZmluZWQgOiBlZGdlZ0VkZ2Uuc2l6ZTtcblxuXG4gICAgaWYgKGdFZGdlLmNvbG9yICYmIG9wdGlvbnMuZWRnZXMuaW5oZXJpdENvbG9yID09PSBmYWxzZSkge1xuICAgICAgdkVkZ2UuY29sb3IgPSBnRWRnZS5jb2xvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdkVkZ2U7XG4gIH0pO1xuXG4gIHZhciB2Tm9kZXMgPSBtYXAkMihfY29udGV4dCA9IGdlcGhpSlNPTi5ub2RlcykuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGdOb2RlKSB7XG4gICAgdmFyIHZOb2RlID0ge1xuICAgICAgaWQ6IGdOb2RlLmlkLFxuICAgICAgZml4ZWQ6IG9wdGlvbnMubm9kZXMuZml4ZWQgJiYgZ05vZGUueCAhPSBudWxsICYmIGdOb2RlLnkgIT0gbnVsbFxuICAgIH07XG5cbiAgICBpZiAoZ05vZGUuYXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS5hdHRyaWJ1dGVzID0gZ05vZGUuYXR0cmlidXRlcztcbiAgICB9XG5cbiAgICBpZiAoZ05vZGUubGFiZWwgIT0gbnVsbCkge1xuICAgICAgdk5vZGUubGFiZWwgPSBnTm9kZS5sYWJlbDtcbiAgICB9XG5cbiAgICBpZiAoZ05vZGUuc2l6ZSAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS5zaXplID0gZ05vZGUuc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoZ05vZGUuYXR0cmlidXRlcyAhPSBudWxsICYmIGdOb2RlLmF0dHJpYnV0ZXMudGl0bGUgIT0gbnVsbCkge1xuICAgICAgdk5vZGUudGl0bGUgPSBnTm9kZS5hdHRyaWJ1dGVzLnRpdGxlO1xuICAgIH1cblxuICAgIGlmIChnTm9kZS50aXRsZSAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS50aXRsZSA9IGdOb2RlLnRpdGxlO1xuICAgIH1cblxuICAgIGlmIChnTm9kZS54ICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLnggPSBnTm9kZS54O1xuICAgIH1cblxuICAgIGlmIChnTm9kZS55ICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLnkgPSBnTm9kZS55O1xuICAgIH1cblxuICAgIGlmIChnTm9kZS5jb2xvciAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5ub2Rlcy5wYXJzZUNvbG9yID09PSB0cnVlKSB7XG4gICAgICAgIHZOb2RlLmNvbG9yID0gZ05vZGUuY29sb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2Tm9kZS5jb2xvciA9IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvcixcbiAgICAgICAgICBib3JkZXI6IGdOb2RlLmNvbG9yLFxuICAgICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogZ05vZGUuY29sb3IsXG4gICAgICAgICAgICBib3JkZXI6IGdOb2RlLmNvbG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogZ05vZGUuY29sb3IsXG4gICAgICAgICAgICBib3JkZXI6IGdOb2RlLmNvbG9yXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2Tm9kZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBub2Rlczogdk5vZGVzLFxuICAgIGVkZ2VzOiB2RWRnZXNcbiAgfTtcbn1cblxudmFyIGdlcGhpUGFyc2VyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdHBhcnNlR2VwaGk6IHBhcnNlR2VwaGlcbn0pO1xuXG4vKipcclxuICogQ3JlYXRlZCBieSBBbGV4IG9uIDExLzYvMjAxNC5cclxuICovXG5mdW5jdGlvbiBrZXljaGFybShvcHRpb25zKSB7XG4gIHZhciBwcmV2ZW50RGVmYXVsdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmV2ZW50RGVmYXVsdCB8fCBmYWxzZTtcbiAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250YWluZXIgfHwgd2luZG93O1xuICB2YXIgX2V4cG9ydEZ1bmN0aW9ucyA9IHt9O1xuICB2YXIgX2JvdW5kID0ge1xuICAgIGtleWRvd246IHt9LFxuICAgIGtleXVwOiB7fVxuICB9O1xuICB2YXIgX2tleXMgPSB7fTtcbiAgdmFyIGk7IC8vIGEgLSB6XG5cbiAgZm9yIChpID0gOTc7IGkgPD0gMTIyOyBpKyspIHtcbiAgICBfa2V5c1tTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IHtcbiAgICAgIGNvZGU6IDY1ICsgKGkgLSA5NyksXG4gICAgICBzaGlmdDogZmFsc2VcbiAgICB9O1xuICB9IC8vIEEgLSBaXG5cblxuICBmb3IgKGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gICAgX2tleXNbU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSB7XG4gICAgICBjb2RlOiBpLFxuICAgICAgc2hpZnQ6IHRydWVcbiAgICB9O1xuICB9IC8vIDAgLSA5XG5cblxuICBmb3IgKGkgPSAwOyBpIDw9IDk7IGkrKykge1xuICAgIF9rZXlzWycnICsgaV0gPSB7XG4gICAgICBjb2RlOiA0OCArIGksXG4gICAgICBzaGlmdDogZmFsc2VcbiAgICB9O1xuICB9IC8vIEYxIC0gRjEyXG5cblxuICBmb3IgKGkgPSAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICBfa2V5c1snRicgKyBpXSA9IHtcbiAgICAgIGNvZGU6IDExMSArIGksXG4gICAgICBzaGlmdDogZmFsc2VcbiAgICB9O1xuICB9IC8vIG51bTAgLSBudW05XG5cblxuICBmb3IgKGkgPSAwOyBpIDw9IDk7IGkrKykge1xuICAgIF9rZXlzWydudW0nICsgaV0gPSB7XG4gICAgICBjb2RlOiA5NiArIGksXG4gICAgICBzaGlmdDogZmFsc2VcbiAgICB9O1xuICB9IC8vIG51bXBhZCBtaXNjXG5cblxuICBfa2V5c1snbnVtKiddID0ge1xuICAgIGNvZGU6IDEwNixcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ251bSsnXSA9IHtcbiAgICBjb2RlOiAxMDcsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydudW0tJ10gPSB7XG4gICAgY29kZTogMTA5LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snbnVtLyddID0ge1xuICAgIGNvZGU6IDExMSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ251bS4nXSA9IHtcbiAgICBjb2RlOiAxMTAsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07IC8vIGFycm93c1xuXG4gIF9rZXlzWydsZWZ0J10gPSB7XG4gICAgY29kZTogMzcsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWyd1cCddID0ge1xuICAgIGNvZGU6IDM4LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1sncmlnaHQnXSA9IHtcbiAgICBjb2RlOiAzOSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ2Rvd24nXSA9IHtcbiAgICBjb2RlOiA0MCxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTsgLy8gZXh0cmEga2V5c1xuXG4gIF9rZXlzWydzcGFjZSddID0ge1xuICAgIGNvZGU6IDMyLFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snZW50ZXInXSA9IHtcbiAgICBjb2RlOiAxMyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ3NoaWZ0J10gPSB7XG4gICAgY29kZTogMTYsXG4gICAgc2hpZnQ6IHVuZGVmaW5lZFxuICB9O1xuICBfa2V5c1snZXNjJ10gPSB7XG4gICAgY29kZTogMjcsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydiYWNrc3BhY2UnXSA9IHtcbiAgICBjb2RlOiA4LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1sndGFiJ10gPSB7XG4gICAgY29kZTogOSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ2N0cmwnXSA9IHtcbiAgICBjb2RlOiAxNyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ2FsdCddID0ge1xuICAgIGNvZGU6IDE4LFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snZGVsZXRlJ10gPSB7XG4gICAgY29kZTogNDYsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWydwYWdldXAnXSA9IHtcbiAgICBjb2RlOiAzMyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJ3BhZ2Vkb3duJ10gPSB7XG4gICAgY29kZTogMzQsXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07IC8vIHN5bWJvbHNcblxuICBfa2V5c1snPSddID0ge1xuICAgIGNvZGU6IDE4NyxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcbiAgX2tleXNbJy0nXSA9IHtcbiAgICBjb2RlOiAxODksXG4gICAgc2hpZnQ6IGZhbHNlXG4gIH07XG4gIF9rZXlzWyddJ10gPSB7XG4gICAgY29kZTogMjIxLFxuICAgIHNoaWZ0OiBmYWxzZVxuICB9O1xuICBfa2V5c1snWyddID0ge1xuICAgIGNvZGU6IDIxOSxcbiAgICBzaGlmdDogZmFsc2VcbiAgfTtcblxuICB2YXIgZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50LCAna2V5ZG93bicpO1xuICB9O1xuXG4gIHZhciB1cCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50LCAna2V5dXAnKTtcbiAgfTsgLy8gaGFuZGxlIHRoZSBhY3R1YWx5IGJvdW5kIGtleSB3aXRoIHRoZSBldmVudFxuXG5cbiAgdmFyIGhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCB0eXBlKSB7XG4gICAgaWYgKF9ib3VuZFt0eXBlXVtldmVudC5rZXlDb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgYm91bmQgPSBfYm91bmRbdHlwZV1bZXZlbnQua2V5Q29kZV07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJvdW5kW2ldLnNoaWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBib3VuZFtpXS5mbihldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYm91bmRbaV0uc2hpZnQgPT0gdHJ1ZSAmJiBldmVudC5zaGlmdEtleSA9PSB0cnVlKSB7XG4gICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kW2ldLnNoaWZ0ID09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5ID09IGZhbHNlKSB7XG4gICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCA9PSB0cnVlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBiaW5kIGEga2V5IHRvIGEgY2FsbGJhY2tcblxuXG4gIF9leHBvcnRGdW5jdGlvbnMuYmluZCA9IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdHlwZSA9ICdrZXlkb3duJztcbiAgICB9XG5cbiAgICBpZiAoX2tleXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiICsga2V5KTtcbiAgICB9XG5cbiAgICBpZiAoX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV0gPSBbXTtcbiAgICB9XG5cbiAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXS5wdXNoKHtcbiAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgIHNoaWZ0OiBfa2V5c1trZXldLnNoaWZ0XG4gICAgfSk7XG4gIH07IC8vIGJpbmQgYWxsIGtleXMgdG8gYSBjYWxsIGJhY2sgKGRlbW8gcHVycG9zZXMpXG5cblxuICBfZXhwb3J0RnVuY3Rpb25zLmJpbmRBbGwgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0eXBlID0gJ2tleWRvd24nO1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBfa2V5cykge1xuICAgICAgaWYgKF9rZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgX2V4cG9ydEZ1bmN0aW9ucy5iaW5kKGtleSwgY2FsbGJhY2ssIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gZ2V0IHRoZSBrZXkgbGFiZWwgZnJvbSBhbiBldmVudFxuXG5cbiAgX2V4cG9ydEZ1bmN0aW9ucy5nZXRLZXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gX2tleXMpIHtcbiAgICAgIGlmIChfa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSA9PSB0cnVlICYmIF9rZXlzW2tleV0uc2hpZnQgPT0gdHJ1ZSAmJiBldmVudC5rZXlDb2RlID09IF9rZXlzW2tleV0uY29kZSkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgPT0gZmFsc2UgJiYgX2tleXNba2V5XS5zaGlmdCA9PSBmYWxzZSAmJiBldmVudC5rZXlDb2RlID09IF9rZXlzW2tleV0uY29kZSkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUgJiYga2V5ID09ICdzaGlmdCcpIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwidW5rbm93biBrZXksIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXCI7XG4gIH07IC8vIHVuYmluZCBlaXRoZXIgYSBzcGVjaWZpYyBjYWxsYmFjayBmcm9tIGEga2V5IG9yIGFsbCBvZiB0aGVtIChieSBsZWF2aW5nIGNhbGxiYWNrIHVuZGVmaW5lZClcblxuXG4gIF9leHBvcnRGdW5jdGlvbnMudW5iaW5kID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0eXBlID0gJ2tleWRvd24nO1xuICAgIH1cblxuICAgIGlmIChfa2V5c1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleTogXCIgKyBrZXkpO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgbmV3QmluZGluZ3MgPSBbXTtcbiAgICAgIHZhciBib3VuZCA9IF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdO1xuXG4gICAgICBpZiAoYm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCEoYm91bmRbaV0uZm4gPT0gY2FsbGJhY2sgJiYgYm91bmRbaV0uc2hpZnQgPT0gX2tleXNba2V5XS5zaGlmdCkpIHtcbiAgICAgICAgICAgIG5ld0JpbmRpbmdzLnB1c2goX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV1baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IG5ld0JpbmRpbmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IFtdO1xuICAgIH1cbiAgfTsgLy8gcmVzZXQgYWxsIGJvdW5kIHZhcmlhYmxlcy5cblxuXG4gIF9leHBvcnRGdW5jdGlvbnMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2JvdW5kID0ge1xuICAgICAga2V5ZG93bjoge30sXG4gICAgICBrZXl1cDoge31cbiAgICB9O1xuICB9OyAvLyB1bmJpbmQgYWxsIGxpc3RlbmVycyBhbmQgcmVzZXQgYWxsIHZhcmlhYmxlcy5cblxuXG4gIF9leHBvcnRGdW5jdGlvbnMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfYm91bmQgPSB7XG4gICAgICBrZXlkb3duOiB7fSxcbiAgICAgIGtleXVwOiB7fVxuICAgIH07XG4gICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duLCB0cnVlKTtcbiAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cCwgdHJ1ZSk7XG4gIH07IC8vIGNyZWF0ZSBsaXN0ZW5lcnMuXG5cblxuICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvd24sIHRydWUpO1xuICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cCwgdHJ1ZSk7IC8vIHJldHVybiB0aGUgcHVibGljIGZ1bmN0aW9ucy5cblxuICByZXR1cm4gX2V4cG9ydEZ1bmN0aW9ucztcbn1cblxuLyohIEhhbW1lci5KUyAtIHYyLjAuMTctcmMgLSAyMDE5LTEyLTE2XG4gKiBodHRwOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanNcbiAqXG4gKiBGb3JrZWQgQnkgTmF2ZXIgZWdqc1xuICogQ29weXJpZ2h0IChjKSBoYW1tZXJqc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlICovXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICovXG5cblxudmFyIGFzc2lnbiQzO1xuXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgYXNzaWduJDMgPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59IGVsc2Uge1xuICBhc3NpZ24kMyA9IE9iamVjdC5hc3NpZ247XG59XG5cbnZhciBhc3NpZ24kMSQxID0gYXNzaWduJDM7XG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8ge1xuICBzdHlsZToge31cbn0gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcbnZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgYWJzID0gTWF0aC5hYnM7XG52YXIgbm93JDMgPSBEYXRlLm5vdztcbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4O1xuICB2YXIgcHJvcDtcbiAgdmFyIGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICBwcm9wID0gcHJlZml4ID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tbmVzdGVkLXRlcm5hcnkgKi9cblxuXG52YXIgd2luO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAvLyB3aW5kb3cgaXMgdW5kZWZpbmVkIGluIG5vZGUuanNcbiAgd2luID0ge307XG59IGVsc2Uge1xuICB3aW4gPSB3aW5kb3c7XG59XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpIHtcbiAgaWYgKCFOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRvdWNoTWFwID0ge307XG4gIHZhciBjc3NTdXBwb3J0cyA9IHdpbi5DU1MgJiYgd2luLkNTUy5zdXBwb3J0cztcbiAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gSWYgY3NzLnN1cHBvcnRzIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IHRoZXJlIGlzIG5hdGl2ZSB0b3VjaC1hY3Rpb24gYXNzdW1lIGl0IHN1cHBvcnRzXG4gICAgLy8gYWxsIHZhbHVlcy4gVGhpcyBpcyB0aGUgY2FzZSBmb3IgSUUgMTAgYW5kIDExLlxuICAgIHJldHVybiB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW4uQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiB0b3VjaE1hcDtcbn1cblxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xudmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG5cbnZhciBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG52YXIgVE9VQ0hfQUNUSU9OX01BUCA9IGdldFRvdWNoQWN0aW9uUHJvcHMoKTtcbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW4pO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW4sICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG52YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbnZhciBJTlBVVF9UWVBFX01PVVNFID0gJ21vdXNlJztcbnZhciBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xudmFyIERJUkVDVElPTl9OT05FID0gMTtcbnZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gNDtcbnZhciBESVJFQ1RJT05fVVAgPSA4O1xudmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG4vKipcbiAqIEBwcml2YXRlXG4gKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cblxuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gIHZhciBpO1xuXG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpIGluIG9iaikge1xuICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBib29sT3JGbih2YWwsIGFyZ3MpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXG4gKi9cblxuXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgLy8gbm9uZVxuICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICB9XG5cbiAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7IC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG5cbiAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgfSAvLyBwYW4teCBPUiBwYW4teVxuXG5cbiAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICB9IC8vIG1hbmlwdWxhdGlvblxuXG5cbiAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gIH1cblxuICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBUb3VjaCBBY3Rpb25cbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgVG91Y2hBY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5zZXQodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFRvdWNoQWN0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICBpZiAodmFsdWUgPT09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgIH1cblxuICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICovXG5cblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgKi9cblxuXG4gIF9wcm90by5jb21wdXRlID0gZnVuY3Rpb24gY29tcHV0ZSgpIHtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbiAocmVjb2duaXplcikge1xuICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cblxuICBfcHJvdG8ucHJldmVudERlZmF1bHRzID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHRzKGlucHV0KSB7XG4gICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjsgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG5cbiAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAvLyBkbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcbiAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICB2YXIgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgIHZhciBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhhc05vbmUgfHwgaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8fCBoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgKi9cblxuXG4gIF9wcm90by5wcmV2ZW50U3JjID0gZnVuY3Rpb24gcHJldmVudFNyYyhzcmNFdmVudCkge1xuICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICByZXR1cm4gVG91Y2hBY3Rpb247XG59KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gKiBAbWV0aG9kIGhhc1BhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICovXG5cblxuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5cblxuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDsgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcblxuICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgIH07XG4gIH1cblxuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XG4gICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICovXG5cblxuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgfTtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRpbWVTdGFtcDogbm93JDMoKSxcbiAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgY2VudGVyOiBnZXRDZW50ZXIocG9pbnRlcnMpLFxuICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHAxIHt4LCB5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgfVxuXG4gIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dO1xuICB2YXIgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxuICogQHBhcmFtIHtPYmplY3R9IHAyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICBwcm9wcyA9IFBST1BTX1hZO1xuICB9XG5cbiAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV07XG4gIHZhciB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICB9XG5cbiAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgfVxuXG4gIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyOyAvLyBsZXQgeyBvZmZzZXREZWx0YTpvZmZzZXQgPSB7fSwgcHJldkRlbHRhID0ge30sIHByZXZJbnB1dCA9IHt9IH0gPSBzZXNzaW9uO1xuICAvLyBqc2NzIHRocm93aW5nIGVycm9yIG9uIGRlZmFsdXQgZGVzdHJ1Y3R1cmVkIHZhbHVlcyBhbmQgd2l0aG91dCBkZWZhdWx0cyB0ZXN0cyBmYWlsXG5cbiAgdmFyIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgfTtcbiAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueVxuICAgIH07XG4gIH1cblxuICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgfTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5cblxuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQ7XG4gIHZhciBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcDtcbiAgdmFyIHZlbG9jaXR5O1xuICB2YXIgdmVsb2NpdHlYO1xuICB2YXIgdmVsb2NpdHlZO1xuICB2YXIgZGlyZWN0aW9uO1xuXG4gIGlmIChpbnB1dC5ldmVudFR5cGUgIT09IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcbiAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgdmVsb2NpdHkgPSBhYnModi54KSA+IGFicyh2LnkpID8gdi54IDogdi55O1xuICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG4gICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xuICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICB9XG5cbiAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbn1cbi8qKlxuKiBAcHJpdmF0ZVxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5cblxuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDsgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuXG4gIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICB9IC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcblxuXG4gIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQsXG4gICAgICBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICB2YXIgb2Zmc2V0Q2VudGVyID0gZmlyc3RNdWx0aXBsZSA/IGZpcnN0TXVsdGlwbGUuY2VudGVyIDogZmlyc3RJbnB1dC5jZW50ZXI7XG4gIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICBpbnB1dC50aW1lU3RhbXAgPSBub3ckMygpO1xuICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcbiAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcbiAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcbiAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBpbnB1dC5wb2ludGVycy5sZW5ndGggPiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzO1xuICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpOyAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuXG4gIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICB2YXIgc3JjRXZlbnRUYXJnZXQ7XG5cbiAgaWYgKHNyY0V2ZW50LmNvbXBvc2VkUGF0aCkge1xuICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gIH0gZWxzZSBpZiAoc3JjRXZlbnQucGF0aCkge1xuICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQucGF0aFswXTtcbiAgfSBlbHNlIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LnRhcmdldDtcbiAgfVxuXG4gIGlmIChoYXNQYXJlbnQoc3JjRXZlbnRUYXJnZXQsIHRhcmdldCkpIHtcbiAgICB0YXJnZXQgPSBzcmNFdmVudFRhcmdldDtcbiAgfVxuXG4gIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cblxuXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICB2YXIgaXNGaXJzdCA9IGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuICB2YXIgaXNGaW5hbCA9IGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xuXG4gIGlmIChpc0ZpcnN0KSB7XG4gICAgbWFuYWdlci5zZXNzaW9uID0ge307XG4gIH0gLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcbiAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG5cblxuICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7IC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuXG4gIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpOyAvLyBlbWl0IHNlY3JldCBldmVudFxuXG4gIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XG4gIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXG4gKi9cblxuXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cblxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5wdXQobWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0OyAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAqIEB2aXJ0dWFsXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7fTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgKi9cblxuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICB9O1xuXG4gIHJldHVybiBJbnB1dDtcbn0oKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seUZpbGxcbiAqIEBwYXJhbSB7QXJyYXl9IHNyY1xuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmluZEJ5S2V5XVxuICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICBpZiAoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQgfHwgIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpIHtcbiAgICAgICAgLy8gZG8gbm90IHVzZSA9PT0gaGVyZSwgdGVzdCBmYWlsc1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxufVxuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTsgLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cblxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gIDM6IElOUFVUX1RZUEVfUEVOLFxuICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcblxufTtcbnZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnOyAvLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcblxuaWYgKHdpbi5NU1BvaW50ZXJFdmVudCAmJiAhd2luLlBvaW50ZXJFdmVudCkge1xuICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG5cbnZhciBQb2ludGVyRXZlbnRJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gIF9pbmhlcml0c0xvb3NlKFBvaW50ZXJFdmVudElucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwcm90byA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZTtcbiAgICBwcm90by5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcbiAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RvcmUgPSBfdGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gUG9pbnRlckV2ZW50SW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcbiAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG4gICAgdmFyIGlzVG91Y2ggPSBwb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9UT1VDSDsgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcblxuICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7IC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgIH0gLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG5cblxuICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcblxuXG4gICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcblxuICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBvaW50ZXJFdmVudElucHV0O1xufShJbnB1dCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICovXG5cblxuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuXG4gICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgfVxuXG4gICAgdmFsdWVzW2ldID0gdmFsO1xuICAgIGkrKztcbiAgfVxuXG4gIGlmIChzb3J0KSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBUb3VjaElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5wdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVG91Y2hJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBUb3VjaElucHV0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIFRvdWNoSW5wdXQucHJvdG90eXBlLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudGFyZ2V0SWRzID0ge307IC8vIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRvdWNoSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgIGlmICghdG91Y2hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFRvdWNoSW5wdXQ7XG59KElucHV0KTtcblxuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gIHZhciB0YXJnZXRJZHMgPSB0aGlzLnRhcmdldElkczsgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcblxuICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gIH1cblxuICB2YXIgaTtcbiAgdmFyIHRhcmdldFRvdWNoZXM7XG4gIHZhciBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuICB2YXIgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXTtcbiAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0OyAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG5cbiAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICB9KTsgLy8gY29sbGVjdCB0b3VjaGVzXG5cbiAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICBpKys7XG4gICAgfVxuICB9IC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcblxuXG4gIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgfSAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuXG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIFsvLyBtZXJnZSB0YXJnZXRUb3VjaGVzIHdpdGggY2hhbmdlZFRhcmdldFRvdWNoZXMgc28gaXQgY29udGFpbnMgQUxMIHRvdWNoZXMsIGluY2x1ZGluZyAnZW5kJyBhbmQgJ2NhbmNlbCdcbiAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLCBjaGFuZ2VkVGFyZ2V0VG91Y2hlc107XG59XG5cbnZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgbW91c2V1cDogSU5QVVRfRU5EXG59O1xudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBNb3VzZSBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgTW91c2VJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gIF9pbmhlcml0c0xvb3NlKE1vdXNlSW5wdXQsIF9JbnB1dCk7XG5cbiAgZnVuY3Rpb24gTW91c2VJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgcHJvdG8gPSBNb3VzZUlucHV0LnByb3RvdHlwZTtcbiAgICBwcm90by5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgcHJvdG8uZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBNb3VzZUlucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdOyAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICB9IC8vIG1vdXNlIG11c3QgYmUgZG93blxuXG5cbiAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTW91c2VJbnB1dDtcbn0oSW5wdXQpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gKlxuICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cblxudmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xudmFyIERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcbiAgdmFyIF9ldmVudERhdGEkY2hhbmdlZFBvaSA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnMsXG4gICAgICB0b3VjaCA9IF9ldmVudERhdGEkY2hhbmdlZFBvaVswXTtcblxuICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICB2YXIgbGFzdFRvdWNoID0ge1xuICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgIHk6IHRvdWNoLmNsaWVudFlcbiAgICB9O1xuICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgIHRoaXMubGFzdFRvdWNoZXMucHVzaChsYXN0VG91Y2gpO1xuXG4gICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uIHJlbW92ZUxhc3RUb3VjaCgpIHtcbiAgICAgIHZhciBpID0gbHRzLmluZGV4T2YobGFzdFRvdWNoKTtcblxuICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZXRUaW1lb3V0KHJlbW92ZUxhc3RUb3VjaCwgREVEVVBfVElNRU9VVCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkVG91Y2hlcyhldmVudFR5cGUsIGV2ZW50RGF0YSkge1xuICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICB0aGlzLnByaW1hcnlUb3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcjtcbiAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KGV2ZW50RGF0YSkge1xuICB2YXIgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYO1xuICB2YXIgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcbiAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdC54KTtcbiAgICB2YXIgZHkgPSBNYXRoLmFicyh5IC0gdC55KTtcblxuICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgVG91Y2hNb3VzZUlucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIFRvdWNoTW91c2VJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lucHV0KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoVG91Y2hNb3VzZUlucHV0LCBfSW5wdXQpO1xuXG4gICAgZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KF9tYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9JbnB1dC5jYWxsKHRoaXMsIF9tYW5hZ2VyLCBjYWxsYmFjaykgfHwgdGhpcztcblxuICAgICAgX3RoaXMuaGFuZGxlciA9IGZ1bmN0aW9uIChtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0g7XG4gICAgICAgIHZhciBpc01vdXNlID0gaW5wdXREYXRhLnBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX01PVVNFO1xuXG4gICAgICAgIGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG5cblxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgIHJlY29yZFRvdWNoZXMuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgaW5wdXREYXRhKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KF90aGlzLm1hbmFnZXIsIF90aGlzLmhhbmRsZXIpO1xuICAgICAgX3RoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dChfdGhpcy5tYW5hZ2VyLCBfdGhpcy5oYW5kbGVyKTtcbiAgICAgIF90aGlzLnByaW1hcnlUb3VjaCA9IG51bGw7XG4gICAgICBfdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cblxuXG4gICAgdmFyIF9wcm90byA9IFRvdWNoTW91c2VJbnB1dC5wcm90b3R5cGU7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuXG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvdWNoTW91c2VJbnB1dDtcbiAgfShJbnB1dCk7XG5cbiAgcmV0dXJuIFRvdWNoTW91c2VJbnB1dDtcbn0oKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgdmFyIFR5cGU7IC8vIGxldCBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcblxuICBpZiAoaW5wdXRDbGFzcykge1xuICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgfSBlbHNlIHtcbiAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUeXBlKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaW52b2tlQXJyYXlBcmcoYXJnLCBmbiwgY29udGV4dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xuXG52YXIgX3VuaXF1ZUlkID0gMTtcblxuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gIHJldHVybiBfdW5pcXVlSWQrKztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xuXG4gIGlmIChtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gIH1cblxuICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge2NvbnN0YW50fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgIHJldHVybiAnY2FuY2VsJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgIHJldHVybiAnbW92ZSc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuXG52YXIgUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBlbmFibGU6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsOyAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgIGFzc2lnbiQxJDEodGhpcy5vcHRpb25zLCBvcHRpb25zKTsgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcblxuICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8ucmVjb2duaXplV2l0aCA9IGZ1bmN0aW9uIHJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcblxuICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG5cblxuICBfcHJvdG8uZHJvcFJlY29nbml6ZVdpdGggPSBmdW5jdGlvbiBkcm9wUmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlcXVpcmVGYWlsdXJlID0gZnVuY3Rpb24gcmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuXG4gICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmRyb3BSZXF1aXJlRmFpbHVyZSA9IGZ1bmN0aW9uIGRyb3BSZXF1aXJlRmFpbHVyZShvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG5cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBfcHJvdG8uaGFzUmVxdWlyZUZhaWx1cmVzID0gZnVuY3Rpb24gaGFzUmVxdWlyZUZhaWx1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgX3Byb3RvLmNhblJlY29nbml6ZVdpdGggPSBmdW5jdGlvbiBjYW5SZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgIH0gLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG5cblxuICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgfVxuXG4gICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7XG4gICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICB9IC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG5cblxuICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cblxuXG4gIF9wcm90by50cnlFbWl0ID0gZnVuY3Rpb24gdHJ5RW1pdChpbnB1dCkge1xuICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgfSAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG5cblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYW4gd2UgZW1pdD9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgX3Byb3RvLmNhbkVtaXQgPSBmdW5jdGlvbiBjYW5FbWl0KCkge1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlY29nbml6ZSA9IGZ1bmN0aW9uIHJlY29nbml6ZShpbnB1dERhdGEpIHtcbiAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgdmFyIGlucHV0RGF0YUNsb25lID0gYXNzaWduJDEkMSh7fSwgaW5wdXREYXRhKTsgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG5cbiAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcblxuXG4gICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTsgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuXG4gICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAqIEB2aXJ0dWFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICogQHJldHVybnMge2NvbnN0YW50fSBTVEFURVxuICAgKi9cblxuICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5cblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXREYXRhKSB7fTtcbiAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAqIEB2aXJ0dWFsXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG5cblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHt9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgKiBAdmlydHVhbFxuICAgKi9cblxuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge307XG5cbiAgcmV0dXJuIFJlY29nbml6ZXI7XG59KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBBIHRhcCBpcyByZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gKiBhIHNpbmdsZSB0YXAuXG4gKlxuICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBUYXBSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShUYXBSZWNvZ25pemVyLCBfUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gVGFwUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3RhcCcsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRhcHM6IDEsXG4gICAgICBpbnRlcnZhbDogMzAwLFxuICAgICAgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgIHRpbWU6IDI1MCxcbiAgICAgIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICB0aHJlc2hvbGQ6IDksXG4gICAgICAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgcG9zVGhyZXNob2xkOiAxMFxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzOyAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG5cbiAgICBfdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgIF90aGlzLnBDZW50ZXIgPSBmYWxzZTtcbiAgICBfdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIF90aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgX3RoaXMuY291bnQgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUYXBSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgdGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICB9IC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuXG5cbiAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwgOiB0cnVlO1xuICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0OyAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuXG4gICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuXG4gICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG5cbiAgICAgICAgICAgIF90aGlzMi50cnlFbWl0KCk7XG4gICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfTtcblxuICBfcHJvdG8uZmFpbFRpbWVvdXQgPSBmdW5jdGlvbiBmYWlsVGltZW91dCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsKTtcbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRhcFJlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cblxuXG52YXIgQXR0clJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKEF0dHJSZWNvZ25pemVyLCBfUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gQXR0clJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBwb2ludGVyczogMVxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gQXR0clJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZXZlbnRUeXBlID0gaW5wdXQuZXZlbnRUeXBlO1xuICAgIHZhciBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7IC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcblxuICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICB9IGVsc2UgaWYgKGlzUmVjb2duaXplZCB8fCBpc1ZhbGlkKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9O1xuXG4gIHJldHVybiBBdHRyUmVjb2duaXplcjtcbn0oUmVjb2duaXplcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Y29uc3RhbnR9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICByZXR1cm4gJ2Rvd24nO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1VQKSB7XG4gICAgcmV0dXJuICd1cCc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICByZXR1cm4gJ3JpZ2h0JztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBQYW5SZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGFuUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBQYW5SZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3BhbicsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgICBfdGhpcy5wWCA9IG51bGw7XG4gICAgX3RoaXMucFkgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYW5SZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuXG4gICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9ucztcbiAgfTtcblxuICBfcHJvdG8uZGlyZWN0aW9uVGVzdCA9IGZ1bmN0aW9uIGRpcmVjdGlvblRlc3QoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7IC8vIGxvY2sgdG8gYXhpcz9cblxuICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgZGlyZWN0aW9uID0geCA9PT0gMCA/IERJUkVDVElPTl9OT05FIDogeCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgaGFzTW92ZWQgPSB4ICE9PSB0aGlzLnBYO1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJlY3Rpb24gPSB5ID09PSAwID8gRElSRUNUSU9OX05PTkUgOiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICBoYXNNb3ZlZCA9IHkgIT09IHRoaXMucFk7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmICggLy8gcmVwbGFjZSB3aXRoIGEgc3VwZXIgY2FsbFxuICAgIHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAhKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSk7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcblxuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIFBhblJlY29nbml6ZXI7XG59KEF0dHJSZWNvZ25pemVyKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIFN3aXBlXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5cblxudmFyIFN3aXBlUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN3aXBlUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgdmVsb2NpdHk6IDAuMyxcbiAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICBwb2ludGVyczogMVxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN3aXBlUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICB2YXIgdmVsb2NpdHk7XG5cbiAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJiBpbnB1dC5tYXhQb2ludGVycyA9PT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmIGFicyh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcblxuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbiwgaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBTd2lwZVJlY29nbml6ZXI7XG59KEF0dHJSZWNvZ25pemVyKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxuXG52YXIgUGluY2hSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGluY2hSZWNvZ25pemVyLCBfQXR0clJlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGluY2hSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgfTtcblxuICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgfVxuXG4gICAgX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBQaW5jaFJlY29nbml6ZXI7XG59KEF0dHJSZWNvZ25pemVyKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBSb3RhdGVSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUm90YXRlUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAncm90YXRlJyxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUm90YXRlUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICB9O1xuXG4gIHJldHVybiBSb3RhdGVSZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuXG5cbnZhciBQcmVzc1JlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFByZXNzUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFByZXNzUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgdGltZTogMjUxLFxuICAgICAgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgIHRocmVzaG9sZDogOVxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICAgIF90aGlzLl90aW1lciA9IG51bGw7XG4gICAgX3RoaXMuX2lucHV0ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUHJlc3NSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcbiAgfTtcblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7IC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuXG4gICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuXG4gICAgICAgIF90aGlzMi50cnlFbWl0KCk7XG4gICAgICB9LCBvcHRpb25zLnRpbWUpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIH07XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBcInVwXCIsIGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5wdXQudGltZVN0YW1wID0gbm93JDMoKTtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUHJlc3NSZWNvZ25pemVyO1xufShSZWNvZ25pemVyKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkb21FdmVudHM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cbiAgICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGNvbXB1dGVcbiAgICovXG4gIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZTogdHJ1ZSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cbiAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGlucHV0VGFyZ2V0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgaW5wdXRDbGFzczogbnVsbCxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cbiAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuICBjc3NQcm9wczoge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdXNlclNlbGVjdDogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdG91Y2hTZWxlY3Q6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxuICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB0b3VjaENhbGxvdXQ6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAqL1xuICAgIGNvbnRlbnRab29taW5nOiBcIm5vbmVcIixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdXNlckRyYWc6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAqL1xuICAgIHRhcEhpZ2hsaWdodENvbG9yOiBcInJnYmEoMCwwLDAsMClcIlxuICB9XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICogVGhpcyBpcyBzZXBhcmF0ZWQgd2l0aCBvdGhlciBkZWZhdWx0cyBiZWNhdXNlIG9mIHRyZWUtc2hha2luZy5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG52YXIgcHJlc2V0ID0gW1tSb3RhdGVSZWNvZ25pemVyLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn1dLCBbUGluY2hSZWNvZ25pemVyLCB7XG4gIGVuYWJsZTogZmFsc2Vcbn0sIFsncm90YXRlJ11dLCBbU3dpcGVSZWNvZ25pemVyLCB7XG4gIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUxcbn1dLCBbUGFuUmVjb2duaXplciwge1xuICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMXG59LCBbJ3N3aXBlJ11dLCBbVGFwUmVjb2duaXplcl0sIFtUYXBSZWNvZ25pemVyLCB7XG4gIGV2ZW50OiAnZG91YmxldGFwJyxcbiAgdGFwczogMlxufSwgWyd0YXAnXV0sIFtQcmVzc1JlY29nbml6ZXJdXTtcbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcblxuICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJvcDtcbiAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgIHByb3AgPSBwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKTtcblxuICAgIGlmIChhZGQpIHtcbiAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSB8fCBcIlwiO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCFhZGQpIHtcbiAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cblxuXG5mdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgdmFyIGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbn1cbi8qKlxuKiBAcHJpdmF0ZVxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24kMSQxKHt9LCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcmVjb2duaXplciA9IF90aGlzLmFkZChuZXcgaXRlbVswXShpdGVtWzFdKSk7XG5cbiAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gICAgYXNzaWduJDEkMSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG5cbiAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICovXG5cblxuICBfcHJvdG8uc3RvcCA9IGZ1bmN0aW9uIHN0b3AoZm9yY2UpIHtcbiAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgKi9cblxuXG4gIF9wcm90by5yZWNvZ25pemUgPSBmdW5jdGlvbiByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG5cbiAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuXG5cbiAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuICAgIHZhciByZWNvZ25pemVyO1xuICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7IC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG5cbiAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjsgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cblxuICAgIGlmICghY3VyUmVjb2duaXplciB8fCBjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTsgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cblxuICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHtcbiAgICAgICAgLy8gM1xuICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgfSAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG5cblxuICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgIHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgIGN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgKi9cblxuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQocmVjb2duaXplcikge1xuICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfVxuXG4gICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09PSByZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICovXG5cblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgXCJhZGRcIiwgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gcmVtb3ZlIGV4aXN0aW5nXG5cblxuICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG5cbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcbiAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgIHJldHVybiByZWNvZ25pemVyO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShyZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsIFwicmVtb3ZlXCIsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0UmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpOyAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuXG4gICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCB0YXJnZXRSZWNvZ25pemVyKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYmluZCBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCB8fCBoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGUgdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5vZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuXG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgIH0gLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG5cblxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG5cbiAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhLnR5cGUgPSBldmVudDtcblxuICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICovXG5cblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gTWFuYWdlcjtcbn0oKTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIFNpbmdsZVRvdWNoSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShTaW5nbGVUb3VjaElucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHByb3RvID0gU2luZ2xlVG91Y2hJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNpbmdsZVRvdWNoSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTsgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpOyAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFNpbmdsZVRvdWNoSW5wdXQ7XG59KElucHV0KTtcblxuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5cblxuZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICB2YXIgZGVwcmVjYXRpb25NZXNzYWdlID0gXCJERVBSRUNBVEVEIE1FVEhPRDogXCIgKyBuYW1lICsgXCJcXG5cIiArIG1lc3NhZ2UgKyBcIiBBVCBcXG5cIjtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgdmFyIHN0YWNrID0gZSAmJiBlLnN0YWNrID8gZS5zdGFjay5yZXBsYWNlKC9eW15cXChdKz9bXFxuJF0vZ20sICcnKS5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcbiAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcblxuICAgIGlmIChsb2cpIHtcbiAgICAgIGxvZy5jYWxsKHdpbmRvdy5jb25zb2xlLCBkZXByZWNhdGlvbk1lc3NhZ2UsIHN0YWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cblxuXG52YXIgZXh0ZW5kID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICBpZiAoIW1lcmdlIHx8IG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICB9XG5cbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn0sICdleHRlbmQnLCAnVXNlIGBhc3NpZ25gLicpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG5cbnZhciBtZXJnZSQxID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChkZXN0LCBzcmMpIHtcbiAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuXG5mdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBiYXNlUCA9IGJhc2UucHJvdG90eXBlO1xuICB2YXIgY2hpbGRQO1xuICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICBpZiAocHJvcGVydGllcykge1xuICAgIGFzc2lnbiQxJDEoY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBib3VuZEZuKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIEhhbW1lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBIYW1tZXIgPVxuICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICAqL1xuICBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgX2V4dGVuZHMoe1xuICAgICAgcmVjb2duaXplcnM6IHByZXNldC5jb25jYXQoKVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICBIYW1tZXIuVkVSU0lPTiA9IFwiMi4wLjE3LXJjXCI7XG4gIEhhbW1lci5ESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0FMTDtcbiAgSGFtbWVyLkRJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG4gIEhhbW1lci5ESVJFQ1RJT05fTEVGVCA9IERJUkVDVElPTl9MRUZUO1xuICBIYW1tZXIuRElSRUNUSU9OX1JJR0hUID0gRElSRUNUSU9OX1JJR0hUO1xuICBIYW1tZXIuRElSRUNUSU9OX1VQID0gRElSRUNUSU9OX1VQO1xuICBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTDtcbiAgSGFtbWVyLkRJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9WRVJUSUNBTDtcbiAgSGFtbWVyLkRJUkVDVElPTl9OT05FID0gRElSRUNUSU9OX05PTkU7XG4gIEhhbW1lci5ESVJFQ1RJT05fRE9XTiA9IERJUkVDVElPTl9ET1dOO1xuICBIYW1tZXIuSU5QVVRfU1RBUlQgPSBJTlBVVF9TVEFSVDtcbiAgSGFtbWVyLklOUFVUX01PVkUgPSBJTlBVVF9NT1ZFO1xuICBIYW1tZXIuSU5QVVRfRU5EID0gSU5QVVRfRU5EO1xuICBIYW1tZXIuSU5QVVRfQ0FOQ0VMID0gSU5QVVRfQ0FOQ0VMO1xuICBIYW1tZXIuU1RBVEVfUE9TU0lCTEUgPSBTVEFURV9QT1NTSUJMRTtcbiAgSGFtbWVyLlNUQVRFX0JFR0FOID0gU1RBVEVfQkVHQU47XG4gIEhhbW1lci5TVEFURV9DSEFOR0VEID0gU1RBVEVfQ0hBTkdFRDtcbiAgSGFtbWVyLlNUQVRFX0VOREVEID0gU1RBVEVfRU5ERUQ7XG4gIEhhbW1lci5TVEFURV9SRUNPR05JWkVEID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgSGFtbWVyLlNUQVRFX0NBTkNFTExFRCA9IFNUQVRFX0NBTkNFTExFRDtcbiAgSGFtbWVyLlNUQVRFX0ZBSUxFRCA9IFNUQVRFX0ZBSUxFRDtcbiAgSGFtbWVyLk1hbmFnZXIgPSBNYW5hZ2VyO1xuICBIYW1tZXIuSW5wdXQgPSBJbnB1dDtcbiAgSGFtbWVyLlRvdWNoQWN0aW9uID0gVG91Y2hBY3Rpb247XG4gIEhhbW1lci5Ub3VjaElucHV0ID0gVG91Y2hJbnB1dDtcbiAgSGFtbWVyLk1vdXNlSW5wdXQgPSBNb3VzZUlucHV0O1xuICBIYW1tZXIuUG9pbnRlckV2ZW50SW5wdXQgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgSGFtbWVyLlRvdWNoTW91c2VJbnB1dCA9IFRvdWNoTW91c2VJbnB1dDtcbiAgSGFtbWVyLlNpbmdsZVRvdWNoSW5wdXQgPSBTaW5nbGVUb3VjaElucHV0O1xuICBIYW1tZXIuUmVjb2duaXplciA9IFJlY29nbml6ZXI7XG4gIEhhbW1lci5BdHRyUmVjb2duaXplciA9IEF0dHJSZWNvZ25pemVyO1xuICBIYW1tZXIuVGFwID0gVGFwUmVjb2duaXplcjtcbiAgSGFtbWVyLlBhbiA9IFBhblJlY29nbml6ZXI7XG4gIEhhbW1lci5Td2lwZSA9IFN3aXBlUmVjb2duaXplcjtcbiAgSGFtbWVyLlBpbmNoID0gUGluY2hSZWNvZ25pemVyO1xuICBIYW1tZXIuUm90YXRlID0gUm90YXRlUmVjb2duaXplcjtcbiAgSGFtbWVyLlByZXNzID0gUHJlc3NSZWNvZ25pemVyO1xuICBIYW1tZXIub24gPSBhZGRFdmVudExpc3RlbmVycztcbiAgSGFtbWVyLm9mZiA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzO1xuICBIYW1tZXIuZWFjaCA9IGVhY2g7XG4gIEhhbW1lci5tZXJnZSA9IG1lcmdlJDE7XG4gIEhhbW1lci5leHRlbmQgPSBleHRlbmQ7XG4gIEhhbW1lci5iaW5kRm4gPSBiaW5kRm47XG4gIEhhbW1lci5hc3NpZ24gPSBhc3NpZ24kMSQxO1xuICBIYW1tZXIuaW5oZXJpdCA9IGluaGVyaXQ7XG4gIEhhbW1lci5iaW5kRm4gPSBiaW5kRm47XG4gIEhhbW1lci5wcmVmaXhlZCA9IHByZWZpeGVkO1xuICBIYW1tZXIudG9BcnJheSA9IHRvQXJyYXk7XG4gIEhhbW1lci5pbkFycmF5ID0gaW5BcnJheTtcbiAgSGFtbWVyLnVuaXF1ZUFycmF5ID0gdW5pcXVlQXJyYXk7XG4gIEhhbW1lci5zcGxpdFN0ciA9IHNwbGl0U3RyO1xuICBIYW1tZXIuYm9vbE9yRm4gPSBib29sT3JGbjtcbiAgSGFtbWVyLmhhc1BhcmVudCA9IGhhc1BhcmVudDtcbiAgSGFtbWVyLmFkZEV2ZW50TGlzdGVuZXJzID0gYWRkRXZlbnRMaXN0ZW5lcnM7XG4gIEhhbW1lci5yZW1vdmVFdmVudExpc3RlbmVycyA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzO1xuICBIYW1tZXIuZGVmYXVsdHMgPSBhc3NpZ24kMSQxKHt9LCBkZWZhdWx0cywge1xuICAgIHByZXNldDogcHJlc2V0XG4gIH0pO1xuICByZXR1cm4gSGFtbWVyO1xufSgpOyAvLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cblxuLyoqXG4gKiBTZXR1cCBhIG1vY2sgaGFtbWVyLmpzIG9iamVjdCwgZm9yIHVuaXQgdGVzdGluZy5cbiAqXG4gKiBJbnNwaXJhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL3ViZXIvZGVjay5nbC9wdWxsLzY1OFxuICpcbiAqIEByZXR1cm5zIHt7b246IG5vb3AsIG9mZjogbm9vcCwgZGVzdHJveTogbm9vcCwgZW1pdDogbm9vcCwgZ2V0OiBnZXR9fVxuICovXG5cbmZ1bmN0aW9uIGhhbW1lck1vY2soKSB7XG4gIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4gIHJldHVybiB7XG4gICAgb246IG5vb3AsXG4gICAgb2ZmOiBub29wLFxuICAgIGRlc3Ryb3k6IG5vb3AsXG4gICAgZW1pdDogbm9vcCxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNldDogbm9vcFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBIYW1tZXIkMSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuSGFtbWVyIHx8IEhhbW1lciA6IGZ1bmN0aW9uICgpIHtcbiAgLy8gaGFtbWVyLmpzIGlzIG9ubHkgYXZhaWxhYmxlIGluIGEgYnJvd3Nlciwgbm90IGluIG5vZGUuanMuIFJlcGxhY2luZyBpdCB3aXRoIGEgbW9jayBvYmplY3QuXG4gIHJldHVybiBoYW1tZXJNb2NrKCk7XG59O1xuXG4vKipcbiAqIFR1cm4gYW4gZWxlbWVudCBpbnRvIGFuIGNsaWNrVG9Vc2UgZWxlbWVudC5cbiAqIFdoZW4gbm90IGFjdGl2ZSwgdGhlIGVsZW1lbnQgaGFzIGEgdHJhbnNwYXJlbnQgb3ZlcmxheS4gV2hlbiB0aGUgb3ZlcmxheSBpc1xuICogY2xpY2tlZCwgdGhlIG1vZGUgaXMgY2hhbmdlZCB0byBhY3RpdmUuXG4gKiBXaGVuIGFjdGl2ZSwgdGhlIGVsZW1lbnQgaXMgZGlzcGxheWVkIHdpdGggYSBibHVlIGJvcmRlciBhcm91bmQgaXQsIGFuZFxuICogdGhlIGludGVyYWN0aXZlIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50IGNhbiBiZSB1c2VkLiBXaGVuIGNsaWNrZWQgb3V0c2lkZVxuICogdGhlIGVsZW1lbnQsIHRoZSBlbGVtZW50cyBtb2RlIGlzIGNoYW5nZWQgdG8gaW5hY3RpdmUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAqIEBjbGFzcyBBY3RpdmF0b3JcbiAqL1xuXG5mdW5jdGlvbiBBY3RpdmF0b3IoY29udGFpbmVyKSB7XG4gIHZhciBfY29udGV4dCxcbiAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgIF9jb250ZXh0MjtcblxuICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLmRvbSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICB9O1xuICB0aGlzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgdGhpcy5kb20ub3ZlcmxheS5jbGFzc05hbWUgPSBcInZpcy1vdmVybGF5XCI7XG4gIHRoaXMuZG9tLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5vdmVybGF5KTtcbiAgdGhpcy5oYW1tZXIgPSBIYW1tZXIkMSh0aGlzLmRvbS5vdmVybGF5KTtcbiAgdGhpcy5oYW1tZXIub24oXCJ0YXBcIiwgYmluZCQyKF9jb250ZXh0ID0gdGhpcy5fb25UYXBPdmVybGF5KS5jYWxsKF9jb250ZXh0LCB0aGlzKSk7IC8vIGJsb2NrIGFsbCB0b3VjaCBldmVudHMgKGV4Y2VwdCB0YXApXG5cbiAgdmFyIGV2ZW50cyA9IFtcInRhcFwiLCBcImRvdWJsZXRhcFwiLCBcInByZXNzXCIsIFwicGluY2hcIiwgXCJwYW5cIiwgXCJwYW5zdGFydFwiLCBcInBhbm1vdmVcIiwgXCJwYW5lbmRcIl07XG5cbiAgZm9yRWFjaCQyKGV2ZW50cykuY2FsbChldmVudHMsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIF90aGlzLmhhbW1lci5vbihldmVudCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgfSk7IC8vIGF0dGFjaCBhIGNsaWNrIGV2ZW50IHRvIHRoZSB3aW5kb3csIGluIG9yZGVyIHRvIGRlYWN0aXZhdGUgd2hlbiBjbGlja2luZyBvdXRzaWRlIHRoZSB0aW1lbGluZVxuXG5cbiAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICB0aGlzLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX2hhc1BhcmVudChldmVudC50YXJnZXQsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm9uQ2xpY2spO1xuICB9XG5cbiAgaWYgKHRoaXMua2V5Y2hhcm0gIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICB9XG5cbiAgdGhpcy5rZXljaGFybSA9IGtleWNoYXJtKCk7IC8vIGtleWNoYXJtIGxpc3RlbmVyIG9ubHkgYm91bmRlZCB3aGVuIGFjdGl2ZSlcblxuICB0aGlzLmVzY0xpc3RlbmVyID0gYmluZCQyKF9jb250ZXh0MiA9IHRoaXMuZGVhY3RpdmF0ZSkuY2FsbChfY29udGV4dDIsIHRoaXMpO1xufSAvLyB0dXJuIGludG8gYW4gZXZlbnQgZW1pdHRlclxuXG5cbmNvbXBvbmVudEVtaXR0ZXIoQWN0aXZhdG9yLnByb3RvdHlwZSk7IC8vIFRoZSBjdXJyZW50bHkgYWN0aXZlIGFjdGl2YXRvclxuXG5BY3RpdmF0b3IuY3VycmVudCA9IG51bGw7XG4vKipcbiAqIERlc3Ryb3kgdGhlIGFjdGl2YXRvci4gQ2xlYW5zIHVwIGFsbCBjcmVhdGVkIERPTSBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gKi9cblxuQWN0aXZhdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRlYWN0aXZhdGUoKTsgLy8gcmVtb3ZlIGRvbVxuXG4gIHRoaXMuZG9tLm92ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5vdmVybGF5KTsgLy8gcmVtb3ZlIGdsb2JhbCBldmVudCBsaXN0ZW5lclxuXG4gIGlmICh0aGlzLm9uQ2xpY2spIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm9uQ2xpY2spO1xuICB9IC8vIHJlbW92ZSBrZXljaGFybVxuXG5cbiAgaWYgKHRoaXMua2V5Y2hhcm0gIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICB9XG5cbiAgdGhpcy5rZXljaGFybSA9IG51bGw7IC8vIGNsZWFudXAgaGFtbWVyIGluc3RhbmNlc1xuXG4gIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgdGhpcy5oYW1tZXIgPSBudWxsOyAvLyBGSVhNRTogY2xlYW5pbmcgdXAgaGFtbWVyIGluc3RhbmNlcyBkb2Vzbid0IHdvcmsgKFRpbWVsaW5lIG5vdCByZW1vdmVkIGZyb20gbWVtb3J5KVxufTtcbi8qKlxuICogQWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgaGlkZGVuLCBlbGVtZW50IGlzIGRlY29yYXRlZCB3aXRoIGEgYmx1ZSBzaGFkb3cgYm9yZGVyXG4gKi9cblxuXG5BY3RpdmF0b3IucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX2NvbnRleHQzO1xuXG4gIC8vIHdlIGFsbG93IG9ubHkgb25lIGFjdGl2ZSBhY3RpdmF0b3IgYXQgYSB0aW1lXG4gIGlmIChBY3RpdmF0b3IuY3VycmVudCkge1xuICAgIEFjdGl2YXRvci5jdXJyZW50LmRlYWN0aXZhdGUoKTtcbiAgfVxuXG4gIEFjdGl2YXRvci5jdXJyZW50ID0gdGhpcztcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmNvbnRhaW5lciwgXCJ2aXMtYWN0aXZlXCIpO1xuICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIHRoaXMuZW1pdChcImFjdGl2YXRlXCIpOyAvLyB1Z2x5IGhhY2s6IGJpbmQgRVNDIGFmdGVyIGVtaXR0aW5nIHRoZSBldmVudHMsIGFzIHRoZSBOZXR3b3JrIHJlYmluZHMgYWxsXG4gIC8vIGtleWJvYXJkIGV2ZW50cyBvbiBhICdjaGFuZ2UnIGV2ZW50XG5cbiAgYmluZCQyKF9jb250ZXh0MyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQzLCBcImVzY1wiLCB0aGlzLmVzY0xpc3RlbmVyKTtcbn07XG4vKipcbiAqIERlYWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgZWxlbWVudFxuICovXG5cblxuQWN0aXZhdG9yLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLmRvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gIHJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5jb250YWluZXIsIFwidmlzLWFjdGl2ZVwiKTtcbiAgdGhpcy5rZXljaGFybS51bmJpbmQoXCJlc2NcIiwgdGhpcy5lc2NMaXN0ZW5lcik7XG4gIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgdGhpcy5lbWl0KFwiZGVhY3RpdmF0ZVwiKTtcbn07XG4vKipcbiAqIEhhbmRsZSBhIHRhcCBldmVudDogYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICpcbiAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuXG5cbkFjdGl2YXRvci5wcm90b3R5cGUuX29uVGFwT3ZlcmxheSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gIHRoaXMuYWN0aXZhdGUoKTtcbiAgZXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHRoZSByZXF1ZXN0ZWQgcGFyZW50IGVsZW1lbnQgc29tZXdoZXJlIGluXG4gKiBpdHMgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBwYXJlbnQgaXMgZm91bmQgc29tZXdoZXJlIGluIHRoZVxuICogICAgICAgICAgICAgICAgICAgIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBfaGFzUGFyZW50KGVsZW1lbnQsIHBhcmVudCkge1xuICB3aGlsZSAoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEVuZ2xpc2hcbnZhciBlbiA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiQ2xpY2sgaW4gYW4gZW1wdHkgc3BhY2UgdG8gcGxhY2UgYSBuZXcgbm9kZS5cIixcbiAgYWRkRWRnZTogXCJBZGQgRWRnZVwiLFxuICBhZGROb2RlOiBcIkFkZCBOb2RlXCIsXG4gIGJhY2s6IFwiQmFja1wiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiQ2Fubm90IGxpbmsgZWRnZXMgdG8gYSBjbHVzdGVyLlwiLFxuICBkZWw6IFwiRGVsZXRlIHNlbGVjdGVkXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBjYW5ub3QgYmUgZGVsZXRlZC5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkNsaWNrIG9uIGEgbm9kZSBhbmQgZHJhZyB0aGUgZWRnZSB0byBhbm90aGVyIG5vZGUgdG8gY29ubmVjdCB0aGVtLlwiLFxuICBlZGl0OiBcIkVkaXRcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJDbHVzdGVycyBjYW5ub3QgYmUgZWRpdGVkLlwiLFxuICBlZGl0RWRnZTogXCJFZGl0IEVkZ2VcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGljayBvbiB0aGUgY29udHJvbCBwb2ludHMgYW5kIGRyYWcgdGhlbSB0byBhIG5vZGUgdG8gY29ubmVjdCB0byBpdC5cIixcbiAgZWRpdE5vZGU6IFwiRWRpdCBOb2RlXCJcbn07IC8vIEdlcm1hblxuXG52YXIgZGUgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIktsaWNrZSBhdWYgZWluZSBmcmVpZSBTdGVsbGUsIHVtIGVpbmVuIG5ldWVuIEtub3RlbiB6dSBwbGF6aWVyZW4uXCIsXG4gIGFkZEVkZ2U6IFwiS2FudGUgaGluenVmXFx4RkNnZW5cIixcbiAgYWRkTm9kZTogXCJLbm90ZW4gaGluenVmXFx4RkNnZW5cIixcbiAgYmFjazogXCJadXJcXHhGQ2NrXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJFcyBpc3QgbmljaHQgbVxceEY2Z2xpY2gsIEthbnRlbiBtaXQgQ2x1c3Rlcm4genUgdmVyYmluZGVuLlwiLFxuICBkZWw6IFwiTFxceEY2c2NoZSBBdXN3YWhsXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJDbHVzdGVyIGtcXHhGNm5uZW4gbmljaHQgZ2VsXFx4RjZzY2h0IHdlcmRlbi5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIktsaWNrZSBhdWYgZWluZW4gS25vdGVuIHVuZCB6aWVoZSBkaWUgS2FudGUgenUgZWluZW0gYW5kZXJlbiBLbm90ZW4sIHVtIGRpZXNlIHp1IHZlcmJpbmRlbi5cIixcbiAgZWRpdDogXCJFZGl0aWVyZW5cIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJDbHVzdGVyIGtcXHhGNm5uZW4gbmljaHQgZWRpdGllcnQgd2VyZGVuLlwiLFxuICBlZGl0RWRnZTogXCJLYW50ZSBlZGl0aWVyZW5cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJLbGlja2UgYXVmIGRpZSBWZXJiaW5kdW5nc3B1bmt0ZSB1bmQgemllaGUgZGllc2UgYXVmIGVpbmVuIEtub3RlbiwgdW0gc2llIHp1IHZlcmJpbmRlbi5cIixcbiAgZWRpdE5vZGU6IFwiS25vdGVuIGVkaXRpZXJlblwiXG59OyAvLyBTcGFuaXNoXG5cbnZhciBlcyA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiSGFnYSBjbGljIGVuIHVuIGx1Z2FyIHZhY1xceEVEbyBwYXJhIGNvbG9jYXIgdW4gbnVldm8gbm9kby5cIixcbiAgYWRkRWRnZTogXCJBXFx4RjFhZGlyIGFyaXN0YVwiLFxuICBhZGROb2RlOiBcIkFcXHhGMWFkaXIgbm9kb1wiLFxuICBiYWNrOiBcIkF0clxceEUxc1wiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiTm8gc2UgcHVlZGUgY29uZWN0YXIgdW5hIGFyaXN0YSBhIHVuIGdydXBvLlwiLFxuICBkZWw6IFwiRWxpbWluYXIgc2VsZWNjaVxceEYzblwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiTm8gZXMgcG9zaWJsZSBlbGltaW5hciBncnVwb3MuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJIYWdhIGNsaWMgZW4gdW4gbm9kbyB5IGFycmFzdHJlIGxhIGFyaXN0YSBoYWNpYSBvdHJvIG5vZG8gcGFyYSBjb25lY3Rhcmxvcy5cIixcbiAgZWRpdDogXCJFZGl0YXJcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJObyBlcyBwb3NpYmxlIGVkaXRhciBncnVwb3MuXCIsXG4gIGVkaXRFZGdlOiBcIkVkaXRhciBhcmlzdGFcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJIYWdhIGNsaWMgZW4gdW4gcHVudG8gZGUgY29udHJvbCB5IGFycmFzdHJlbG8gYSB1biBub2RvIHBhcmEgY29uZWN0YXJsby5cIixcbiAgZWRpdE5vZGU6IFwiRWRpdGFyIG5vZG9cIlxufTsgLy9JdGFsaWFub1xuXG52YXIgaXQgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkNsaWNjYSBwZXIgYWdnaXVuZ2VyZSB1biBudW92byBub2RvXCIsXG4gIGFkZEVkZ2U6IFwiQWdnaXVuZ2kgdW4gdmVydGljZVwiLFxuICBhZGROb2RlOiBcIkFnZ2l1bmdpIHVuIG5vZG9cIixcbiAgYmFjazogXCJJbmRpZXRyb1wiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiTm9uIHNpIHBvc3Nvbm8gY29sbGVnYXJlIHZlcnRpY2kgYWQgdW4gY2x1c3RlclwiLFxuICBkZWw6IFwiQ2FuY2VsbGEgbGEgc2VsZXppb25lXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJJIGNsdXN0ZXIgbm9uIHBvc3Nvbm8gZXNzZXJlIGNhbmNlbGxhdGlcIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkNsaWNjYSBzdSB1biBub2RvIGUgdHJhc2NpbmFsbyBhZCB1biBhbHRybyBub2RvIHBlciBjb25uZXR0ZXJsaS5cIixcbiAgZWRpdDogXCJNb2RpZmljYVwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkkgY2x1c3RlcnMgbm9uIHBvc3Nvbm8gZXNzZXJlIG1vZGlmaWNhdGkuXCIsXG4gIGVkaXRFZGdlOiBcIk1vZGlmaWNhIGlsIHZlcnRpY2VcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGljY2Egc3VpIFB1bnRpIGRpIGNvbnRyb2xsbyBlIHRyYXNjaW5hbGkgYWQgdW4gbm9kbyBwZXIgY29ubmV0dGVybGkuXCIsXG4gIGVkaXROb2RlOiBcIk1vZGlmaWNhIGlsIG5vZG9cIlxufTsgLy8gRHV0Y2hcblxudmFyIG5sID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJLbGlrIG9wIGVlbiBsZWVnIGdlYmllZCBvbSBlZW4gbmlldXdlIG5vZGUgdGUgbWFrZW4uXCIsXG4gIGFkZEVkZ2U6IFwiTGluayB0b2V2b2VnZW5cIixcbiAgYWRkTm9kZTogXCJOb2RlIHRvZXZvZWdlblwiLFxuICBiYWNrOiBcIlRlcnVnXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJLYW4gZ2VlbiBsaW5rIG1ha2VuIG5hYXIgZWVuIGNsdXN0ZXIuXCIsXG4gIGRlbDogXCJTZWxlY3RpZSB2ZXJ3aWpkZXJlblwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMga3VubmVuIG5pZXQgd29yZGVuIHZlcndpamRlcmQuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJLbGlrIG9wIGVlbiBub2RlIGVuIHNsZWVwIGRlIGxpbmsgbmFhciBlZW4gYW5kZXJlIG5vZGUgb20gemUgdGUgdmVyYmluZGVuLlwiLFxuICBlZGl0OiBcIldpanppZ2VuXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMga3VubmVuIG5pZXQgd29yZGVuIGFhbmdlcGFzdC5cIixcbiAgZWRpdEVkZ2U6IFwiTGluayB3aWp6aWdlblwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIktsaWsgb3AgZGUgdmVyYmluZGluZ3NwdW50ZW4gZW4gc2xlZXAgemUgbmFhciBlZW4gbm9kZSBvbSBkYWFybWVlIHRlIHZlcmJpbmRlbi5cIixcbiAgZWRpdE5vZGU6IFwiTm9kZSB3aWp6aWdlblwiXG59OyAvLyBQb3J0dWd1ZXNlIEJyYXppbFxuXG52YXIgcHQgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkNsaXF1ZSBlbSB1bSBlc3Bhw6dvIGVtIGJyYW5jbyBwYXJhIGFkaWNpb25hciB1bSBub3ZvIG7Ds1wiLFxuICBhZGRFZGdlOiBcIkFkaWNpb25hciBhcmVzdGFcIixcbiAgYWRkTm9kZTogXCJBZGljaW9uYXIgbsOzXCIsXG4gIGJhY2s6IFwiVm9sdGFyXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJOw6NvIGZvaSBwb3Nzw612ZWwgbGlua2FyIGFyZXN0YXMgYSB1bSBjbHVzdGVyLlwiLFxuICBkZWw6IFwiUmVtb3ZlciBzZWxlY2lvbmFkb1wiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMgbsOjbyBwdWRlcmFtIHNlciByZW1vdmlkb3MuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJDbGlxdWUgZW0gdW0gbsOzIGUgYXJyYXN0ZSBhIGFyZXN0YSBhdMOpIG91dHJvIG7DsyBwYXJhIGNvbmVjdMOhLWxvc1wiLFxuICBlZGl0OiBcIkVkaXRhclwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIG7Do28gcHVkZXJhbSBzZXIgZWRpdGFkb3MuXCIsXG4gIGVkaXRFZGdlOiBcIkVkaXRhciBhcmVzdGFcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGlxdWUgbm9zIHBvbnRvcyBkZSBjb250cm9sZSBlIG9zIGFycmFzdGUgcGFyYSB1bSBuw7MgcGFyYSBjb25lY3TDoS1sb3NcIixcbiAgZWRpdE5vZGU6IFwiRWRpdGFyIG7Ds1wiXG59OyAvLyBSdXNzaWFuXG5cbnZhciBydSA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwi0JrQu9C40LrQvdC40YLQtSDQsiDRgdCy0L7QsdC+0LTQvdC+0LUg0LzQtdGB0YLQviwg0YfRgtC+0LHRiyDQtNC+0LHQsNCy0LjRgtGMINC90L7QstGL0Lkg0YPQt9C10LsuXCIsXG4gIGFkZEVkZ2U6IFwi0JTQvtCx0LDQstC40YLRjCDRgNC10LHRgNC+XCIsXG4gIGFkZE5vZGU6IFwi0JTQvtCx0LDQstC40YLRjCDRg9C30LXQu1wiLFxuICBiYWNrOiBcItCd0LDQt9Cw0LRcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcItCd0LXQstC+0LfQvNC+0LbQvdC+INGB0L7QtdC00LjQvdC40YLRjCDRgNC10LHRgNCwINCyINC60LvQsNGB0YLQtdGALlwiLFxuICBkZWw6IFwi0KPQtNCw0LvQuNGC0Ywg0LLRi9Cx0YDQsNC90L3QvtC1XCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCLQmtC70LDRgdGC0LXRgNGLINC90LUg0LzQvtCz0YPRgiDQsdGL0YLRjCDRg9C00LDQu9C10L3Ri1wiLFxuICBlZGdlRGVzY3JpcHRpb246IFwi0JrQu9C40LrQvdC40YLQtSDQvdCwINGD0LfQtdC7INC4INC/0YDQvtGC0Y/QvdC40YLQtSDRgNC10LHRgNC+INC6INC00YDRg9Cz0L7QvNGDINGD0LfQu9GDLCDRh9GC0L7QsdGLINGB0L7QtdC00LjQvdC40YLRjCDQuNGFLlwiLFxuICBlZGl0OiBcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwi0JrQu9Cw0YHRgtC10YDRiyDQvdC10LTQvtGB0YLRg9C/0L3RiyDQtNC70Y8g0YDQtdC00LDQutGC0LjRgNC+0LLQsNC90LjRjy5cIixcbiAgZWRpdEVkZ2U6IFwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0Ywg0YDQtdCx0YDQvlwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcItCa0LvQuNC60L3QuNGC0LUg0L3QsCDQutC+0L3RgtGA0L7Qu9GM0L3Ri9C1INGC0L7Rh9C60Lgg0Lgg0L/QtdGA0LXRgtCw0YnQuNGC0LUg0LjRhSDQsiDRg9C30LXQuywg0YfRgtC+0LHRiyDQv9C+0LTQutC70Y7Rh9C40YLRjNGB0Y8g0Log0L3QtdC80YMuXCIsXG4gIGVkaXROb2RlOiBcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMINGD0LfQtdC7XCJcbn07IC8vIENoaW5lc2VcblxudmFyIGNuID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCLljZXlh7vnqbrnmb3lpITmlL7nva7mlrDoioLngrnjgIJcIixcbiAgYWRkRWRnZTogXCLmt7vliqDov57mjqXnur9cIixcbiAgYWRkTm9kZTogXCLmt7vliqDoioLngrlcIixcbiAgYmFjazogXCLov5Tlm55cIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIuaXoOazleWwhui/nuaOpee6v+i/nuaOpeWIsOe+pOmbhuOAglwiLFxuICBkZWw6IFwi5Yig6Zmk6YCJ5a6aXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCLml6Dms5XliKDpmaTnvqTpm4bjgIJcIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIuWNleWHu+afkOS4quiKgueCueW5tuWwhuivpei/nuaOpee6v+aLluWKqOWIsOWPpuS4gOS4quiKgueCueS7pei/nuaOpeWug+S7rOOAglwiLFxuICBlZGl0OiBcIue8lui+kVwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIuaXoOazlee8lui+kee+pOmbhuOAglwiLFxuICBlZGl0RWRnZTogXCLnvJbovpHov57mjqXnur9cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCLljZXlh7vmjqfliLboioLngrnlubblsIblroPku6zmi5bliLDoioLngrnkuIrov57mjqXjgIJcIixcbiAgZWRpdE5vZGU6IFwi57yW6L6R6IqC54K5XCJcbn07IC8vIFVrcmFpbmlhblxuXG52YXIgdWsgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkvQu9GW0LrQvdGW0YLRjCDQvdCwINCy0ZbQu9GM0L3QtSDQvNGW0YHRhtC1LCDRidC+0LEg0LTQvtC00LDRgtC4INC90L7QstC40Lkg0LLRg9C30L7Quy5cIixcbiAgYWRkRWRnZTogXCLQlNC+0LTQsNGC0Lgg0LrRgNCw0LlcIixcbiAgYWRkTm9kZTogXCLQlNC+0LTQsNGC0Lgg0LLRg9C30L7Qu1wiLFxuICBiYWNrOiBcItCd0LDQt9Cw0LRcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcItCd0LUg0LzQvtC20LvQuNCy0L4g0L7QsSfRlNC00L3QsNGC0Lgg0LrRgNCw0Zcg0LIg0LPRgNGD0L/Rgy5cIixcbiAgZGVsOiBcItCS0LjQtNCw0LvQuNGC0Lgg0L7QsdGA0LDQvdC1XCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCLQk9GA0YPQv9C4INC90LUg0LzQvtC20YPRgtGMINCx0YPRgtC4INCy0LjQtNCw0LvQtdC90ZYuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCLQmtC70ZbQutC90ZbRgtGMINC90LAg0LLRg9C30L7QuyDRliDQv9C10YDQtdGC0Y/Qs9C90ZbRgtGMINC60YDQsNC5INC00L4g0ZbQvdGI0L7Qs9C+INCy0YPQt9C70LAsINGJ0L7QsSDRl9GFINC3J9GU0LTQvdCw0YLQuC5cIixcbiAgZWRpdDogXCLQoNC10LTQsNCz0YPQstCw0YLQuFwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcItCT0YDRg9C/0Lgg0L3QtdC00L7RgdGC0YPQv9C90ZYg0LTQu9GPINGA0LXQtNCw0LPRg9Cy0LDQvdC90Y8uXCIsXG4gIGVkaXRFZGdlOiBcItCg0LXQtNCw0LPRg9Cy0LDRgtC4INC60YDQsNC5XCIsXG4gIGVkaXRFZGdlRGVzY3JpcHRpb246IFwi0JrQu9GW0LrQvdGW0YLRjCDQvdCwINC60L7QvdGC0YDQvtC70YzQvdGWINGC0L7Rh9C60Lgg0ZYg0L/QtdGA0LXRgtGP0LPQvdGW0YLRjCDRl9GFINGDINCy0YPQt9C+0LssINGJ0L7QsSDQv9GW0LTQutC70Y7Rh9C40YLQuNGB0Y8g0LTQviDQvdGM0L7Qs9C+LlwiLFxuICBlZGl0Tm9kZTogXCLQoNC10LTQsNCz0YPQstCw0YLQuCDQstGD0LfQvtC7XCJcbn07IC8vIEZyZW5jaFxuXG52YXIgZnIgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIkNsaXF1ZXogZGFucyB1biBlbmRyb2l0IHZpZGUgcG91ciBwbGFjZXIgdW4gbsWTdWQuXCIsXG4gIGFkZEVkZ2U6IFwiQWpvdXRlciB1biBsaWVuXCIsXG4gIGFkZE5vZGU6IFwiQWpvdXRlciB1biBuxZN1ZFwiLFxuICBiYWNrOiBcIlJldG91clwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiSW1wb3NzaWJsZSBkZSBjcsOpZXIgdW4gbGllbiB2ZXJzIHVuIGNsdXN0ZXIuXCIsXG4gIGRlbDogXCJFZmZhY2VyIGxhIHPDqWxlY3Rpb25cIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkxlcyBjbHVzdGVycyBuZSBwZXV2ZW50IHBhcyDDqnRyZSBlZmZhY8Opcy5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIkNsaXF1ZXogc3VyIHVuIG7Fk3VkIGV0IGdsaXNzZXogbGUgbGllbiB2ZXJzIHVuIGF1dHJlIG7Fk3VkIHBvdXIgbGVzIGNvbm5lY3Rlci5cIixcbiAgZWRpdDogXCLDiWRpdGVyXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiTGVzIGNsdXN0ZXJzIG5lIHBldXZlbnQgcGFzIMOqdHJlIMOpZGl0w6lzLlwiLFxuICBlZGl0RWRnZTogXCLDiWRpdGVyIGxlIGxpZW5cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGlxdWV6IHN1ciBsZXMgcG9pbnRzIGRlIGNvbnRyw7RsZSBldCBnbGlzc2V6LWxlcyBwb3VyIGNvbm5lY3RlciB1biBuxZN1ZC5cIixcbiAgZWRpdE5vZGU6IFwiw4lkaXRlciBsZSBuxZN1ZFwiXG59OyAvLyBDemVjaFxuXG52YXIgY3MgPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIktsdWtudXTDrW0gZG8gcHLDoXpkbsOpaG8gcHJvc3RvcnUgbcWvxb5ldGUgcMWZaWRhdCBub3bDvSB2cmNob2wuXCIsXG4gIGFkZEVkZ2U6IFwiUMWZaWRhdCBocmFudVwiLFxuICBhZGROb2RlOiBcIlDFmWlkYXQgdnJjaG9sXCIsXG4gIGJhY2s6IFwiWnDEm3RcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIk5lbHplIHDFmWlwb2ppdCBocmFudSBrZSBzaGx1a3UuXCIsXG4gIGRlbDogXCJTbWF6YXQgdsO9YsSbclwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiTmVsemUgbWF6YXQgc2hsdWt5LlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiUMWZZXRhxb5lbsOtbSB6IGplZG5vaG8gdnJjaG9sdSBkbyBkcnVow6lobyBtxa/FvmV0ZSBzcG9qaXQgdHl0byB2cmNob2x5IG5vdm91IGhyYW5vdS5cIixcbiAgZWRpdDogXCJVcHJhdml0XCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiTmVsemUgdXByYXZvdmF0IHNobHVreS5cIixcbiAgZWRpdEVkZ2U6IFwiVXByYXZpdCBocmFudVwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIlDFmWV0YcW+ZW7DrW0ga29udHJvbG7DrWhvIHZyY2hvbHUgaHJhbnkgamkgbcWvxb5ldGUgcMWZaXBvaml0IGsgamluw6ltdSB2cmNob2x1LlwiLFxuICBlZGl0Tm9kZTogXCJVcHJhdml0IHZyY2hvbFwiXG59O1xuXG52YXIgbG9jYWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRlbjogZW4sXG5cdGRlOiBkZSxcblx0ZXM6IGVzLFxuXHRpdDogaXQsXG5cdG5sOiBubCxcblx0cHQ6IHB0LFxuXHRydTogcnUsXG5cdGNuOiBjbixcblx0dWs6IHVrLFxuXHRmcjogZnIsXG5cdGNzOiBjc1xufSk7XG5cbi8qKlxyXG4gKiBOb3JtYWxpemVzIGxhbmd1YWdlIGNvZGUgaW50byB0aGUgZm9ybWF0IHVzZWQgaW50ZXJuYWxseS5cclxuICpcclxuICogQHBhcmFtIGxvY2FsZXMgLSBBbGwgdGhlIGF2YWlsYWJsZSBsb2NhbGVzLlxyXG4gKiBAcGFyYW0gcmF3Q29kZSAtIFRoZSBvcmlnaW5hbCBjb2RlIGFzIHN1cHBsaWVkIGJ5IHRoZSB1c2VyLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBMYW5ndWFnZSBjb2RlIGluIHRoZSBmb3JtYXQgbGFuZ3VhZ2UtQ09VTlRSWSBvciBsYW5ndWFnZSwgZXZlbnR1YWxseVxyXG4gKiBmYWxsYmFja3MgdG8gZW4uXHJcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTGFuZ3VhZ2VDb2RlKGxvY2FsZXMsIHJhd0NvZGUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgX3Jhd0NvZGUkc3BsaXQgPSByYXdDb2RlLnNwbGl0KC9bLV8gL10vLCAyKSxcbiAgICAgICAgX3Jhd0NvZGUkc3BsaXQyID0gc2xpY2VkVG9BcnJheShfcmF3Q29kZSRzcGxpdCwgMiksXG4gICAgICAgIHJhd0xhbmd1YWdlID0gX3Jhd0NvZGUkc3BsaXQyWzBdLFxuICAgICAgICByYXdDb3VudHJ5ID0gX3Jhd0NvZGUkc3BsaXQyWzFdO1xuXG4gICAgdmFyIGxhbmd1YWdlID0gcmF3TGFuZ3VhZ2UgIT0gbnVsbCA/IHJhd0xhbmd1YWdlLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgIHZhciBjb3VudHJ5ID0gcmF3Q291bnRyeSAhPSBudWxsID8gcmF3Q291bnRyeS50b1VwcGVyQ2FzZSgpIDogbnVsbDtcblxuICAgIGlmIChsYW5ndWFnZSAmJiBjb3VudHJ5KSB7XG4gICAgICB2YXIgY29kZSA9IGxhbmd1YWdlICsgXCItXCIgKyBjb3VudHJ5O1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxvY2FsZXMsIGNvZGUpKSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICAgIGNvbnNvbGUud2Fybihjb25jYXQkMihfY29udGV4dCA9IFwiVW5rbm93biB2YXJpYW50IFwiLmNvbmNhdChjb3VudHJ5LCBcIiBvZiBsYW5ndWFnZSBcIikpLmNhbGwoX2NvbnRleHQsIGxhbmd1YWdlLCBcIi5cIikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgdmFyIF9jb2RlID0gbGFuZ3VhZ2U7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYWxlcywgX2NvZGUpKSB7XG4gICAgICAgIHJldHVybiBfY29kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gbGFuZ3VhZ2UgXCIuY29uY2F0KGxhbmd1YWdlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS53YXJuKFwiVW5rbm93biBsb2NhbGUgXCIuY29uY2F0KHJhd0NvZGUsIFwiLCBmYWxsaW5nIGJhY2sgdG8gRW5nbGlzaC5cIikpO1xuICAgIHJldHVybiBcImVuXCI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgY29uc29sZS53YXJuKFwiVW5leHBlY3RlZCBlcnJvciB3aGlsZSBub3JtYWxpemluZyBsb2NhbGUgXCIuY29uY2F0KHJhd0NvZGUsIFwiLCBmYWxsaW5nIGJhY2sgdG8gRW5nbGlzaC5cIikpO1xuICAgIHJldHVybiBcImVuXCI7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gX2NsYXNzQ2FsbENoZWNrO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcblxuICAgIGRlZmluZVByb3BlcnR5JDYodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbnZhciBjcmVhdGVDbGFzcyA9IF9jcmVhdGVDbGFzcztcblxuLyoqXG4gKiBBc3NvY2lhdGVzIGEgY2FudmFzIHRvIGEgZ2l2ZW4gaW1hZ2UsIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcmVuZGVyaW5nc1xuICogb2YgdGhlIGltYWdlIGF0IHZhcmlvdXMgc2l6ZXMuXG4gKlxuICogVGhpcyB0ZWNobmlxdWUgaXMga25vd24gYXMgJ21pcG1hcHBpbmcnLlxuICpcbiAqIE5PVEU6IEltYWdlcyBjYW4gYWxzbyBiZSBvZiB0eXBlICdkYXRhOnN2Zyt4bWxgLiBUaGlzIGNvZGUgYWxzbyB3b3Jrc1xuICogICAgICAgZm9yIHN2ZywgYnV0IHRoZSBtaXBtYXBwaW5nIG1heSBub3QgYmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gKi9cbnZhciBDYWNoZWRJbWFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBDYWNoZWRJbWFnZSgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDYWNoZWRJbWFnZSk7XG5cbiAgICB0aGlzLk5VTV9JVEVSQVRJT05TID0gNDsgLy8gTnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBjb29yZGluYXRlcyBhcnJheVxuXG4gICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGltYWdlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoQ2FjaGVkSW1hZ2UsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKCkpIHJldHVybjtcbiAgICAgIHRoaXMuc3JjID0gdGhpcy5pbWFnZS5zcmM7IC8vIEZvciBzYW1lIGludGVyZmFjZSB3aXRoIEltYWdlXG5cbiAgICAgIHZhciB3ID0gdGhpcy5pbWFnZS53aWR0aDtcbiAgICAgIHZhciBoID0gdGhpcy5pbWFnZS5oZWlnaHQ7IC8vIEVhc2UgZXh0ZXJuYWwgYWNjZXNzXG5cbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgICAgdmFyIGgyID0gTWF0aC5mbG9vcihoIC8gMik7XG4gICAgICB2YXIgaDQgPSBNYXRoLmZsb29yKGggLyA0KTtcbiAgICAgIHZhciBoOCA9IE1hdGguZmxvb3IoaCAvIDgpO1xuICAgICAgdmFyIGgxNiA9IE1hdGguZmxvb3IoaCAvIDE2KTtcbiAgICAgIHZhciB3MiA9IE1hdGguZmxvb3IodyAvIDIpO1xuICAgICAgdmFyIHc0ID0gTWF0aC5mbG9vcih3IC8gNCk7XG4gICAgICB2YXIgdzggPSBNYXRoLmZsb29yKHcgLyA4KTtcbiAgICAgIHZhciB3MTYgPSBNYXRoLmZsb29yKHcgLyAxNik7IC8vIE1ha2UgY2FudmFzIGFzIHNtYWxsIGFzIHBvc3NpYmxlXG5cbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gMyAqIHc0O1xuICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaDI7IC8vIENvb3JkaW5hdGVzIGFuZCBzaXplcyBvZiBpbWFnZXMgY29udGFpbmVkIGluIHRoZSBjYW52YXNcbiAgICAgIC8vIFZhbHVlcyBwZXIgcm93OiAgW3RvcCB4LCBsZWZ0IHksIHdpZHRoLCBoZWlnaHRdXG5cbiAgICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBbWzAsIDAsIHcyLCBoMl0sIFt3MiwgMCwgdzQsIGg0XSwgW3cyLCBoNCwgdzgsIGg4XSwgWzUgKiB3OCwgaDQsIHcxNiwgaDE2XV07XG5cbiAgICAgIHRoaXMuX2ZpbGxNaXBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaW5pdCgpIGhhcyBiZWVuIGNhbGxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgbWFpbiBpbWFnZSBpbiB2YXJpb3VzIHNpemVzIHRvIHRoZSBjb250ZXh0LlxuICAgICAqXG4gICAgICogVGhlIHJhdGlvbmFsZSBiZWhpbmQgdGhpcyBpcyB0byByZWR1Y2UgYXJ0ZWZhY3RzIGR1ZSB0byBpbnRlcnBvbGF0aW9uXG4gICAgICogYXQgZGlmZmVyaW5nIHpvb20gbGV2ZWxzLlxuICAgICAqXG4gICAgICogU291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODc2MTQwNC8xMjIzNTMxXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZHMgdGFrZXMgdGhlIHJlc2l6aW5nIG91dCBvZiB0aGUgZHJhd2luZyBsb29wLCBpbiBvcmRlciB0b1xuICAgICAqIHJlZHVjZSBwZXJmb3JtYW5jZSBvdmVyaGVhZC5cbiAgICAgKlxuICAgICAqIFRPRE86IFRoZSBjb2RlIGFzc3VtZXMgdGhhdCBhIDJEIGNvbnRleHQgY2FuIGFsd2F5cyBiZSBnb3R0ZW4uIFRoaXMgaXNcbiAgICAgKiAgICAgICBub3QgbmVjZXNzYXJpbHkgdHJ1ZSEgT1RPSCwgaWYgbm90IHRydWUgdGhlbiB1c2FnZSBvZiB0aGlzIGNsYXNzXG4gICAgICogICAgICAgaXMgc2Vuc2VsZXNzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maWxsTWlwTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maWxsTWlwTWFwKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTsgLy8gRmlyc3Qgem9vbS1sZXZlbCBjb21lcyBmcm9tIHRoZSBpbWFnZVxuXG4gICAgICB2YXIgdG8gPSB0aGlzLmNvb3JkaW5hdGVzWzBdO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltYWdlLCB0b1swXSwgdG9bMV0sIHRvWzJdLCB0b1szXSk7IC8vIFRoZSByZXN0IGFyZSBjb3B5IGFjdGlvbnMgaW50ZXJuYWwgdG8gdGhlIGNhbnZhcy9jb250ZXh0XG5cbiAgICAgIGZvciAodmFyIGl0ZXJhdGlvbnMgPSAxOyBpdGVyYXRpb25zIDwgdGhpcy5OVU1fSVRFUkFUSU9OUzsgaXRlcmF0aW9ucysrKSB7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5jb29yZGluYXRlc1tpdGVyYXRpb25zIC0gMV07XG4gICAgICAgIHZhciBfdG8gPSB0aGlzLmNvb3JkaW5hdGVzW2l0ZXJhdGlvbnNdO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzLCBmcm9tWzBdLCBmcm9tWzFdLCBmcm9tWzJdLCBmcm9tWzNdLCBfdG9bMF0sIF90b1sxXSwgX3RvWzJdLCBfdG9bM10pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoZSBpbWFnZSwgdXNpbmcgdGhlIG1pcG1hcCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBNaXBNYXAgaXMgb25seSB1c2VkIGlmIHBhcmFtIGZhY3RvciA+IDI7IG90aGVyd2lzZSwgb3JpZ2luYWwgYml0bWFwXG4gICAgICogaXMgcmVzaXplZC4gVGhpcyBpcyBhbHNvIHVzZWQgdG8gc2tpcCBtaXBtYXAgdXNhZ2UsIGUuZy4gYnkgc2V0dGluZyBmYWN0b3IgPSAxXG4gICAgICpcbiAgICAgKiBDcmVkaXRzIHRvICdBbGV4IGRlIE11bGRlcicgZm9yIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgY29udGV4dCBvbiB3aGljaCB0byBkcmF3IHpvb21lZCBpbWFnZVxuICAgICAqIEBwYXJhbSB7RmxvYXR9IGZhY3RvciBzY2FsZSBmYWN0b3IgYXQgd2hpY2ggdG8gZHJhd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdJbWFnZUF0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIGZhY3RvciwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQoKSkgcmV0dXJuOyAvL2Nhbid0IGRyYXcgaW1hZ2UgeWV0IG5vdCBpbnRpYWxpemVkXG5cbiAgICAgIGlmIChmYWN0b3IgPiAyKSB7XG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCB6b29tZWQgaW1hZ2UgdG8gdXNlXG4gICAgICAgIGZhY3RvciAqPSAwLjU7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcblxuICAgICAgICB3aGlsZSAoZmFjdG9yID4gMiAmJiBpdGVyYXRpb25zIDwgdGhpcy5OVU1fSVRFUkFUSU9OUykge1xuICAgICAgICAgIGZhY3RvciAqPSAwLjU7XG4gICAgICAgICAgaXRlcmF0aW9ucyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPj0gdGhpcy5OVU1fSVRFUkFUSU9OUykge1xuICAgICAgICAgIGl0ZXJhdGlvbnMgPSB0aGlzLk5VTV9JVEVSQVRJT05TIC0gMTtcbiAgICAgICAgfSAvL2NvbnNvbGUubG9nKFwiaXRlcmF0aW9uczogXCIgKyBpdGVyYXRpb25zKTtcblxuXG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5jb29yZGluYXRlc1tpdGVyYXRpb25zXTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhcywgZnJvbVswXSwgZnJvbVsxXSwgZnJvbVsyXSwgZnJvbVszXSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgaW1hZ2UgZGlyZWN0bHlcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltYWdlLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYWNoZWRJbWFnZTtcbn0oKTtcblxuLyoqXG4gKiBUaGlzIGNhbGxiYWNrIGlzIGEgY2FsbGJhY2sgdGhhdCBhY2NlcHRzIGFuIEltYWdlLlxuICpcbiAqIEBjYWxsYmFjayBJbWFnZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICovXG5cbi8qKlxuICogVGhpcyBjbGFzcyBsb2FkcyBpbWFnZXMgYW5kIGtlZXBzIHRoZW0gc3RvcmVkLlxuICpcbiAqIEBwYXJhbSB7SW1hZ2VDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuXG52YXIgSW1hZ2VzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW1hZ2VDYWxsYmFja30gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIEltYWdlcyhjYWxsYmFjaykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlcyk7XG5cbiAgICB0aGlzLmltYWdlcyA9IHt9O1xuICAgIHRoaXMuaW1hZ2VCcm9rZW4gPSB7fTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgICAgICAgICAgICAgVGhlIG9yaWdpbmFsIFVybCB0aGF0IGZhaWxlZCB0byBsb2FkLCBpZiB0aGUgYnJva2VuIGltYWdlIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWQgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgY2FjaGUgdXNpbmcgdGhpcyBVcmwgYXMgdGhlIGtleSBzbyB0aGF0IHN1YnNlcXVlbnQgcmVxdWVzdHMgZm9yIHRoaXMgVXJsIHdpbGwgcmV0dXJuIHRoZSBicm9rZW4gaW1hZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJyb2tlblVybCAgICAgICAgICAgICAgICBVcmwgdGhlIGJyb2tlbiBpbWFnZSB0byB0cnkgYW5kIGxvYWRcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbiAgIFRoZSBpbWFnZSBvYmplY3RcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhJbWFnZXMsIFt7XG4gICAga2V5OiBcIl90cnlsb2FkQnJva2VuVXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cnlsb2FkQnJva2VuVXJsKHVybCwgYnJva2VuVXJsLCBpbWFnZVRvTG9hZEJyb2tlblVybE9uKSB7XG4gICAgICAvL0lmIHRoZXNlIHBhcmFtZXRlcnMgYXJlbid0IHNwZWNpZmllZCB0aGVuIGV4aXQgdGhlIGZ1bmN0aW9uIGJlY2F1c2Ugbm90aGluZyBjb25zdHJ1Y3RpdmUgY2FuIGJlIGRvbmVcbiAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCBpbWFnZVRvTG9hZEJyb2tlblVybE9uID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgaWYgKGJyb2tlblVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vIGJyb2tlbiB1cmwgaW1hZ2UgZGVmaW5lZFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvL0NsZWFyIHRoZSBvbGQgc3Vic2NyaXB0aW9uIHRvIHRoZSBlcnJvciBldmVudCBhbmQgcHV0IGEgbmV3IGluIHBsYWNlIHRoYXQgb25seSBoYW5kbGUgZXJyb3JzIGluIGxvYWRpbmcgdGhlIGJyb2tlbkltYWdlVXJsXG5cblxuICAgICAgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbi5pbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGxvYWQgYnJva2VuSW1hZ2U6XCIsIGJyb2tlblVybCk7IC8vIGNhY2hlIGl0ZW0gd2lsbCBjb250YWluIGVtcHR5IGltYWdlLCB0aGlzIHNob3VsZCBiZSBPSyBmb3IgZGVmYXVsdFxuICAgICAgfTsgLy9TZXQgdGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgdG8gdGhlIGJyb2tlblVybCwgdGhpcyBpcyBhY3R1YWxseSB3aGF0IGtpY2tzIG9mZiB0aGUgbG9hZGluZyBvZiB0aGUgYnJva2VuIGltYWdlXG5cblxuICAgICAgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbi5pbWFnZS5zcmMgPSBicm9rZW5Vcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuSW1hZ2V9IGltYWdlVG9SZWRyYXdXaXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZWRyYXdXaXRoSW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZHJhd1dpdGhJbWFnZShpbWFnZVRvUmVkcmF3V2l0aCkge1xuICAgICAgaWYgKHRoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhpbWFnZVRvUmVkcmF3V2l0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgVXJsIG9mIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBicm9rZW5VcmwgICAgVXJsIG9mIGFuIGltYWdlIHRvIHVzZSBpZiB0aGUgdXJsIGltYWdlIGlzIG5vdCBmb3VuZFxuICAgICAqIEByZXR1cm5zIHtJbWFnZX0gaW1nICAgICAgICAgIFRoZSBpbWFnZSBvYmplY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIGJyb2tlblVybCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy9UcnkgYW5kIGdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgY2FjaGUsIGlmIHN1Y2Nlc3NmdWwgdGhlbiByZXR1cm4gdGhlIGNhY2hlZCBpbWFnZVxuICAgICAgdmFyIGNhY2hlZEltYWdlID0gdGhpcy5pbWFnZXNbdXJsXTtcbiAgICAgIGlmIChjYWNoZWRJbWFnZSkgcmV0dXJuIGNhY2hlZEltYWdlOyAvL0NyZWF0ZSBhIG5ldyBpbWFnZVxuXG4gICAgICB2YXIgaW1nID0gbmV3IENhY2hlZEltYWdlKCk7IC8vIE5lZWQgdG8gYWRkIHRvIGNhY2hlIGhlcmUsIG90aGVyd2lzZSBmaW5hbCByZXR1cm4gd2lsbCBzcGF3biBkaWZmZXJlbnQgY29waWVzIG9mIHRoZSBzYW1lIGltYWdlLFxuICAgICAgLy8gQWxzbywgdGhlcmUgd2lsbCBiZSBtdWx0aXBsZSBsb2FkcyBvZiB0aGUgc2FtZSBpbWFnZS5cblxuICAgICAgdGhpcy5pbWFnZXNbdXJsXSA9IGltZzsgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBsb2FkcyBzdWNjZXNzZnVsbHlcblxuICAgICAgaW1nLmltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUHJvcGVybHkgaW5pdCB0aGUgY2FjaGVkIGl0ZW0gYW5kIHRoZW4gcmVxdWVzdCBhIHJlZHJhd1xuICAgICAgICBfdGhpcy5fZml4SW1hZ2VDb29yZGluYXRlcyhpbWcuaW1hZ2UpO1xuXG4gICAgICAgIGltZy5pbml0KCk7XG5cbiAgICAgICAgX3RoaXMuX3JlZHJhd1dpdGhJbWFnZShpbWcpO1xuICAgICAgfTsgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBmYWlscyB0byBsb2FkXG5cblxuICAgICAgaW1nLmltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgbG9hZCBpbWFnZTpcIiwgdXJsKTsgLy9UcnkgYW5kIGxvYWQgdGhlIGltYWdlIHNwZWNpZmllZCBieSB0aGUgYnJva2VuVXJsIHVzaW5nXG5cbiAgICAgICAgX3RoaXMuX3RyeWxvYWRCcm9rZW5VcmwodXJsLCBicm9rZW5VcmwsIGltZyk7XG4gICAgICB9OyAvL1NldCB0aGUgc291cmNlIG9mIHRoZSBpbWFnZSB0byB0aGUgdXJsLCB0aGlzIGlzIHdoYXQgYWN0dWFsbHkga2lja3Mgb2ZmIHRoZSBsb2FkaW5nIG9mIHRoZSBpbWFnZVxuXG5cbiAgICAgIGltZy5pbWFnZS5zcmMgPSB1cmw7IC8vUmV0dXJuIHRoZSBuZXcgaW1hZ2VcblxuICAgICAgcmV0dXJuIGltZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSUUxMSBmaXggLS0gdGhhbmtzIGRwb25jaCFcbiAgICAgKlxuICAgICAqIExvY2FsIGhlbHBlciBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuSW1hZ2V9IGltYWdlVG9DYWNoZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZml4SW1hZ2VDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZml4SW1hZ2VDb29yZGluYXRlcyhpbWFnZVRvQ2FjaGUpIHtcbiAgICAgIGlmIChpbWFnZVRvQ2FjaGUud2lkdGggPT09IDApIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWFnZVRvQ2FjaGUpO1xuICAgICAgICBpbWFnZVRvQ2FjaGUud2lkdGggPSBpbWFnZVRvQ2FjaGUub2Zmc2V0V2lkdGg7XG4gICAgICAgIGltYWdlVG9DYWNoZS5oZWlnaHQgPSBpbWFnZVRvQ2FjaGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGltYWdlVG9DYWNoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEltYWdlcztcbn0oKTtcblxudmFyIGZyZWV6aW5nID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcblxudmFyIGludGVybmFsTWV0YWRhdGEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG4gIHZhciBNRVRBREFUQSA9IHVpZCgnbWV0YScpO1xuICB2YXIgaWQgPSAwO1xuXG4gIHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB2YXIgc2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShpdCwgTUVUQURBVEEsIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIG9iamVjdElEOiAnTycgKyArK2lkLFxuICAgICAgICAvLyBvYmplY3QgSURcbiAgICAgICAgd2Vha0RhdGE6IHt9IC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG5cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gICAgLy8gcmV0dXJuIGEgcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gICAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG5cbiAgICBpZiAoIWhhcyhpdCwgTUVUQURBVEEpKSB7XG4gICAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnOyAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXG4gICAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJzsgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblxuICAgICAgc2V0TWV0YWRhdGEoaXQpOyAvLyByZXR1cm4gb2JqZWN0IElEXG4gICAgfVxuXG4gICAgcmV0dXJuIGl0W01FVEFEQVRBXS5vYmplY3RJRDtcbiAgfTtcblxuICB2YXIgZ2V0V2Vha0RhdGEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAgIGlmICghaGFzKGl0LCBNRVRBREFUQSkpIHtcbiAgICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlOyAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXG4gICAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlOyAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuXG4gICAgICBzZXRNZXRhZGF0YShpdCk7IC8vIHJldHVybiB0aGUgc3RvcmUgb2Ygd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgICB9XG5cbiAgICByZXR1cm4gaXRbTUVUQURBVEFdLndlYWtEYXRhO1xuICB9OyAvLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcblxuXG4gIHZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChmcmVlemluZyAmJiBtZXRhLlJFUVVJUkVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQURBVEEpKSBzZXRNZXRhZGF0YShpdCk7XG4gICAgcmV0dXJuIGl0O1xuICB9O1xuXG4gIHZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUkVRVUlSRUQ6IGZhbHNlLFxuICAgIGZhc3RLZXk6IGZhc3RLZXksXG4gICAgZ2V0V2Vha0RhdGE6IGdldFdlYWtEYXRhLFxuICAgIG9uRnJlZXplOiBvbkZyZWV6ZVxuICB9O1xuICBoaWRkZW5LZXlzW01FVEFEQVRBXSA9IHRydWU7XG59KTtcblxudmFyIFJlc3VsdCA9IGZ1bmN0aW9uIChzdG9wcGVkLCByZXN1bHQpIHtcbiAgdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG52YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgdW5ib3VuZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBmdW5jdGlvbkJpbmRDb250ZXh0KHVuYm91bmRGdW5jdGlvbiwgdGhhdCwgMSArIEFTX0VOVFJJRVMgKyBJTlRFUlJVUFRFRCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QodmFsdWUpO1xuICAgICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWUsIHN0b3ApIDogZm4odmFsdWUpO1xuICB9O1xuXG4gIGlmIChJU19JVEVSQVRPUikge1xuICAgIGl0ZXJhdG9yID0gaXRlcmFibGU7XG4gIH0gZWxzZSB7XG4gICAgaXRlckZuID0gZ2V0SXRlcmF0b3JNZXRob2QoaXRlcmFibGUpO1xuICAgIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBpdGVyYWJsZScpOyAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcblxuICB3aGlsZSAoIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbnZhciBhbkluc3RhbmNlID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0ICcgKyAobmFtZSA/IG5hbWUgKyAnICcgOiAnJykgKyAnaW52b2NhdGlvbicpO1xuICB9XG5cbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIGRlZmluZVByb3BlcnR5JDkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGZvckVhY2gkNCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQzID0gaW50ZXJuYWxTdGF0ZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yO1xuXG52YXIgY29sbGVjdGlvbiA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FLCB3cmFwcGVyLCBjb21tb24pIHtcbiAgdmFyIElTX01BUCA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignTWFwJykgIT09IC0xO1xuICB2YXIgSVNfV0VBSyA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignV2VhaycpICE9PSAtMTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsXzFbQ09OU1RSVUNUT1JfTkFNRV07XG4gIHZhciBOYXRpdmVQcm90b3R5cGUgPSBOYXRpdmVDb25zdHJ1Y3RvciAmJiBOYXRpdmVDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBleHBvcnRlZCA9IHt9O1xuICB2YXIgQ29uc3RydWN0b3I7XG5cbiAgaWYgKCFkZXNjcmlwdG9ycyB8fCB0eXBlb2YgTmF0aXZlQ29uc3RydWN0b3IgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgTmF0aXZlUHJvdG90eXBlLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIENvbnN0cnVjdG9yID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpO1xuICAgIGludGVybmFsTWV0YWRhdGEuUkVRVUlSRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQzKGFuSW5zdGFuY2UodGFyZ2V0LCBDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSksIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgY29sbGVjdGlvbjogbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKClcbiAgICAgIH0pO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZShpdGVyYWJsZSwgdGFyZ2V0W0FEREVSXSwge1xuICAgICAgICB0aGF0OiB0YXJnZXQsXG4gICAgICAgIEFTX0VOVFJJRVM6IElTX01BUFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuICAgIGZvckVhY2gkNChbJ2FkZCcsICdjbGVhcicsICdkZWxldGUnLCAnZm9yRWFjaCcsICdnZXQnLCAnaGFzJywgJ3NldCcsICdrZXlzJywgJ3ZhbHVlcycsICdlbnRyaWVzJ10sIGZ1bmN0aW9uIChLRVkpIHtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG5cbiAgICAgIGlmIChLRVkgaW4gTmF0aXZlUHJvdG90eXBlICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbnN0cnVjdG9yLnByb3RvdHlwZSwgS0VZLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5jb2xsZWN0aW9uO1xuICAgICAgICAgIGlmICghSVNfQURERVIgJiYgSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkpIHJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY29sbGVjdGlvbltLRVldKGEgPT09IDAgPyAwIDogYSwgYik7XG4gICAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgSVNfV0VBSyB8fCBkZWZpbmVQcm9wZXJ0eSQ5KENvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIGZhbHNlLCB0cnVlKTtcbiAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBDb25zdHJ1Y3RvcjtcbiAgX2V4cG9ydCh7XG4gICAgZ2xvYmFsOiB0cnVlLFxuICAgIGZvcmNlZDogdHJ1ZVxuICB9LCBleHBvcnRlZCk7XG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufTtcblxudmFyIHJlZGVmaW5lQWxsID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuc2FmZSAmJiB0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtlbHNlIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIFNQRUNJRVMkMyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG52YXIgc2V0U3BlY2llcyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4oQ09OU1RSVUNUT1JfTkFNRSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cbiAgaWYgKGRlc2NyaXB0b3JzICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTJDNdKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMkMywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkkYSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgZmFzdEtleSA9IGludGVybmFsTWV0YWRhdGEuZmFzdEtleTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDQgPSBpbnRlcm5hbFN0YXRlLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDEgPSBpbnRlcm5hbFN0YXRlLmdldHRlckZvcjtcbnZhciBjb2xsZWN0aW9uU3Ryb25nID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQ0KHRoYXQsIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgaW5kZXg6IG9iamVjdENyZWF0ZShudWxsKSxcbiAgICAgICAgZmlyc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFzdDogdW5kZWZpbmVkLFxuICAgICAgICBzaXplOiAwXG4gICAgICB9KTtcbiAgICAgIGlmICghZGVzY3JpcHRvcnMpIHRoYXQuc2l6ZSA9IDA7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwge1xuICAgICAgICB0aGF0OiB0aGF0LFxuICAgICAgICBBU19FTlRSSUVTOiBJU19NQVBcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvciQxKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgIHZhciBwcmV2aW91cywgaW5kZXg7IC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuXG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTsgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdCA9IGVudHJ5ID0ge1xuICAgICAgICAgIGluZGV4OiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSxcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzID0gc3RhdGUubGFzdCxcbiAgICAgICAgICBuZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgcmVtb3ZlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdGF0ZS5maXJzdCkgc3RhdGUuZmlyc3QgPSBlbnRyeTtcbiAgICAgICAgaWYgKHByZXZpb3VzKSBwcmV2aW91cy5uZXh0ID0gZW50cnk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9ycykgc3RhdGUuc2l6ZSsrO2Vsc2UgdGhhdC5zaXplKys7IC8vIGFkZCB0byBpbmRleFxuXG4gICAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSBzdGF0ZS5pbmRleFtpbmRleF0gPSBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIHZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7IC8vIGZhc3QgY2FzZVxuXG4gICAgICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gICAgICB2YXIgZW50cnk7XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHN0YXRlLmluZGV4W2luZGV4XTsgLy8gZnJvemVuIG9iamVjdCBjYXNlXG5cbiAgICAgIGZvciAoZW50cnkgPSBzdGF0ZS5maXJzdDsgZW50cnk7IGVudHJ5ID0gZW50cnkubmV4dCkge1xuICAgICAgICBpZiAoZW50cnkua2V5ID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZGF0YSA9IHN0YXRlLmluZGV4O1xuICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcblxuICAgICAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucHJldmlvdXMpIGVudHJ5LnByZXZpb3VzID0gZW50cnkucHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pbmRleF07XG4gICAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZmlyc3QgPSBzdGF0ZS5sYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGVzY3JpcHRvcnMpIHN0YXRlLnNpemUgPSAwO2Vsc2UgdGhhdC5zaXplID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcblxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgICAgICBkZWxldGUgc3RhdGUuaW5kZXhbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5LnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnByZXZpb3VzID0gcHJldjtcbiAgICAgICAgICBpZiAoc3RhdGUuZmlyc3QgPT0gZW50cnkpIHN0YXRlLmZpcnN0ID0gbmV4dDtcbiAgICAgICAgICBpZiAoc3RhdGUubGFzdCA9PSBlbnRyeSkgc3RhdGUubGFzdCA9IHByZXY7XG4gICAgICAgICAgaWYgKGRlc2NyaXB0b3JzKSBzdGF0ZS5zaXplLS07ZWxzZSB0aGF0LnNpemUtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm5cbiAgICAgIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqL1xuICAgICAgKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIHZhciBib3VuZEZ1bmN0aW9uID0gZnVuY3Rpb25CaW5kQ29udGV4dChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcblxuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5maXJzdCkge1xuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7IC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuXG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBJU19NQVAgPyB7XG4gICAgICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnZhbHVlO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkZXNjcmlwdG9ycykgZGVmaW5lUHJvcGVydHkkYShDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKSB7XG4gICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XG4gICAgdmFyIGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvciQxKENPTlNUUlVDVE9SX05BTUUpO1xuICAgIHZhciBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDEoSVRFUkFUT1JfTkFNRSk7IC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcblxuICAgIGRlZmluZUl0ZXJhdG9yKEMsIENPTlNUUlVDVE9SX05BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQ0KHRoaXMsIHtcbiAgICAgICAgdHlwZTogSVRFUkFUT1JfTkFNRSxcbiAgICAgICAgdGFyZ2V0OiBpdGVyYXRlZCxcbiAgICAgICAgc3RhdGU6IGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlKGl0ZXJhdGVkKSxcbiAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgbGFzdDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gICAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5sYXN0OyAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcblxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7IC8vIGdldCBuZXh0IGVudHJ5XG5cblxuICAgICAgaWYgKCFzdGF0ZS50YXJnZXQgfHwgIShzdGF0ZS5sYXN0ID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5zdGF0ZS5maXJzdCkpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSAvLyByZXR1cm4gc3RlcCBieSBraW5kXG5cblxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogZW50cnkua2V5LFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogZW50cnkudmFsdWUsXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXSxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpOyAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWFwLW9iamVjdHNcblxuXG52YXIgZXNfbWFwID0gY29sbGVjdGlvbignTWFwJywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn0sIGNvbGxlY3Rpb25TdHJvbmcpO1xuXG52YXIgbWFwJDMgPSBwYXRoLk1hcDtcblxudmFyIG1hcCQ0ID0gbWFwJDM7XG5cbnZhciBtYXAkNSA9IG1hcCQ0O1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgY2FuIHN0b3JlIGdyb3VwcyBhbmQgb3B0aW9ucyBzcGVjaWZpYyBmb3IgZ3JvdXBzLlxuICovXG52YXIgR3JvdXBzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEdyb3VwcygpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBHcm91cHMpO1xuXG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuX2RlZmF1bHRJbmRleCA9IDA7XG4gICAgdGhpcy5fZ3JvdXBJbmRleCA9IDA7XG4gICAgdGhpcy5fZGVmYXVsdEdyb3VwcyA9IFt7XG4gICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjOTdDMkZDXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRDJFNUZGXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIlxuICAgICAgfVxuICAgIH0sIC8vIDA6IGJsdWVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZGQTUwMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkZGRjAwXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRkE1MDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZGRkEzXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGQTUwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkZGQTNcIlxuICAgICAgfVxuICAgIH0sIC8vIDE6IHllbGxvd1xuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRkEwQTEwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGQjdFODFcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZBMEExMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkFGQjFcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkEwQTEwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQUZCMVwiXG4gICAgICB9XG4gICAgfSwgLy8gMjogcmVkXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM0MUE5MDZcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzdCRTE0MVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjNDFBOTA2XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ExRUM3NlwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0MUE5MDZcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjQTFFQzc2XCJcbiAgICAgIH1cbiAgICB9LCAvLyAzOiBncmVlblxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRTEyOUYwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNFQjdERjRcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0UxMjlGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGMEIzRjVcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRTEyOUYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0YwQjNGNVwiXG4gICAgICB9XG4gICAgfSwgLy8gNDogbWFnZW50YVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjN0MyOUYwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNBRDg1RTRcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzdDMjlGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEM0JERjBcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjN0MyOUYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0QzQkRGMFwiXG4gICAgICB9XG4gICAgfSwgLy8gNTogcHVycGxlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNDMzdGMDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQTgwN1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjQzM3RjAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQ0E2NlwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNDMzdGMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZDQTY2XCJcbiAgICAgIH1cbiAgICB9LCAvLyA2OiBvcmFuZ2VcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzQyMjBGQlwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjNkU2RUZEXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0MjIwRkJcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjOUI5QkZEXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzQyMjBGQlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM5QjlCRkRcIlxuICAgICAgfVxuICAgIH0sIC8vIDc6IGRhcmtibHVlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNGRDVBNzdcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQzBDQlwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkQ1QTc3XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGRDFEOVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRDVBNzdcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZEMUQ5XCJcbiAgICAgIH1cbiAgICB9LCAvLyA4OiBwaW5rXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM0QUQ2M0FcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0MyRkFCQ1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjNEFENjNBXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0U2RkZFM1wiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0QUQ2M0FcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRTZGRkUzXCJcbiAgICAgIH1cbiAgICB9LCAvLyA5OiBtaW50XG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM5OTAwMDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0VFMDAwMFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjQkIwMDAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGMzMzM1wiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNCQjAwMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkYzMzMzXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxMDpicmlnaHQgcmVkXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNGRjYwMDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkY2MDAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGNjAwMFwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRjYwMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkY2MDAwXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxMjogcmVhbCBvcmFuZ2VcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzk3QzJGQ1wiLFxuICAgICAgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNEMkU1RkZcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0QyRTVGRlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyQjdDRTlcIlxuICAgICAgfVxuICAgIH0sIC8vIDEzOiBibHVlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiMzOTk2MDVcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjMzk5NjA1XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMzOTk2MDVcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjU1QzAzXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxNDogZ3JlZW5cbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0I3MDA1NFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkYwMDdFXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNCNzAwNTRcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkYwMDdFXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0I3MDA1NFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjAwN0VcIlxuICAgICAgfVxuICAgIH0sIC8vIDE1OiBtYWdlbnRhXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNBRDg1RTRcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRDNCREYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNEM0JERjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjN0MyOUYwXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxNjogcHVycGxlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM0NTU3RkFcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjNkU2RUZEXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM2RTZFRkRcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMDAwRUExXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxNzogZGFya2JsdWVcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZGQzBDQlwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRkQxRDlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkQ1QTc3XCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGRDFEOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRDVBNzdcIlxuICAgICAgfVxuICAgIH0sIC8vIDE4OiBwaW5rXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNDMkZBQkNcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRTZGRkUzXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNFNkZGRTNcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNzRENjZBXCJcbiAgICAgIH1cbiAgICB9LCAvLyAxOTogbWludFxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRUUwMDAwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM5OTAwMDBcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGMzMzM1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNCQjAwMDBcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkYzMzMzXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0JCMDAwMFwiXG4gICAgICB9XG4gICAgfSAvLyAyMDpicmlnaHQgcmVkXG4gICAgXTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdXNlRGVmYXVsdEdyb3VwczogdHJ1ZVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKEdyb3VwcywgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBvcHRpb25GaWVsZHMgPSBbXCJ1c2VEZWZhdWx0R3JvdXBzXCJdO1xuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIGdyb3VwTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBncm91cE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZiQzKG9wdGlvbkZpZWxkcykuY2FsbChvcHRpb25GaWVsZHMsIGdyb3VwTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHZhciBncm91cCA9IG9wdGlvbnNbZ3JvdXBOYW1lXTtcbiAgICAgICAgICAgICAgdGhpcy5hZGQoZ3JvdXBOYW1lLCBncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBncm91cHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fZ3JvdXBzID0gbmV3IG1hcCQ1KCk7XG4gICAgICB0aGlzLl9ncm91cE5hbWVzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBncm91cCBvcHRpb25zIG9mIGEgZ3JvdXBuYW1lLlxuICAgICAqIElmIGdyb3VwbmFtZSBpcyBub3QgZm91bmQsIGEgbmV3IGdyb3VwIG1heSBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSAgICAgICBncm91cG5hbWUgICAgIENhbiBiZSBhIG51bWJlciwgc3RyaW5nLCBEYXRlLCBldGMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkQ3JlYXRlPXRydWVdIElmIHRydWUsIGNyZWF0ZSBhIG5ldyBncm91cFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBmb3VuZCBvciBjcmVhdGVkIGdyb3VwXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGdyb3VwbmFtZSkge1xuICAgICAgdmFyIHNob3VsZENyZWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdmFyIGdyb3VwID0gdGhpcy5fZ3JvdXBzLmdldChncm91cG5hbWUpO1xuXG4gICAgICBpZiAoZ3JvdXAgPT09IHVuZGVmaW5lZCAmJiBzaG91bGRDcmVhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VEZWZhdWx0R3JvdXBzID09PSBmYWxzZSAmJiB0aGlzLl9ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBjcmVhdGUgbmV3IGdyb3VwXG4gICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZ3JvdXBJbmRleCAlIHRoaXMuX2dyb3VwTmFtZXMubGVuZ3RoO1xuICAgICAgICAgICsrdGhpcy5fZ3JvdXBJbmRleDtcbiAgICAgICAgICBncm91cCA9IHt9O1xuICAgICAgICAgIGdyb3VwLmNvbG9yID0gdGhpcy5fZ3JvdXBzLmdldCh0aGlzLl9ncm91cE5hbWVzW2luZGV4XSk7XG5cbiAgICAgICAgICB0aGlzLl9ncm91cHMuc2V0KGdyb3VwbmFtZSwgZ3JvdXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgZ3JvdXBcbiAgICAgICAgICB2YXIgX2luZGV4ID0gdGhpcy5fZGVmYXVsdEluZGV4ICUgdGhpcy5fZGVmYXVsdEdyb3Vwcy5sZW5ndGg7XG5cbiAgICAgICAgICB0aGlzLl9kZWZhdWx0SW5kZXgrKztcbiAgICAgICAgICBncm91cCA9IHt9O1xuICAgICAgICAgIGdyb3VwLmNvbG9yID0gdGhpcy5fZGVmYXVsdEdyb3Vwc1tfaW5kZXhdO1xuXG4gICAgICAgICAgdGhpcy5fZ3JvdXBzLnNldChncm91cG5hbWUsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBjdXN0b20gZ3JvdXAgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGdyb3VwLCBhIG5ldyBncm91cCB3aWxsIGJlXG4gICAgICogY3JlYXRlZCBpZiBhIGdyb3VwIHdpdGggdGhlIHNhbWUgbmFtZSBkb2Vzbid0IGV4aXN0LCBvdGhlcndpc2UgdGhlIG9sZFxuICAgICAqIGdyb3VwcyBzdHlsZSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZSAtIEFuIG9iamVjdCBjb250YWluaW5nIGJvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICogZXRjLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBjcmVhdGVkIGdyb3VwIG9iamVjdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZ3JvdXBOYW1lLCBzdHlsZSkge1xuICAgICAgLy8gT25seSBwdXNoIGdyb3VwIG5hbWUgb25jZSB0byBwcmV2ZW50IGR1cGxpY2F0ZXMgd2hpY2ggd291bGQgY29uc3VtZSBtb3JlXG4gICAgICAvLyBSQU0gYW5kIGFsc28gc2tldyB0aGUgZGlzdHJpYnV0aW9uIHRvd2FyZHMgbW9yZSBvZnRlbiB1cGRhdGVkIGdyb3VwcyxcbiAgICAgIC8vIG5laXRoZXIgb2Ygd2hpY2ggaXMgZGVzaXJhYmxlLlxuICAgICAgaWYgKCF0aGlzLl9ncm91cHMuaGFzKGdyb3VwTmFtZSkpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBOYW1lcy5wdXNoKGdyb3VwTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2dyb3Vwcy5zZXQoZ3JvdXBOYW1lLCBzdHlsZSk7XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR3JvdXBzO1xufSgpO1xuXG52YXIgc2xpY2UkNiA9IFtdLnNsaWNlO1xudmFyIE1TSUUgPSAvTVNJRSAuXFwuLy50ZXN0KGVuZ2luZVVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcblxudmFyIHdyYXAkMSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChoYW5kbGVyLCB0aW1lb3V0XG4gIC8qICwgLi4uYXJndW1lbnRzICovXG4gICkge1xuICAgIHZhciBib3VuZEFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICB2YXIgYXJncyA9IGJvdW5kQXJncyA/IHNsaWNlJDYuY2FsbChhcmd1bWVudHMsIDIpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBzY2hlZHVsZXIoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGhhbmRsZXIgPT0gJ2Z1bmN0aW9uJyA/IGhhbmRsZXIgOiBGdW5jdGlvbihoYW5kbGVyKSkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSA6IGhhbmRsZXIsIHRpbWVvdXQpO1xuICB9O1xufTsgLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCN0aW1lcnNcblxuXG5fZXhwb3J0KHtcbiAgZ2xvYmFsOiB0cnVlLFxuICBiaW5kOiB0cnVlLFxuICBmb3JjZWQ6IE1TSUVcbn0sIHtcbiAgLy8gYHNldFRpbWVvdXRgIG1ldGhvZFxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sI2RvbS1zZXR0aW1lb3V0XG4gIHNldFRpbWVvdXQ6IHdyYXAkMShnbG9iYWxfMS5zZXRUaW1lb3V0KSxcbiAgLy8gYHNldEludGVydmFsYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCNkb20tc2V0aW50ZXJ2YWxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAkMShnbG9iYWxfMS5zZXRJbnRlcnZhbClcbn0pO1xuXG52YXIgc2V0VGltZW91dCQxID0gcGF0aC5zZXRUaW1lb3V0O1xuXG52YXIgc2V0VGltZW91dCQyID0gc2V0VGltZW91dCQxO1xuXG52YXIgJHNvbWUgPSBhcnJheUl0ZXJhdGlvbi5zb21lO1xudmFyIFNUUklDVF9NRVRIT0QkMiA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ3NvbWUnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCQ3ID0gYXJyYXlNZXRob2RVc2VzVG9MZW5ndGgoJ3NvbWUnKTsgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG5cbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EJDIgfHwgIVVTRVNfVE9fTEVOR1RIJDdcbn0sIHtcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIHNvbWUgPSBlbnRyeVZpcnR1YWwoJ0FycmF5Jykuc29tZTtcblxudmFyIEFycmF5UHJvdG90eXBlJDkgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBzb21lXzEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNvbWU7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkOSB8fCBpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkOS5zb21lID8gc29tZSA6IG93bjtcbn07XG5cbnZhciBzb21lJDEgPSBzb21lXzE7XG5cbnZhciBzb21lJDIgPSBzb21lJDE7XG5cbnZhciBnbG9iYWxJc0Zpbml0ZSA9IGdsb2JhbF8xLmlzRmluaXRlOyAvLyBgTnVtYmVyLmlzRmluaXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci5pc2Zpbml0ZVxuXG52YXIgbnVtYmVySXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBnbG9iYWxJc0Zpbml0ZShpdCk7XG59O1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1udW1iZXIuaXNmaW5pdGVcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ051bWJlcicsXG4gIHN0YXQ6IHRydWVcbn0sIHtcbiAgaXNGaW5pdGU6IG51bWJlcklzRmluaXRlXG59KTtcblxudmFyIF9pc0Zpbml0ZSA9IHBhdGguTnVtYmVyLmlzRmluaXRlO1xuXG52YXIgX2lzRmluaXRlJDEgPSBfaXNGaW5pdGU7XG5cbnZhciBfaXNGaW5pdGUkMiA9IF9pc0Zpbml0ZSQxO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1udW1iZXIuaXNuYW5cblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ051bWJlcicsXG4gIHN0YXQ6IHRydWVcbn0sIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7XG5cbnZhciBpc05hbiA9IHBhdGguTnVtYmVyLmlzTmFOO1xuXG52YXIgaXNOYW4kMSA9IGlzTmFuO1xuXG52YXIgaXNOYW4kMiA9IGlzTmFuJDE7XG5cbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzJDIgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZjtcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTJDMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoMSk7XG59KTsgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG5cbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdPYmplY3QnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMkM1xufSwge1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzJDJcbn0pO1xuXG52YXIgT2JqZWN0JDIgPSBwYXRoLk9iamVjdDtcblxudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiBPYmplY3QkMi5nZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbn07XG5cbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzJDEgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuXG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyQyID0gZ2V0T3duUHJvcGVydHlOYW1lcyQxO1xuXG52YXIgdHJpbSQyID0gc3RyaW5nVHJpbS50cmltO1xudmFyICRwYXJzZUZsb2F0ID0gZ2xvYmFsXzEucGFyc2VGbG9hdDtcbnZhciBGT1JDRUQkMyA9IDEgLyAkcGFyc2VGbG9hdCh3aGl0ZXNwYWNlcyArICctMCcpICE9PSAtSW5maW5pdHk7IC8vIGBwYXJzZUZsb2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG5cbnZhciBudW1iZXJQYXJzZUZsb2F0ID0gRk9SQ0VEJDMgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cmluZykge1xuICB2YXIgdHJpbW1lZFN0cmluZyA9IHRyaW0kMihTdHJpbmcoc3RyaW5nKSk7XG4gIHZhciByZXN1bHQgPSAkcGFyc2VGbG9hdCh0cmltbWVkU3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiB0cmltbWVkU3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiAkcGFyc2VGbG9hdDtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcGFyc2VmbG9hdC1zdHJpbmdcblxuX2V4cG9ydCh7XG4gIGdsb2JhbDogdHJ1ZSxcbiAgZm9yY2VkOiBwYXJzZUZsb2F0ICE9IG51bWJlclBhcnNlRmxvYXRcbn0sIHtcbiAgcGFyc2VGbG9hdDogbnVtYmVyUGFyc2VGbG9hdFxufSk7XG5cbnZhciBfcGFyc2VGbG9hdCA9IHBhdGgucGFyc2VGbG9hdDtcblxudmFyIF9wYXJzZUZsb2F0JDEgPSBfcGFyc2VGbG9hdDtcblxudmFyIF9wYXJzZUZsb2F0JDIgPSBfcGFyc2VGbG9hdCQxO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIGNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIERldGVybWluZSB2YWx1ZXMgdG8gdXNlIGZvciAoc3ViKW9wdGlvbnMgb2YgJ2Nob3NlbicuXG4gKlxuICogVGhpcyBvcHRpb24gaXMgZWl0aGVyIGEgYm9vbGVhbiBvciBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIHNob3VsZCBiZSBleGFtaW5lZCBmdXJ0aGVyLlxuICogVGhlIHJlbGV2YW50IHN0cnVjdHVyZXMgYXJlOlxuICpcbiAqIC0gY2hvc2VuOiA8Ym9vbGVhbiB2YWx1ZT5cbiAqIC0gY2hvc2VuOiB7IHN1Yk9wdGlvbjogPGJvb2xlYW4gb3IgZnVuY3Rpb24+IH1cbiAqXG4gKiBXaGVyZSBzdWJPcHRpb24gaXMgJ25vZGUnLCAnZWRnZScgb3IgJ2xhYmVsJy5cbiAqXG4gKiBUaGUgaW50ZW50aW9uIG9mIHRoaXMgbWV0aG9kIGFwcGVhcnMgdG8gYmUgdG8gc2V0IGEgc3BlY2lmaWMgcHJpb3JpdHkgdG8gdGhlIG9wdGlvbnM7XG4gKiBTaW5jZSBtb3N0IHByb3BlcnRpZXMgYXJlIGVpdGhlciBicmlkZ2VkIG9yIG1lcmdlZCBpbnRvIHRoZSBsb2NhbCBvcHRpb25zIG9iamVjdHMsIHRoZXJlXG4gKiBpcyBub3QgbXVjaCBwb2ludCBpbiBoYW5kbGluZyB0aGVtIHNlcGFyYXRlbHkuXG4gKiBUT0RPOiBleGFtaW5lIGlmICdtb3N0JyBpbiBwcmV2aW91cyBzZW50ZW5jZSBjYW4gYmUgcmVwbGFjZWQgd2l0aCAnYWxsJy4gSW4gdGhhdCBjYXNlLCB3ZVxuICogICAgICAgc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiB0aGlzIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gIHN1Yk9wdGlvbiAgb3B0aW9uIHdpdGhpbiBvYmplY3QgJ2Nob3NlbicgdG8gY29uc2lkZXI7IGVpdGhlciAnbm9kZScsICdlZGdlJyBvciAnbGFiZWwnXG4gKiBAcGFyYW0ge29iamVjdH0gIHBpbGUgICAgICAgYXJyYXkgb2Ygb3B0aW9ucyBvYmplY3RzIHRvIGNvbnNpZGVyXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW4gfCBGdW5jdGlvbn0gIHZhbHVlIGZvciBwYXNzZWQgc3ViT3B0aW9uIG9mICdjaG9zZW4nIHRvIHVzZVxuICovXG5cbmZ1bmN0aW9uIGNob29zaWZ5KHN1Yk9wdGlvbiwgcGlsZSkge1xuICAvLyBhbGxvd2VkIHZhbHVlcyBmb3Igc3ViT3B0aW9uXG4gIHZhciBhbGxvd2VkID0gW1wibm9kZVwiLCBcImVkZ2VcIiwgXCJsYWJlbFwiXTtcbiAgdmFyIHZhbHVlID0gdHJ1ZTtcbiAgdmFyIGNob3NlbiA9IHRvcE1vc3QocGlsZSwgXCJjaG9zZW5cIik7XG5cbiAgaWYgKHR5cGVvZiBjaG9zZW4gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgdmFsdWUgPSBjaG9zZW47XG4gIH0gZWxzZSBpZiAoX3R5cGVvZl8xKGNob3NlbikgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoaW5kZXhPZiQzKGFsbG93ZWQpLmNhbGwoYWxsb3dlZCwgc3ViT3B0aW9uKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNob29zaWZ5OiBzdWJPcHRpb24gJ1wiICsgc3ViT3B0aW9uICsgXCInIHNob3VsZCBiZSBvbmUgb2YgXCIgKyBcIidcIiArIGFsbG93ZWQuam9pbihcIicsICdcIikgKyBcIidcIik7XG4gICAgfVxuXG4gICAgdmFyIGNob3NlbkVkZ2UgPSB0b3BNb3N0KHBpbGUsIFtcImNob3NlblwiLCBzdWJPcHRpb25dKTtcblxuICAgIGlmICh0eXBlb2YgY2hvc2VuRWRnZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIGNob3NlbkVkZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFsdWUgPSBjaG9zZW5FZGdlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICpcbiAqIEBwYXJhbSB7cmVjdH0gcmVjdFxuICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAqIEBwYXJhbSB7cm90YXRpb25Qb2ludH0gW3JvdGF0aW9uUG9pbnRdIGlmIHNwZWNpZmllZCwgdGhlIHJvdGF0aW9uIHRoYXQgYXBwbGllcyB0byB0aGUgcmVjdGFuZ2xlLlxuICogQHJldHVybnMge2Jvb2xlYW59ICB0cnVlIGlmIHBvaW50IHdpdGhpbiByZWN0YW5nbGUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5cbmZ1bmN0aW9uIHBvaW50SW5SZWN0KHJlY3QsIHBvaW50LCByb3RhdGlvblBvaW50KSB7XG4gIGlmIChyZWN0LndpZHRoIDw9IDAgfHwgcmVjdC5oZWlnaHQgPD0gMCkge1xuICAgIHJldHVybiBmYWxzZTsgLy8gZWFybHkgb3V0XG4gIH1cblxuICBpZiAocm90YXRpb25Qb2ludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gUm90YXRlIHRoZSBwb2ludCB0aGUgc2FtZSBhbW91bnQgYXMgdGhlIHJlY3RhbmdsZVxuICAgIHZhciB0bXAgPSB7XG4gICAgICB4OiBwb2ludC54IC0gcm90YXRpb25Qb2ludC54LFxuICAgICAgeTogcG9pbnQueSAtIHJvdGF0aW9uUG9pbnQueVxuICAgIH07XG5cbiAgICBpZiAocm90YXRpb25Qb2ludC5hbmdsZSAhPT0gMCkge1xuICAgICAgLy8gSW4gb3JkZXIgdG8gZ2V0IHRoZSBjb29yZGluYXRlcyB0aGUgc2FtZSwgeW91IG5lZWQgdG9cbiAgICAgIC8vIHJvdGF0ZSBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgIHZhciBhbmdsZSA9IC1yb3RhdGlvblBvaW50LmFuZ2xlO1xuICAgICAgdmFyIHRtcDIgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIHRtcC54IC0gTWF0aC5zaW4oYW5nbGUpICogdG1wLnksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIHRtcC54ICsgTWF0aC5jb3MoYW5nbGUpICogdG1wLnlcbiAgICAgIH07XG4gICAgICBwb2ludCA9IHRtcDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ID0gdG1wO1xuICAgIH0gLy8gTm90ZSB0aGF0IGlmIGEgcm90YXRpb24gaXMgc3BlY2lmaWVkLCB0aGUgcmVjdGFuZ2xlIGNvb3JkaW5hdGVzXG4gICAgLy8gYXJlICoqbm90KiB0aGUgZnVsbCBjYW52YXMgY29vcmRpbmF0ZXMuIFRoZXkgYXJlIHJlbGF0aXZlIHRvIHRoZVxuICAgIC8vIHJvdGF0aW9uUG9pbnQuIEhlbmNlLCB0aGUgcG9pbnQgY29vcmRpbmF0ZXMgbmVlZCBub3QgYmUgdHJhbnNsYXRlZFxuICAgIC8vIGJhY2sgaW4gdGhpcyBjYXNlLlxuXG4gIH1cblxuICB2YXIgcmlnaHQgPSByZWN0LnggKyByZWN0LndpZHRoO1xuICB2YXIgYm90dG9tID0gcmVjdC55ICsgcmVjdC53aWR0aDtcbiAgcmV0dXJuIHJlY3QubGVmdCA8IHBvaW50LnggJiYgcmlnaHQgPiBwb2ludC54ICYmIHJlY3QudG9wIDwgcG9pbnQueSAmJiBib3R0b20gPiBwb2ludC55O1xufVxuLyoqXG4gKiBDaGVjayBpZiBnaXZlbiB2YWx1ZSBpcyBhY2NlcHRhYmxlIGFzIGEgbGFiZWwgdGV4dC5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgdmFsdWUgdG8gY2hlY2s7IGNhbiBiZSBhbnl0aGluZyBhdCB0aGlzIHBvaW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCBsYWJlbCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZExhYmVsKHRleHQpIHtcbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgcXVpdGUgc3RyaWN0OiB0eXBlcyB0aGF0ICptaWdodCogYmUgY29udmVydGVkIHRvIHN0cmluZyBhcmUgZGlzYWxsb3dlZFxuICByZXR1cm4gdHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIgJiYgdGV4dCAhPT0gXCJcIjtcbn1cbi8qKlxuICogUmV0dXJucyB4LCB5IG9mIHNlbGYgcmVmZXJlbmNlIGNpcmNsZSBiYXNlZCBvbiBwcm92aWRlZCBhbmdsZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjdHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICogQHBhcmFtIHtWaXNOb2RlfSBub2RlXG4gKlxuICogQHJldHVybnMge29iamVjdH0geCBhbmQgeSBjb29yZGluYXRlc1xuICovXG5cbmZ1bmN0aW9uIGdldFNlbGZSZWZDb29yZGluYXRlcyhjdHgsIGFuZ2xlLCByYWRpdXMsIG5vZGUpIHtcbiAgdmFyIHggPSBub2RlLng7XG4gIHZhciB5ID0gbm9kZS55O1xuXG4gIGlmICh0eXBlb2Ygbm9kZS5kaXN0YW5jZVRvQm9yZGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvL2NhbGN1bGF0aW5nIG9wcG9zaXRlIGFuZCBhZGphY2VudFxuICAgIC8vZGlzdGFuZVRvQm9yZGVyIGJlY29tZXMgSHlwb3RlbnVzZS5cbiAgICAvL0Zvcm11bGFzIHNpbihhKSA9IE9wcG9zaXRlIC8gSHlwb3RlbnVzZSBhbmQgY29zKGEpID0gQWRqYWNlbnQgLyBIeXBvdGVudXNlXG4gICAgdmFyIHRvQm9yZGVyRGlzdCA9IG5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB2YXIgeUZyb21Ob2RlQ2VudGVyID0gTWF0aC5zaW4oYW5nbGUpICogdG9Cb3JkZXJEaXN0O1xuICAgIHZhciB4RnJvbU5vZGVDZW50ZXIgPSBNYXRoLmNvcyhhbmdsZSkgKiB0b0JvcmRlckRpc3Q7IC8veEZyb21Ob2RlQ2VudGVyIGlzIGJhc2ljYWxseSB4IGFuZCBpZiB4RnJvbU5vZGVDZW50ZXIgZXF1YWxzIHRvIHRoZSBkaXN0YW5jZSB0byBib3JkZXIgdGhlbiBpdCBtZWFuc1xuICAgIC8vdGhhdCB5IGRvZXMgbm90IG5lZWQgY2FsY3VsYXRpb24gYmVjYXVzZSBpdCBpcyBlcXVhbCBub2RlLmhlaWdodCAvIDIgb3Igbm9kZS55XG4gICAgLy9zYW1lIHRoaW5nIHdpdGggeUZyb21Ob2RlQ2VudGVyIGFuZCBpZiB5RnJvbU5vZGVDZW50ZXIgZXF1YWxzIHRvIHRoZSBkaXN0YW5jZSB0byBib3JkZXIgdGhlbiBpdCBtZWFuc1xuICAgIC8vdGhhdCB4IGlzIGVxdWFsIG5vZGUud2lkdGggLyAyIG9yIG5vZGUueFxuXG4gICAgaWYgKHhGcm9tTm9kZUNlbnRlciA9PT0gdG9Cb3JkZXJEaXN0KSB7XG4gICAgICB4ICs9IHRvQm9yZGVyRGlzdDtcbiAgICAgIHkgPSBub2RlLnk7XG4gICAgfSBlbHNlIGlmICh5RnJvbU5vZGVDZW50ZXIgPT09IHRvQm9yZGVyRGlzdCkge1xuICAgICAgeCA9IG5vZGUueDtcbiAgICAgIHkgLT0gdG9Cb3JkZXJEaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IHhGcm9tTm9kZUNlbnRlcjtcbiAgICAgIHkgLT0geUZyb21Ob2RlQ2VudGVyO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnNoYXBlLndpZHRoID4gbm9kZS5zaGFwZS5oZWlnaHQpIHtcbiAgICB4ID0gbm9kZS54ICsgbm9kZS5zaGFwZS53aWR0aCAqIDAuNTtcbiAgICB5ID0gbm9kZS55IC0gcmFkaXVzO1xuICB9IGVsc2Uge1xuICAgIHggPSBub2RlLnggKyByYWRpdXM7XG4gICAgeSA9IG5vZGUueSAtIG5vZGUuc2hhcGUuaGVpZ2h0ICogMC41O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxudmFyIHZhbHVlcyQxID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLnZhbHVlcztcblxudmFyIHZhbHVlcyQyID0gdmFsdWVzJDE7XG5cbnZhciBBcnJheVByb3RvdHlwZSRhID0gQXJyYXkucHJvdG90eXBlO1xudmFyIERPTUl0ZXJhYmxlcyQxID0ge1xuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIE5vZGVMaXN0OiB0cnVlXG59O1xuXG52YXIgdmFsdWVzXzEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnZhbHVlcztcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRhIHx8IGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRhLnZhbHVlcyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIHx8IERPTUl0ZXJhYmxlcyQxLmhhc093blByb3BlcnR5KGNsYXNzb2YoaXQpKSA/IHZhbHVlcyQyIDogb3duO1xufTtcblxudmFyIHZhbHVlcyQzID0gdmFsdWVzXzE7XG5cbi8qKlxuICogQ2FsbGJhY2sgdG8gZGV0ZXJtaW5lIHRleHQgZGltZW5zaW9ucywgdXNpbmcgdGhlIHBhcmVudCBsYWJlbCBzZXR0aW5ncy5cbiAqXG4gKiBAY2FsbGJhY2sgTWVhc3VyZVRleHRcbiAqIEBwYXJhbSB7dGV4dH0gdGV4dFxuICogQHBhcmFtIHt0ZXh0fSBtb2RcbiAqIEByZXR1cm5zIHtvYmplY3R9IHsgd2lkdGgsIHZhbHVlc30gd2lkdGggaW4gcGl4ZWxzIGFuZCBmb250IGF0dHJpYnV0ZXNcbiAqL1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3IgTGFiZWwgd2hpY2ggY29sbGVjdHMgcmVzdWx0cyBvZiBzcGxpdHRpbmcgbGFiZWxzIGludG8gbGluZXMgYW5kIGJsb2Nrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTGFiZWxBY2N1bXVsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge01lYXN1cmVUZXh0fSBtZWFzdXJlVGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gTGFiZWxBY2N1bXVsYXRvcihtZWFzdXJlVGV4dCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsQWNjdW11bGF0b3IpO1xuXG4gICAgdGhpcy5tZWFzdXJlVGV4dCA9IG1lYXN1cmVUZXh0O1xuICAgIHRoaXMuY3VycmVudCA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMubGluZXMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIGdpdmVuIHRleHQgdG8gdGhlIGdpdmVuIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgbCAgICBpbmRleCBvZiBsaW5lIHRvIGFkZCB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gIHRleHQgc3RyaW5nIHRvIGFwcGVuZCB0byBsaW5lXG4gICAqIEBwYXJhbSB7J2JvbGQnfCdpdGFsJ3wnYm9sZGl0YWwnfCdtb25vJ3wnbm9ybWFsJ30gW21vZD0nbm9ybWFsJ11cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhMYWJlbEFjY3VtdWxhdG9yLCBbe1xuICAgIGtleTogXCJfYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGQobCwgdGV4dCkge1xuICAgICAgdmFyIG1vZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJub3JtYWxcIjtcblxuICAgICAgaWYgKHRoaXMubGluZXNbbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxpbmVzW2xdID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICBibG9ja3M6IFtdXG4gICAgICAgIH07XG4gICAgICB9IC8vIFdlIHN0aWxsIG5lZWQgdG8gc2V0IGEgYmxvY2sgZm9yIHVuZGVmaW5lZCBhbmQgZW1wdHkgdGV4dHMsIGhlbmNlIHJldHVybiBhdCB0aGlzIHBvaW50XG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIGRvbid0IGtub3cgYXQgdGhpcyBwb2ludCBpZiB3ZSdyZSBhdCB0aGVcbiAgICAgIC8vIHN0YXJ0IG9mIGFuIGVtcHR5IGxpbmUgb3Igbm90LlxuICAgICAgLy8gVG8gY29tcGVuc2F0ZSwgZW1wdHkgYmxvY2tzIGFyZSByZW1vdmVkIGluIGBmaW5hbGl6ZSgpYC5cbiAgICAgIC8vXG4gICAgICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBzdGlsbCBoYXZlIGEgaGVpZ2h0XG5cblxuICAgICAgdmFyIHRtcFRleHQgPSB0ZXh0O1xuICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCB8fCB0ZXh0ID09PSBcIlwiKSB0bXBUZXh0ID0gXCIgXCI7IC8vIERldGVybWluZSB3aWR0aCBhbmQgZ2V0IHRoZSBmb250IHByb3BlcnRpZXNcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubWVhc3VyZVRleHQodG1wVGV4dCwgbW9kKTtcblxuICAgICAgdmFyIGJsb2NrID0gYXNzaWduJDIoe30sIHZhbHVlcyQzKHJlc3VsdCkpO1xuXG4gICAgICBibG9jay50ZXh0ID0gdGV4dDtcbiAgICAgIGJsb2NrLndpZHRoID0gcmVzdWx0LndpZHRoO1xuICAgICAgYmxvY2subW9kID0gbW9kO1xuXG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgYmxvY2sud2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxpbmVzW2xdLmJsb2Nrcy5wdXNoKGJsb2NrKTsgLy8gVXBkYXRlIHRoZSBsaW5lIHdpZHRoLiBXZSBuZWVkIHRoaXMgZm9yIGRldGVybWluaW5nIGlmIGEgc3RyaW5nIGdvZXMgb3ZlciBtYXggd2lkdGhcblxuICAgICAgdGhpcy5saW5lc1tsXS53aWR0aCArPSBibG9jay53aWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VyV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VyV2lkdGgoKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbdGhpcy5jdXJyZW50XTtcbiAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIGxpbmUud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0IGluIGJsb2NrIHRvIGN1cnJlbnQgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwibm9ybWFsXCI7XG5cbiAgICAgIHRoaXMuX2FkZCh0aGlzLmN1cnJlbnQsIHRleHQsIG1vZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0IGluIGJsb2NrIHRvIGN1cnJlbnQgbGluZSBhbmQgc3RhcnQgYSBuZXcgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld0xpbmUodGV4dCkge1xuICAgICAgdmFyIG1vZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJub3JtYWxcIjtcblxuICAgICAgdGhpcy5fYWRkKHRoaXMuY3VycmVudCwgdGV4dCwgbW9kKTtcblxuICAgICAgdGhpcy5jdXJyZW50Kys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBhbmQgc2V0IHRoZSBoZWlnaHRzIG9mIGFsbCB0aGUgbGluZXMgY3VycmVudGx5IGNvbnRhaW5lZCBpbiB0aGlzIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2lkdGggaGFzIGFscmVhZHkgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZXJtaW5lTGluZUhlaWdodHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lTGluZUhlaWdodHMoKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdOyAvLyBMb29raW5nIGZvciBtYXggaGVpZ2h0IG9mIGJsb2NrcyBpbiBsaW5lXG5cbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKGxpbmUuYmxvY2tzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBDYW4gaGFwcGVuIGlmIHRleHQgY29udGFpbnMgZS5nLiAnXFxuICdcbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmUuYmxvY2tzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBsaW5lLmJsb2Nrc1tsXTtcblxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IGJsb2NrLmhlaWdodCkge1xuICAgICAgICAgICAgICBoZWlnaHQgPSBibG9jay5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGluZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZnVsbCBzaXplIG9mIHRoZSBsYWJlbCB0ZXh0LCBhcyBkZXRlcm1pbmVkIGJ5IGN1cnJlbnQgbGluZXMgYW5kIGJsb2Nrc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZUxhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVMYWJlbFNpemUoKSB7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5saW5lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNba107XG5cbiAgICAgICAgaWYgKGxpbmUud2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIHdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlaWdodCArPSBsaW5lLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgZW1wdHkgYmxvY2tzIGFuZCBlbXB0eSBsaW5lcyB3ZSBkb24ndCBuZWVkXG4gICAgICpcbiAgICAgKiBUaGlzIG11c3QgYmUgZG9uZSBhZnRlciB0aGUgd2lkdGgvaGVpZ2h0IGRldGVybWluYXRpb24sXG4gICAgICogc28gdGhhdCB0aGVzZSBhcmUgc2V0IHByb3Blcmx5IGZvciBwcm9jZXNzaW5nIGhlcmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8TGluZT59IExpbmVzIHdpdGggZW1wdHkgYmxvY2tzIChhbmQgc29tZSBlbXB0eSBsaW5lcykgcmVtb3ZlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFbXB0eUJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFbXB0eUJsb2NrcygpIHtcbiAgICAgIHZhciB0bXBMaW5lcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdOyAvLyBOb3RlOiBhbiBlbXB0eSBsaW5lIGluIGJldHdlZW4gdGV4dCBoYXMgd2lkdGggemVybyBidXQgaXMgc3RpbGwgcmVsZXZhbnQgdG8gbGF5b3V0LlxuICAgICAgICAvLyBTbyB3ZSBjYW4ndCB1c2Ugd2lkdGggZm9yIHRlc3RpbmcgZW1wdHkgbGluZSBoZXJlXG5cbiAgICAgICAgaWYgKGxpbmUuYmxvY2tzLmxlbmd0aCA9PT0gMCkgY29udGludWU7IC8vIERpc2NhcmQgZmluYWwgZW1wdHkgbGluZSBhbHdheXNcblxuICAgICAgICBpZiAoayA9PT0gdGhpcy5saW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgaWYgKGxpbmUud2lkdGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcExpbmUgPSB7fTtcblxuICAgICAgICBhc3NpZ24kMih0bXBMaW5lLCBsaW5lKTtcblxuICAgICAgICB0bXBMaW5lLmJsb2NrcyA9IFtdO1xuICAgICAgICB2YXIgZmlyc3RFbXB0eUJsb2NrID0gdm9pZCAwO1xuICAgICAgICB2YXIgdG1wQmxvY2tzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lLmJsb2Nrcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIHZhciBibG9jayA9IGxpbmUuYmxvY2tzW2xdO1xuXG4gICAgICAgICAgaWYgKGJsb2NrLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICB0bXBCbG9ja3MucHVzaChibG9jayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaXJzdEVtcHR5QmxvY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBmaXJzdEVtcHR5QmxvY2sgPSBibG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgKnNvbWUqIHRleHQgcHJlc2VudFxuXG5cbiAgICAgICAgaWYgKHRtcEJsb2Nrcy5sZW5ndGggPT09IDAgJiYgZmlyc3RFbXB0eUJsb2NrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0bXBCbG9ja3MucHVzaChmaXJzdEVtcHR5QmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wTGluZS5ibG9ja3MgPSB0bXBCbG9ja3M7XG4gICAgICAgIHRtcExpbmVzLnB1c2godG1wTGluZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0bXBMaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzaXplcyBmb3IgYWxsIGxpbmVzIGFuZCB0aGUgd2hvbGUgdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiAobnVtYmVyfCopLCBoZWlnaHQ6IChudW1iZXJ8KiksIGxpbmVzOiBBcnJheX19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5hbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkodGhpcy5saW5lcywgbnVsbCwgMikpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVMaW5lSGVpZ2h0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVMYWJlbFNpemUoKTtcbiAgICAgIHZhciB0bXBMaW5lcyA9IHRoaXMucmVtb3ZlRW1wdHlCbG9ja3MoKTsgLy8gUmV0dXJuIGEgc2ltcGxlIGhhc2ggb2JqZWN0IGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICBsaW5lczogdG1wTGluZXNcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExhYmVsQWNjdW11bGF0b3I7XG59KCk7XG5cbnZhciB0YWdQYXR0ZXJuID0ge1xuICAvLyBIVE1MXG4gIFwiPGI+XCI6IC88Yj4vLFxuICBcIjxpPlwiOiAvPGk+LyxcbiAgXCI8Y29kZT5cIjogLzxjb2RlPi8sXG4gIFwiPC9iPlwiOiAvPFxcL2I+LyxcbiAgXCI8L2k+XCI6IC88XFwvaT4vLFxuICBcIjwvY29kZT5cIjogLzxcXC9jb2RlPi8sXG4gIC8vIE1hcmtkb3duXG4gIFwiKlwiOiAvXFwqLyxcbiAgLy8gYm9sZFxuICBfOiAvXy8sXG4gIC8vIGl0YWxcbiAgXCJgXCI6IC9gLyxcbiAgLy8gbW9ub1xuICBhZnRlckJvbGQ6IC9bXipdLyxcbiAgYWZ0ZXJJdGFsOiAvW15fXS8sXG4gIGFmdGVyTW9ubzogL1teYF0vXG59O1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgY2xhc3MgZm9yIHBhcnNpbmcgdGhlIG1hcmt1cCB0YWdzIGZvciBIVE1MIGFuZCBNYXJrZG93bi5cbiAqXG4gKiBOT1RFOiBTZXF1ZW5jZXMgb2YgdGFicyBhbmQgc3BhY2VzIGFyZSByZWR1Y2VkIHRvIHNpbmdsZSBzcGFjZS5cbiAqICAgICAgIFNjYW4gdXNhZ2Ugb2YgYHRoaXMuc3BhY2luZ2Agd2l0aGluIG1ldGhvZFxuICovXG5cbnZhciBNYXJrdXBBY2N1bXVsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgIHRleHQgdG8gcGFyc2UgZm9yIG1hcmt1cFxuICAgKi9cbiAgZnVuY3Rpb24gTWFya3VwQWNjdW11bGF0b3IodGV4dCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmt1cEFjY3VtdWxhdG9yKTtcblxuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5ib2xkID0gZmFsc2U7XG4gICAgdGhpcy5pdGFsID0gZmFsc2U7XG4gICAgdGhpcy5tb25vID0gZmFsc2U7XG4gICAgdGhpcy5zcGFjaW5nID0gZmFsc2U7XG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgIHRoaXMubW9kU3RhY2sgPSBbXTtcbiAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1vZCBsYWJlbCBjdXJyZW50bHkgb24gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gIGxhYmVsIG9mIHRvcG1vc3QgbW9kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoTWFya3VwQWNjdW11bGF0b3IsIFt7XG4gICAga2V5OiBcIm1vZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb2QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RTdGFjay5sZW5ndGggPT09IDAgPyBcIm5vcm1hbFwiIDogdGhpcy5tb2RTdGFja1swXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtb2QgbGFiZWwgY3VycmVudGx5IGFjdGl2ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gIGxhYmVsIG9mIGFjdGl2ZSBtb2RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9kTmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb2ROYW1lKCkge1xuICAgICAgaWYgKHRoaXMubW9kU3RhY2subGVuZ3RoID09PSAwKSByZXR1cm4gXCJub3JtYWxcIjtlbHNlIGlmICh0aGlzLm1vZFN0YWNrWzBdID09PSBcIm1vbm9cIikgcmV0dXJuIFwibW9ub1wiO2Vsc2Uge1xuICAgICAgICBpZiAodGhpcy5ib2xkICYmIHRoaXMuaXRhbCkge1xuICAgICAgICAgIHJldHVybiBcImJvbGRpdGFsXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5ib2xkKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYm9sZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXRhbCkge1xuICAgICAgICAgIHJldHVybiBcIml0YWxcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdEJsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRCbG9jaygpIHtcbiAgICAgIGlmICh0aGlzLnNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5hZGQoXCIgXCIpO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ibG9ja3MucHVzaCh7XG4gICAgICAgICAgdGV4dDogdGhpcy5idWZmZXIsXG4gICAgICAgICAgbW9kOiB0aGlzLm1vZE5hbWUoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdXRwdXQgdGV4dCB0byBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICB0ZXh0IHRvIGFkZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09PSBcIiBcIikge1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zcGFjaW5nKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyICs9IFwiIFwiO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHQgIT0gXCIgXCIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBhcnNpbmcgb2Ygd2hpdGVzcGFjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoICB0aGUgY2hhcmFjdGVyIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNoYXJhY3RlciB3YXMgcHJvY2Vzc2VkIGFzIHdoaXRlc3BhY2UsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VXU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVdTKGNoKSB7XG4gICAgICBpZiAoL1sgXFx0XS8udGVzdChjaCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vbm8pIHtcbiAgICAgICAgICB0aGlzLnNwYWNpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWRkKGNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lICBsYWJlbCBmb3IgYmxvY2sgdHlwZSB0byBzZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRhZyh0YWdOYW1lKSB7XG4gICAgICB0aGlzLmVtaXRCbG9jaygpO1xuICAgICAgdGhpc1t0YWdOYW1lXSA9IHRydWU7XG4gICAgICB0aGlzLm1vZFN0YWNrLnVuc2hpZnQodGFnTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lICBsYWJlbCBmb3IgYmxvY2sgdHlwZSB0byB1bnNldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnNldFRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNldFRhZyh0YWdOYW1lKSB7XG4gICAgICB0aGlzLmVtaXRCbG9jaygpO1xuICAgICAgdGhpc1t0YWdOYW1lXSA9IGZhbHNlO1xuICAgICAgdGhpcy5tb2RTdGFjay5zaGlmdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBsYWJlbCBmb3IgYmxvY2sgdHlwZSB3ZSBhcmUgY3VycmVudGx5IHByb2Nlc3NpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0YWcgd2FzIHByb2Nlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVN0YXJ0VGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcodGFnTmFtZSwgdGFnKSB7XG4gICAgICAvLyBOb3RlOiBpZiAnbW9ubycgcGFzc2VkIGFzIHRhZ05hbWUsIHRoZXJlIGlzIGEgZG91YmxlIGNoZWNrIGhlcmUuIFRoaXMgaXMgT0tcbiAgICAgIGlmICghdGhpcy5tb25vICYmICF0aGlzW3RhZ05hbWVdICYmIHRoaXMubWF0Y2godGFnKSkge1xuICAgICAgICB0aGlzLnNldFRhZyh0YWdOYW1lKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FkdmFuY2U9dHJ1ZV0gaWYgc2V0LCBhZHZhbmNlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGV4dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIG1hdGNoIGF0IGdpdmVuIHBvc2l0aW9uLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2godGFnKSB7XG4gICAgICB2YXIgYWR2YW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdmFyIF90aGlzJHByZXBhcmVSZWdFeHAgPSB0aGlzLnByZXBhcmVSZWdFeHAodGFnKSxcbiAgICAgICAgICBfdGhpcyRwcmVwYXJlUmVnRXhwMiA9IHNsaWNlZFRvQXJyYXkoX3RoaXMkcHJlcGFyZVJlZ0V4cCwgMiksXG4gICAgICAgICAgcmVnRXhwID0gX3RoaXMkcHJlcGFyZVJlZ0V4cDJbMF0sXG4gICAgICAgICAgbGVuZ3RoID0gX3RoaXMkcHJlcGFyZVJlZ0V4cDJbMV07XG5cbiAgICAgIHZhciBtYXRjaGVkID0gcmVnRXhwLnRlc3QodGhpcy50ZXh0LnN1YnN0cih0aGlzLnBvc2l0aW9uLCBsZW5ndGgpKTtcblxuICAgICAgaWYgKG1hdGNoZWQgJiYgYWR2YW5jZSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBsYWJlbCBmb3IgYmxvY2sgdHlwZSB3ZSBhcmUgY3VycmVudGx5IHByb2Nlc3NpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbbmV4dFRhZ10gcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGZvciBjaGFyYWN0ZXJzICpmb2xsb3dpbmcqIHRoZSBjdXJyZW50IHRhZ1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0YWcgd2FzIHByb2Nlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUVuZFRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUVuZFRhZyh0YWdOYW1lLCB0YWcsIG5leHRUYWcpIHtcbiAgICAgIHZhciBjaGVja1RhZyA9IHRoaXMubW9kKCkgPT09IHRhZ05hbWU7XG5cbiAgICAgIGlmICh0YWdOYW1lID09PSBcIm1vbm9cIikge1xuICAgICAgICAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciAnbW9ubydcbiAgICAgICAgY2hlY2tUYWcgPSBjaGVja1RhZyAmJiB0aGlzLm1vbm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja1RhZyA9IGNoZWNrVGFnICYmICF0aGlzLm1vbm87XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja1RhZyAmJiB0aGlzLm1hdGNoKHRhZykpIHtcbiAgICAgICAgaWYgKG5leHRUYWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFB1cnBvc2Ugb2YgdGhlIGZvbGxvd2luZyBtYXRjaCBpcyB0byBwcmV2ZW50IGEgZGlyZWN0IHVuc2V0L3NldCBvZiBhIGdpdmVuIHRhZ1xuICAgICAgICAgIC8vIEUuZy4gJypib2xkICoqc3RpbGwgYm9sZConID0+ICcqYm9sZCBzdGlsbCBib2xkKidcbiAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gdGhpcy50ZXh0Lmxlbmd0aCAtIDEgfHwgdGhpcy5tYXRjaChuZXh0VGFnLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMudW5zZXRUYWcodGFnTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudW5zZXRUYWcodGFnTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZyAgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcGFyYW0ge3ZhbHVlfSB2YWx1ZSAgc3RyaW5nIHRvIHJlcGxhY2UgdGFnIHdpdGgsIGlmIGZvdW5kIGF0IGN1cnJlbnQgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHRhZywgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKHRhZykpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWUpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdGhlIHRhZyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uZS5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXkgYFtSZWdFeHAsIG51bWJlcl1gLCB3aXRoIGV4YWN0bHkgdHdvIHZhbHVlLCB3aGVyZTpcbiAgICAgKiAgLSBSZWdFeHAgaXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2VcbiAgICAgKiAgLSBudW1iZXIgaXMgdGhlIGxlbnRoIG9mIHRoZSBpbnB1dCBzdHJpbmcgdG8gbWF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnICBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2UgYW5kIGxlbmd0aCBvZiBpbnB1dCBzdHJpbmcgdG8gbWF0Y2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyZVJlZ0V4cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlUmVnRXhwKHRhZykge1xuICAgICAgdmFyIGxlbmd0aDtcbiAgICAgIHZhciByZWdFeHA7XG5cbiAgICAgIGlmICh0YWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmVnRXhwID0gdGFnO1xuICAgICAgICBsZW5ndGggPSAxOyAvLyBBU1NVTVBUSU9OOiByZWdleHAgb25seSB0ZXN0cyBvbmUgY2hhcmFjdGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgcHJlcGFyZWQgcmVnZXhwIGlmIHByZXNlbnRcbiAgICAgICAgdmFyIHByZXBhcmVkID0gdGFnUGF0dGVyblt0YWddO1xuXG4gICAgICAgIGlmIChwcmVwYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVnRXhwID0gcHJlcGFyZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnRXhwID0gbmV3IFJlZ0V4cCh0YWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gdGFnLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyZWdFeHAsIGxlbmd0aF07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcmt1cEFjY3VtdWxhdG9yO1xufSgpO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIExhYmVsIHdoaWNoIGV4cGxvZGVzIHRoZSBsYWJlbCB0ZXh0IGludG8gbGluZXMgYW5kIGJsb2NrcyB3aXRoaW4gbGluZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIExhYmVsU3BsaXR0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtIHtMYWJlbH0gcGFyZW50IHJlZmVyZW5jZSB0byB0aGUgTGFiZWwgaW5zdGFuY2UgdXNpbmcgY3VycmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICovXG4gIGZ1bmN0aW9uIExhYmVsU3BsaXR0ZXIoY3R4LCBwYXJlbnQsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbFNwbGl0dGVyKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICB0aGlzLmhvdmVyID0gaG92ZXI7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gZGV0ZXJtaW5lIHRleHQgd2lkdGg7IHBhc3NlZCB0byBMYWJlbEFjY3VtdWxhdG9yIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgc3RyaW5nIHRvIGRldGVybWluZSB3aWR0aCBvZlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbW9kICBmb250IHR5cGUgdG8gdXNlIGZvciB0aGlzIHRleHRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB7IHdpZHRoLCB2YWx1ZXN9IHdpZHRoIGluIHBpeGVscyBhbmQgZm9udCBhdHRyaWJ1dGVzXG4gICAgICovXG5cbiAgICB2YXIgdGV4dFdpZHRoID0gZnVuY3Rpb24gdGV4dFdpZHRoKHRleHQsIG1vZCkge1xuICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7IC8vIFRPRE86IFRoaXMgY2FuIGJlIGRvbmUgbW9yZSBlZmZpY2llbnRseSB3aXRoIGNhY2hpbmdcbiAgICAgIC8vIFRoaXMgd2lsbCBzZXQgdGhlIGN0eC5mb250IGNvcnJlY3RseSwgZGVwZW5kaW5nIG9uIHNlbGVjdGVkL2hvdmVyIGFuZCBtb2QgLSBzbyB0aGF0IGN0eC5tZWFzdXJlVGV4dCgpIHdpbGwgYmUgYWNjdXJhdGUuXG5cbiAgICAgIHZhciB2YWx1ZXMgPSBfdGhpcy5wYXJlbnQuZ2V0Rm9ybWF0dGluZ1ZhbHVlcyhjdHgsIHNlbGVjdGVkLCBob3ZlciwgbW9kKTtcblxuICAgICAgdmFyIHdpZHRoID0gMDtcblxuICAgICAgaWYgKHRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgdmFyIG1lYXN1cmUgPSBfdGhpcy5jdHgubWVhc3VyZVRleHQodGV4dCk7XG5cbiAgICAgICAgd2lkdGggPSBtZWFzdXJlLndpZHRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLmxpbmVzID0gbmV3IExhYmVsQWNjdW11bGF0b3IodGV4dFdpZHRoKTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgcGFzc2VkIHRleHQgb2YgYSBsYWJlbCBpbnRvIGxpbmVzIGFuZCBibG9ja3MuXG4gICAqXG4gICAqICMgTk9URVxuICAgKlxuICAgKiBUaGUgaGFuZGxpbmcgb2Ygc3BhY2luZyBpcyBvcHRpb24gZGVwZW5kZW50OlxuICAgKlxuICAgKiAtIGlmIGBmb250Lm11bHRpIDogZmFsc2VgLCBhbGwgc3BhY2VzIGFyZSByZXRhaW5lZFxuICAgKiAtIGlmIGBmb250Lm11bHRpIDogdHJ1ZWAsIGV2ZXJ5IHNlcXVlbmNlIG9mIHNwYWNlcyBpcyBjb21wcmVzc2VkIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAqXG4gICAqIFRoaXMgbWlnaHQgbm90IGJlIHRoZSBiZXN0IHdheSB0byBkbyBpdCwgYnV0IHRoaXMgaXMgYXMgaXQgaGFzIGJlZW4gd29ya2luZyB0aWxsIG5vdy5cbiAgICogSW4gb3JkZXIgbm90IHRvIGJyZWFrIGV4aXN0aW5nIGZ1bmN0aW9uYWxpdHksIGZvciB0aGUgdGltZSBiZWluZyB0aGlzIGJlaGF2aW91ciB3aWxsXG4gICAqIGJlIHJldGFpbmVkIGluIGFueSBjb2RlIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICB0ZXh0IHRvIHNwbGl0XG4gICAqIEByZXR1cm5zIHtBcnJheTxsaW5lPn1cbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhMYWJlbFNwbGl0dGVyLCBbe1xuICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3ModGV4dCkge1xuICAgICAgaWYgKCFpc1ZhbGlkTGFiZWwodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXMuZmluYWxpemUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZvbnQgPSB0aGlzLnBhcmVudC5mb250T3B0aW9uczsgLy8gTm9ybWFsaXplIHRoZSBlbmQtb2YtbGluZSdzIHRvIGEgc2luZ2xlIHJlcHJlc2VudGF0aW9uIC0gb3JkZXIgaW1wb3J0YW50XG5cbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKTsgLy8gRG9zIEVPTCdzXG5cbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKTsgLy8gTWFjIEVPTCdzXG4gICAgICAvLyBOb3RlIHRoYXQgYXQgdGhpcyBwb2ludCwgdGhlcmUgY2FuIGJlIG5vIFxccidzIGluIHRoZSB0ZXh0LlxuICAgICAgLy8gVGhpcyBpcyB1c2VkIGxhdGVyIG9uIHNwbGl0U3RyaW5nSW50b0xpbmVzKCkgdG8gc3BsaXQgbXVsdGlmb250IHRleHRzLlxuXG4gICAgICB2YXIgbmxMaW5lcyA9IFN0cmluZyh0ZXh0KS5zcGxpdChcIlxcblwiKTtcbiAgICAgIHZhciBsaW5lQ291bnQgPSBubExpbmVzLmxlbmd0aDtcblxuICAgICAgaWYgKGZvbnQubXVsdGkpIHtcbiAgICAgICAgLy8gTXVsdGktZm9udCBjYXNlOiBzdHlsaW5nIHRhZ3MgYWN0aXZlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgYmxvY2tzID0gdGhpcy5zcGxpdEJsb2NrcyhubExpbmVzW2ldLCBmb250Lm11bHRpKTsgLy8gUG9zdDogU2VxdWVuY2VzIG9mIHRhYnMgYW5kIHNwYWNlcyBhcmUgcmVkdWNlZCB0byBzaW5nbGUgc3BhY2VcblxuICAgICAgICAgIGlmIChibG9ja3MgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG5cbiAgICAgICAgICBpZiAoYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKFwiXCIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZvbnQubWF4V2R0ID4gMCkge1xuICAgICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gZGVmaW5lZFxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnUnVubmluZyB3aWR0aENvbnN0cmFpbnQgbXVsdGksIG1heDogJyArIHRoaXMuZm9udE9wdGlvbnMubWF4V2R0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmxvY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBtb2QgPSBibG9ja3Nbal0ubW9kO1xuICAgICAgICAgICAgICB2YXIgX3RleHQgPSBibG9ja3Nbal0udGV4dDtcbiAgICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhfdGV4dCwgbW9kLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2lkdGhDb25zdHJhaW50Lm1heGltdW0gTk9UIGRlZmluZWRcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBibG9ja3MubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfbW9kID0gYmxvY2tzW19qXS5tb2Q7XG4gICAgICAgICAgICAgIHZhciBfdGV4dDIgPSBibG9ja3NbX2pdLnRleHQ7XG4gICAgICAgICAgICAgIHRoaXMubGluZXMuYXBwZW5kKF90ZXh0MiwgX21vZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmdsZS1mb250IGNhc2VcbiAgICAgICAgaWYgKGZvbnQubWF4V2R0ID4gMCkge1xuICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIGRlZmluZWRcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUnVubmluZyB3aWR0aENvbnN0cmFpbnQgbm9ybWFsLCBtYXg6ICcgKyB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCk7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxpbmVDb3VudDsgX2krKykge1xuICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhubExpbmVzW19pXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIE5PVCBkZWZpbmVkXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGluZUNvdW50OyBfaTIrKykge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKG5sTGluZXNbX2kyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxpbmVzLmZpbmFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG5vcm1hbGl6ZSB0aGUgbWFya3VwIHN5c3RlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufCdtZCd8J21hcmtkb3duJ3wnaHRtbCd9IG1hcmt1cFN5c3RlbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVNYXJrdXBTeXN0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlTWFya3VwU3lzdGVtKG1hcmt1cFN5c3RlbSkge1xuICAgICAgdmFyIHN5c3RlbSA9IFwibm9uZVwiO1xuXG4gICAgICBpZiAobWFya3VwU3lzdGVtID09PSBcIm1hcmtkb3duXCIgfHwgbWFya3VwU3lzdGVtID09PSBcIm1kXCIpIHtcbiAgICAgICAgc3lzdGVtID0gXCJtYXJrZG93blwiO1xuICAgICAgfSBlbHNlIGlmIChtYXJrdXBTeXN0ZW0gPT09IHRydWUgfHwgbWFya3VwU3lzdGVtID09PSBcImh0bWxcIikge1xuICAgICAgICBzeXN0ZW0gPSBcImh0bWxcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN5c3RlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNwbGl0SHRtbEJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdEh0bWxCbG9ja3ModGV4dCkge1xuICAgICAgdmFyIHMgPSBuZXcgTWFya3VwQWNjdW11bGF0b3IodGV4dCk7XG5cbiAgICAgIHZhciBwYXJzZUVudGl0aWVzID0gZnVuY3Rpb24gcGFyc2VFbnRpdGllcyhjaCkge1xuICAgICAgICBpZiAoLyYvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgdmFyIHBhcnNlZCA9IHMucmVwbGFjZShzLnRleHQsIFwiJmx0O1wiLCBcIjxcIikgfHwgcy5yZXBsYWNlKHMudGV4dCwgXCImYW1wO1wiLCBcIiZcIik7XG5cbiAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgcy5hZGQoXCImXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHMucG9zaXRpb24gPCBzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaCA9IHMudGV4dC5jaGFyQXQocy5wb3NpdGlvbik7XG4gICAgICAgIHZhciBwYXJzZWQgPSBzLnBhcnNlV1MoY2gpIHx8IC88Ly50ZXN0KGNoKSAmJiAocy5wYXJzZVN0YXJ0VGFnKFwiYm9sZFwiLCBcIjxiPlwiKSB8fCBzLnBhcnNlU3RhcnRUYWcoXCJpdGFsXCIsIFwiPGk+XCIpIHx8IHMucGFyc2VTdGFydFRhZyhcIm1vbm9cIiwgXCI8Y29kZT5cIikgfHwgcy5wYXJzZUVuZFRhZyhcImJvbGRcIiwgXCI8L2I+XCIpIHx8IHMucGFyc2VFbmRUYWcoXCJpdGFsXCIsIFwiPC9pPlwiKSB8fCBzLnBhcnNlRW5kVGFnKFwibW9ub1wiLCBcIjwvY29kZT5cIikpIHx8IHBhcnNlRW50aXRpZXMoY2gpO1xuXG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgcy5hZGQoY2gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5wb3NpdGlvbisrO1xuICAgICAgfVxuXG4gICAgICBzLmVtaXRCbG9jaygpO1xuICAgICAgcmV0dXJuIHMuYmxvY2tzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRNYXJrZG93bkJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdE1hcmtkb3duQmxvY2tzKHRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgcyA9IG5ldyBNYXJrdXBBY2N1bXVsYXRvcih0ZXh0KTtcbiAgICAgIHZhciBiZWdpbmFibGUgPSB0cnVlO1xuXG4gICAgICB2YXIgcGFyc2VPdmVycmlkZSA9IGZ1bmN0aW9uIHBhcnNlT3ZlcnJpZGUoY2gpIHtcbiAgICAgICAgaWYgKC9cXFxcLy50ZXN0KGNoKSkge1xuICAgICAgICAgIGlmIChzLnBvc2l0aW9uIDwgX3RoaXMyLnRleHQubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgcy5wb3NpdGlvbisrO1xuICAgICAgICAgICAgY2ggPSBfdGhpczIudGV4dC5jaGFyQXQocy5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmICgvIFxcdC8udGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMuYWRkKGNoKTtcbiAgICAgICAgICAgICAgYmVnaW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAocy5wb3NpdGlvbiA8IHMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoID0gcy50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHMucGFyc2VXUyhjaCkgfHwgcGFyc2VPdmVycmlkZShjaCkgfHwgKGJlZ2luYWJsZSB8fCBzLnNwYWNpbmcpICYmIChzLnBhcnNlU3RhcnRUYWcoXCJib2xkXCIsIFwiKlwiKSB8fCBzLnBhcnNlU3RhcnRUYWcoXCJpdGFsXCIsIFwiX1wiKSB8fCBzLnBhcnNlU3RhcnRUYWcoXCJtb25vXCIsIFwiYFwiKSkgfHwgcy5wYXJzZUVuZFRhZyhcImJvbGRcIiwgXCIqXCIsIFwiYWZ0ZXJCb2xkXCIpIHx8IHMucGFyc2VFbmRUYWcoXCJpdGFsXCIsIFwiX1wiLCBcImFmdGVySXRhbFwiKSB8fCBzLnBhcnNlRW5kVGFnKFwibW9ub1wiLCBcImBcIiwgXCJhZnRlck1vbm9cIik7XG5cbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICBzLmFkZChjaCk7XG4gICAgICAgICAgYmVnaW5hYmxlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzLnBvc2l0aW9uKys7XG4gICAgICB9XG5cbiAgICAgIHMuZW1pdEJsb2NrKCk7XG4gICAgICByZXR1cm4gcy5ibG9ja3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGxvZGVzIGEgcGllY2Ugb2YgdGV4dCBpbnRvIHNpbmdsZS1mb250IGJsb2NrcyB1c2luZyBhIGdpdmVuIG1hcmt1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58J21kJ3wnbWFya2Rvd24nfCdodG1sJ30gbWFya3VwU3lzdGVtXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7dGV4dDogc3RyaW5nLCBtb2Q6IHN0cmluZ30+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdEJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdEJsb2Nrcyh0ZXh0LCBtYXJrdXBTeXN0ZW0pIHtcbiAgICAgIHZhciBzeXN0ZW0gPSB0aGlzLmRlY29kZU1hcmt1cFN5c3RlbShtYXJrdXBTeXN0ZW0pO1xuXG4gICAgICBpZiAoc3lzdGVtID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIG1vZDogXCJub3JtYWxcIlxuICAgICAgICB9XTtcbiAgICAgIH0gZWxzZSBpZiAoc3lzdGVtID09PSBcIm1hcmtkb3duXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRNYXJrZG93bkJsb2Nrcyh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3lzdGVtID09PSBcImh0bWxcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdEh0bWxCbG9ja3ModGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGV4dCBsZW5ndGggb3ZlciB0aGUgY3VycmVudCBtYXggd2l0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvdmVyTWF4V2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3Zlck1heFdpZHRoKHRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgcmV0dXJuIHRoaXMubGluZXMuY3VyV2lkdGgoKSArIHdpZHRoID4gdGhpcy5wYXJlbnQuZm9udE9wdGlvbnMubWF4V2R0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGxvbmdlc3QgcGFydCBvZiB0aGUgc2VudGVuY2Ugd2hpY2ggc3RpbGwgZml0cyBpbiB0aGVcbiAgICAgKiBjdXJyZW50IG1heCB3aWR0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzICBBcnJheSBvZiBzdHJpbmdzIHNpZ25pZnlpbmcgYSB0ZXh0IGxpbmVzXG4gICAgICogQHJldHVybnMge251bWJlcn0gICAgICBpbmRleCBvZiBmaXJzdCBpdGVtIGluIHN0cmluZyBtYWtpbmcgc3RyaW5nIGdvIG92ZXIgbWF4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldExvbmdlc3RGaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9uZ2VzdEZpdCh3b3Jkcykge1xuICAgICAgdmFyIHRleHQgPSBcIlwiO1xuICAgICAgdmFyIHcgPSAwO1xuXG4gICAgICB3aGlsZSAodyA8IHdvcmRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgcHJlID0gdGV4dCA9PT0gXCJcIiA/IFwiXCIgOiBcIiBcIjtcbiAgICAgICAgdmFyIG5ld1RleHQgPSB0ZXh0ICsgcHJlICsgd29yZHNbd107XG4gICAgICAgIGlmICh0aGlzLm92ZXJNYXhXaWR0aChuZXdUZXh0KSkgYnJlYWs7XG4gICAgICAgIHRleHQgPSBuZXdUZXh0O1xuICAgICAgICB3Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGxvbmdlc3QgcGFydCBvZiB0aGUgc3RyaW5nIHdoaWNoIHN0aWxsIGZpdHMgaW4gdGhlXG4gICAgICogY3VycmVudCBtYXggd2lkdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBBcnJheSBvZiBzdHJpbmdzIHNpZ25pZnlpbmcgYSB0ZXh0IGxpbmVzXG4gICAgICogQHJldHVybnMge251bWJlcn0gaW5kZXggb2YgZmlyc3QgaXRlbSBpbiBzdHJpbmcgbWFraW5nIHN0cmluZyBnbyBvdmVyIG1heFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9uZ2VzdEZpdFdvcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9uZ2VzdEZpdFdvcmQod29yZHMpIHtcbiAgICAgIHZhciB3ID0gMDtcblxuICAgICAgd2hpbGUgKHcgPCB3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMub3Zlck1heFdpZHRoKHNsaWNlJDUod29yZHMpLmNhbGwod29yZHMsIDAsIHcpKSkgYnJlYWs7XG4gICAgICAgIHcrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0IHRoZSBwYXNzZWQgdGV4dCBpbnRvIGxpbmVzLCBhY2NvcmRpbmcgdG8gd2lkdGggY29uc3RyYWludCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgYXNzdW1lcyB0aGF0IHRoZSBpbnB1dCBzdHJpbmcgaXMgYSBzaW5nbGUgbGluZSwgaS5lLiB3aXRob3V0IGxpbmVzIGJyZWFrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0YWlucyBzcGFjZXMsIGlmIHN0aWxsIHByZXNlbnQgKGNhc2UgYGZvbnQubXVsdGk6IGZhbHNlYCkuXG4gICAgICogQSBzcGFjZSB3aGljaCBmYWxscyBvbiBhbiBpbnRlcm5hbCBsaW5lIGJyZWFrLCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgbmV3bGluZS5cbiAgICAgKiBUaGVyZSBpcyBubyBzcGVjaWFsIGhhbmRsaW5nIG9mIHRhYnM7IHRoZXNlIGdvIGFsb25nIHdpdGggdGhlIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttb2Q9J25vcm1hbCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYXBwZW5kTGFzdD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRTdHJpbmdJbnRvTGluZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXRTdHJpbmdJbnRvTGluZXMoc3RyKSB7XG4gICAgICB2YXIgbW9kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIm5vcm1hbFwiO1xuICAgICAgdmFyIGFwcGVuZExhc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgLy8gU2V0IHRoZSBjYW52YXMgY29udGV4dCBmb250LCBiYXNlZCB1cG9uIHRoZSBjdXJyZW50IHNlbGVjdGVkL2hvdmVyIHN0YXRlXG4gICAgICAvLyBhbmQgdGhlIHByb3ZpZGVkIG1vZCwgc28gdGhlIHRleHQgbWVhc3VyZW1lbnQgcGVyZm9ybWVkIGJ5IGdldExvbmdlc3RGaXRcbiAgICAgIC8vIHdpbGwgYmUgYWNjdXJhdGUgLSBhbmQgbm90IGp1c3QgdXNlIHRoZSBmb250IG9mIHdob2V2ZXIgbGFzdCB1c2VkIHRoZSBjYW52YXMuXG4gICAgICB0aGlzLnBhcmVudC5nZXRGb3JtYXR0aW5nVmFsdWVzKHRoaXMuY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBtb2QpOyAvLyBTdGlsbC1wcmVzZW50IHNwYWNlcyBhcmUgcmVsZXZhbnQsIHJldGFpbiB0aGVtXG5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKCArKS9nLCBcIiQxXFxyXCIpO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhbXlxccl1bXiBdKikoICspL2csIFwiJDFcXHIkMlxcclwiKTtcbiAgICAgIHZhciB3b3JkcyA9IHN0ci5zcGxpdChcIlxcclwiKTtcblxuICAgICAgd2hpbGUgKHdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLmdldExvbmdlc3RGaXQod29yZHMpO1xuXG4gICAgICAgIGlmICh3ID09PSAwKSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiB0aGUgZmlyc3Qgd29yZCBpcyBhbHJlYWR5IGxhcmdlciB0aGFuIHRoZSBtYXggd2lkdGguXG4gICAgICAgICAgdmFyIHdvcmQgPSB3b3Jkc1swXTsgLy8gQnJlYWsgdGhlIHdvcmQgdG8gdGhlIGxhcmdlc3QgcGFydCB0aGF0IGZpdHMgdGhlIGxpbmVcblxuICAgICAgICAgIHZhciB4ID0gdGhpcy5nZXRMb25nZXN0Rml0V29yZCh3b3JkKTtcbiAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUoc2xpY2UkNSh3b3JkKS5jYWxsKHdvcmQsIDAsIHgpLCBtb2QpOyAvLyBBZGp1c3QgdGhlIHdvcmQsIHNvIHRoYXQgdGhlIHJlc3Qgd2lsbCBiZSBkb25lIG5leHQgaXRlcmF0aW9uXG5cbiAgICAgICAgICB3b3Jkc1swXSA9IHNsaWNlJDUod29yZCkuY2FsbCh3b3JkLCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBza2lwIGFueSBzcGFjZSB0aGF0IGlzIHJlcGxhY2VkIGJ5IGEgbmV3bGluZVxuICAgICAgICAgIHZhciBuZXdXID0gdztcblxuICAgICAgICAgIGlmICh3b3Jkc1t3IC0gMV0gPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB3LS07XG4gICAgICAgICAgfSBlbHNlIGlmICh3b3Jkc1tuZXdXXSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgIG5ld1crKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGV4dCA9IHNsaWNlJDUod29yZHMpLmNhbGwod29yZHMsIDAsIHcpLmpvaW4oXCJcIik7XG5cbiAgICAgICAgICBpZiAodyA9PSB3b3Jkcy5sZW5ndGggJiYgYXBwZW5kTGFzdCkge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5hcHBlbmQodGV4dCwgbW9kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKHRleHQsIG1vZCk7XG4gICAgICAgICAgfSAvLyBBZGp1c3QgdGhlIHdvcmQsIHNvIHRoYXQgdGhlIHJlc3Qgd2lsbCBiZSBkb25lIG5leHQgaXRlcmF0aW9uXG5cblxuICAgICAgICAgIHdvcmRzID0gc2xpY2UkNSh3b3JkcykuY2FsbCh3b3JkcywgbmV3Vyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGFiZWxTcGxpdHRlcjtcbn0oKTtcblxuLyoqXG4gKiBMaXN0IG9mIHNwZWNpYWwgc3R5bGVzIGZvciBtdWx0aS1mb250c1xuICpcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIG11bHRpRm9udFN0eWxlID0gW1wiYm9sZFwiLCBcIml0YWxcIiwgXCJib2xkaXRhbFwiLCBcIm1vbm9cIl07XG4vKipcbiAqIEEgTGFiZWwgdG8gYmUgdXNlZCBmb3IgTm9kZXMgb3IgRWRnZXMuXG4gKi9cblxudmFyIExhYmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VkZ2VsYWJlbD1mYWxzZV1cbiAgICovXG4gIGZ1bmN0aW9uIExhYmVsKGJvZHksIG9wdGlvbnMpIHtcbiAgICB2YXIgZWRnZWxhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5wb2ludFRvU2VsZiA9IGZhbHNlO1xuICAgIHRoaXMuYmFzZVNpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb250T3B0aW9ucyA9IHt9OyAvLyBpbnN0YW5jZSB2YXJpYWJsZSBjb250YWluaW5nIHRoZSAqaW5zdGFuY2UtbG9jYWwqIGZvbnQgb3B0aW9uc1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHlMaW5lOiAwXG4gICAgfTtcbiAgICB0aGlzLmlzRWRnZUxhYmVsID0gZWRnZWxhYmVsO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgcGFyZW50IE5vZGUtaW5zdGFuY2VcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhMYWJlbCwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZWxlbWVudE9wdGlvbnMgPSBvcHRpb25zOyAvLyBSZWZlcmVuY2UgdG8gdGhlIG9wdGlvbnMgb2YgdGhlIHBhcmVudCBOb2RlLWluc3RhbmNlXG5cbiAgICAgIHRoaXMuaW5pdEZvbnRPcHRpb25zKG9wdGlvbnMuZm9udCk7XG5cbiAgICAgIGlmIChpc1ZhbGlkTGFiZWwob3B0aW9ucy5sYWJlbCkpIHtcbiAgICAgICAgdGhpcy5sYWJlbERpcnR5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJhZCBsYWJlbCEgQ2hhbmdlIHRoZSBvcHRpb24gdmFsdWUgdG8gcHJldmVudCBiYWQgc3R1ZmYgaGFwcGVuaW5nXG4gICAgICAgIG9wdGlvbnMubGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmZvbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gZm9udCBvcHRpb25zIGNhbiBiZSBkZWxldGVkIGF0IHZhcmlvdXMgbGV2ZWxzXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb250ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5iYXNlU2l6ZSA9IHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mXzEob3B0aW9ucy5mb250KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHZhciBzaXplID0gb3B0aW9ucy5mb250LnNpemU7XG5cbiAgICAgICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VTaXplID0gc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdCB0aGUgZm9udCBPcHRpb25zIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIE1lbWJlciBmb250T3B0aW9ucyBzZXJ2ZXMgYXMgYW4gYWNjdW11bGF0b3IgZm9yIHRoZSBjdXJyZW50IGZvbnQgb3B0aW9ucy5cbiAgICAgKiBBcyBzdWNoLCBpdCBuZWVkcyB0byBiZSBjb21wbGV0ZWx5IHNlcGFyYXRlZCBmcm9tIHRoZSBub2RlIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3Rm9udE9wdGlvbnMgdGhlIG5ldyBmb250IG9wdGlvbnMgdG8gcHJvY2Vzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0Rm9udE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdEZvbnRPcHRpb25zKG5ld0ZvbnRPcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBQcmVwYXJlIHRoZSBtdWx0aS1mb250IG9wdGlvbiBvYmplY3RzLlxuICAgICAgLy8gVGhlc2Ugd2lsbCBiZSBmaWxsZWQgaW4gcHJvcGFnYXRlRm9udHMoKSwgaWYgcmVxdWlyZWRcbiAgICAgIGZvckVhY2gkMyhtdWx0aUZvbnRTdHlsZSwgZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIF90aGlzLmZvbnRPcHRpb25zW3N0eWxlXSA9IHt9O1xuICAgICAgfSk7IC8vIEhhbmRsZSBzaG9ydGhhbmQgb3B0aW9uLCBpZiBwcmVzZW50XG5cbiAgICAgIGlmIChMYWJlbC5wYXJzZUZvbnRTdHJpbmcodGhpcy5mb250T3B0aW9ucywgbmV3Rm9udE9wdGlvbnMpKSB7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMudmFkanVzdCA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ29weSBvdmVyIHRoZSBub24tbXVsdGlmb250IG9wdGlvbnMsIGlmIHNwZWNpZmllZFxuXG5cbiAgICAgIGZvckVhY2gkMyhuZXdGb250T3B0aW9ucywgZnVuY3Rpb24gKHByb3AsIG4pIHtcbiAgICAgICAgaWYgKHByb3AgIT09IHVuZGVmaW5lZCAmJiBwcm9wICE9PSBudWxsICYmIF90eXBlb2ZfMShwcm9wKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIF90aGlzLmZvbnRPcHRpb25zW25dID0gcHJvcDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGluLXZhcmlhYmxlIGlzIGEgc3RyaW5nLCBwYXJzZSBpdCBhcyBhIGZvbnQgc3BlY2lmaWVyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGZvbGxvd2luZyBpcyBub3QgZG9uZSBoZXJlIGFuZCBoYXZlIHRvIGJlIGRvbmUgYWZ0ZXIgdGhlIGNhbGw6XG4gICAgICogLSBOb3QgYWxsIGZvbnQgb3B0aW9ucyBhcmUgc2V0ICh2YWRqdXN0LCBtb2QpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3V0T3B0aW9ucyAgb3V0LXBhcmFtZXRlciwgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSBwYXJzZSByZXN1bHRzIChpZiBhbnkpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluT3B0aW9ucyAgZm9udCBvcHRpb25zIHRvIHBhcnNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgZm9udCBwYXJzZWQgYXMgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdHJhaW5cIixcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBjb25zdHJhaW50cyBiYXNlZCBvbiAnbmVhcmVzdCcgdmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBpbGUgYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgdG8gY29uc2lkZXJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgYWN0dWFsIGNvbnN0cmFpbnQgdmFsdWVzIHRvIHVzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN0cmFpbihwaWxlKSB7XG4gICAgICAvLyBOT1RFOiBjb25zdHJhaW5XaWR0aCBhbmQgIGNvbnN0cmFpbkhlaWdodCBuZXZlciBzZXQhXG4gICAgICAvLyBOT1RFOiBmb3IgZWRnZSBsYWJlbHMsIG9ubHkgJ21heFdkdCcgc2V0XG4gICAgICAvLyBOb2RlIGxhYmVscyBjYW4gc2V0IGFsbCB0aGUgZmllbGRzXG4gICAgICB2YXIgZm9udE9wdGlvbnMgPSB7XG4gICAgICAgIGNvbnN0cmFpbldpZHRoOiBmYWxzZSxcbiAgICAgICAgbWF4V2R0OiAtMSxcbiAgICAgICAgbWluV2R0OiAtMSxcbiAgICAgICAgY29uc3RyYWluSGVpZ2h0OiBmYWxzZSxcbiAgICAgICAgbWluSGd0OiAtMSxcbiAgICAgICAgdmFsaWduOiBcIm1pZGRsZVwiXG4gICAgICB9O1xuICAgICAgdmFyIHdpZHRoQ29uc3RyYWludCA9IHRvcE1vc3QocGlsZSwgXCJ3aWR0aENvbnN0cmFpbnRcIik7XG5cbiAgICAgIGlmICh0eXBlb2Ygd2lkdGhDb25zdHJhaW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGZvbnRPcHRpb25zLm1heFdkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnQpO1xuICAgICAgICBmb250T3B0aW9ucy5taW5XZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZl8xKHdpZHRoQ29uc3RyYWludCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHdpZHRoQ29uc3RyYWludE1heGltdW0gPSB0b3BNb3N0KHBpbGUsIFtcIndpZHRoQ29uc3RyYWludFwiLCBcIm1heGltdW1cIl0pO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGhDb25zdHJhaW50TWF4aW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGZvbnRPcHRpb25zLm1heFdkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnRNYXhpbXVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aWR0aENvbnN0cmFpbnRNaW5pbXVtID0gdG9wTW9zdChwaWxlLCBbXCJ3aWR0aENvbnN0cmFpbnRcIiwgXCJtaW5pbXVtXCJdKTtcblxuICAgICAgICBpZiAodHlwZW9mIHdpZHRoQ29uc3RyYWludE1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5taW5XZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50TWluaW11bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGhlaWdodENvbnN0cmFpbnQgPSB0b3BNb3N0KHBpbGUsIFwiaGVpZ2h0Q29uc3RyYWludFwiKTtcblxuICAgICAgaWYgKHR5cGVvZiBoZWlnaHRDb25zdHJhaW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGZvbnRPcHRpb25zLm1pbkhndCA9IE51bWJlcihoZWlnaHRDb25zdHJhaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZl8xKGhlaWdodENvbnN0cmFpbnQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBoZWlnaHRDb25zdHJhaW50TWluaW11bSA9IHRvcE1vc3QocGlsZSwgW1wiaGVpZ2h0Q29uc3RyYWludFwiLCBcIm1pbmltdW1cIl0pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0Q29uc3RyYWludE1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5taW5IZ3QgPSBOdW1iZXIoaGVpZ2h0Q29uc3RyYWludE1pbmltdW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlaWdodENvbnN0cmFpbnRWYWxpZ24gPSB0b3BNb3N0KHBpbGUsIFtcImhlaWdodENvbnN0cmFpbnRcIiwgXCJ2YWxpZ25cIl0pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChoZWlnaHRDb25zdHJhaW50VmFsaWduID09PSBcInRvcFwiIHx8IGhlaWdodENvbnN0cmFpbnRWYWxpZ24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICAgIGZvbnRPcHRpb25zLnZhbGlnbiA9IGhlaWdodENvbnN0cmFpbnRWYWxpZ247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb250T3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG9wdGlvbnMgYW5kIHVwZGF0ZSBpbnRlcm5hbCBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIG9wdGlvbnMgdG8gc2V0XG4gICAgICogQHBhcmFtIHtBcnJheX0gIHBpbGUgICAgIGFycmF5IG9mIG9wdGlvbiBvYmplY3RzIHRvIGNvbnNpZGVyIGZvciBvcHRpb24gJ2Nob3NlbidcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUob3B0aW9ucywgcGlsZSkge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMsIHRydWUpO1xuICAgICAgdGhpcy5wcm9wYWdhdGVGb250cyhwaWxlKTtcbiAgICAgIGRlZXBFeHRlbmQodGhpcy5mb250T3B0aW9ucywgdGhpcy5jb25zdHJhaW4ocGlsZSkpO1xuICAgICAgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyID0gY2hvb3NpZnkoXCJsYWJlbFwiLCBwaWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBtYXJnaW5zIGFyZSBzZXQgaW4gYW4gZWxlbWVudCwgYWRqdXN0IHNpemVzIGlzIGNhbGxlZCB0byByZW1vdmUgdGhlbVxuICAgICAqIGZyb20gdGhlIHdpZHRoL2hlaWdodCBjb25zdHJhaW50cy4gVGhpcyBtdXN0IGJlIGRvbmUgcHJpb3IgdG8gbGFiZWwgc2l6aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBtYXJnaW5zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RTaXplc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RTaXplcyhtYXJnaW5zKSB7XG4gICAgICB2YXIgd2lkdGhCaWFzID0gbWFyZ2lucyA/IG1hcmdpbnMucmlnaHQgKyBtYXJnaW5zLmxlZnQgOiAwO1xuXG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5jb25zdHJhaW5XaWR0aCkge1xuICAgICAgICB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCAtPSB3aWR0aEJpYXM7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWluV2R0IC09IHdpZHRoQmlhcztcbiAgICAgIH1cblxuICAgICAgdmFyIGhlaWdodEJpYXMgPSBtYXJnaW5zID8gbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbSA6IDA7XG5cbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmNvbnN0cmFpbkhlaWdodCkge1xuICAgICAgICB0aGlzLmZvbnRPcHRpb25zLm1pbkhndCAtPSBoZWlnaHRCaWFzO1xuICAgICAgfVxuICAgIH0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTWV0aG9kcyBmb3IgaGFuZGxpbmcgb3B0aW9ucyBwaWxlc1xuICAgIC8vIEV2ZW50dWFsbHksIHRoZXNlIHdpbGwgYmUgbW92ZWQgdG8gYSBzZXBhcmF0ZSBjbGFzc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBmb250IG1lbWJlcnMgb2YgdGhlIHBhc3NlZCBsaXN0IG9mIG9wdGlvbiBvYmplY3RzIHRvIHRoZSBwaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBkc3RQaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIGFkZCB0b1xuICAgICAqIEBwYXJhbSB7UGlsZX0gc3JjUGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB0YWtlIGZvbnQgb3B0aW9ucyBmcm9tXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEZvbnRPcHRpb25zVG9QaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEZvbnRPcHRpb25zVG9QaWxlKGRzdFBpbGUsIHNyY1BpbGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjUGlsZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmFkZEZvbnRUb1BpbGUoZHN0UGlsZSwgc3JjUGlsZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBnaXZlbiBmb250IG9wdGlvbiBvYmplY3QgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyAodGhlICdwaWxlJykgdG8gY29uc2lkZXIgZm9yIGRldGVybWluaW5nXG4gICAgICogbXVsdGktZm9udCBvcHRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBpbnN0YW5jZSB0byBhZGQgdG8gcGlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRGb250VG9QaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEZvbnRUb1BpbGUocGlsZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgaWYgKG9wdGlvbnMuZm9udCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZm9udCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIGl0ZW0gPSBvcHRpb25zLmZvbnQ7XG4gICAgICBwaWxlLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxlY3QgYWxsIG93bi1wcm9wZXJ0eSB2YWx1ZXMgZnJvbSB0aGUgZm9udCBwaWxlIHRoYXQgYXJlbid0IG11bHRpLWZvbnQgb3B0aW9uIG9iamVjdHNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IG9iamVjdCB3aXRoIGFsbCBjdXJyZW50IG93biBiYXNpYyBmb250IHByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzaWNPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2ljT3B0aW9ucyhwaWxlKSB7XG4gICAgICB2YXIgcmV0ID0ge307IC8vIFNjYW5zIHRoZSB3aG9sZSBwaWxlIHRvIGdldCBhbGwgb3B0aW9ucyBwcmVzZW50XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcGlsZS5sZW5ndGg7ICsrbikge1xuICAgICAgICB2YXIgZm9udE9wdGlvbnMgPSBwaWxlW25dOyAvLyBDb252ZXJ0IHNob3J0aGFuZCBpZiBuZWNlc3NhcnlcblxuICAgICAgICB2YXIgdG1wU2hvcnRoYW5kID0ge307XG5cbiAgICAgICAgaWYgKExhYmVsLnBhcnNlRm9udFN0cmluZyh0bXBTaG9ydGhhbmQsIGZvbnRPcHRpb25zKSkge1xuICAgICAgICAgIGZvbnRPcHRpb25zID0gdG1wU2hvcnRoYW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yRWFjaCQzKGZvbnRPcHRpb25zLCBmdW5jdGlvbiAob3B0LCBuYW1lKSB7XG4gICAgICAgICAgaWYgKG9wdCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIG11bHRpLWZvbnQgb3B0aW9uIG5lZWQgbm90IGJlIHByZXNlbnRcblxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmV0LCBuYW1lKSkgcmV0dXJuOyAvLyBLZWVwIGZpcnN0IHZhbHVlIHdlIGVuY291bnRlclxuXG4gICAgICAgICAgaWYgKGluZGV4T2YkMyhtdWx0aUZvbnRTdHlsZSkuY2FsbChtdWx0aUZvbnRTdHlsZSwgbmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBTa2lwIG11bHRpLWZvbnQgcHJvcGVydGllcyBidXQgd2UgZG8gbmVlZCB0aGUgc3RydWN0dXJlXG4gICAgICAgICAgICByZXRbbmFtZV0gPSB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0W25hbWVdID0gb3B0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgZm9yIGdpdmVuIG9wdGlvbiBmb3IgdGhlIGdpdmVuIG11bHRpLWZvbnQuXG4gICAgICpcbiAgICAgKiBBbGwgYXZhaWxhYmxlIG9wdGlvbiBvYmplY3RzIGFyZSB0cmF3bGVkIGluIHRoZSBzZXQgb3JkZXIgdG8gY29uc3RydWN0IHRoZSBvcHRpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIyMgVHJhdmVyc2FsIG9mIHBpbGUgZm9yIG11bHRpLWZvbnRzXG4gICAgICpcbiAgICAgKiBUaGUgZGV0ZXJtaW5hdGlvbiBvZiBtdWx0aS1mb250IG9wdGlvbiB2YWx1ZXMgaXMgYSBzcGVjaWFsIGNhc2UsIGJlY2F1c2UgYW55IHZhbHVlcyBub3RcbiAgICAgKiBwcmVzZW50IGluIHRoZSBtdWx0aS1mb250IG9wdGlvbnMgc2hvdWxkIGJ5IGRlZmluaXRpb24gYmUgdGFrZW4gZnJvbSB0aGUgbWFpbiBmb250IG9wdGlvbnMsXG4gICAgICogaS5lLiBmcm9tIHRoZSBjdXJyZW50ICdwYXJlbnQnIG9iamVjdCBvZiB0aGUgbXVsdGktZm9udCBvcHRpb24uXG4gICAgICpcbiAgICAgKiAjIyMgU2VhcmNoIG9yZGVyIGZvciBtdWx0aS1mb250c1xuICAgICAqXG4gICAgICogJ2JvbGQnIHVzZWQgYXMgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgLSBzZWFyY2ggaW4gb3B0aW9uIGdyb3VwICdib2xkJyBpbiBsb2NhbCBwcm9wZXJ0aWVzXG4gICAgICogICAtIHNlYXJjaCBpbiBtYWluIGZvbnQgb3B0aW9uIGdyb3VwIGluIGxvY2FsIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7TXVsdGlGb250U3R5bGV9IG11bHRpTmFtZSBzdWIgcGF0aCBmb3IgdGhlIG11bHRpLWZvbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uICB0aGUgb3B0aW9uIHRvIHNlYXJjaCBmb3IsIGZvciB0aGUgZ2l2ZW4gbXVsdGktZm9udFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9udE9wdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb250T3B0aW9uKHBpbGUsIG11bHRpTmFtZSwgb3B0aW9uKSB7XG4gICAgICB2YXIgbXVsdGlGb250OyAvLyBTZWFyY2ggbXVsdGkgZm9udCBpbiBsb2NhbCBwcm9wZXJ0aWVzXG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcGlsZS5sZW5ndGg7ICsrbikge1xuICAgICAgICB2YXIgZm9udE9wdGlvbnMgPSBwaWxlW25dO1xuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9udE9wdGlvbnMsIG11bHRpTmFtZSkpIHtcbiAgICAgICAgICBtdWx0aUZvbnQgPSBmb250T3B0aW9uc1ttdWx0aU5hbWVdO1xuICAgICAgICAgIGlmIChtdWx0aUZvbnQgPT09IHVuZGVmaW5lZCB8fCBtdWx0aUZvbnQgPT09IG51bGwpIGNvbnRpbnVlOyAvLyBDb252ZXJ0IHNob3J0aGFuZCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAvLyBUT0RPOiBpbmVmZmljaWVudCB0byBkbyB0aGlzIGNvbnZlcnNpb24gZXZlcnkgdGltZTsgZmluZCBhIGJldHRlciB3YXkuXG5cbiAgICAgICAgICB2YXIgdG1wU2hvcnRoYW5kID0ge307XG5cbiAgICAgICAgICBpZiAoTGFiZWwucGFyc2VGb250U3RyaW5nKHRtcFNob3J0aGFuZCwgbXVsdGlGb250KSkge1xuICAgICAgICAgICAgbXVsdGlGb250ID0gdG1wU2hvcnRoYW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobXVsdGlGb250LCBvcHRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbXVsdGlGb250W29wdGlvbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIE9wdGlvbiBpcyBub3QgbWVudGlvbmVkIGluIHRoZSBtdWx0aSBmb250IG9wdGlvbnM7IHRha2UgaXQgZnJvbSB0aGUgcGFyZW50IGZvbnQgb3B0aW9ucy5cbiAgICAgIC8vIFRoZXNlIGhhdmUgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCB3aXRoIGdldEJhc2ljT3B0aW9ucygpLCBzbyB1c2UgdGhlIGNvbnZlcnRlZCB2YWx1ZXMuXG5cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmZvbnRPcHRpb25zLCBvcHRpb24pKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRPcHRpb25zW29wdGlvbl07XG4gICAgICB9IC8vIEEgdmFsdWUgKiptdXN0KiogYmUgZm91bmQ7IHlvdSBzaG91bGQgbmV2ZXIgZ2V0IGhlcmUuXG5cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBmaW5kIHZhbHVlIGZvciBtdWx0aS1mb250IGZvciBwcm9wZXJ0eTogJ1wiICsgb3B0aW9uICsgXCInXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIG9wdGlvbnMgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gbXVsdGktZm9udC5cbiAgICAgKlxuICAgICAqIEFsbCBhdmFpbGFibGUgb3B0aW9uIG9iamVjdHMgYXJlIHRyYXdsZWQgaW4gdGhlIHNldCBvcmRlciB0byBjb25zdHJ1Y3QgdGhlIG9wdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHBhcmFtIHtNdWx0aUZvbnRTdHlsZX0gbXVsdGlOYW1lIHN1YiBwYXRoIGZvciB0aGUgbW9kLWZvbnRcbiAgICAgKiBAcmV0dXJucyB7TXVsdGlGb250T3B0aW9uc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9udE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9udE9wdGlvbnMocGlsZSwgbXVsdGlOYW1lKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgb3B0aW9uTmFtZXMgPSBbXCJjb2xvclwiLCBcInNpemVcIiwgXCJmYWNlXCIsIFwibW9kXCIsIFwidmFkanVzdFwiXTsgLy8gTGlzdCBvZiBhbGxvd2VkIG9wdGlvbnMgcGVyIG11bHRpLWZvbnRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25OYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbW9kID0gb3B0aW9uTmFtZXNbaV07XG4gICAgICAgIHJlc3VsdFttb2RdID0gdGhpcy5nZXRGb250T3B0aW9uKHBpbGUsIG11bHRpTmFtZSwgbW9kKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEVuZCBtZXRob2RzIGZvciBoYW5kbGluZyBvcHRpb25zIHBpbGVzXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSB0aGUgZm9udCBvcHRpb25zIGZvciB0aGUgbXVsdGktZm9udCB0byBzaW5nbGUgb2JqZWN0cywgZnJvbVxuICAgICAqIHRoZSBjaGFpbiBvZiBvcHRpb24gb2JqZWN0cyBwYXNzZWQgKHRoZSAncGlsZScpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQaWxlfSBwaWxlICBzZXF1ZW5jZSBvZiBvcHRpb24gb2JqZWN0cyB0byBjb25zaWRlci5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIEZpcnN0IGl0ZW0gaW4gbGlzdCBhc3N1bWVkIHRvIGJlIHRoZSBuZXdseSBzZXQgb3B0aW9ucy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByb3BhZ2F0ZUZvbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3BhZ2F0ZUZvbnRzKHBpbGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9udFBpbGUgPSBbXTsgLy8gc2VxdWVuY2Ugb2YgZm9udCBvYmplY3RzIHRvIGNvbnNpZGVyLCBvcmRlciBpbXBvcnRhbnRcbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzLmVsZW1lbnRPcHRpb25zIGlzIG5vdCB1c2VkIGhlcmUuXG5cbiAgICAgIHRoaXMuYWRkRm9udE9wdGlvbnNUb1BpbGUoZm9udFBpbGUsIHBpbGUpO1xuICAgICAgdGhpcy5mb250T3B0aW9ucyA9IHRoaXMuZ2V0QmFzaWNPcHRpb25zKGZvbnRQaWxlKTsgLy8gV2Ugc2V0IG11bHRpZm9udCB2YWx1ZXMgZXZlbiBpZiBtdWx0aSA9PT0gZmFsc2UsIGZvciBjb25zaXN0ZW5jeSAodGhpbmdzIGJyZWFrIG90aGVyd2lzZSlcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICB2YXIgbW9kID0gbXVsdGlGb250U3R5bGVbaV07XG4gICAgICAgIHZhciBtb2RPcHRpb25zID0gX3RoaXMyLmZvbnRPcHRpb25zW21vZF07XG5cbiAgICAgICAgdmFyIHRtcE11bHRpRm9udE9wdGlvbnMgPSBfdGhpczIuZ2V0Rm9udE9wdGlvbnMoZm9udFBpbGUsIG1vZCk7IC8vIENvcHkgb3ZlciBmb3VuZCB2YWx1ZXNcblxuXG4gICAgICAgIGZvckVhY2gkMyh0bXBNdWx0aUZvbnRPcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uLCBuKSB7XG4gICAgICAgICAgbW9kT3B0aW9uc1tuXSA9IG9wdGlvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vZE9wdGlvbnMuc2l6ZSA9IE51bWJlcihtb2RPcHRpb25zLnNpemUpO1xuICAgICAgICBtb2RPcHRpb25zLnZhZGp1c3QgPSBOdW1iZXIobW9kT3B0aW9ucy52YWRqdXN0KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlGb250U3R5bGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgX2xvb3AoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1haW4gZnVuY3Rpb24uIFRoaXMgaXMgY2FsbGVkIGZyb20gYW55dGhpbmcgdGhhdCB3YW50cyB0byBkcmF3IGEgbGFiZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtiYXNlbGluZT0nbWlkZGxlJ11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBcIm1pZGRsZVwiO1xuICAgICAgLy8gaWYgbm8gbGFiZWwsIHJldHVyblxuICAgICAgaWYgKHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBjaGVjayBpZiB3ZSBoYXZlIHRvIHJlbmRlciB0aGUgbGFiZWxcblxuICAgICAgdmFyIHZpZXdGb250U2l6ZSA9IHRoaXMuZm9udE9wdGlvbnMuc2l6ZSAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwgJiYgdmlld0ZvbnRTaXplIDwgdGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSAxKSByZXR1cm47IC8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZXJlIHdpbGwgbm90IGJlIEhVR0UgbGV0dGVycyBvbiBzY3JlZW5cbiAgICAgIC8vIGJ5IHNldHRpbmcgYW4gdXBwZXIgbGltaXQgb24gdGhlIHZpc2libGUgdGV4dCBzaXplIChyZWdhcmRsZXNzIG9mIHpvb21MZXZlbClcblxuICAgICAgaWYgKHZpZXdGb250U2l6ZSA+PSB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSkge1xuICAgICAgICB2aWV3Rm9udFNpemUgPSBOdW1iZXIodGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heFZpc2libGUpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9IC8vIHVwZGF0ZSB0aGUgc2l6ZSBjYWNoZSBpZiByZXF1aXJlZFxuXG5cbiAgICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB4LCB5LCBiYXNlbGluZSk7XG5cbiAgICAgIHRoaXMuX2RyYXdCYWNrZ3JvdW5kKGN0eCk7XG5cbiAgICAgIHRoaXMuX2RyYXdUZXh0KGN0eCwgeCwgdGhpcy5zaXplLnlMaW5lLCBiYXNlbGluZSwgdmlld0ZvbnRTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGxhYmVsIGJhY2tncm91bmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdCYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3QmFja2dyb3VuZChjdHgpIHtcbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQ7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICAgIGN0eC5maWxsUmVjdChzaXplLmxlZnQsIHNpemUudG9wLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Rm9udFNpemVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3VGV4dChjdHgsIHgsIHkpIHtcbiAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJtaWRkbGVcIjtcbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIF90aGlzJF9zZXRBbGlnbm1lbnQgPSB0aGlzLl9zZXRBbGlnbm1lbnQoY3R4LCB4LCB5LCBiYXNlbGluZSk7XG5cbiAgICAgIHZhciBfdGhpcyRfc2V0QWxpZ25tZW50MiA9IHNsaWNlZFRvQXJyYXkoX3RoaXMkX3NldEFsaWdubWVudCwgMik7XG5cbiAgICAgIHggPSBfdGhpcyRfc2V0QWxpZ25tZW50MlswXTtcbiAgICAgIHkgPSBfdGhpcyRfc2V0QWxpZ25tZW50MlsxXTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgIHggPSB4IC0gdGhpcy5zaXplLndpZHRoIC8gMjsgLy8gU2hpZnQgbGFiZWwgMS8yLWRpc3RhbmNlIHRvIHRoZSBsZWZ0XG5cbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiAmJiB0aGlzLnNpemUuaGVpZ2h0ID4gdGhpcy5zaXplLmxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgIHkgLT0gKHRoaXMuc2l6ZS5oZWlnaHQgLSB0aGlzLnNpemUubGFiZWxIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgICAgIHkgKz0gKHRoaXMuc2l6ZS5oZWlnaHQgLSB0aGlzLnNpemUubGFiZWxIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBkcmF3IHRoZSB0ZXh0XG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcblxuICAgICAgICBpZiAobGluZSAmJiBsaW5lLmJsb2Nrcykge1xuICAgICAgICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0VkZ2VMYWJlbCB8fCB0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICB3aWR0aCArPSAodGhpcy5zaXplLndpZHRoIC0gbGluZS53aWR0aCkgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICB3aWR0aCArPSB0aGlzLnNpemUud2lkdGggLSBsaW5lLndpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5ibG9ja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IGxpbmUuYmxvY2tzW2pdO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBibG9jay5mb250O1xuXG4gICAgICAgICAgICB2YXIgX3RoaXMkX2dldENvbG9yID0gdGhpcy5fZ2V0Q29sb3IoYmxvY2suY29sb3IsIHZpZXdGb250U2l6ZSwgYmxvY2suc3Ryb2tlQ29sb3IpLFxuICAgICAgICAgICAgICAgIF90aGlzJF9nZXRDb2xvcjIgPSBzbGljZWRUb0FycmF5KF90aGlzJF9nZXRDb2xvciwgMiksXG4gICAgICAgICAgICAgICAgZm9udENvbG9yID0gX3RoaXMkX2dldENvbG9yMlswXSxcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvciA9IF90aGlzJF9nZXRDb2xvcjJbMV07XG5cbiAgICAgICAgICAgIGlmIChibG9jay5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJsb2NrLnN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvcjtcbiAgICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZm9udENvbG9yO1xuXG4gICAgICAgICAgICBpZiAoYmxvY2suc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGJsb2NrLnRleHQsIHggKyB3aWR0aCwgeSArIGJsb2NrLnZhZGp1c3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguZmlsbFRleHQoYmxvY2sudGV4dCwgeCArIHdpZHRoLCB5ICsgYmxvY2sudmFkanVzdCk7XG4gICAgICAgICAgICB3aWR0aCArPSBibG9jay53aWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB5ICs9IGxpbmUuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZWxpbmVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRBbGlnbm1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEFsaWdubWVudChjdHgsIHgsIHksIGJhc2VsaW5lKSB7XG4gICAgICAvLyBjaGVjayBmb3IgbGFiZWwgYWxpZ25tZW50IChmb3IgZWRnZXMpXG4gICAgICAvLyBUT0RPOiBtYWtlIGFsaWdubWVudCBmb3Igbm9kZXNcbiAgICAgIGlmICh0aGlzLmlzRWRnZUxhYmVsICYmIHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gIT09IFwiaG9yaXpvbnRhbFwiICYmIHRoaXMucG9pbnRUb1NlbGYgPT09IGZhbHNlKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgICB5ID0gMDtcbiAgICAgICAgdmFyIGxpbmVNYXJnaW4gPSAyO1xuXG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiO1xuICAgICAgICAgIHkgLT0gMiAqIGxpbmVNYXJnaW47IC8vIGRpc3RhbmNlIGZyb20gZWRnZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgYWxwaGFiZXRpYy4gQWxwaGFiZXRpYyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZvbnRPcHRpb25zLmFsaWduID09PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwiaGFuZ2luZ1wiO1xuICAgICAgICAgIHkgKz0gMiAqIGxpbmVNYXJnaW47IC8vIGRpc3RhbmNlIGZyb20gZWRnZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgaGFuZ2luZy4gSGFuZ2luZyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IGJhc2VsaW5lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmYWRlIGluIHdoZW4gcmVsYXRpdmUgc2NhbGUgaXMgYmV0d2VlbiB0aHJlc2hvbGQgYW5kIHRocmVzaG9sZCAtIDEuXG4gICAgICogSWYgdGhlIHJlbGF0aXZlIHNjYWxlIHdvdWxkIGJlIHNtYWxsZXIgdGhhbiB0aHJlc2hvbGQgLTEgdGhlIGRyYXcgZnVuY3Rpb24gd291bGQgaGF2ZSByZXR1cm5lZCBiZWZvcmUgY29taW5nIGhlcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgIFRoZSBmb250IGNvbG9yIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Rm9udFNpemVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5pdGlhbFN0cm9rZUNvbG9yXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmb250IGNvbG9yIGFuZCBzdHJva2UgY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb2xvcihjb2xvciwgdmlld0ZvbnRTaXplLCBpbml0aWFsU3Ryb2tlQ29sb3IpIHtcbiAgICAgIHZhciBmb250Q29sb3IgPSBjb2xvciB8fCBcIiMwMDAwMDBcIjtcbiAgICAgIHZhciBzdHJva2VDb2xvciA9IGluaXRpYWxTdHJva2VDb2xvciB8fCBcIiNmZmZmZmZcIjtcblxuICAgICAgaWYgKHZpZXdGb250U2l6ZSA8PSB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCkge1xuICAgICAgICB2YXIgb3BhY2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIDEgLSAodGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSB2aWV3Rm9udFNpemUpKSk7XG4gICAgICAgIGZvbnRDb2xvciA9IG92ZXJyaWRlT3BhY2l0eShmb250Q29sb3IsIG9wYWNpdHkpO1xuICAgICAgICBzdHJva2VDb2xvciA9IG92ZXJyaWRlT3BhY2l0eShzdHJva2VDb2xvciwgb3BhY2l0eSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZm9udENvbG9yLCBzdHJva2VDb2xvcl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZXh0U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0U2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICB0aGlzLl9wcm9jZXNzTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy5zaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHQsXG4gICAgICAgIGxpbmVDb3VudDogdGhpcy5saW5lQ291bnRcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBkaW1lbnNpb25zIG9mIHRoZSBsYWJlbFxuICAgICAqXG4gICAgICogQHJldHVybnMge3JlY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNpemUoKSB7XG4gICAgICB2YXIgbGluZU1hcmdpbiA9IDI7XG4gICAgICB2YXIgeCA9IHRoaXMuc2l6ZS5sZWZ0OyAvLyBkZWZhdWx0IHZhbHVlcyB3aGljaCBtaWdodCBiZSBvdmVycmlkZGVuIGJlbG93XG5cbiAgICAgIHZhciB5ID0gdGhpcy5zaXplLnRvcCAtIDAuNSAqIGxpbmVNYXJnaW47IC8vIGlkZW1cblxuICAgICAgaWYgKHRoaXMuaXNFZGdlTGFiZWwpIHtcbiAgICAgICAgdmFyIHgyID0gLXRoaXMuc2l6ZS53aWR0aCAqIDAuNTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24pIHtcbiAgICAgICAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgICB5ID0gLXRoaXMuc2l6ZS5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgIHkgPSAtKHRoaXMuc2l6ZS5oZWlnaHQgKyBsaW5lTWFyZ2luKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgeCA9IHgyO1xuICAgICAgICAgICAgeSA9IGxpbmVNYXJnaW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBsZWZ0OiB4LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHdpZHRoOiB0aGlzLnNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5zaXplLmhlaWdodFxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICogQHBhcmFtIHsnbWlkZGxlJ3wnaGFuZ2luZyd9IFtiYXNlbGluZT0nbWlkZGxlJ11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUxhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgICB2YXIgYmFzZWxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IFwibWlkZGxlXCI7XG5cbiAgICAgIHRoaXMuX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHRoaXMuc2l6ZS5sZWZ0ID0geCAtIHRoaXMuc2l6ZS53aWR0aCAqIDAuNTtcbiAgICAgIHRoaXMuc2l6ZS50b3AgPSB5IC0gdGhpcy5zaXplLmhlaWdodCAqIDAuNTtcbiAgICAgIHRoaXMuc2l6ZS55TGluZSA9IHkgKyAoMSAtIHRoaXMubGluZUNvdW50KSAqIDAuNSAqIHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcblxuICAgICAgaWYgKGJhc2VsaW5lID09PSBcImhhbmdpbmdcIikge1xuICAgICAgICB0aGlzLnNpemUudG9wICs9IDAuNSAqIHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5zaXplLnRvcCArPSA0OyAvLyBkaXN0YW5jZSBmcm9tIG5vZGUsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGhhbmdpbmcuIEhhbmdpbmcgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG5cbiAgICAgICAgdGhpcy5zaXplLnlMaW5lICs9IDQ7IC8vIGRpc3RhbmNlIGZyb20gbm9kZVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RcbiAgICAgKiBAcmV0dXJucyB7e2NvbG9yLCBzaXplLCBmYWNlLCBtb2QsIHZhZGp1c3QsIHN0cm9rZVdpZHRoOiAqLCBzdHJva2VDb2xvcjogKCp8c3RyaW5nfGFsbE9wdGlvbnMuZWRnZXMuZm9udC5zdHJva2VDb2xvcnx7c3RyaW5nfXxhbGxPcHRpb25zLm5vZGVzLmZvbnQuc3Ryb2tlQ29sb3J8QXJyYXkpfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdHRpbmdWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0dGluZ1ZhbHVlcyhjdHgsIHNlbGVjdGVkLCBob3ZlciwgbW9kKSB7XG4gICAgICB2YXIgZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZShmb250T3B0aW9ucywgbW9kLCBvcHRpb24pIHtcbiAgICAgICAgaWYgKG1vZCA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIGlmIChvcHRpb24gPT09IFwibW9kXCIpIHJldHVybiBcIlwiO1xuICAgICAgICAgIHJldHVybiBmb250T3B0aW9uc1tvcHRpb25dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvbnRPcHRpb25zW21vZF1bb3B0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gR3J1bWJsIGxlYXZpbmcgb3V0IHRlc3Qgb24gdW5kZWZpbmVkIGVxdWFscyBmYWxzZSBmb3IgXCJcIlxuICAgICAgICAgIHJldHVybiBmb250T3B0aW9uc1ttb2RdW29wdGlvbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGFrZSBmcm9tIHBhcmVudCBmb250IG9wdGlvblxuICAgICAgICAgIHJldHVybiBmb250T3B0aW9uc1tvcHRpb25dO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgdmFsdWVzID0ge1xuICAgICAgICBjb2xvcjogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcImNvbG9yXCIpLFxuICAgICAgICBzaXplOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwic2l6ZVwiKSxcbiAgICAgICAgZmFjZTogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcImZhY2VcIiksXG4gICAgICAgIG1vZDogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcIm1vZFwiKSxcbiAgICAgICAgdmFkanVzdDogZ2V0VmFsdWUodGhpcy5mb250T3B0aW9ucywgbW9kLCBcInZhZGp1c3RcIiksXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmZvbnRPcHRpb25zLnN0cm9rZVdpZHRoLFxuICAgICAgICBzdHJva2VDb2xvcjogdGhpcy5mb250T3B0aW9ucy5zdHJva2VDb2xvclxuICAgICAgfTtcblxuICAgICAgaWYgKHNlbGVjdGVkIHx8IGhvdmVyKSB7XG4gICAgICAgIGlmIChtb2QgPT09IFwibm9ybWFsXCIgJiYgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyID09PSB0cnVlICYmIHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWxIaWdobGlnaHRCb2xkKSB7XG4gICAgICAgICAgdmFsdWVzLm1vZCA9IFwiYm9sZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9udE9wdGlvbnMuY2hvb3Nlcih2YWx1ZXMsIHRoaXMuZWxlbWVudE9wdGlvbnMuaWQsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmb250U3RyaW5nID0gXCJcIjtcblxuICAgICAgaWYgKHZhbHVlcy5tb2QgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMubW9kICE9PSBcIlwiKSB7XG4gICAgICAgIC8vIHNhZmVndWFyZCBmb3IgdW5kZWZpbmVkIC0gdGhpcyBoYXBwZW5lZFxuICAgICAgICBmb250U3RyaW5nICs9IHZhbHVlcy5tb2QgKyBcIiBcIjtcbiAgICAgIH1cblxuICAgICAgZm9udFN0cmluZyArPSB2YWx1ZXMuc2l6ZSArIFwicHggXCIgKyB2YWx1ZXMuZmFjZTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZy5yZXBsYWNlKC9cIi9nLCBcIlwiKTtcbiAgICAgIHZhbHVlcy5mb250ID0gY3R4LmZvbnQ7XG4gICAgICB2YWx1ZXMuaGVpZ2h0ID0gdmFsdWVzLnNpemU7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaWZmZXJlbnRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaWZmZXJlbnRTdGF0ZShzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZCAhPT0gdGhpcy5zZWxlY3RlZFN0YXRlIHx8IGhvdmVyICE9PSB0aGlzLmhvdmVyU3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZXhwbG9kZXMgdGhlIHBhc3NlZCB0ZXh0IGludG8gbGluZXMgYW5kIGRldGVybWluZXMgdGhlIHdpZHRoLCBoZWlnaHQgYW5kIG51bWJlciBvZiBsaW5lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpblRleHQgIHRoZSB0ZXh0IHRvIGV4cGxvZGVcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoLCBoZWlnaHQsIGxpbmVzfXwqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcHJvY2Vzc0xhYmVsVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc0xhYmVsVGV4dChjdHgsIHNlbGVjdGVkLCBob3ZlciwgaW5UZXh0KSB7XG4gICAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgTGFiZWxTcGxpdHRlcihjdHgsIHRoaXMsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICByZXR1cm4gc3BsaXR0ZXIucHJvY2VzcyhpblRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGV4cGxvZGVzIHRoZSBsYWJlbCBzdHJpbmcgaW50byBsaW5lcyBhbmQgc2V0cyB0aGUgd2lkdGgsIGhlaWdodCBhbmQgbnVtYmVyIG9mIGxpbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wcm9jZXNzTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubGFiZWxEaXJ0eSA9PT0gZmFsc2UgJiYgIXRoaXMuZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKSkgcmV0dXJuO1xuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLl9wcm9jZXNzTGFiZWxUZXh0KGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsKTtcblxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMubWluV2R0ID4gMCAmJiBzdGF0ZS53aWR0aCA8IHRoaXMuZm9udE9wdGlvbnMubWluV2R0KSB7XG4gICAgICAgIHN0YXRlLndpZHRoID0gdGhpcy5mb250T3B0aW9ucy5taW5XZHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2l6ZS5sYWJlbEhlaWdodCA9IHN0YXRlLmhlaWdodDtcblxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMubWluSGd0ID4gMCAmJiBzdGF0ZS5oZWlnaHQgPCB0aGlzLmZvbnRPcHRpb25zLm1pbkhndCkge1xuICAgICAgICBzdGF0ZS5oZWlnaHQgPSB0aGlzLmZvbnRPcHRpb25zLm1pbkhndDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5saW5lcyA9IHN0YXRlLmxpbmVzO1xuICAgICAgdGhpcy5saW5lQ291bnQgPSBzdGF0ZS5saW5lcy5sZW5ndGg7XG4gICAgICB0aGlzLnNpemUud2lkdGggPSBzdGF0ZS53aWR0aDtcbiAgICAgIHRoaXMuc2l6ZS5oZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG4gICAgICB0aGlzLnNlbGVjdGVkU3RhdGUgPSBzZWxlY3RlZDtcbiAgICAgIHRoaXMuaG92ZXJTdGF0ZSA9IGhvdmVyO1xuICAgICAgdGhpcy5sYWJlbERpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgbGFiZWwgaXMgdmlzaWJsZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyBsYWJlbCB3aWxsIGJlIHNob3csIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmlzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aXNpYmxlKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZS53aWR0aCA9PT0gMCB8fCB0aGlzLnNpemUuaGVpZ2h0ID09PSAwIHx8IHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG5vdGhpbmcgdG8gZGlzcGxheVxuICAgICAgfVxuXG4gICAgICB2YXIgdmlld0ZvbnRTaXplID0gdGhpcy5mb250T3B0aW9ucy5zaXplICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG5cbiAgICAgIGlmICh2aWV3Rm9udFNpemUgPCB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUb28gc21hbGwgb3IgdG9vIGZhciBhd2F5IHRvIHNob3dcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VGb250U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRm9udFN0cmluZyhvdXRPcHRpb25zLCBpbk9wdGlvbnMpIHtcbiAgICAgIGlmICghaW5PcHRpb25zIHx8IHR5cGVvZiBpbk9wdGlvbnMgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBuZXdPcHRpb25zQXJyYXkgPSBpbk9wdGlvbnMuc3BsaXQoXCIgXCIpO1xuICAgICAgb3V0T3B0aW9ucy5zaXplID0gK25ld09wdGlvbnNBcnJheVswXS5yZXBsYWNlKFwicHhcIiwgXCJcIik7XG4gICAgICBvdXRPcHRpb25zLmZhY2UgPSBuZXdPcHRpb25zQXJyYXlbMV07XG4gICAgICBvdXRPcHRpb25zLmNvbG9yID0gbmV3T3B0aW9uc0FycmF5WzJdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExhYmVsO1xufSgpO1xuXG52YXIgbmF0aXZlQ29uc3RydWN0ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTsgLy8gYFJlZmxlY3QuY29uc3RydWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuY29uc3RydWN0XG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcblxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICByZXR1cm4gIShuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0pO1xufSk7XG52YXIgRk9SQ0VEJDQgPSBORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRztcbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdSZWZsZWN0JyxcbiAgc3RhdDogdHJ1ZSxcbiAgZm9yY2VkOiBGT1JDRUQkNCxcbiAgc2hhbTogRk9SQ0VEJDRcbn0sIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzXG4gIC8qICwgbmV3VGFyZ2V0ICovXG4gICkge1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiBuYXRpdmVDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuXG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldCgpO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH0gLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcblxuXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGZ1bmN0aW9uQmluZC5hcHBseShUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9IC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuXG5cbiAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IG9iamVjdENyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuXG52YXIgY29uc3RydWN0JDEgPSBwYXRoLlJlZmxlY3QuY29uc3RydWN0O1xuXG52YXIgY29uc3RydWN0JDIgPSBjb25zdHJ1Y3QkMTtcblxudmFyIGNvbnN0cnVjdCQzID0gY29uc3RydWN0JDI7XG5cbnZhciBjcmVhdGUkMyA9IGNyZWF0ZTtcblxudmFyIGNyZWF0ZSQ0ID0gY3JlYXRlJDM7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuXG5fZXhwb3J0KHtcbiAgdGFyZ2V0OiAnT2JqZWN0JyxcbiAgc3RhdDogdHJ1ZVxufSwge1xuICBzZXRQcm90b3R5cGVPZjogb2JqZWN0U2V0UHJvdG90eXBlT2Zcbn0pO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSBwYXRoLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxudmFyIHNldFByb3RvdHlwZU9mJDEgPSBzZXRQcm90b3R5cGVPZjtcblxudmFyIHNldFByb3RvdHlwZU9mJDIgPSBzZXRQcm90b3R5cGVPZiQxO1xuXG52YXIgc2V0UHJvdG90eXBlT2YkMyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mJDIgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7XG59KTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBjcmVhdGUkNChzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mJDMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG52YXIgaW5oZXJpdHMgPSBfaW5oZXJpdHM7XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZl8xKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YkMyA9IGdldFByb3RvdHlwZU9mO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YkNCA9IGdldFByb3RvdHlwZU9mJDM7XG5cbnZhciBnZXRQcm90b3R5cGVPZiQ1ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gc2V0UHJvdG90eXBlT2YkMiA/IGdldFByb3RvdHlwZU9mJDQgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IGdldFByb3RvdHlwZU9mJDQobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcblxuXG52YXIgYXJyYXlGaWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZVxuLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi9cbikge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xuXG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuXG4gIHJldHVybiBPO1xufTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWVcbn0sIHtcbiAgZmlsbDogYXJyYXlGaWxsXG59KTsgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcblxudmFyIGZpbGwgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykuZmlsbDtcblxudmFyIEFycmF5UHJvdG90eXBlJGIgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBmaWxsXzEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmZpbGw7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkYiB8fCBpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkYi5maWxsID8gZmlsbCA6IG93bjtcbn07XG5cbnZhciBmaWxsJDEgPSBmaWxsXzE7XG5cbnZhciBmaWxsJDIgPSBmaWxsJDE7XG5cbi8qKlxuICogVGhlIEJhc2UgY2xhc3MgZm9yIGFsbCBOb2Rlcy5cbiAqL1xudmFyIE5vZGVCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBOb2RlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVCYXNlKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5sYWJlbE1vZHVsZSA9IGxhYmVsTW9kdWxlO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1hcmdpbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlZnJlc2hOZWVkZWQgPSB0cnVlO1xuICAgIHRoaXMuYm91bmRpbmdCb3ggPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKE5vZGVCYXNlLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0TWFyZ2luc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSkge1xuICAgICAgdGhpcy5tYXJnaW4gPSB7fTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXJnaW4pIHtcbiAgICAgICAgaWYgKF90eXBlb2ZfMSh0aGlzLm9wdGlvbnMubWFyZ2luKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhpcy5tYXJnaW4udG9wID0gdGhpcy5vcHRpb25zLm1hcmdpbi50b3A7XG4gICAgICAgICAgdGhpcy5tYXJnaW4ucmlnaHQgPSB0aGlzLm9wdGlvbnMubWFyZ2luLnJpZ2h0O1xuICAgICAgICAgIHRoaXMubWFyZ2luLmJvdHRvbSA9IHRoaXMub3B0aW9ucy5tYXJnaW4uYm90dG9tO1xuICAgICAgICAgIHRoaXMubWFyZ2luLmxlZnQgPSB0aGlzLm9wdGlvbnMubWFyZ2luLmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tYXJnaW4udG9wID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5yaWdodCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4uYm90dG9tID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5sZWZ0ID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYWJlbE1vZHVsZS5hZGp1c3RTaXplcyh0aGlzLm1hcmdpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5hYnModGhpcy53aWR0aCAvIDIgLyBNYXRoLmNvcyhhbmdsZSkpLCBNYXRoLmFicyh0aGlzLmhlaWdodCAvIDIgLyBNYXRoLnNpbihhbmdsZSkpKSArIGJvcmRlcldpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVTaGFkb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdykge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB2YWx1ZXMuc2hhZG93Q29sb3I7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdmFsdWVzLnNoYWRvd1NpemU7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdmFsdWVzLnNoYWRvd1g7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdmFsdWVzLnNoYWRvd1k7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVTaGFkb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5zaGFkb3cpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDAsMCwwLDApXCI7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZUJvcmRlckRhc2hlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVCb3JkZXJEYXNoZXMoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuYm9yZGVyRGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZGFzaGVzID0gdmFsdWVzLmJvcmRlckRhc2hlcztcblxuICAgICAgICAgIGlmIChkYXNoZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRhc2hlcyA9IFs1LCAxNV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgYm9yZGVycyBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YWx1ZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZUJvcmRlckRhc2hlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmJvcmRlckRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgYm9yZGVycyBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YWx1ZXMuYm9yZGVyRGFzaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBzaGFwZSBvZiBhIG5vZGUgbmVlZHMgdG8gYmUgcmVjYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZWVkc1JlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMucmVmcmVzaE5lZWRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IG5vdCB0aGUgYmVzdCBsb2NhdGlvbiB0byByZXNldCB0aGlzIG1lbWJlci5cbiAgICAgICAgLy8gSG93ZXZlciwgaW4gdGhlIGN1cnJlbnQgbG9naWMsIGl0IGlzIHRoZSBtb3N0IGNvbnZlbmllbnQgb25lLlxuICAgICAgICB0aGlzLnJlZnJlc2hOZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSB1bmRlZmluZWQgfHwgdGhpcy5sYWJlbE1vZHVsZS5kaWZmZXJlbnRTdGF0ZShzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0Q29udGV4dEZvckRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKSB7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB2YWx1ZXMuYm9yZGVyV2lkdGggLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZXMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVzLmNvbG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwZXJmb3JtU3Ryb2tlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1TdHJva2UoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHZhbHVlcy5ib3JkZXJXaWR0aCAvIHRoaXMuYm9keS52aWV3LnNjYWxlOyAvL2RyYXcgZGFzaGVkIGJvcmRlciBpZiBlbmFibGVkLCBzYXZlIGFuZCByZXN0b3JlIGlzIHJlcXVpcmVkIGZvciBmaXJlZm94IG5vdCB0byBjcmFzaCBvbiB1bml4LlxuXG4gICAgICBjdHguc2F2ZSgpOyAvLyBpZiBib3JkZXJzIGFyZSB6ZXJvIHdpZHRoLCB0aGV5IHdpbGwgYmUgZHJhd24gd2l0aCB3aWR0aCAxIGJ5IGRlZmF1bHQuIFRoaXMgcHJldmVudHMgdGhhdFxuXG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKTsgLy9kcmF3IHRoZSBib3JkZXJcblxuICAgICAgICBjdHguc3Ryb2tlKCk7IC8vZGlzYWJsZSBkYXNoZWQgYm9yZGVyIGZvciBvdGhlciBlbGVtZW50c1xuXG4gICAgICAgIHRoaXMuZGlzYWJsZUJvcmRlckRhc2hlcyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBlcmZvcm1GaWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlcy5jb2xvcjsgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7IC8vIGRyYXcgdGhlIGJhY2tncm91bmRcblxuICAgICAgZmlsbCQyKGN0eCkuY2FsbChjdHgpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG5cbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5wZXJmb3JtU3Ryb2tlKGN0eCwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRCb3VuZGluZ0JveE1hcmdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQm91bmRpbmdCb3hNYXJnaW4obWFyZ2luKSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgLT0gbWFyZ2luO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgLT0gbWFyZ2luO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKz0gbWFyZ2luO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCArPSBtYXJnaW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBjYWxsLlxuICAgICAqXG4gICAgICogRG9pbmcgaXQgbGlrZSB0aGlzIG1ha2VzIGl0IGVhc2llciB0byBvdmVycmlkZVxuICAgICAqIGluIHRoZSBjaGlsZCBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKGN0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIGNhbGwuXG4gICAgICogVGhpcyBhY3RzIGFzIGEgc3R1YiB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdGhpcy5fdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRpbWVuc2lvbnMgdG8gdXNlIGZvciBub2RlcyB3aXRoIGFuIGludGVybmFsIGxhYmVsXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHksIHRoZXNlIGFyZTogQ2lyY2xlLCBFbGxpcHNlLCBEYXRhYmFzZSwgQm94XG4gICAgICogVGhlIG90aGVyIG5vZGVzIGhhdmUgZXh0ZXJuYWwgbGFiZWxzLCBhbmQgd2lsbCBub3QgY2FsbCB0aGlzIG1ldGhvZFxuICAgICAqXG4gICAgICogSWYgdGhlcmUgaXMgbm8gbGFiZWwsIGRlY2VudCBkZWZhdWx0IHZhbHVlcyBhcmUgc3VwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAgICogQHJldHVybnMge3t3aWR0aDpudW1iZXIsIGhlaWdodDpudW1iZXJ9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGltZW5zaW9uc0Zyb21MYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICAvLyBOT1RFOiBwcmV2aW91c2x5ICd0ZXh0U2l6ZScgd2FzIG5vdCBwdXQgaW4gJ3RoaXMnIGZvciBFbGxpcHNlXG4gICAgICAvLyBUT0RPOiBleGFtaW5lIHRoZSBjb25zZXF1ZW5jZXMuXG4gICAgICB0aGlzLnRleHRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLnRleHRTaXplLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMudGV4dFNpemUuaGVpZ2h0O1xuICAgICAgdmFyIERFRkFVTFRfU0laRSA9IDE0O1xuXG4gICAgICBpZiAod2lkdGggPT09IDApIHtcbiAgICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbGFiZWwgdGV4dCBzZXRcbiAgICAgICAgd2lkdGggPSBERUZBVUxUX1NJWkU7IC8vIHVzZSBhIGRlY2VudCBkZWZhdWx0XG5cbiAgICAgICAgaGVpZ2h0ID0gREVGQVVMVF9TSVpFOyAvLyBpZiB3aWR0aCB6ZXJvLCB0aGVuIGhlaWdodCBhbHNvIGFsd2F5cyB6ZXJvXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVCYXNlO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QkMykgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0JDMuc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbnN0cnVjdCQzKERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIEJveCBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cblxudmFyIEJveCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIGluaGVyaXRzKEJveCwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJveCk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBCb3gob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCb3gpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKEJveCwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB0aGlzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLmluaXRDb250ZXh0Rm9yRHJhdyhjdHgsIHZhbHVlcyk7XG4gICAgICBkcmF3Um91bmRSZWN0KGN0eCwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHZhbHVlcy5ib3JkZXJSYWRpdXMpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMudGV4dFNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgdGhpcy50b3AgKyB0aGlzLnRleHRTaXplLmhlaWdodCAvIDIgKyB0aGlzLm1hcmdpbi50b3AsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHZhciBib3JkZXJSYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1czsgLy8gb25seSBlZmZlY3RpdmUgZm9yIGJveFxuXG4gICAgICB0aGlzLl9hZGRCb3VuZGluZ0JveE1hcmdpbihib3JkZXJSYWRpdXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGguYWJzKHRoaXMud2lkdGggLyAyIC8gTWF0aC5jb3MoYW5nbGUpKSwgTWF0aC5hYnModGhpcy5oZWlnaHQgLyAyIC8gTWF0aC5zaW4oYW5nbGUpKSkgKyBib3JkZXJXaWR0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm94O1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQxKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIE5PVEU6IFRoaXMgaXMgYSBiYWQgYmFzZSBjbGFzc1xuICpcbiAqIENoaWxkIGNsYXNzZXMgYXJlOlxuICpcbiAqICAgSW1hZ2UgICAgICAgLSB1c2VzICpvbmx5KiBpbWFnZSBtZXRob2RzXG4gKiAgIENpcmNsZSAgICAgIC0gdXNlcyAqb25seSogX2RyYXdSYXdDaXJjbGVcbiAqICAgQ2lyY2xlSW1hZ2UgLSB1c2VzIGFsbFxuICpcbiAqIFRPRE86IFJlZmFjdG9yLCBtb3ZlIF9kcmF3UmF3Q2lyY2xlIHRvIGRpZmZlcmVudCBtb2R1bGUsIGRlcml2ZSBDaXJjbGUgZnJvbSBOb2RlQmFzZVxuICogICAgICAgUmVuYW1lIHRoaXMgdG8gSW1hZ2VCYXNlXG4gKiAgICAgICBDb25zb2xpZGF0ZSBjb21tb24gY29kZSBpbiBJbWFnZSBhbmQgQ2lyY2xlSW1hZ2UgdG8gYmFzZSBjbGFzc1xuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG5cbnZhciBDaXJjbGVJbWFnZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBpbmhlcml0cyhDaXJjbGVJbWFnZUJhc2UsIF9Ob2RlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQxKENpcmNsZUltYWdlQmFzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBDaXJjbGVJbWFnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGVJbWFnZUJhc2UpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gICAgX3RoaXMubGFiZWxPZmZzZXQgPSAwO1xuICAgIF90aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW2ltYWdlT2JqXVxuICAgKiBAcGFyYW0ge29iamVjdH0gW2ltYWdlT2JqQWx0XVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKENpcmNsZUltYWdlQmFzZSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgaWYgKCEoaW1hZ2VPYmogPT09IHVuZGVmaW5lZCAmJiBpbWFnZU9iakFsdCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGltYWdlcyBmb3IgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogVGhlIGltYWdlcyBjYW4gYmUgdXBkYXRlZCBhZnRlciB0aGUgaW5pdGlhbCBzZXR0aW5nIG9mIG9wdGlvbnM7XG4gICAgICogdGhlcmVmb3JlLCB0aGlzIG1ldGhvZCBuZWVkcyB0byBiZSByZWVudHJhbnQuXG4gICAgICpcbiAgICAgKiBGb3IgY29ycmVjdCB3b3JraW5nIGluIGVycm9yIGNhc2VzLCBpdCBpcyBuZWNlc3NhcnkgdG8gcHJvcGVybHkgc2V0XG4gICAgICogZmllbGQgJ25vZGVzLmJyb2tlbkltYWdlJyBpbiB0aGUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlT2JqICByZXF1aXJlZDsgbWFpbiBpbWFnZSB0byBzaG93IGZvciB0aGlzIG5vZGVcbiAgICAgKiBAcGFyYW0ge0ltYWdlfHVuZGVmaW5lZH0gaW1hZ2VPYmpBbHQgb3B0aW9uYWw7IGltYWdlIHRvIHNob3cgd2hlbiBub2RlIGlzIHNlbGVjdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRJbWFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICAgaWYgKGltYWdlT2JqQWx0ICYmIHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqQWx0O1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VPYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmltYWdlT2JqID0gaW1hZ2VPYmo7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSBpbWFnZU9iakFsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHNlbGVjdGlvbiBhbmQgc3dpdGNoIGJldHdlZW4gdGhlIGJhc2UgYW5kIHRoZSBzZWxlY3RlZCBpbWFnZS5cbiAgICAgKlxuICAgICAqIERvIHRoZSBzd2l0Y2ggb25seSBpZiBpbWFnZU9iakFsdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkIHZhbHVlIG9mIG5ldyBzZWxlY3RlZCBzdGF0ZSBmb3IgY3VycmVudCBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzd2l0Y2hJbWFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uX2NoYW5nZWQgPSBzZWxlY3RlZCAmJiAhdGhpcy5zZWxlY3RlZCB8fCAhc2VsZWN0ZWQgJiYgdGhpcy5zZWxlY3RlZDtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDsgLy8gUmVtZW1iZXIgbmV3IHNlbGVjdGlvblxuXG4gICAgICBpZiAodGhpcy5pbWFnZU9iakFsdCAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdGlvbl9jaGFuZ2VkKSB7XG4gICAgICAgIHZhciBpbWFnZVRtcCA9IHRoaXMuaW1hZ2VPYmo7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlT2JqQWx0O1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VUbXA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgSW1hZ2UgUGFkZGluZyBmcm9tIG5vZGUgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge3t0b3A6IG51bWJlcixsZWZ0OiBudW1iZXIsYm90dG9tOiBudW1iZXIscmlnaHQ6IG51bWJlcn19IGltYWdlIHBhZGRpbmcgaW5zaWRlIHRoaXMgc2hhcGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEltYWdlUGFkZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW1hZ2VQYWRkaW5nKCkge1xuICAgICAgdmFyIGltZ1BhZGRpbmcgPSB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZVBhZGRpbmcpIHtcbiAgICAgICAgdmFyIG9wdEltZ1BhZGRpbmcgPSB0aGlzLm9wdGlvbnMuaW1hZ2VQYWRkaW5nO1xuXG4gICAgICAgIGlmIChfdHlwZW9mXzEob3B0SW1nUGFkZGluZykgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGltZ1BhZGRpbmcudG9wID0gb3B0SW1nUGFkZGluZy50b3A7XG4gICAgICAgICAgaW1nUGFkZGluZy5yaWdodCA9IG9wdEltZ1BhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgaW1nUGFkZGluZy5ib3R0b20gPSBvcHRJbWdQYWRkaW5nLmJvdHRvbTtcbiAgICAgICAgICBpbWdQYWRkaW5nLmxlZnQgPSBvcHRJbWdQYWRkaW5nLmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1nUGFkZGluZy50b3AgPSBvcHRJbWdQYWRkaW5nO1xuICAgICAgICAgIGltZ1BhZGRpbmcucmlnaHQgPSBvcHRJbWdQYWRkaW5nO1xuICAgICAgICAgIGltZ1BhZGRpbmcuYm90dG9tID0gb3B0SW1nUGFkZGluZztcbiAgICAgICAgICBpbWdQYWRkaW5nLmxlZnQgPSBvcHRJbWdQYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbWdQYWRkaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIG5vZGUgZGltZW5zaW9ucyBmb3IgYSBsb2FkZWQgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBQcmU6IHRoaXMuaW1hZ2VPYmogaXMgdmFsaWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNpemVJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplSW1hZ2UoKSB7XG4gICAgICB2YXIgd2lkdGgsIGhlaWdodDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMudXNlSW1hZ2VTaXplID09PSBmYWxzZSkge1xuICAgICAgICAvLyBVc2UgdGhlIHNpemUgcHJvcGVydHlcbiAgICAgICAgdmFyIHJhdGlvX3dpZHRoID0gMTtcbiAgICAgICAgdmFyIHJhdGlvX2hlaWdodCA9IDE7IC8vIE9ubHkgY2FsY3VsYXRlIHRoZSBwcm9wZXIgcmF0aW8gaWYgYm90aCB3aWR0aCBhbmQgaGVpZ2h0IG5vdCB6ZXJvXG5cbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggJiYgdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCA+IHRoaXMuaW1hZ2VPYmouaGVpZ2h0KSB7XG4gICAgICAgICAgICByYXRpb193aWR0aCA9IHRoaXMuaW1hZ2VPYmoud2lkdGggLyB0aGlzLmltYWdlT2JqLmhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmF0aW9faGVpZ2h0ID0gdGhpcy5pbWFnZU9iai5oZWlnaHQgLyB0aGlzLmltYWdlT2JqLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdpZHRoID0gdGhpcy5vcHRpb25zLnNpemUgKiAyICogcmF0aW9fd2lkdGg7XG4gICAgICAgIGhlaWdodCA9IHRoaXMub3B0aW9ucy5zaXplICogMiAqIHJhdGlvX2hlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZSB0aGUgaW1hZ2Ugc2l6ZSB3aXRoIGltYWdlIHBhZGRpbmdcbiAgICAgICAgdmFyIGltZ1BhZGRpbmcgPSB0aGlzLl9nZXRJbWFnZVBhZGRpbmcoKTtcblxuICAgICAgICB3aWR0aCA9IHRoaXMuaW1hZ2VPYmoud2lkdGggKyBpbWdQYWRkaW5nLmxlZnQgKyBpbWdQYWRkaW5nLnJpZ2h0O1xuICAgICAgICBoZWlnaHQgPSB0aGlzLmltYWdlT2JqLmhlaWdodCArIGltZ1BhZGRpbmcudG9wICsgaW1nUGFkZGluZy5ib3R0b207XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdSYXdDaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdSYXdDaXJjbGUoY3R4LCB4LCB5LCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGRyYXdDaXJjbGUoY3R4LCB4LCB5LCB2YWx1ZXMuc2l6ZSk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0ltYWdlQXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHRoaXMuaW1hZ2VPYmoud2lkdGggIT0gMCkge1xuICAgICAgICAvLyBkcmF3IHRoZSBpbWFnZVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB2YWx1ZXMub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gdmFsdWVzLm9wYWNpdHkgOiAxOyAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG5cbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgICB2YXIgZmFjdG9yID0gMTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5pbnRlcnBvbGF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgZmFjdG9yID0gdGhpcy5pbWFnZU9iai53aWR0aCAvIHRoaXMud2lkdGggLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbWdQYWRkaW5nID0gdGhpcy5fZ2V0SW1hZ2VQYWRkaW5nKCk7XG5cbiAgICAgICAgdmFyIGltZ1Bvc0xlZnQgPSB0aGlzLmxlZnQgKyBpbWdQYWRkaW5nLmxlZnQ7XG4gICAgICAgIHZhciBpbWdQb3NUb3AgPSB0aGlzLnRvcCArIGltZ1BhZGRpbmcudG9wO1xuICAgICAgICB2YXIgaW1nV2lkdGggPSB0aGlzLndpZHRoIC0gaW1nUGFkZGluZy5sZWZ0IC0gaW1nUGFkZGluZy5yaWdodDtcbiAgICAgICAgdmFyIGltZ0hlaWdodCA9IHRoaXMuaGVpZ2h0IC0gaW1nUGFkZGluZy50b3AgLSBpbWdQYWRkaW5nLmJvdHRvbTtcbiAgICAgICAgdGhpcy5pbWFnZU9iai5kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgZmFjdG9yLCBpbWdQb3NMZWZ0LCBpbWdQb3NUb3AsIGltZ1dpZHRoLCBpbWdIZWlnaHQpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdJbWFnZUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VMYWJlbChjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgICB2YXIgbGFiZWxEaW1lbnNpb25zID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgICAgaWYgKGxhYmVsRGltZW5zaW9ucy5saW5lQ291bnQgPj0gMSkge1xuICAgICAgICAgIG9mZnNldCArPSBsYWJlbERpbWVuc2lvbnMuaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgeUxhYmVsID0geSArIG9mZnNldDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCkge1xuICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5TGFiZWwsIHNlbGVjdGVkLCBob3ZlciwgXCJoYW5naW5nXCIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjbGVJbWFnZUJhc2U7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mJDUoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mJDUodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdCQzKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDIoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0JDMpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdCQzLnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25zdHJ1Y3QkMyhEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBDaXJjbGUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBDaXJjbGVJbWFnZUJhc2VcbiAqL1xuXG52YXIgQ2lyY2xlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2lyY2xlSW1hZ2VCYXNlKSB7XG4gIGluaGVyaXRzKENpcmNsZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQyKENpcmNsZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBDaXJjbGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKENpcmNsZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB2YXIgZGlhbWV0ZXIgPSBNYXRoLm1heChkaW1lbnNpb25zLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0LCBkaW1lbnNpb25zLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gZGlhbWV0ZXIgLyAyOyAvLyBOT1RFOiB0aGlzIHNpemUgZmllbGQgb25seSBzZXQgaGVyZSwgbm90IGluIEVsbGlwc2UsIERhdGFiYXNlLCBCb3hcblxuICAgICAgICB0aGlzLndpZHRoID0gZGlhbWV0ZXI7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGlhbWV0ZXI7XG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICB0aGlzLl9kcmF3UmF3Q2lyY2xlKGN0eCwgeCwgeSwgdmFsdWVzKTtcblxuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMudGV4dFNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4KSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLndpZHRoICogMC41O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjbGU7XG59KENpcmNsZUltYWdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQzKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDMoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQzKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgQ2lyY3VsYXJJbWFnZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIENpcmNsZUltYWdlQmFzZVxuICovXG5cbnZhciBDaXJjdWxhckltYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2lyY2xlSW1hZ2VCYXNlKSB7XG4gIGluaGVyaXRzKENpcmN1bGFySW1hZ2UsIF9DaXJjbGVJbWFnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMyhDaXJjdWxhckltYWdlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpBbHRcbiAgICovXG4gIGZ1bmN0aW9uIENpcmN1bGFySW1hZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmN1bGFySW1hZ2UpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5zZXRJbWFnZXMoaW1hZ2VPYmosIGltYWdlT2JqQWx0KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoQ2lyY3VsYXJJbWFnZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcbiAgICAgIHZhciBpbWFnZUFic2VudCA9IHRoaXMuaW1hZ2VPYmouc3JjID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmouaGVpZ2h0ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpbWFnZUFic2VudCkge1xuICAgICAgICB2YXIgZGlhbWV0ZXIgPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICAgIHRoaXMud2lkdGggPSBkaWFtZXRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaWFtZXRlcjtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIGFuIGltYWdlIGlzIHByZXNlbnQsIGkuZS4gdGhpcy5pbWFnZU9iaiBpcyB2YWxpZC5cblxuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLl9yZXNpemVJbWFnZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICB2YXIgbGFiZWxYID0geCxcbiAgICAgICAgICBsYWJlbFkgPSB5O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luID09PSBcInRvcC1sZWZ0XCIpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0geDtcbiAgICAgICAgdGhpcy50b3AgPSB5O1xuICAgICAgICBsYWJlbFggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGxhYmVsWSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH0gLy8gZHJhdyB0aGUgYmFja2dyb3VuZCBjaXJjbGUuIElNUE9SVEFOVDogdGhlIHN0cm9rZSBpbiB0aGlzIG1ldGhvZCBpcyB1c2VkIGJ5IHRoZSBjbGlwIG1ldGhvZCBiZWxvdy5cblxuXG4gICAgICB0aGlzLl9kcmF3UmF3Q2lyY2xlKGN0eCwgbGFiZWxYLCBsYWJlbFksIHZhbHVlcyk7IC8vIG5vdyB3ZSBkcmF3IGluIHRoZSBjaXJjbGUsIHdlIHNhdmUgc28gd2UgY2FuIHJldmVydCB0aGUgY2xpcCBvcGVyYXRpb24gYWZ0ZXIgZHJhd2luZy5cblxuXG4gICAgICBjdHguc2F2ZSgpOyAvLyBjbGlwIGlzIHVzZWQgdG8gdXNlIHRoZSBzdHJva2UgaW4gZHJhd1Jhd0NpcmNsZSBhcyBhbiBhcmVhIHRoYXQgd2UgY2FuIGRyYXcgaW4uXG5cbiAgICAgIGN0eC5jbGlwKCk7IC8vIGRyYXcgdGhlIGltYWdlXG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCB2YWx1ZXMpOyAvLyByZXN0b3JlIHNvIHdlIGNhbiBhZ2FpbiBkcmF3IG9uIHRoZSBmdWxsIGNhbnZhc1xuXG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUxhYmVsKGN0eCwgbGFiZWxYLCBsYWJlbFksIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgfSAvLyBUT0RPOiBjb21wYXJlIHdpdGggQ2lyY2xlLnVwZGF0ZUJvdW5kaW5nQm94KCksIGNvbnNvbGlkYXRlPyBNb3JlIHN0dWZmIGlzIGhhcHBlbmluZyBoZXJlXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luID09PSBcInRvcC1sZWZ0XCIpIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemUgKiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB9IC8vIFRPRE86IGNvbXBhcmUgd2l0aCBJbWFnZS51cGRhdGVCb3VuZGluZ0JveCgpLCBjb25zb2xpZGF0ZT9cblxuXG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy53aWR0aCAqIDAuNTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2lyY3VsYXJJbWFnZTtcbn0oQ2lyY2xlSW1hZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDQoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mJDUoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mJDUodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdCQzKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0JDMpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdCQzLnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25zdHJ1Y3QkMyhEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RydWN0aW5nIE5vZGUvQ2x1c3RlciBTaGFwZXMuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cblxudmFyIFNoYXBlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIGluaGVyaXRzKFNoYXBlQmFzZSwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDQoU2hhcGVCYXNlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFNoYXBlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYXBlQmFzZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICogQHBhcmFtIHtvYmplY3R9IFt2YWx1ZXM9e3NpemU6IHRoaXMub3B0aW9ucy5zaXplfV1cbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhTaGFwZUJhc2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG4gICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7XG4gICAgICAgIHNpemU6IHRoaXMub3B0aW9ucy5zaXplXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgX3RoaXMkY3VzdG9tU2l6ZVdpZHRoLCBfdGhpcyRjdXN0b21TaXplSGVpZ2g7XG5cbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHZhciBzaXplID0gMiAqIHZhbHVlcy5zaXplO1xuICAgICAgICB0aGlzLndpZHRoID0gKF90aGlzJGN1c3RvbVNpemVXaWR0aCA9IHRoaXMuY3VzdG9tU2l6ZVdpZHRoKSAhPT0gbnVsbCAmJiBfdGhpcyRjdXN0b21TaXplV2lkdGggIT09IHZvaWQgMCA/IF90aGlzJGN1c3RvbVNpemVXaWR0aCA6IHNpemU7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gKF90aGlzJGN1c3RvbVNpemVIZWlnaCA9IHRoaXMuY3VzdG9tU2l6ZUhlaWdodCkgIT09IG51bGwgJiYgX3RoaXMkY3VzdG9tU2l6ZUhlaWdoICE9PSB2b2lkIDAgPyBfdGhpcyRjdXN0b21TaXplSGVpZ2ggOiBzaXplO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplTXVsdGlwbGllciAtIFVudXNlZCEgVE9ETzogUmVtb3ZlIG5leHQgbWFqb3IgcmVsZWFzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3U2hhcGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdTaGFwZShjdHgsIHNoYXBlLCBzaXplTXVsdGlwbGllciwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZ2V0U2hhcGUoc2hhcGUpKGN0eCwgeCwgeSwgdmFsdWVzLnNpemUpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHguZm9udCA9IChzZWxlY3RlZCA/IFwiYm9sZCBcIiA6IFwiXCIpICsgdGhpcy5oZWlnaHQgLyAyICsgXCJweCBcIiArICh0aGlzLm9wdGlvbnMuaWNvbi5mYWNlIHx8IFwiRm9udEF3ZXNvbWVcIik7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMub3B0aW9ucy5pY29uLmNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy5vcHRpb25zLmljb24uY29kZSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHJhd0V4dGVybmFsTGFiZWw6IGZ1bmN0aW9uIGRyYXdFeHRlcm5hbExhYmVsKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY2FsbCBmb2xsb3dpbmcgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdmFsdWUgZm9yXG4gICAgICAgICAgICAvLyBgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodGAuXG4gICAgICAgICAgICBfdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHgsIHksIFwiaGFuZ2luZ1wiKTtcblxuICAgICAgICAgICAgdmFyIHlMYWJlbCA9IHkgKyAwLjUgKiBfdGhpcy5oZWlnaHQgKyAwLjUgKiBfdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodDtcblxuICAgICAgICAgICAgX3RoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHlMYWJlbCwgc2VsZWN0ZWQsIGhvdmVyLCBcImhhbmdpbmdcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGFwZUJhc2U7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBrZXlzJDMob2JqZWN0KTsgaWYgKGdldE93blByb3BlcnR5U3ltYm9scyQyKSB7IHZhciBzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzJDIob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gZmlsdGVyJDIoc3ltYm9scykuY2FsbChzeW1ib2xzLCBmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IHZhciBfY29udGV4dDsgZm9yRWFjaCQyKF9jb250ZXh0ID0gb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCB0cnVlKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGtleSkgeyBkZWZpbmVQcm9wZXJ0eSQ3KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMikgeyBkZWZpbmVQcm9wZXJ0aWVzJDEodGFyZ2V0LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDIoc291cmNlKSk7IH0gZWxzZSB7IHZhciBfY29udGV4dDI7IGZvckVhY2gkMihfY29udGV4dDIgPSBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGtleSkgeyBkZWZpbmVQcm9wZXJ0eSQyKHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDUoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mJDUoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mJDUodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdCQzKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDUoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0JDMpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdCQzLnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25zdHJ1Y3QkMyhEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBDdXN0b21TaGFwZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG5cbnZhciBDdXN0b21TaGFwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBpbmhlcml0cyhDdXN0b21TaGFwZSwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ1KEN1c3RvbVNoYXBlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3R4UmVuZGVyZXJcbiAgIFxuICAgKi9cbiAgZnVuY3Rpb24gQ3VzdG9tU2hhcGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGN0eFJlbmRlcmVyKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VzdG9tU2hhcGUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSwgY3R4UmVuZGVyZXIpO1xuICAgIF90aGlzLmN0eFJlbmRlcmVyID0gY3R4UmVuZGVyZXI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBkaWZmZXJlbnQgbGF5ZXJzLlxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKEN1c3RvbVNoYXBlLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7IC8vIEd1YXJkIHJpZ2h0IGF3YXkgYmVjYXVzZSBzb21lb25lIG1heSBqdXN0IGRyYXcgaW4gdGhlIGZ1bmN0aW9uIGl0c2VsZi5cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBkcmF3TGF0ZXIgPSB0aGlzLmN0eFJlbmRlcmVyKHtcbiAgICAgICAgY3R4OiBjdHgsXG4gICAgICAgIGlkOiB0aGlzLm9wdGlvbnMuaWQsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgICAgIGhvdmVyOiBob3ZlclxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZCh7fSwgdmFsdWVzKSxcbiAgICAgICAgbGFiZWw6IHRoaXMub3B0aW9ucy5sYWJlbFxuICAgICAgfSk7IC8vIFJlbmRlciB0aGUgbm9kZSBzaGFwZSBiZWxsb3cgYXJyb3dzLlxuXG4gICAgICBpZiAoZHJhd0xhdGVyLmRyYXdOb2RlICE9IG51bGwpIHtcbiAgICAgICAgZHJhd0xhdGVyLmRyYXdOb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmIChkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwpIHtcbiAgICAgICAgLy8gR3VhcmQgdGhlIGV4dGVybmFsIGxhYmVsIChhYm92ZSBhcnJvd3MpIGRyYXdpbmcgZnVuY3Rpb24uXG4gICAgICAgIHZhciBkcmF3RXh0ZXJuYWxMYWJlbCA9IGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbDtcblxuICAgICAgICBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbCgpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmF3TGF0ZXIubm9kZURpbWVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5jdXN0b21TaXplV2lkdGggPSBkcmF3TGF0ZXIubm9kZURpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgIHRoaXMuY3VzdG9tU2l6ZUhlaWdodCA9IGRyYXdMYXRlci5ub2RlRGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkcmF3TGF0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1c3RvbVNoYXBlO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2YkNShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2YkNSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0JDMoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QkMykgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0JDMuc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbnN0cnVjdCQzKERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIERhdGFiYXNlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZUJhc2VcbiAqL1xuXG52YXIgRGF0YWJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBpbmhlcml0cyhEYXRhYmFzZSwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDYoRGF0YWJhc2UpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRGF0YWJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhYmFzZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcblxuICAgIF90aGlzLl9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhEYXRhYmFzZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB2YXIgc2l6ZSA9IGRpbWVuc2lvbnMud2lkdGggKyB0aGlzLm1hcmdpbi5yaWdodCArIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemU7XG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZHJhd0RhdGFiYXNlKGN0eCwgeCAtIHRoaXMud2lkdGggLyAyLCB5IC0gdGhpcy5oZWlnaHQgLyAyLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YWJhc2U7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDcoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mJDUoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mJDUodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdCQzKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDcoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0JDMpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdCQzLnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25zdHJ1Y3QkMyhEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBEaWFtb25kIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIERpYW1vbmQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgaW5oZXJpdHMoRGlhbW9uZCwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ3KERpYW1vbmQpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRGlhbW9uZChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERpYW1vbmQpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhEaWFtb25kLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwiZGlhbW9uZFwiLCA0LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERpYW1vbmQ7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ4KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDgoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ4KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgRG90IE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIERvdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBpbmhlcml0cyhEb3QsIF9TaGFwZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkOChEb3QpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRG90KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRG90KTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoRG90LCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwiY2lyY2xlXCIsIDIsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgpIHtcbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaXplO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEb3Q7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ5KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDkoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ5KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEFtIEVsbGlwc2UgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG5cbnZhciBFbGxpcHNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgaW5oZXJpdHMoRWxsaXBzZSwgX05vZGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDkoRWxsaXBzZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBFbGxpcHNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxsaXBzZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhFbGxpcHNlLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQgKiAyO1xuICAgICAgICB0aGlzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggKiAwLjU7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGRyYXdFbGxpcHNlKGN0eCwgdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYSA9IHRoaXMud2lkdGggKiAwLjU7XG4gICAgICB2YXIgYiA9IHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgdmFyIHcgPSBNYXRoLnNpbihhbmdsZSkgKiBhO1xuICAgICAgdmFyIGggPSBNYXRoLmNvcyhhbmdsZSkgKiBiO1xuICAgICAgcmV0dXJuIGEgKiBiIC8gTWF0aC5zcXJ0KHcgKiB3ICsgaCAqIGgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbGxpcHNlO1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRhKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRhKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEFuIGljb24gcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cblxudmFyIEljb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBpbmhlcml0cyhJY29uLCBfTm9kZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkYShJY29uKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIEljb24ob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuXG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVW51c2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoSWNvbiwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5pY29uU2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aDogTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpLFxuICAgICAgICAgIGhlaWdodDogTnVtYmVyKHRoaXMub3B0aW9ucy5pY29uLnNpemUpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmljb25TaXplLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuaWNvblNpemUuaGVpZ2h0ICsgdGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLm9wdGlvbnMuaWNvbi5zaXplID0gdGhpcy5vcHRpb25zLmljb24uc2l6ZSB8fCA1MDtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgdGhpcy5faWNvbihjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHJhd0V4dGVybmFsTGFiZWw6IGZ1bmN0aW9uIGRyYXdFeHRlcm5hbExhYmVsKCkge1xuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaWNvblRleHRTcGFjaW5nID0gNTtcblxuICAgICAgICAgICAgX3RoaXMyLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCBfdGhpczIubGVmdCArIF90aGlzMi5pY29uU2l6ZS53aWR0aCAvIDIgKyBfdGhpczIubWFyZ2luLmxlZnQsIHkgKyBfdGhpczIuaGVpZ2h0IC8gMiArIGljb25UZXh0U3BhY2luZywgc2VsZWN0ZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMi51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0geCAtIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuaWNvbi5zaXplICogMC41O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICB2YXIgaWNvblRleHRTcGFjaW5nID0gNTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCArIGljb25UZXh0U3BhY2luZyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXIgLSBVbnVzZWRcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaWNvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaWNvbihjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB2YXIgaWNvblNpemUgPSBOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWNvbi5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LmZvbnQgPSBbdGhpcy5vcHRpb25zLmljb24ud2VpZ2h0ICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuaWNvbi53ZWlnaHQgOiBzZWxlY3RlZCA/IFwiYm9sZFwiIDogXCJcIiwgLy8gSWYgdGhlIHdlaWdodCBpcyBmb3JjZWQgKGZvciBleGFtcGxlIHRvIG1ha2UgRm9udCBBd2Vzb21lIDUgd29ya1xuICAgICAgICAvLyBwcm9wZXJseSkgc3Vic3RpdHV0ZSBzbGlnaHRseSBiaWdnZXIgc2l6ZSBmb3IgYm9sZCBmb250IGZhY2UuXG4gICAgICAgICh0aGlzLm9wdGlvbnMuaWNvbi53ZWlnaHQgIT0gbnVsbCAmJiBzZWxlY3RlZCA/IDUgOiAwKSArIGljb25TaXplICsgXCJweFwiLCB0aGlzLm9wdGlvbnMuaWNvbi5mYWNlXS5qb2luKFwiIFwiKTsgLy8gZHJhdyBpY29uXG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMub3B0aW9ucy5pY29uLmNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiOyAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG5cbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5vcHRpb25zLmljb24uY29kZSwgeCwgeSk7IC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXaGVuIHVzaW5nIHRoZSBpY29uIHNoYXBlLCB5b3UgbmVlZCB0byBkZWZpbmUgdGhlIGNvZGUgaW4gdGhlIGljb24gb3B0aW9ucyBvYmplY3QuIFRoaXMgY2FuIGJlIGRvbmUgcGVyIG5vZGUgb3IgZ2xvYmFsbHkuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJY29uO1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRiKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGIoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRiKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEFuIGltYWdlLWJhc2VkIHJlcGxhY2VtZW50IGZvciB0aGUgZGVmYXVsdCBOb2RlIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBDaXJjbGVJbWFnZUJhc2VcbiAqL1xuXG52YXIgSW1hZ2UkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICBpbmhlcml0cyhJbWFnZSwgX0NpcmNsZUltYWdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRiKEltYWdlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpcbiAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmpBbHRcbiAgICovXG4gIGZ1bmN0aW9uIEltYWdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcblxuICAgIF90aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVW51c2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoSW1hZ2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG4gICAgICB2YXIgaW1hZ2VBYnNlbnQgPSB0aGlzLmltYWdlT2JqLnNyYyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmoud2lkdGggPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLmhlaWdodCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaW1hZ2VBYnNlbnQpIHtcbiAgICAgICAgdmFyIHNpZGUgPSB0aGlzLm9wdGlvbnMuc2l6ZSAqIDI7XG4gICAgICAgIHRoaXMud2lkdGggPSBzaWRlO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplSW1hZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5zd2l0Y2hJbWFnZXMoc2VsZWN0ZWQpO1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIHZhciBsYWJlbFggPSB4LFxuICAgICAgICAgIGxhYmVsWSA9IHk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4gPT09IFwidG9wLWxlZnRcIikge1xuICAgICAgICB0aGlzLmxlZnQgPSB4O1xuICAgICAgICB0aGlzLnRvcCA9IHk7XG4gICAgICAgIGxhYmVsWCArPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgbGFiZWxZICs9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy51c2VCb3JkZXJXaXRoSW1hZ2UgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG5ldXRyYWxib3JkZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkxpbmVXaWR0aCA9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkIHx8IDIgKiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IChzZWxlY3RlZCA/IHNlbGVjdGlvbkxpbmVXaWR0aCA6IG5ldXRyYWxib3JkZXJXaWR0aCkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWluKHRoaXMud2lkdGgsIGJvcmRlcldpZHRoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzZWxlY3RlZCA/IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYm9yZGVyIDogdGhpcy5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgdmFyIGZpbGxTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIDogaG92ZXIgPyB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZCA6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kO1xuXG4gICAgICAgIGlmICh2YWx1ZXMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3Ryb2tlU3R5bGUgPSBvdmVycmlkZU9wYWNpdHkoc3Ryb2tlU3R5bGUsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgICBmaWxsU3R5bGUgPSBvdmVycmlkZU9wYWNpdHkoZmlsbFN0eWxlLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgIH0gLy8gc2V0dXAgdGhlIGxpbmUgcHJvcGVydGllcy5cblxuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlOyAvLyBzZXQgYSBmaWxsc3R5bGVcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlOyAvLyBkcmF3IGEgcmVjdGFuZ2xlIHRvIGZvcm0gdGhlIGJvcmRlciBhcm91bmQuIFRoaXMgcmVjdGFuZ2xlIGlzIGZpbGxlZCBzbyB0aGUgb3BhY2l0eSBvZiBhIHBpY3R1cmUgKGluIGZ1dHVyZSB2aXMgcmVsZWFzZXM/KSBjYW4gYmUgdXNlZCB0byB0aW50IHRoZSBpbWFnZVxuXG4gICAgICAgIGN0eC5yZWN0KHRoaXMubGVmdCAtIDAuNSAqIGN0eC5saW5lV2lkdGgsIHRoaXMudG9wIC0gMC41ICogY3R4LmxpbmVXaWR0aCwgdGhpcy53aWR0aCArIGN0eC5saW5lV2lkdGgsIHRoaXMuaGVpZ2h0ICsgY3R4LmxpbmVXaWR0aCk7XG5cbiAgICAgICAgZmlsbCQyKGN0eCkuY2FsbChjdHgpO1xuXG4gICAgICAgIHRoaXMucGVyZm9ybVN0cm9rZShjdHgsIHZhbHVlcyk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZHJhd0ltYWdlQXRQb3NpdGlvbihjdHgsIHZhbHVlcyk7XG5cbiAgICAgIHRoaXMuX2RyYXdJbWFnZUxhYmVsKGN0eCwgbGFiZWxYLCBsYWJlbFksIHNlbGVjdGVkLCBob3Zlcik7XG5cbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4gPT09IFwidG9wLWxlZnRcIikge1xuICAgICAgICB0aGlzLmxlZnQgPSB4O1xuICAgICAgICB0aGlzLnRvcCA9IHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSBNYXRoLm1pbih0aGlzLmJvdW5kaW5nQm94LmxlZnQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0KTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSwgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gKyB0aGlzLmxhYmVsT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2U7XG59KENpcmNsZUltYWdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRjKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGMoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRjKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgU3F1YXJlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIFNxdWFyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBpbmhlcml0cyhTcXVhcmUsIF9TaGFwZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkYyhTcXVhcmUpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU3F1YXJlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3F1YXJlKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoU3F1YXJlLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwic3F1YXJlXCIsIDIsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3F1YXJlO1xufShTaGFwZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkZChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRkKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2YkNShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2YkNSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0JDMoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QkMykgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0JDMuc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbnN0cnVjdCQzKERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIEhleGFnb24gTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xuXG52YXIgSGV4YWdvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBpbmhlcml0cyhIZXhhZ29uLCBfU2hhcGVCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGQoSGV4YWdvbik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBIZXhhZ29uKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSGV4YWdvbik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKEhleGFnb24sIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJoZXhhZ29uXCIsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGV4YWdvbjtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGUoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mJDUoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mJDUodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdCQzKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGUoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0JDMpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdCQzLnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25zdHJ1Y3QkMyhEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBTdGFyIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cblxudmFyIFN0YXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgaW5oZXJpdHMoU3RhciwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRlKFN0YXIpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU3RhcihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXIpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhTdGFyLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwic3RhclwiLCA0LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0YXI7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRmKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGYoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRmKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEEgdGV4dC1iYXNlZCByZXBsYWNlbWVudCBmb3IgdGhlIGRlZmF1bHQgTm9kZSBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZUJhc2VcbiAqL1xuXG52YXIgVGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIGluaGVyaXRzKFRleHQsIF9Ob2RlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRmKFRleHQpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dChvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG5cbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoVGV4dCwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy50ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy50ZXh0U2l6ZS53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnRleHRTaXplLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjsgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuXG4gICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB0aGlzLmxlZnQgKyB0aGlzLnRleHRTaXplLndpZHRoIC8gMiArIHRoaXMubWFyZ2luLmxlZnQsIHRoaXMudG9wICsgdGhpcy50ZXh0U2l6ZS5oZWlnaHQgLyAyICsgdGhpcy5tYXJnaW4udG9wLCBzZWxlY3RlZCwgaG92ZXIpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHQ7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGcoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mJDUoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mJDUodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdCQzKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGcoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0JDMpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdCQzLnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25zdHJ1Y3QkMyhEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBUcmlhbmdsZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG5cbnZhciBUcmlhbmdsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBpbmhlcml0cyhUcmlhbmdsZSwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRnKFRyaWFuZ2xlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIFRyaWFuZ2xlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJpYW5nbGUpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKFRyaWFuZ2xlLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwidHJpYW5nbGVcIiwgMywgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmlhbmdsZTtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGgoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mJDUoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mJDUodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdCQzKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGgoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0JDMpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdCQzLnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25zdHJ1Y3QkMyhEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogQSBkb3dud2FyZCBmYWNpbmcgVHJpYW5nbGUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xuXG52YXIgVHJpYW5nbGVEb3duID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIGluaGVyaXRzKFRyaWFuZ2xlRG93biwgX1NoYXBlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRoKFRyaWFuZ2xlRG93bik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBUcmlhbmdsZURvd24ob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZURvd24pO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKFRyaWFuZ2xlRG93biwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcInRyaWFuZ2xlRG93blwiLCAzLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyaWFuZ2xlRG93bjtcbn0oU2hhcGVCYXNlKTtcblxudmFyICRzdHJpbmdpZnkkMSA9IGdldEJ1aWx0SW4oJ0pTT04nLCAnc3RyaW5naWZ5Jyk7XG52YXIgcmUgPSAvW1xcdUQ4MDAtXFx1REZGRl0vZztcbnZhciBsb3cgPSAvXltcXHVEODAwLVxcdURCRkZdJC87XG52YXIgaGkgPSAvXltcXHVEQzAwLVxcdURGRkZdJC87XG5cbnZhciBmaXggPSBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCwgc3RyaW5nKSB7XG4gIHZhciBwcmV2ID0gc3RyaW5nLmNoYXJBdChvZmZzZXQgLSAxKTtcbiAgdmFyIG5leHQgPSBzdHJpbmcuY2hhckF0KG9mZnNldCArIDEpO1xuXG4gIGlmIChsb3cudGVzdChtYXRjaCkgJiYgIWhpLnRlc3QobmV4dCkgfHwgaGkudGVzdChtYXRjaCkgJiYgIWxvdy50ZXN0KHByZXYpKSB7XG4gICAgcmV0dXJuICdcXFxcdScgKyBtYXRjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn07XG5cbnZhciBGT1JDRUQkNSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRzdHJpbmdpZnkkMSgnXFx1REYwNlxcdUQ4MzQnKSAhPT0gJ1wiXFxcXHVkZjA2XFxcXHVkODM0XCInIHx8ICRzdHJpbmdpZnkkMSgnXFx1REVBRCcpICE9PSAnXCJcXFxcdWRlYWRcIic7XG59KTtcblxuaWYgKCRzdHJpbmdpZnkkMSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC13ZWxsLWZvcm1lZC1zdHJpbmdpZnlcbiAgX2V4cG9ydCh7XG4gICAgdGFyZ2V0OiAnSlNPTicsXG4gICAgc3RhdDogdHJ1ZSxcbiAgICBmb3JjZWQ6IEZPUkNFRCQ1XG4gIH0sIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJHN0cmluZ2lmeSQxLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAnc3RyaW5nJyA/IHJlc3VsdC5yZXBsYWNlKHJlLCBmaXgpIDogcmVzdWx0O1xuICAgIH1cbiAgfSk7XG59XG5cbmlmICghcGF0aC5KU09OKSBwYXRoLkpTT04gPSB7XG4gIHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnlcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG52YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgcmV0dXJuIHBhdGguSlNPTi5zdHJpbmdpZnkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBzdHJpbmdpZnkkMSA9IHN0cmluZ2lmeTtcblxudmFyIHN0cmluZ2lmeSQyID0gc3RyaW5naWZ5JDE7XG5cbnZhciBlcnJvckZvdW5kID0gZmFsc2U7XG52YXIgYWxsT3B0aW9ucztcbnZhciBwcmludFN0eWxlID0gXCJiYWNrZ3JvdW5kOiAjRkZlZWVlOyBjb2xvcjogI2RkMDAwMFwiO1xuLyoqXG4gKiAgVXNlZCB0byB2YWxpZGF0ZSBvcHRpb25zLlxuICovXG5cbnZhciBWYWxpZGF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gVmFsaWRhdG9yKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZhbGlkYXRvcik7XG4gIH1cbiAgLyoqXG4gICAqIE1haW4gZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdWJPYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBzdGF0aWNcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhWYWxpZGF0b3IsIG51bGwsIFt7XG4gICAga2V5OiBcInZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHN1Yk9iamVjdCkge1xuICAgICAgZXJyb3JGb3VuZCA9IGZhbHNlO1xuICAgICAgYWxsT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgICB2YXIgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zO1xuXG4gICAgICBpZiAoc3ViT2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zW3N1Yk9iamVjdF07XG4gICAgICB9XG5cbiAgICAgIFZhbGlkYXRvci5wYXJzZShvcHRpb25zLCB1c2VkT3B0aW9ucywgW10pO1xuICAgICAgcmV0dXJuIGVycm9yRm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgdHJhdmVyc2UgYW4gb2JqZWN0IHJlY3Vyc2l2ZWx5IGFuZCBjaGVjayBldmVyeSB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIGZvciAodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgb3B0aW9uKSkge1xuICAgICAgICAgIFZhbGlkYXRvci5jaGVjayhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGV2ZXJ5IHZhbHVlLiBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LCBjYWxsIHRoZSBwYXJzZSBmdW5jdGlvbiBvbiB0aGF0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2sob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgICBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dID09PSB1bmRlZmluZWQgJiYgcmVmZXJlbmNlT3B0aW9ucy5fX2FueV9fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgVmFsaWRhdG9yLmdldFN1Z2dlc3Rpb24ob3B0aW9uLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmZXJlbmNlT3B0aW9uID0gb3B0aW9uO1xuICAgICAgdmFyIGlzX29iamVjdCA9IHRydWU7XG5cbiAgICAgIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOT1RFOiBUaGlzIG9ubHkgdHJpZ2dlcnMgaWYgdGhlIF9fYW55X18gaXMgaW4gdGhlIHRvcCBsZXZlbCBvZiB0aGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICAgIC8vICAgICAgIFRIQVQnUyBBIFJFQUxMWSBCQUQgUExBQ0UgVE8gQUxMT1cgSVQhISEhXG4gICAgICAgIC8vIFRPRE86IEV4YW1pbmUgaWYgbmVlZGVkLCByZW1vdmUgaWYgcG9zc2libGVcbiAgICAgICAgLy8gX19hbnlfXyBpcyBhIHdpbGRjYXJkLiBBbnkgdmFsdWUgaXMgYWNjZXB0ZWQgYW5kIHdpbGwgYmUgZnVydGhlciBhbmFseXNlZCBieSByZWZlcmVuY2UuXG4gICAgICAgIHJlZmVyZW5jZU9wdGlvbiA9IFwiX19hbnlfX1wiOyAvLyBpZiB0aGUgYW55LXN1Ymdyb3VwIGlzIG5vdCBhIHByZWRlZmluZWQgb2JqZWN0IGluIHRoZSBjb25maWd1cmF0b3IsXG4gICAgICAgIC8vIHdlIGRvIG5vdCBsb29rIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG5cbiAgICAgICAgaXNfb2JqZWN0ID0gVmFsaWRhdG9yLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKSA9PT0gXCJvYmplY3RcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZk9wdGlvbk9iaiA9IHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXTtcblxuICAgICAgaWYgKGlzX29iamVjdCAmJiByZWZPcHRpb25PYmouX190eXBlX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWZPcHRpb25PYmogPSByZWZPcHRpb25PYmouX190eXBlX187XG4gICAgICB9XG5cbiAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbiwgcmVmT3B0aW9uT2JqLCBwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIG9wdGlvbiAgICAgICAgICAgfCB0aGUgb3B0aW9uIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9ICBvcHRpb25zICAgICAgICAgIHwgVGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9ICByZWZlcmVuY2VPcHRpb25zIHwgVGhlIHJlZmVyZW5jZSBvcHRpb25zIGNvbnRhaW5pbmcgYWxsIG9wdGlvbnMgYW5kIHRoZWlyIGFsbG93ZWQgZm9ybWF0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgcmVmZXJlbmNlT3B0aW9uICB8IFVzdWFsbHkgdGhpcyBpcyB0aGUgc2FtZSBhcyBvcHRpb24sIGV4Y2VwdCB3aGVuIGhhbmRsaW5nIGFuIF9fYW55X18gdGFnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgcmVmT3B0aW9uT2JqICAgICB8IFRoaXMgaXMgdGhlIHR5cGUgb2JqZWN0IGZyb20gdGhlIHJlZmVyZW5jZSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBwYXRoICAgICAgICAgICAgIHwgd2hlcmUgaW4gdGhlIG9iamVjdCBpcyB0aGUgb3B0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tGaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGaWVsZHMob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCByZWZlcmVuY2VPcHRpb24sIHJlZk9wdGlvbk9iaiwgcGF0aCkge1xuICAgICAgdmFyIGxvZyA9IGZ1bmN0aW9uIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCIlY1wiICsgbWVzc2FnZSArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiksIHByaW50U3R5bGUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9wdGlvblR5cGUgPSBWYWxpZGF0b3IuZ2V0VHlwZShvcHRpb25zW29wdGlvbl0pO1xuICAgICAgdmFyIHJlZk9wdGlvblR5cGUgPSByZWZPcHRpb25PYmpbb3B0aW9uVHlwZV07XG5cbiAgICAgIGlmIChyZWZPcHRpb25UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgd2UgY2hlY2sgaWYgaXQgaXMgc3VwcG9zZWQgdG8gYmUgb25lIG9mIGEgZmV3IHNlbGVjdCB2YWx1ZXNcbiAgICAgICAgaWYgKFZhbGlkYXRvci5nZXRUeXBlKHJlZk9wdGlvblR5cGUpID09PSBcImFycmF5XCIgJiYgaW5kZXhPZiQzKHJlZk9wdGlvblR5cGUpLmNhbGwocmVmT3B0aW9uVHlwZSwgb3B0aW9uc1tvcHRpb25dKSA9PT0gLTEpIHtcbiAgICAgICAgICBsb2coJ0ludmFsaWQgb3B0aW9uIGRldGVjdGVkIGluIFwiJyArIG9wdGlvbiArICdcIi4nICsgXCIgQWxsb3dlZCB2YWx1ZXMgYXJlOlwiICsgVmFsaWRhdG9yLnByaW50KHJlZk9wdGlvblR5cGUpICsgJyBub3QgXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiLiAnKTtcbiAgICAgICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25UeXBlID09PSBcIm9iamVjdFwiICYmIHJlZmVyZW5jZU9wdGlvbiAhPT0gXCJfX2FueV9fXCIpIHtcbiAgICAgICAgICBwYXRoID0gY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgICAgVmFsaWRhdG9yLnBhcnNlKG9wdGlvbnNbb3B0aW9uXSwgcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWZPcHRpb25PYmpbXCJhbnlcIl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0eXBlIG9mIHRoZSBmaWVsZCBpcyBpbmNvcnJlY3QgYW5kIHRoZSBmaWVsZCBjYW5ub3QgYmUgYW55XG4gICAgICAgIGxvZygnSW52YWxpZCB0eXBlIHJlY2VpdmVkIGZvciBcIicgKyBvcHRpb24gKyAnXCIuIEV4cGVjdGVkOiAnICsgVmFsaWRhdG9yLnByaW50KGtleXMkMyhyZWZPcHRpb25PYmopKSArIFwiLiBSZWNlaXZlZCBbXCIgKyBvcHRpb25UeXBlICsgJ10gXCInICsgb3B0aW9uc1tvcHRpb25dICsgJ1wiJyk7XG4gICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgYm9vbGVhbiB8IG51bWJlciB8IHN0cmluZyB8IEFycmF5LjxudW1iZXI+IHwgRGF0ZSB8IE5vZGUgfCBNb21lbnQgfCB1bmRlZmluZWQgfCBudWxsfSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHlwZShvYmplY3QpIHtcbiAgICAgIHZhciB0eXBlID0gX3R5cGVvZl8xKG9iamVjdCk7XG5cbiAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5JDUob2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmplY3Qubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBcImRvbVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdC5faXNBTW9tZW50T2JqZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIFwibW9tZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3VnZ2VzdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdWdnZXN0aW9uKG9wdGlvbiwgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIGxvY2FsU2VhcmNoID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zLCBwYXRoLCBmYWxzZSk7XG4gICAgICB2YXIgZ2xvYmFsU2VhcmNoID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBhbGxPcHRpb25zLCBbXSwgdHJ1ZSk7XG4gICAgICB2YXIgbG9jYWxTZWFyY2hUaHJlc2hvbGQgPSA4O1xuICAgICAgdmFyIGdsb2JhbFNlYXJjaFRocmVzaG9sZCA9IDQ7XG4gICAgICB2YXIgbXNnO1xuXG4gICAgICBpZiAobG9jYWxTZWFyY2guaW5kZXhNYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1zZyA9IFwiIGluIFwiICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uLCBcIlwiKSArICdQZXJoYXBzIGl0IHdhcyBpbmNvbXBsZXRlPyBEaWQgeW91IG1lYW46IFwiJyArIGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggKyAnXCI/XFxuXFxuJztcbiAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsU2VhcmNoLmRpc3RhbmNlIDw9IGdsb2JhbFNlYXJjaFRocmVzaG9sZCAmJiBsb2NhbFNlYXJjaC5kaXN0YW5jZSA+IGdsb2JhbFNlYXJjaC5kaXN0YW5jZSkge1xuICAgICAgICBtc2cgPSBcIiBpbiBcIiArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgXCJcIikgKyBcIlBlcmhhcHMgaXQgd2FzIG1pc3BsYWNlZD8gTWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGF0OiBcIiArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGdsb2JhbFNlYXJjaC5wYXRoLCBnbG9iYWxTZWFyY2guY2xvc2VzdE1hdGNoLCBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYWxTZWFyY2guZGlzdGFuY2UgPD0gbG9jYWxTZWFyY2hUaHJlc2hvbGQpIHtcbiAgICAgICAgbXNnID0gJy4gRGlkIHlvdSBtZWFuIFwiJyArIGxvY2FsU2VhcmNoLmNsb3Nlc3RNYXRjaCArICdcIj8nICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1zZyA9IFwiLiBEaWQgeW91IG1lYW4gb25lIG9mIHRoZXNlOiBcIiArIFZhbGlkYXRvci5wcmludChrZXlzJDMob3B0aW9ucykpICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5lcnJvcignJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiJyArIG1zZywgcHJpbnRTdHlsZSk7XG4gICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJhdmVyc2UgdGhlIG9wdGlvbnMgaW4gc2VhcmNoIGZvciBhIG1hdGNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVjdXJzaXZlPWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHt7Y2xvc2VzdE1hdGNoOiBzdHJpbmcsIHBhdGg6IEFycmF5LCBkaXN0YW5jZTogbnVtYmVyfX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5kSW5PcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgICB2YXIgcmVjdXJzaXZlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICB2YXIgY2xvc2VzdE1hdGNoID0gXCJcIjtcbiAgICAgIHZhciBjbG9zZXN0TWF0Y2hQYXRoID0gW107XG4gICAgICB2YXIgbG93ZXJDYXNlT3B0aW9uID0gb3B0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgaW5kZXhNYXRjaCA9IHVuZGVmaW5lZDtcblxuICAgICAgZm9yICh2YXIgb3AgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKG9wdGlvbnNbb3BdLl9fdHlwZV9fICE9PSB1bmRlZmluZWQgJiYgcmVjdXJzaXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9uc1tvcF0sIGNvcHlBbmRFeHRlbmRBcnJheShwYXRoLCBvcCkpO1xuXG4gICAgICAgICAgaWYgKG1pbiA+IHJlc3VsdC5kaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gcmVzdWx0LmNsb3Nlc3RNYXRjaDtcbiAgICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSByZXN1bHQucGF0aDtcbiAgICAgICAgICAgIG1pbiA9IHJlc3VsdC5kaXN0YW5jZTtcbiAgICAgICAgICAgIGluZGV4TWF0Y2ggPSByZXN1bHQuaW5kZXhNYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICAgICAgaWYgKGluZGV4T2YkMyhfY29udGV4dCA9IG9wLnRvTG93ZXJDYXNlKCkpLmNhbGwoX2NvbnRleHQsIGxvd2VyQ2FzZU9wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICBpbmRleE1hdGNoID0gb3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlzdGFuY2UgPSBWYWxpZGF0b3IubGV2ZW5zaHRlaW5EaXN0YW5jZShvcHRpb24sIG9wKTtcblxuICAgICAgICAgIGlmIChtaW4gPiBkaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoID0gb3A7XG4gICAgICAgICAgICBjbG9zZXN0TWF0Y2hQYXRoID0gY29weUFycmF5KHBhdGgpO1xuICAgICAgICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsb3Nlc3RNYXRjaDogY2xvc2VzdE1hdGNoLFxuICAgICAgICBwYXRoOiBjbG9zZXN0TWF0Y2hQYXRoLFxuICAgICAgICBkaXN0YW5jZTogbWluLFxuICAgICAgICBpbmRleE1hdGNoOiBpbmRleE1hdGNoXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByaW50TG9jYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pIHtcbiAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiUHJvYmxlbSB2YWx1ZSBmb3VuZCBhdDogXFxuXCI7XG4gICAgICB2YXIgc3RyID0gXCJcXG5cXG5cIiArIHByZWZpeCArIFwib3B0aW9ucyA9IHtcXG5cIjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSArIDE7IGorKykge1xuICAgICAgICAgIHN0ciArPSBcIiAgXCI7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gcGF0aFtpXSArIFwiOiB7XFxuXCI7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBwYXRoLmxlbmd0aCArIDE7IF9qKyspIHtcbiAgICAgICAgc3RyICs9IFwiICBcIjtcbiAgICAgIH1cblxuICAgICAgc3RyICs9IG9wdGlvbiArIFwiXFxuXCI7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwYXRoLmxlbmd0aCArIDE7IF9pKyspIHtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgcGF0aC5sZW5ndGggLSBfaTsgX2oyKyspIHtcbiAgICAgICAgICBzdHIgKz0gXCIgIFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IFwifVxcblwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyICsgXCJcXG5cXG5cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByaW50KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnkkMihvcHRpb25zKS5yZXBsYWNlKC8oXCIpfChcXFspfChcXF0pfCgsXCJfX3R5cGVfX1wiKS9nLCBcIlwiKS5yZXBsYWNlKC8oLCkvZywgXCIsIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGVkaXQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3NcbiAgICAgKiBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9TdHJpbmdzL0xldmVuc2h0ZWluX2Rpc3RhbmNlI0phdmFTY3JpcHRcbiAgICAgKlxuICAgICAqIENvcHlyaWdodCAoYykgMjAxMSBBbmRyZWkgTWFja2VuemllXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqXG4gICAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn19XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGV2ZW5zaHRlaW5EaXN0YW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXZlbnNodGVpbkRpc3RhbmNlKGEsIGIpIHtcbiAgICAgIGlmIChhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGIubGVuZ3RoO1xuICAgICAgaWYgKGIubGVuZ3RoID09PSAwKSByZXR1cm4gYS5sZW5ndGg7XG4gICAgICB2YXIgbWF0cml4ID0gW107IC8vIGluY3JlbWVudCBhbG9uZyB0aGUgZmlyc3QgY29sdW1uIG9mIGVhY2ggcm93XG5cbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF0cml4W2ldID0gW2ldO1xuICAgICAgfSAvLyBpbmNyZW1lbnQgZWFjaCBjb2x1bW4gaW4gdGhlIGZpcnN0IHJvd1xuXG5cbiAgICAgIHZhciBqO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbWF0cml4WzBdW2pdID0gajtcbiAgICAgIH0gLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgbWF0cml4XG5cblxuICAgICAgZm9yIChpID0gMTsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gYS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChiLmNoYXJBdChpIC0gMSkgPT0gYS5jaGFyQXQoaiAtIDEpKSB7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaSAtIDFdW2ogLSAxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4obWF0cml4W2kgLSAxXVtqIC0gMV0gKyAxLCAvLyBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgIE1hdGgubWluKG1hdHJpeFtpXVtqIC0gMV0gKyAxLCAvLyBpbnNlcnRpb25cbiAgICAgICAgICAgIG1hdHJpeFtpIC0gMV1bal0gKyAxKSk7IC8vIGRlbGV0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRyaXhbYi5sZW5ndGhdW2EubGVuZ3RoXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmFsaWRhdG9yO1xufSgpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IGtleXMkMyhvYmplY3QpOyBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzJDIpIHsgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMihvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBmaWx0ZXIkMihzeW1ib2xzKS5jYWxsKHN5bWJvbHMsIGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyB2YXIgX2NvbnRleHQ1OyBmb3JFYWNoJDIoX2NvbnRleHQ1ID0gb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCB0cnVlKSkuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkNyh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDIpIHsgZGVmaW5lUHJvcGVydGllcyQxKHRhcmdldCwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQyKHNvdXJjZSkpOyB9IGVsc2UgeyB2YXIgX2NvbnRleHQ2OyBmb3JFYWNoJDIoX2NvbnRleHQ2ID0gb3duS2V5cyQzKE9iamVjdChzb3VyY2UpKSkuY2FsbChfY29udGV4dDYsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkMih0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMoc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcbiAqIEEgbm9kZS4gQSBub2RlIGNhbiBiZSBjb25uZWN0ZWQgdG8gb3RoZXIgbm9kZXMgdmlhIG9uZSBvciBtdWx0aXBsZSBlZGdlcy5cbiAqL1xuXG52YXIgTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciB0aGUgbm9kZS4gQWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgYXJlIG9wdGlvbmFsLCBleGNlcHQgZm9yIHRoZSBpZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBpZCAgICAgSWQgb2YgdGhlIG5vZGUuIFJlcXVpcmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbGFiZWwgIFRleHQgbGFiZWwgZm9yIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0geCAgICAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSB5ICAgICAgVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBzaGFwZSAgTm9kZSBzaGFwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGltYWdlICBBbiBpbWFnZSB1cmxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSB0aXRsZSAgQSB0aXRsZSB0ZXh0LCBjYW4gYmUgSFRNTFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHthbnl0eXBlfSBncm91cCBBIGdyb3VwIG5hbWUgb3IgbnVtYmVyXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5ICAgICAgICAgICAgICAgU2hhcmVkIHN0YXRlIG9mIGN1cnJlbnQgbmV0d29yayBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge05ldHdvcmsuSW1hZ2VzfSBpbWFnZWxpc3QgIEEgbGlzdCB3aXRoIGltYWdlcy4gT25seSBuZWVkZWQgd2hlbiB0aGUgbm9kZSBoYXMgYW4gaW1hZ2VcbiAgICogQHBhcmFtIHtHcm91cHN9IGdyb3VwbGlzdCAgICAgICAgICBBIGxpc3Qgd2l0aCBncm91cHMuIE5lZWRlZCBmb3IgcmV0cmlldmluZyBncm91cCBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxPcHRpb25zICAgICAgQ3VycmVudCBnbG9iYWwgbm9kZSBvcHRpb25zOyB0aGVzZSBzZXJ2ZSBhcyBkZWZhdWx0cyBmb3IgdGhlIG5vZGUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRPcHRpb25zICAgICBHbG9iYWwgZGVmYXVsdCBvcHRpb25zIGZvciBub2Rlczsgbm90ZSB0aGF0IHRoaXMgaXMgYWxzbyB0aGUgcHJvdG90eXBlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHBhcmFtZXRlciBgZ2xvYmFsT3B0aW9uc2AuXG4gICAqL1xuICBmdW5jdGlvbiBOb2RlKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGUpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMpO1xuICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnM7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5lZGdlcyA9IFtdOyAvLyBhbGwgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZVxuICAgIC8vIHNldCBkZWZhdWx0cyBmb3IgdGhlIG9wdGlvbnNcblxuICAgIHRoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbWFnZWxpc3QgPSBpbWFnZWxpc3Q7XG4gICAgdGhpcy5ncm91cGxpc3QgPSBncm91cGxpc3Q7IC8vIHN0YXRlIG9wdGlvbnNcblxuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlU2l6ZSA9IHRoaXMub3B0aW9ucy5zaXplO1xuICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5vcHRpb25zLmZvbnQuc2l6ZTtcbiAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlOyAvLyB1c2VkIHRvIGNoZWNrIGlmIGluaXRpYWwgZml0IHNob3VsZCBqdXN0IHRha2UgdGhlIHJhbmdlIG9yIGFwcHJveGltYXRlXG5cbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob3ZlciA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWxNb2R1bGUgPSBuZXcgTGFiZWwodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIGZhbHNlXG4gICAgLyogTm90IGVkZ2UgbGFiZWwgKi9cbiAgICApO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoIGEgZWRnZSB0byB0aGUgbm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhOb2RlLCBbe1xuICAgIGtleTogXCJhdHRhY2hFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaEVkZ2UoZWRnZSkge1xuICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICBpZiAoaW5kZXhPZiQzKF9jb250ZXh0ID0gdGhpcy5lZGdlcykuY2FsbChfY29udGV4dCwgZWRnZSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0YWNoIGEgZWRnZSBmcm9tIHRoZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRldGFjaEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoRWRnZShlZGdlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgICB2YXIgaW5kZXggPSBpbmRleE9mJDMoX2NvbnRleHQyID0gdGhpcy5lZGdlcykuY2FsbChfY29udGV4dDIsIGVkZ2UpO1xuXG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MztcblxuICAgICAgICBzcGxpY2UkMihfY29udGV4dDMgPSB0aGlzLmVkZ2VzKS5jYWxsKF9jb250ZXh0MywgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgb3Igb3ZlcndyaXRlIG9wdGlvbnMgZm9yIHRoZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBhbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gICAgICogQHJldHVybnMge251bGx8Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFNoYXBlID0gdGhpcy5vcHRpb25zLnNoYXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBOb3RlIHRoYXQgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlICd1bmRlZmluZWQnISBUaGlzIGlzIE9LLlxuICAgICAgfSAvLyBTYXZlIHRoZSBjb2xvciBmb3IgbGF0ZXIuXG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBwcmV2ZW50IGxvY2FsIGNvbG9yIGZyb20gYmVpbmcgb3ZlcndyaXR0ZW4gYnkgZ3JvdXAgY29sb3IuXG4gICAgICAvLyBUT0RPOiBUbyBwcmV2ZW50IHN1Y2ggd29ya2Fyb3VuZHMgdGhlIHdheSBvcHRpb25zIGFyZSBoYW5kbGVkIHNob3VsZCBiZSByZXdyaXR0ZW4gZnJvbSBzY3JhdGNoLlxuICAgICAgLy8gVGhpcyBpcyBub3QgdGhlIG9ubHkgcHJvYmxlbSB3aXRoIGN1cnJlbnQgb3B0aW9ucyBoYW5kbGluZy5cblxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29sb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxDb2xvciA9IG9wdGlvbnMuY29sb3I7XG4gICAgICB9IC8vIGJhc2ljIG9wdGlvbnNcblxuXG4gICAgICBpZiAob3B0aW9ucy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGUgbXVzdCBoYXZlIGFuIGlkXCIpO1xuICAgICAgfVxuXG4gICAgICBOb2RlLmNoZWNrTWFzcyhvcHRpb25zLCB0aGlzLmlkKTsgLy8gc2V0IHRoZXNlIG9wdGlvbnMgbG9jYWxseVxuICAgICAgLy8gY2xlYXIgeCBhbmQgeSBwb3NpdGlvbnNcblxuICAgICAgaWYgKG9wdGlvbnMueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnggPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnggPSBfcGFyc2VJbnQkMihvcHRpb25zLngpO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMueSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueSA9IF9wYXJzZUludCQyKG9wdGlvbnMueSk7XG4gICAgICAgICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJhc2VTaXplID0gb3B0aW9ucy5zaXplO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMudmFsdWUgPSBfcGFyc2VGbG9hdCQyKG9wdGlvbnMudmFsdWUpO1xuICAgICAgfSAvLyB0aGlzIHRyYW5zZm9ybXMgYWxsIHNob3J0aGFuZHMgaW50byBmdWxseSBkZWZpbmVkIG9wdGlvbnNcblxuXG4gICAgICBOb2RlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZ2xvYmFsT3B0aW9ucywgdGhpcy5ncm91cGxpc3QpO1xuICAgICAgdmFyIHBpbGUgPSBbb3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zXTtcbiAgICAgIHRoaXMuY2hvb3NlciA9IGNob29zaWZ5KFwibm9kZVwiLCBwaWxlKTtcblxuICAgICAgdGhpcy5fbG9hZF9pbWFnZXMoKTtcblxuICAgICAgdGhpcy51cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKTsgLy8gTmVlZCB0byBzZXQgbG9jYWwgb3BhY2l0eSBhZnRlciBgdGhpcy51cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKTtgIGJlY2F1c2UgYHRoaXMudXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucyk7YCBvdmVycml0ZXMgbG9jYWwgb3BhY2l0eSB3aXRoIGdyb3VwIG9wYWNpdHlcblxuICAgICAgaWYgKG9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIE5vZGUuY2hlY2tPcGFjaXR5KG9wdGlvbnMub3BhY2l0eSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlU2hhcGUoY3VycmVudFNoYXBlKTtcbiAgICAgIHJldHVybiBvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBpbWFnZXMgZnJvbSB0aGUgb3B0aW9ucywgZm9yIHRoZSBub2RlcyB0aGF0IG5lZWQgdGhlbS5cbiAgICAgKlxuICAgICAqIEltYWdlcyBhcmUgYWx3YXlzIGxvYWRlZCwgZXZlbiBpZiB0aGV5IGFyZSBub3QgdXNlZCBpbiB0aGUgY3VycmVudCBzaGFwZS5cbiAgICAgKiBUaGUgdXNlciBtYXkgc3dpdGNoIHRvIGFuIGltYWdlIHNoYXBlIGxhdGVyIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9sb2FkX2ltYWdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZF9pbWFnZXMoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlID09PSBcImNpcmN1bGFySW1hZ2VcIiB8fCB0aGlzLm9wdGlvbnMuc2hhcGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb24gaW1hZ2UgbXVzdCBiZSBkZWZpbmVkIGZvciBub2RlIHR5cGUgJ1wiICsgdGhpcy5vcHRpb25zLnNoYXBlICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmltYWdlbGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEVycm9yOiBObyBpbWFnZXMgcHJvdmlkZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmltYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZSwgdGhpcy5vcHRpb25zLmJyb2tlbkltYWdlLCB0aGlzLmlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UudW5zZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdW5zZWxlY3RlZCBpbWFnZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS51bnNlbGVjdGVkLCB0aGlzLm9wdGlvbnMuYnJva2VuSW1hZ2UsIHRoaXMuaWQpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2Uuc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS5zZWxlY3RlZCwgdGhpcy5vcHRpb25zLmJyb2tlbkltYWdlLCB0aGlzLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgb3BhY2l0eSBpcyBvbmx5IGJldHdlZW4gMCBhbmQgMVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdHRpbmdWYWx1ZXNcIixcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge3tjb2xvcjogKiwgYm9yZGVyV2lkdGg6ICosIGJvcmRlckNvbG9yOiAqLCBzaXplOiAqLCBib3JkZXJEYXNoZXM6IChib29sZWFufEFycmF5fGFsbE9wdGlvbnMubm9kZXMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlc3x7Ym9vbGVhbiwgYXJyYXl9KSwgYm9yZGVyUmFkaXVzOiAobnVtYmVyfGFsbE9wdGlvbnMubm9kZXMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1c3x7bnVtYmVyfXxBcnJheSksIHNoYWRvdzogKiwgc2hhZG93Q29sb3I6ICosIHNoYWRvd1NpemU6ICosIHNoYWRvd1g6ICosIHNoYWRvd1k6ICp9fVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXR0aW5nVmFsdWVzKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgY29sb3I6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLm9wdGlvbnMub3BhY2l0eSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXIsXG4gICAgICAgIHNpemU6IHRoaXMub3B0aW9ucy5zaXplLFxuICAgICAgICBib3JkZXJEYXNoZXM6IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzLFxuICAgICAgICBib3JkZXJSYWRpdXM6IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzLFxuICAgICAgICBzaGFkb3c6IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCxcbiAgICAgICAgc2hhZG93Q29sb3I6IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3IsXG4gICAgICAgIHNoYWRvd1NpemU6IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSxcbiAgICAgICAgc2hhZG93WDogdGhpcy5vcHRpb25zLnNoYWRvdy54LFxuICAgICAgICBzaGFkb3dZOiB0aGlzLm9wdGlvbnMuc2hhZG93LnlcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkIHx8IHRoaXMuaG92ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hvb3NlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YWx1ZXMuYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGhTZWxlY3RlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJXaWR0aCAqPSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQ7XG4gICAgICAgICAgICB2YWx1ZXMuYm9yZGVyQ29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhvdmVyKSB7XG4gICAgICAgICAgICB2YWx1ZXMuY29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3IuaG92ZXIuYmFja2dyb3VuZDtcbiAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXI7XG4gICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jaG9vc2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLmNob29zZXIodmFsdWVzLCB0aGlzLm9wdGlvbnMuaWQsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuXG4gICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLnNoYWRvd0NvbG9yICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yIHx8IHZhbHVlcy5zaGFkb3dTaXplICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUgfHwgdmFsdWVzLnNoYWRvd1ggIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueCB8fCB2YWx1ZXMuc2hhZG93WSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy55KSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcbiAgICAgICAgdmFsdWVzLmJvcmRlckNvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHZhbHVlcy5ib3JkZXJDb2xvciwgb3BhY2l0eSk7XG4gICAgICAgIHZhbHVlcy5jb2xvciA9IG92ZXJyaWRlT3BhY2l0eSh2YWx1ZXMuY29sb3IsIG9wYWNpdHkpO1xuICAgICAgICB2YWx1ZXMuc2hhZG93Q29sb3IgPSBvdmVycmlkZU9wYWNpdHkodmFsdWVzLnNoYWRvd0NvbG9yLCBvcGFjaXR5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlTGFiZWxNb2R1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5sYWJlbCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubGFiZWwgPSBcIlwiO1xuICAgICAgfVxuXG4gICAgICBOb2RlLnVwZGF0ZUdyb3VwT3B0aW9ucyh0aGlzLm9wdGlvbnMsIF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICBjb2xvcjogb3B0aW9ucyAmJiBvcHRpb25zLmNvbG9yIHx8IHRoaXMuX2xvY2FsQ29sb3IgfHwgdW5kZWZpbmVkXG4gICAgICB9KSwgdGhpcy5ncm91cGxpc3QpOyAvL1xuICAgICAgLy8gTm90ZTpUaGUgcHJvdG90eXBlIGNoYWluIGZvciB0aGlzLm9wdGlvbnMgaXM6XG4gICAgICAvL1xuICAgICAgLy8gdGhpcy5vcHRpb25zIC0+ICAgIE5vZGVzSGFuZGxlci5vcHRpb25zICAgIC0+IE5vZGVzSGFuZGxlci5kZWZhdWx0T3B0aW9uc1xuICAgICAgLy8gICAgICAgICAgICAgICAgIChhbHNvOiB0aGlzLmdsb2JhbE9wdGlvbnMpXG4gICAgICAvL1xuICAgICAgLy8gTm90ZSB0aGF0IHRoZSBwcm90b3R5cGVzIGFyZSBtZW50aW9uZWQgZXhwbGljaXRseSBpbiB0aGUgcGlsZSBsaXN0IGJlbG93O1xuICAgICAgLy8gV0UgRE9OJ1QgV0FOVCBUSEUgT1JERVIgT0YgVEhFIFBST1RPVFlQRVMhISEhIEF0IGxlYXN0LCBub3QgZm9yIGZvbnQgaGFuZGxpbmcgb2YgbGFiZWxzLlxuICAgICAgLy8gVGhpcyBpcyBhIGdvb2QgaW5kaWNhdGlvbiB0aGF0IHRoZSBwcm90b3R5cGUgdXNhZ2Ugb2Ygb3B0aW9ucyBpcyBkZWZpY2llbnQuXG4gICAgICAvL1xuXG4gICAgICB2YXIgY3VycmVudEdyb3VwID0gdGhpcy5ncm91cGxpc3QuZ2V0KHRoaXMub3B0aW9ucy5ncm91cCwgZmFsc2UpO1xuICAgICAgdmFyIHBpbGUgPSBbb3B0aW9ucywgLy8gbmV3IG9wdGlvbnNcbiAgICAgIHRoaXMub3B0aW9ucywgLy8gY3VycmVudCBub2RlIG9wdGlvbnMsIHNlZSBjb21tZW50IGFib3ZlIGZvciBwcm90b3R5cGVcbiAgICAgIGN1cnJlbnRHcm91cCwgLy8gZ3JvdXAgb3B0aW9ucywgaWYgYW55XG4gICAgICB0aGlzLmdsb2JhbE9wdGlvbnMsIC8vIEN1cnJlbnRseSBzZXQgZ2xvYmFsIG5vZGUgb3B0aW9uc1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyAvLyBEZWZhdWx0IGdsb2JhbCBub2RlIG9wdGlvbnNcbiAgICAgIF07XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLnVwZGF0ZSh0aGlzLm9wdGlvbnMsIHBpbGUpO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFNoYXBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTaGFwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTaGFwZShjdXJyZW50U2hhcGUpIHtcbiAgICAgIGlmIChjdXJyZW50U2hhcGUgPT09IHRoaXMub3B0aW9ucy5zaGFwZSAmJiB0aGlzLnNoYXBlKSB7XG4gICAgICAgIHRoaXMuc2hhcGUuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMsIHRoaXMuaW1hZ2VPYmosIHRoaXMuaW1hZ2VPYmpBbHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2hvb3NlIGRyYXcgbWV0aG9kIGRlcGVuZGluZyBvbiB0aGUgc2hhcGVcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuc2hhcGUpIHtcbiAgICAgICAgICBjYXNlIFwiYm94XCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEJveCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJjaXJjbGVcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQ2lyY2xlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImNpcmN1bGFySW1hZ2VcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQ2lyY3VsYXJJbWFnZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSwgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJjdXN0b21cIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQ3VzdG9tU2hhcGUodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMub3B0aW9ucy5jdHhSZW5kZXJlcik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJkYXRhYmFzZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBEYXRhYmFzZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IERpYW1vbmQodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiZG90XCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IERvdCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEVsbGlwc2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiaWNvblwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBJY29uKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEltYWdlJDEodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMuaW1hZ2VPYmosIHRoaXMuaW1hZ2VPYmpBbHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwic3F1YXJlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFNxdWFyZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJoZXhhZ29uXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEhleGFnb24odGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwic3RhclwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTdGFyKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgVGV4dCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0cmlhbmdsZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBUcmlhbmdsZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0cmlhbmdsZURvd25cIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgVHJpYW5nbGVEb3duKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRWxsaXBzZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZWRzUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgdGhpcyBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLm5lZWRzUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1bnNlbGVjdCB0aGlzIG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuc2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2VsZWN0KCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgbm9kZSwgZm9yY2VzIGl0IHRvIHJlY2FsY3VsYXRlIGl0cyBzaXplXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZWVkc1JlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVlZHNSZWZyZXNoKCkge1xuICAgICAgdGhpcy5zaGFwZS5yZWZyZXNoTmVlZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aXRsZSAgICBUaGUgdGl0bGUgb2YgdGhlIG5vZGUsIG9yIHVuZGVmaW5lZCB3aGVuIG5vIHRpdGxlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaXRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdG8gdGhlIGJvcmRlciBvZiB0aGUgTm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlICAgICAgICBBbmdsZSBpbiByYWRpYW5zXG4gICAgICogQHJldHVybnMge251bWJlcn0gZGlzdGFuY2UgICBEaXN0YW5jZSB0byB0aGUgYm9yZGVyIGluIHBpeGVsc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgbm9kZSBoYXMgYSBmaXhlZCB4IGFuZCB5IHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgICB0cnVlIGlmIGZpeGVkLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzRml4ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXhlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZml4ZWQueCAmJiB0aGlzLm9wdGlvbnMuZml4ZWQueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2hlY2sgaWYgdGhpcyBub2RlIGlzIHNlbGVjdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBzZWxlY3RlZCAgIFRydWUgaWYgbm9kZSBpcyBzZWxlY3RlZCwgZWxzZSBmYWxzZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTZWxlY3RlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NlbGVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZS4gQ2FuIGJlIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGRpbWVuc2lvbnMgb2YgdGhlIGxhYmVsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7cmVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbFNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbE1vZHVsZS5zaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIG5vZGUuIFRoZSBub2RlIHdpbGwgYWRqdXN0IGl0J3Mgc2l6ZVxuICAgICAqIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlUmFuZ2UobWluLCBtYXgsIHRvdGFsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxpbmcuY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdGhpcy5vcHRpb25zLnZhbHVlKTtcbiAgICAgICAgdmFyIHNpemVEaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGZvbnREaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW4gKyBzY2FsZSAqIGZvbnREaWZmO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLnNpemUgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW4gKyBzY2FsZSAqIHNpemVEaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNpemUgPSB0aGlzLmJhc2VTaXplO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5iYXNlRm9udFNpemU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuZHJhdyhjdHgsIHRoaXMueCwgdGhpcy55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpIHx8IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgc2hhcGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goY3R4KSB7XG4gICAgICB0aGlzLnNoYXBlLnVwZGF0ZUJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55LCBjdHgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuICAgICAgdGhpcy5zaGFwZS5yZXNpemUoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgYWxsIHZpc3VhbCBlbGVtZW50cyBvZiB0aGlzIG5vZGUgaW5zdGFuY2UsIGluIHdoaWNoIHRoZSBnaXZlblxuICAgICAqIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgYm91bmRpbmcgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bm9kZUNsaWNrSXRlbXxub2RlTGFiZWxDbGlja0l0ZW0+fSBsaXN0IHdpdGggdGhlIGl0ZW1zIHdoaWNoIGFyZSBvbiB0aGUgcG9pbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEl0ZW1zT25Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJdGVtc09uUG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpKSB7XG4gICAgICAgIGlmIChwb2ludEluUmVjdCh0aGlzLmxhYmVsTW9kdWxlLmdldFNpemUoKSwgcG9pbnQpKSB7XG4gICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgbm9kZUlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgbGFiZWxJZDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb2ludEluUmVjdCh0aGlzLnNoYXBlLmJvdW5kaW5nQm94LCBwb2ludCkpIHtcbiAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgIG5vZGVJZDogdGhpcy5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc092ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJsYXBwaW5nV2l0aChvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmxlZnQgPCBvYmoucmlnaHQgJiYgdGhpcy5zaGFwZS5sZWZ0ICsgdGhpcy5zaGFwZS53aWR0aCA+IG9iai5sZWZ0ICYmIHRoaXMuc2hhcGUudG9wIDwgb2JqLmJvdHRvbSAmJiB0aGlzLnNoYXBlLnRvcCArIHRoaXMuc2hhcGUuaGVpZ2h0ID4gb2JqLnRvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgob2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0IDwgb2JqLnJpZ2h0ICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQgPiBvYmoubGVmdCAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LnRvcCA8IG9iai5ib3R0b20gJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b20gPiBvYmoudG9wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB2YWxpZCB2YWx1ZXMgZm9yIG1hc3NcbiAgICAgKlxuICAgICAqIFRoZSBtYXNzIG1heSBub3QgYmUgbmVnYXRpdmUgb3IgemVyby4gSWYgaXQgaXMsIHJlc2V0IHRvIDFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBpZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwiY2hlY2tPcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgICByZXR1cm4gMCA8PSBvcGFjaXR5ICYmIG9wYWNpdHkgPD0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBvcmlnaW4gaXMgJ2NlbnRlcicgb3IgJ3RvcC1sZWZ0J1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tDb29yZGluYXRlT3JpZ2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQ29vcmRpbmF0ZU9yaWdpbihvcmlnaW4pIHtcbiAgICAgIHJldHVybiBvcmlnaW4gPT09IHVuZGVmaW5lZCB8fCBvcmlnaW4gPT09IFwiY2VudGVyXCIgfHwgb3JpZ2luID09PSBcInRvcC1sZWZ0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgZ3JvdXAgb3B0aW9uIHZhbHVlcyBpbnRvIHRoZSBub2RlIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBUaGUgZ3JvdXAgb3B0aW9ucyBvdmVycmlkZSB0aGUgZ2xvYmFsIG5vZGUgb3B0aW9ucywgc28gdGhlIGNvcHkgb2YgZ3JvdXAgb3B0aW9uc1xuICAgICAqICBtdXN0IGhhcHBlbiAqYWZ0ZXIqIHRoZSBnbG9iYWwgbm9kZSBvcHRpb25zIGhhdmUgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtdXN0IGFsc28gYmUgY2FsbGVkIGFsc28gaWYgdGhlIGdsb2JhbCBub2RlIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkIGFuZCB0aGUgZ3JvdXAgb3B0aW9ucyBkaWQgbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9ucyAgbmV3IHZhbHVlcyBmb3IgdGhlIG9wdGlvbnMsIGN1cnJlbnRseSBvbmx5IHBhc3NlZCBpbiBmb3IgY2hlY2tcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBMaXN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVHcm91cE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlR3JvdXBPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGdyb3VwTGlzdCkge1xuICAgICAgdmFyIF9jb250ZXh0NDtcblxuICAgICAgaWYgKGdyb3VwTGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIE5vIGdyb3Vwcywgbm90aGluZyB0byBkb1xuXG4gICAgICB2YXIgZ3JvdXAgPSBwYXJlbnRPcHRpb25zLmdyb3VwOyAvLyBwYXJhbm9pYTogdGhlIHNlbGVjdGVkIGdyb3VwIGlzIGFscmVhZHkgbWVyZ2VkIGludG8gbm9kZSBvcHRpb25zLCBjaGVjay5cblxuICAgICAgaWYgKG5ld09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmdyb3VwICE9PSB1bmRlZmluZWQgJiYgZ3JvdXAgIT09IG5ld09wdGlvbnMuZ3JvdXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXBkYXRlR3JvdXBPcHRpb25zOiBncm91cCB2YWx1ZXMgaW4gb3B0aW9ucyBkb24ndCBtYXRjaC5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNHcm91cCA9IHR5cGVvZiBncm91cCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZ3JvdXAgPT09IFwic3RyaW5nXCIgJiYgZ3JvdXAgIT0gXCJcIjtcbiAgICAgIGlmICghaGFzR3JvdXApIHJldHVybjsgLy8gY3VycmVudCBub2RlIGhhcyBubyBncm91cCwgbm8gbmVlZCB0byBtZXJnZVxuXG4gICAgICB2YXIgZ3JvdXBPYmogPSBncm91cExpc3QuZ2V0KGdyb3VwKTtcblxuICAgICAgaWYgKGdyb3VwT2JqLm9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLm9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIU5vZGUuY2hlY2tPcGFjaXR5KGdyb3VwT2JqLm9wYWNpdHkpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBncm91cE9iai5vcGFjaXR5KTtcbiAgICAgICAgICBncm91cE9iai5vcGFjaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IC8vIFNraXAgYW55IG5ldyBvcHRpb24gdG8gYXZvaWQgdGhlbSBiZWluZyBvdmVycmlkZGVuIGJ5IHRoZSBncm91cCBvcHRpb25zLlxuXG5cbiAgICAgIHZhciBza2lwUHJvcGVydGllcyA9IGZpbHRlciQyKF9jb250ZXh0NCA9IGdldE93blByb3BlcnR5TmFtZXMkMihuZXdPcHRpb25zKSkuY2FsbChfY29udGV4dDQsIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBuZXdPcHRpb25zW3BdICE9IG51bGw7XG4gICAgICB9KTsgLy8gQWx3YXlzIHNraXAgbWVyZ2luZyBncm91cCBmb250IG9wdGlvbnMgaW50byBwYXJlbnQ7IHRoZXNlIGFyZSByZXF1aXJlZCB0byBiZSBkaXN0aW5jdCBmb3IgbGFiZWxzXG5cblxuICAgICAgc2tpcFByb3BlcnRpZXMucHVzaChcImZvbnRcIik7XG4gICAgICBzZWxlY3RpdmVOb3REZWVwRXh0ZW5kKHNraXBQcm9wZXJ0aWVzLCBwYXJlbnRPcHRpb25zLCBncm91cE9iaik7IC8vIHRoZSBjb2xvciBvYmplY3QgbmVlZHMgdG8gYmUgY29tcGxldGVseSBkZWZpbmVkLlxuICAgICAgLy8gU2luY2UgZ3JvdXBzIGNhbiBwYXJ0aWFsbHkgb3ZlcndyaXRlIHRoZSBjb2xvcnMsIHdlIHBhcnNlIGl0IGFnYWluLCBqdXN0IGluIGNhc2UuXG5cbiAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSBwYXJzZUNvbG9yKHBhcmVudE9wdGlvbnMuY29sb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHByb2Nlc3MgYWxsIHBvc3NpYmxlIHNob3J0aGFuZHMgaW4gdGhlIG5ldyBvcHRpb25zIGFuZCBtYWtlcyBzdXJlIHRoYXQgdGhlIHBhcmVudE9wdGlvbnMgYXJlIGZ1bGx5IGRlZmluZWQuXG4gICAgICogU3RhdGljIHNvIGl0IGNhbiBhbHNvIGJlIHVzZWQgYnkgdGhlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWxsb3dEZWxldGlvbj1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2dsb2JhbE9wdGlvbnM9e31dXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtncm91cExpc3RdXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gICAgICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICB2YXIgZ3JvdXBMaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgZmllbGRzID0gW1wiY29sb3JcIiwgXCJmaXhlZFwiLCBcInNoYWRvd1wiXTtcbiAgICAgIHNlbGVjdGl2ZU5vdERlZXBFeHRlbmQoZmllbGRzLCBwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgIE5vZGUuY2hlY2tNYXNzKG5ld09wdGlvbnMpO1xuXG4gICAgICBpZiAocGFyZW50T3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFOb2RlLmNoZWNrT3BhY2l0eShwYXJlbnRPcHRpb25zLm9wYWNpdHkpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBwYXJlbnRPcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMub3BhY2l0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFOb2RlLmNoZWNrT3BhY2l0eShuZXdPcHRpb25zLm9wYWNpdHkpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBuZXdPcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICAgIG5ld09wdGlvbnMub3BhY2l0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5zaGFwZVByb3BlcnRpZXMgJiYgIU5vZGUuY2hlY2tDb29yZGluYXRlT3JpZ2luKG5ld09wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4pKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBjb29yZGluYXRlT3JpZ2luLCBmb3VuZDogXCIgKyBuZXdPcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luKTtcbiAgICAgIH0gLy8gbWVyZ2UgdGhlIHNoYWRvdyBvcHRpb25zIGludG8gdGhlIHBhcmVudC5cblxuXG4gICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgXCJzaGFkb3dcIiwgZ2xvYmFsT3B0aW9ucyk7IC8vIGluZGl2aWR1YWwgc2hhcGUgbmV3T3B0aW9uc1xuXG4gICAgICBpZiAobmV3T3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhcnNlZENvbG9yID0gcGFyc2VDb2xvcihuZXdPcHRpb25zLmNvbG9yKTtcbiAgICAgICAgZmlsbElmRGVmaW5lZChwYXJlbnRPcHRpb25zLmNvbG9yLCBwYXJzZWRDb2xvcik7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5jb2xvciA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmNvbG9yID0gYnJpZGdlT2JqZWN0KGdsb2JhbE9wdGlvbnMuY29sb3IpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfSAvLyBoYW5kbGUgdGhlIGZpeGVkIG9wdGlvbnNcblxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5maXhlZCAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZml4ZWQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPcHRpb25zLmZpeGVkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueCA9IG5ld09wdGlvbnMuZml4ZWQ7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC55ID0gbmV3T3B0aW9ucy5maXhlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3T3B0aW9ucy5maXhlZC54ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5ld09wdGlvbnMuZml4ZWQueCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueCA9IG5ld09wdGlvbnMuZml4ZWQueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV3T3B0aW9ucy5maXhlZC55ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG5ld09wdGlvbnMuZml4ZWQueSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueSA9IG5ld09wdGlvbnMuZml4ZWQueTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5mb250ID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZm9udCA9IGJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmZvbnQpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfVxuXG4gICAgICBOb2RlLnVwZGF0ZUdyb3VwT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBncm91cExpc3QpOyAvLyBoYW5kbGUgdGhlIHNjYWxpbmcgb3B0aW9ucywgc3BlY2lmaWNhbGx5IHRoZSBsYWJlbCBwYXJ0XG5cbiAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5zY2FsaW5nLCBuZXdPcHRpb25zLnNjYWxpbmcsIFwibGFiZWxcIiwgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tNYXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrTWFzcyhvcHRpb25zLCBpZCkge1xuICAgICAgaWYgKG9wdGlvbnMubWFzcyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMubWFzcyA8PSAwKSB7XG4gICAgICAgIHZhciBzdHJJZCA9IFwiXCI7XG5cbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdHJJZCA9IFwiIGluIG5vZGUgaWQ6IFwiICsgaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmVycm9yKFwiJWNOZWdhdGl2ZSBvciB6ZXJvIG1hc3MgZGlzYWxsb3dlZFwiICsgc3RySWQgKyBcIiwgc2V0dGluZyBtYXNzIHRvIDEuXCIsIHByaW50U3R5bGUpO1xuICAgICAgICBvcHRpb25zLm1hc3MgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBzeW1ib2wkNCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBnZXRJdGVyYXRvck1ldGhvZCQxKG8pID09IG51bGwpIHsgaWYgKGlzQXJyYXkkNShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGdldEl0ZXJhdG9yJDEobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQyKG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQ0OyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlJDUoX2NvbnRleHQ0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0NCwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbV8xJDIobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDIoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG4vKipcbiAqIEhhbmRsZXIgZm9yIE5vZGVzXG4gKi9cblxudmFyIE5vZGVzSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0ltYWdlc30gaW1hZ2VzXG4gICAqIEBwYXJhbSB7QXJyYXkuPEdyb3VwPn0gZ3JvdXBzXG4gICAqIEBwYXJhbSB7TGF5b3V0RW5naW5lfSBsYXlvdXRFbmdpbmVcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGVzSGFuZGxlcihib2R5LCBpbWFnZXMsIGdyb3VwcywgbGF5b3V0RW5naW5lKSB7XG4gICAgdmFyIF9jb250ZXh0LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOb2Rlc0hhbmRsZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICB0aGlzLmdyb3VwcyA9IGdyb3VwcztcbiAgICB0aGlzLmxheW91dEVuZ2luZSA9IGxheW91dEVuZ2luZTsgLy8gY3JlYXRlIHRoZSBub2RlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcblxuICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZSA9IGJpbmQkMihfY29udGV4dCA9IHRoaXMuY3JlYXRlKS5jYWxsKF9jb250ZXh0LCB0aGlzKTtcbiAgICB0aGlzLm5vZGVzTGlzdGVuZXJzID0ge1xuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy5hZGQocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZShwYXJhbXMuaXRlbXMsIHBhcmFtcy5kYXRhLCBwYXJhbXMub2xkRGF0YSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy5yZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGJyb2tlbkltYWdlOiB1bmRlZmluZWQsXG4gICAgICBjb2xvcjoge1xuICAgICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM5N0MyRkNcIixcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIlxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJvcmRlcjogXCIjMkI3Q0U5XCIsXG4gICAgICAgICAgYmFja2dyb3VuZDogXCIjRDJFNUZGXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHVuZGVmaW5lZCxcbiAgICAgIC8vIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgIGZpeGVkOiB7XG4gICAgICAgIHg6IGZhbHNlLFxuICAgICAgICB5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6IFwiIzM0MzQzNFwiLFxuICAgICAgICBzaXplOiAxNCxcbiAgICAgICAgLy8gcHhcbiAgICAgICAgZmFjZTogXCJhcmlhbFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIHZhZGp1c3Q6IDAsXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgIG1vZDogXCJib2xkXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9sZGl0YWw6IHtcbiAgICAgICAgICBtb2Q6IFwiYm9sZCBpdGFsaWNcIlxuICAgICAgICB9LFxuICAgICAgICBpdGFsOiB7XG4gICAgICAgICAgbW9kOiBcIml0YWxpY1wiXG4gICAgICAgIH0sXG4gICAgICAgIG1vbm86IHtcbiAgICAgICAgICBtb2Q6IFwiXCIsXG4gICAgICAgICAgc2l6ZTogMTUsXG4gICAgICAgICAgLy8gcHhcbiAgICAgICAgICBmYWNlOiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICAgIHZhZGp1c3Q6IDJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdyb3VwOiB1bmRlZmluZWQsXG4gICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgaWNvbjoge1xuICAgICAgICBmYWNlOiBcIkZvbnRBd2Vzb21lXCIsXG4gICAgICAgIC8vJ0ZvbnRBd2Vzb21lJyxcbiAgICAgICAgY29kZTogdW5kZWZpbmVkLFxuICAgICAgICAvLydcXHVmMDA3JyxcbiAgICAgICAgc2l6ZTogNTAsXG4gICAgICAgIC8vNTAsXG4gICAgICAgIGNvbG9yOiBcIiMyQjdDRTlcIiAvLycjYWEwMGZmJ1xuXG4gICAgICB9LFxuICAgICAgaW1hZ2U6IHVuZGVmaW5lZCxcbiAgICAgIC8vIC0tPiBVUkxcbiAgICAgIGltYWdlUGFkZGluZzoge1xuICAgICAgICAvLyBvbmx5IGZvciBpbWFnZSBzaGFwZVxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sXG4gICAgICBsYWJlbDogdW5kZWZpbmVkLFxuICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgICAgbGV2ZWw6IHVuZGVmaW5lZCxcbiAgICAgIG1hcmdpbjoge1xuICAgICAgICB0b3A6IDUsXG4gICAgICAgIHJpZ2h0OiA1LFxuICAgICAgICBib3R0b206IDUsXG4gICAgICAgIGxlZnQ6IDVcbiAgICAgIH0sXG4gICAgICBtYXNzOiAxLFxuICAgICAgcGh5c2ljczogdHJ1ZSxcbiAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgbWluOiAxMCxcbiAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBtaW46IDE0LFxuICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgbWF4VmlzaWJsZTogMzAsXG4gICAgICAgICAgZHJhd1RocmVzaG9sZDogNVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IGZ1bmN0aW9uIGN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAxIC8gKG1heCAtIG1pbik7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHZhbHVlIC0gbWluKSAqIHNjYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgeDogNSxcbiAgICAgICAgeTogNVxuICAgICAgfSxcbiAgICAgIHNoYXBlOiBcImVsbGlwc2VcIixcbiAgICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgICBib3JkZXJEYXNoZXM6IGZhbHNlLFxuICAgICAgICAvLyBvbmx5IGZvciBib3JkZXJzXG4gICAgICAgIGJvcmRlclJhZGl1czogNixcbiAgICAgICAgLy8gb25seSBmb3IgYm94IHNoYXBlXG4gICAgICAgIGludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuICAgICAgICB1c2VJbWFnZVNpemU6IGZhbHNlLFxuICAgICAgICAvLyBvbmx5IGZvciBpbWFnZSBhbmQgY2lyY3VsYXJJbWFnZSBzaGFwZXNcbiAgICAgICAgdXNlQm9yZGVyV2l0aEltYWdlOiBmYWxzZSxcbiAgICAgICAgLy8gb25seSBmb3IgaW1hZ2Ugc2hhcGVcbiAgICAgICAgY29vcmRpbmF0ZU9yaWdpbjogXCJjZW50ZXJcIiAvLyBvbmx5IGZvciBpbWFnZSBhbmQgY2lyY3VsYXJJbWFnZSBzaGFwZXNcblxuICAgICAgfSxcbiAgICAgIHNpemU6IDI1LFxuICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB4OiB1bmRlZmluZWQsXG4gICAgICB5OiB1bmRlZmluZWRcbiAgICB9OyAvLyBQcm90ZWN0IGZyb20gaWRpb2N5XG5cbiAgICBpZiAodGhpcy5kZWZhdWx0T3B0aW9ucy5tYXNzIDw9IDApIHtcbiAgICAgIHRocm93IFwiSW50ZXJuYWwgZXJyb3I6IG1hc3MgaW4gZGVmYXVsdE9wdGlvbnMgb2YgTm9kZXNIYW5kbGVyIG1heSBub3QgYmUgemVybyBvciBuZWdhdGl2ZVwiO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IGJyaWRnZU9iamVjdCh0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhOb2Rlc0hhbmRsZXIsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX2NvbnRleHQyLFxuICAgICAgICAgIF9jb250ZXh0MyxcbiAgICAgICAgICBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyByZWZyZXNoIHRoZSBub2Rlcy4gVXNlZCB3aGVuIHJldmVydGluZyBmcm9tIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaE5vZGVzXCIsIGJpbmQkMihfY29udGV4dDIgPSB0aGlzLnJlZnJlc2gpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hcIiwgYmluZCQyKF9jb250ZXh0MyA9IHRoaXMucmVmcmVzaCkuY2FsbChfY29udGV4dDMsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvckVhY2gkMyhfdGhpczIubm9kZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLmJvZHkuZGF0YS5ub2RlcykgX3RoaXMyLmJvZHkuZGF0YS5ub2Rlcy5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy5hZGQ7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMudXBkYXRlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzLnJlbW92ZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycztcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBOb2RlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBOZWVkIHRvIHNldCBvcGFjaXR5IGhlcmUgYmVjYXVzZSBOb2RlLnBhcnNlT3B0aW9ucyBpcyBhbHNvIHVzZWQgZm9yIGdyb3VwcyxcbiAgICAgICAgLy8gaWYgeW91IHNldCBvcGFjaXR5IGluIE5vZGUucGFyc2VPcHRpb25zIGl0IG92ZXJ3cml0ZXMgZ3JvdXAgb3BhY2l0eS5cblxuICAgICAgICBpZiAob3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoaXNOYW4kMihvcHRpb25zLm9wYWNpdHkpIHx8ICFfaXNGaW5pdGUkMihvcHRpb25zLm9wYWNpdHkpIHx8IG9wdGlvbnMub3BhY2l0eSA8IDAgfHwgb3B0aW9ucy5vcGFjaXR5ID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBvcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdXBkYXRlIHRoZSBzaGFwZSBpbiBhbGwgbm9kZXNcblxuXG4gICAgICAgIGlmIChvcHRpb25zLnNoYXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS51cGRhdGVTaGFwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIGxhYmVscyBvZiBub2RlcyBpZiBhbnkgcmVsZXZhbnQgb3B0aW9ucyBjaGFuZ2VkLlxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZvbnQgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG9wdGlvbnMud2lkdGhDb25zdHJhaW50ICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBvcHRpb25zLmhlaWdodENvbnN0cmFpbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IGtleXMkMyh0aGlzLmJvZHkubm9kZXMpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfbm9kZUlkID0gX09iamVjdCRrZXlzW19pXTtcblxuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWRdLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkXS5uZWVkc1JlZnJlc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdXBkYXRlIHRoZSBzaGFwZSBzaXplIGluIGFsbCBub2Rlc1xuXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgX25vZGVJZDIgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2RlcywgX25vZGVJZDIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkMl0ubmVlZHNSZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIHZhcmlhYmxlcyBpZiBuZWVkZWRcblxuXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBkYXRhIHNldCB3aXRoIG5vZGVzIGZvciB0aGUgbmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gbm9kZXMgICAgICAgICBUaGUgZGF0YSBjb250YWluaW5nIHRoZSBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdIC0gU3VwcHJlc3MgZGF0YSBjaGFuZ2VkIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEobm9kZXMpIHtcbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIG9sZE5vZGVzRGF0YSA9IHRoaXMuYm9keS5kYXRhLm5vZGVzO1xuXG4gICAgICBpZiAoaXNEYXRhVmlld0xpa2UoXCJpZFwiLCBub2RlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBub2RlcztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQ1KG5vZGVzKSkge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2RlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmFkZChub2Rlcyk7XG4gICAgICB9IGVsc2UgaWYgKCFub2Rlcykge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5ub2RlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9sZE5vZGVzRGF0YSkge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICAgIGZvckVhY2gkMyh0aGlzLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgb2xkTm9kZXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gcmVtb3ZlIGRyYXduIG5vZGVzXG5cblxuICAgICAgdGhpcy5ib2R5Lm5vZGVzID0ge307XG5cbiAgICAgIGlmICh0aGlzLmJvZHkuZGF0YS5ub2Rlcykge1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgZm9yRWFjaCQzKHRoaXMubm9kZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBtZS5ib2R5LmRhdGEubm9kZXMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7IC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuXG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXRJZHMoKTtcbiAgICAgICAgdGhpcy5hZGQoaWRzLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90RW1pdD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpZHMpIHtcbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGlkO1xuICAgICAgdmFyIG5ld05vZGVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldChpZCk7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGUocHJvcGVydGllcyk7XG4gICAgICAgIG5ld05vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tpZF0gPSBub2RlOyAvLyBub3RlOiB0aGlzIG1heSByZXBsYWNlIGFuIGV4aXN0aW5nIG5vZGVcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXlvdXRFbmdpbmUucG9zaXRpb25Jbml0aWFsbHkobmV3Tm9kZXMpO1xuXG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhpc3Rpbmcgbm9kZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHMgaWQncyBvZiBjaGFuZ2VkIG5vZGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2hhbmdlZERhdGEgYXJyYXkgd2l0aCBjaGFuZ2VkIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5fHVuZGVmaW5lZH0gb2xkRGF0YSBvcHRpb25hbDsgYXJyYXkgd2l0aCBwcmV2aW91cyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoaWRzLCBjaGFuZ2VkRGF0YSwgb2xkRGF0YSkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpZF07XG4gICAgICAgIHZhciBkYXRhID0gY2hhbmdlZERhdGFbaV07XG5cbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHVwZGF0ZSBub2RlXG4gICAgICAgICAgaWYgKG5vZGUuc2V0T3B0aW9ucyhkYXRhKSkge1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7IC8vIGNyZWF0ZSBub2RlXG5cbiAgICAgICAgICBub2RlID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICAgICAgbm9kZXNbaWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGFDaGFuZ2VkICYmIG9sZERhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgYW55IGNoYW5nZXMgd2hpY2ggc2hvdWxkIHRyaWdnZXIgYSBsYXlvdXQgcmVjYWxjdWxhdGlvblxuICAgICAgICAvLyBGb3Igbm93LCB0aGlzIGlzIGp1c3QgJ2xldmVsJyBmb3IgaGllcmFyY2hpY2FsIGxheW91dFxuICAgICAgICAvLyBBc3N1bXB0aW9uOiBvbGQgYW5kIG5ldyBkYXRhIGFycmFuZ2VkIGluIHNhbWUgb3JkZXI7IGF0IHRpbWUgb2Ygd3JpdGluZywgdGhpcyBob2xkcy5cbiAgICAgICAgZGF0YUNoYW5nZWQgPSBzb21lJDIoY2hhbmdlZERhdGEpLmNhbGwoY2hhbmdlZERhdGEsIGZ1bmN0aW9uIChuZXdWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGREYXRhW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gb2xkVmFsdWUgJiYgb2xkVmFsdWUubGV2ZWwgIT09IG5ld1ZhbHVlLmxldmVsO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFVcGRhdGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXhpc3Rpbmcgbm9kZXMuIElmIG5vZGVzIGRvIG5vdCBleGlzdCwgdGhlIG1ldGhvZCB3aWxsIGp1c3QgaWdub3JlIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShpZHMpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICBkZWxldGUgbm9kZXNbaWRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Y2xhc3N9IFtjb25zdHJ1Y3RvckNsYXNzPU5vZGUuZGVmYXVsdF1cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgdmFyIGNvbnN0cnVjdG9yQ2xhc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE5vZGU7XG4gICAgICByZXR1cm4gbmV3IGNvbnN0cnVjdG9yQ2xhc3MocHJvcGVydGllcywgdGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5ncm91cHMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2xlYXJQb3NpdGlvbnM9ZmFsc2VdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGNsZWFyUG9zaXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIGZvckVhY2gkMyh0aGlzLmJvZHkubm9kZXMsIGZ1bmN0aW9uIChub2RlLCBub2RlSWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfdGhpczMuYm9keS5kYXRhLm5vZGVzLmdldChub2RlSWQpO1xuXG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY2xlYXJQb3NpdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICAgIHk6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBmaXhlZDogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBub2RlLnNldE9wdGlvbnMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZS5pZD4gfCBzdHJpbmd9IFtpZHNdICAtLT4gb3B0aW9uYWwsIGNhbiBiZSBhcnJheSBvZiBub2RlSWRzLCBjYW4gYmUgc3RyaW5nXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhpZHMpIHtcbiAgICAgIHZhciBkYXRhQXJyYXkgPSB7fTtcblxuICAgICAgaWYgKGlkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc0FycmF5JDUoaWRzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZHNbaV1dO1xuICAgICAgICAgICAgICBkYXRhQXJyYXlbaWRzW2ldXSA9IHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKG5vZGUueCksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChub2RlLnkpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbaWRzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX25vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRzXTtcbiAgICAgICAgICAgIGRhdGFBcnJheVtpZHNdID0ge1xuICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKF9ub2RlLngpLFxuICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKF9ub2RlLnkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX25vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaTJdXTtcbiAgICAgICAgICBkYXRhQXJyYXlbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pMl1dID0ge1xuICAgICAgICAgICAgeDogTWF0aC5yb3VuZChfbm9kZTIueCksXG4gICAgICAgICAgICB5OiBNYXRoLnJvdW5kKF9ub2RlMi55KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFBcnJheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB4IHkgcG9zaXRpb24gb2YgYSBzcGVjaWZpYyBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgdG8gcmV0cmlldmUuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIG5vIGlkIGlzIGluY2x1ZGVkLlxuICAgICAqIEB0aHJvd3Mge1JlZmVyZW5jZUVycm9yfSBJZiBhbiBpbnZhbGlkIGlkIGlzIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3sgeDogbnVtYmVyLCB5OiBudW1iZXIgfX0gUmV0dXJucyBYLCBZIGNhbnZhcyBwb3NpdGlvbiBvZiB0aGUgbm9kZSB3aXRoIGdpdmVuIGlkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24oaWQpIHtcbiAgICAgIGlmIChpZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIGlkIHdhcyBzcGVjaWZpZWQgZm9yIGdldFBvc2l0aW9uIG1ldGhvZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYm9keS5ub2Rlc1tpZF0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIk5vZGVJZCBwcm92aWRlZCBmb3IgZ2V0UG9zaXRpb24gZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIi5jb25jYXQoaWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZCh0aGlzLmJvZHkubm9kZXNbaWRdLngpLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQodGhpcy5ib2R5Lm5vZGVzW2lkXS55KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBYWSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzIGludG8gdGhlIGRhdGFzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9yZVBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9yZVBvc2l0aW9ucygpIHtcbiAgICAgIC8vIHRvZG86IGFkZCBzdXBwb3J0IGZvciBjbHVzdGVycyBhbmQgaGllcmFyY2hpY2FsLlxuICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgdmFyIGRhdGFzZXQgPSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKGRhdGFzZXQuZ2V0KCkpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBkc05vZGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgaWQgPSBkc05vZGUuaWQ7XG4gICAgICAgICAgdmFyIGJvZHlOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2lkXTtcbiAgICAgICAgICB2YXIgeCA9IE1hdGgucm91bmQoYm9keU5vZGUueCk7XG4gICAgICAgICAgdmFyIHkgPSBNYXRoLnJvdW5kKGJvZHlOb2RlLnkpO1xuXG4gICAgICAgICAgaWYgKGRzTm9kZS54ICE9PSB4IHx8IGRzTm9kZS55ICE9PSB5KSB7XG4gICAgICAgICAgICBkYXRhQXJyYXkucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFzZXQudXBkYXRlKGRhdGFBcnJheSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgYm91bmRpbmcgYm94IG9mIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge2p8Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KG5vZGVJZCkge1xuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnNoYXBlLmJvdW5kaW5nQm94O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIElkcyBvZiBub2RlcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcGFyYW0geyd0byd8J2Zyb20nfHVuZGVmaW5lZH0gZGlyZWN0aW9uIHZhbHVlcyAnZnJvbScgYW5kICd0bycgc2VsZWN0IHJlc3BlY3RpdmVseSBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzIG9ubHkuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbnkgb3RoZXIgdmFsdWUgcmV0dXJucyBib3RoIHBhcmVudCBhbmQgY2hpbGQgbm9kZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29ubmVjdGVkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29ubmVjdGVkTm9kZXMobm9kZUlkLCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBub2RlTGlzdCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICB2YXIgbm9kZU9iaiA9IHt9OyAvLyB1c2VkIHRvIHF1aWNrbHkgY2hlY2sgaWYgbm9kZSBhbHJlYWR5IGV4aXN0c1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcblxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IFwidG9cIiAmJiBlZGdlLnRvSWQgPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRvdWJsZSBlcXVhbHMgc2luY2UgaWRzIGNhbiBiZSBudW1lcmljIG9yIHN0cmluZ1xuICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS5mcm9tSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLmZyb21JZCk7XG4gICAgICAgICAgICAgIG5vZGVPYmpbZWRnZS5mcm9tSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAhPT0gXCJmcm9tXCIgJiYgZWRnZS5mcm9tSWQgPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGRvdWJsZSBlcXVhbHMgc2luY2UgaWRzIGNhbiBiZSBudW1lcmljIG9yIHN0cmluZ1xuICAgICAgICAgICAgaWYgKG5vZGVPYmpbZWRnZS50b0lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS50b0lkKTtcbiAgICAgICAgICAgICAgbm9kZU9ialtlZGdlLnRvSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkcyBvZiB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25uZWN0ZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWRFZGdlcyhub2RlSWQpIHtcbiAgICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVkZ2VMaXN0LnB1c2gobm9kZS5lZGdlc1tpXS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlSWQgcHJvdmlkZWQgZm9yIGdldENvbm5lY3RlZEVkZ2VzIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogXCIsIG5vZGVJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlZGdlTGlzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZSBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVOb2RlKG5vZGVJZCwgeCwgeSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnggPSBOdW1iZXIoeCk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnkgPSBOdW1iZXIoeSk7XG5cbiAgICAgICAgc2V0VGltZW91dCQyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGUgaWQgc3VwcGxpZWQgdG8gbW92ZU5vZGUgZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIiwgbm9kZUlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZXNIYW5kbGVyO1xufSgpO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JfMTtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDQ7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuZ2V0XG5cbmZ1bmN0aW9uIGdldCQxKHRhcmdldCwgcHJvcGVydHlLZXlcbi8qICwgcmVjZWl2ZXIgKi9cbikge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXTtcbiAgdmFyIGRlc2NyaXB0b3IsIHByb3RvdHlwZTtcbiAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYgKGRlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZih0YXJnZXQsIHByb3BlcnR5S2V5KSkgcmV0dXJuIGhhcyhkZXNjcmlwdG9yLCAndmFsdWUnKSA/IGRlc2NyaXB0b3IudmFsdWUgOiBkZXNjcmlwdG9yLmdldCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZGVzY3JpcHRvci5nZXQuY2FsbChyZWNlaXZlcik7XG4gIGlmIChpc09iamVjdChwcm90b3R5cGUgPSBvYmplY3RHZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldCQxKHByb3RvdHlwZSwgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ1JlZmxlY3QnLFxuICBzdGF0OiB0cnVlXG59LCB7XG4gIGdldDogZ2V0JDFcbn0pO1xuXG52YXIgZ2V0JDIgPSBwYXRoLlJlZmxlY3QuZ2V0O1xuXG52YXIgZ2V0JDMgPSBnZXQkMjtcblxudmFyIGdldCQ0ID0gZ2V0JDM7XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZiQ1KG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG52YXIgc3VwZXJQcm9wQmFzZSA9IF9zdXBlclByb3BCYXNlO1xuXG52YXIgZ2V0JDUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gIGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2V0JDQpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IGdldCQ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgIHZhciBiYXNlID0gc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNShiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQ7XG59KTtcblxudmFyICRoeXBvdCA9IE1hdGguaHlwb3Q7XG52YXIgYWJzJDEgPSBNYXRoLmFicztcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0OyAvLyBDaHJvbWUgNzcgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05NTQ2XG5cbnZhciBCVUdHWSA9ICEhJGh5cG90ICYmICRoeXBvdChJbmZpbml0eSwgTmFOKSAhPT0gSW5maW5pdHk7IC8vIGBNYXRoLmh5cG90YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hdGguaHlwb3RcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ01hdGgnLFxuICBzdGF0OiB0cnVlLFxuICBmb3JjZWQ6IEJVR0dZXG59LCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG5cbiAgICB3aGlsZSAoaSA8IGFMZW4pIHtcbiAgICAgIGFyZyA9IGFicyQxKGFyZ3VtZW50c1tpKytdKTtcblxuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogc3FydChzdW0pO1xuICB9XG59KTtcblxudmFyIGh5cG90ID0gcGF0aC5NYXRoLmh5cG90O1xuXG52YXIgaHlwb3QkMSA9IGh5cG90O1xuXG52YXIgaHlwb3QkMiA9IGh5cG90JDE7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRpKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGkoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRpKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcclxuICogQ29tbW9uIG1ldGhvZHMgZm9yIGVuZHBvaW50c1xyXG4gKlxyXG4gKiBAY2xhc3NcclxuICovXG5cbnZhciBFbmRQb2ludCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVuZFBvaW50KCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEVuZFBvaW50KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEVuZFBvaW50LCBudWxsLCBbe1xuICAgIGtleTogXCJ0cmFuc2Zvcm1cIixcblxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgdHJhbnNmb3JtYXRpb24gb24gcG9pbnRzIGZvciBkaXNwbGF5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb2xsb3dpbmcgaXMgZG9uZTpcclxuICAgICAqIC0gcm90YXRlIGJ5IHRoZSBzcGVjaWZpZWQgYW5nbGVcclxuICAgICAqIC0gbXVsdGlwbHkgdGhlIChub3JtYWxpemVkKSBjb29yZGluYXRlcyBieSB0aGUgcGFzc2VkIGxlbmd0aFxyXG4gICAgICogLSBvZmZzZXQgYnkgdGhlIHRhcmdldCBjb29yZGluYXRlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgcG9pbnQocykgdG8gYmUgdHJhbnNmb3JtZWQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKSB7XG4gICAgICBpZiAoIWlzQXJyYXkkNShwb2ludHMpKSB7XG4gICAgICAgIHBvaW50cyA9IFtwb2ludHNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IGFycm93RGF0YS5wb2ludC54O1xuICAgICAgdmFyIHkgPSBhcnJvd0RhdGEucG9pbnQueTtcbiAgICAgIHZhciBhbmdsZSA9IGFycm93RGF0YS5hbmdsZTtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJvd0RhdGEubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIHh0ID0gcC54ICogTWF0aC5jb3MoYW5nbGUpIC0gcC55ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB2YXIgeXQgPSBwLnggKiBNYXRoLnNpbihhbmdsZSkgKyBwLnkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHAueCA9IHggKyBsZW5ndGggKiB4dDtcbiAgICAgICAgcC55ID0geSArIGxlbmd0aCAqIHl0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIERyYXcgYSBjbG9zZWQgcGF0aCB1c2luZyB0aGUgZ2l2ZW4gcmVhbCBjb29yZGluYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHBhdGggd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgcG9pbnRzIG9mIHRoZSBwYXRoLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UGF0aChjdHgsIHBvaW50cykge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRW5kUG9pbnQ7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgYXJyb3cgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBJbWFnZSQyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW5kUG9pbnQpIHtcbiAgaW5oZXJpdHMoSW1hZ2UsIF9FbmRQb2ludCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRpKEltYWdlKTtcblxuICBmdW5jdGlvbiBJbWFnZSgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhJbWFnZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBGYWxzZSBhcyB0aGVyZSBpcyBubyB3YXkgdG8gZmlsbCBhbiBpbWFnZS5cclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICBpZiAoYXJyb3dEYXRhLmltYWdlKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoYXJyb3dEYXRhLnBvaW50LngsIGFycm93RGF0YS5wb2ludC55KTtcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJIC8gMiArIGFycm93RGF0YS5hbmdsZSk7XG4gICAgICAgIHZhciB3aWR0aCA9IGFycm93RGF0YS5pbWFnZVdpZHRoICE9IG51bGwgPyBhcnJvd0RhdGEuaW1hZ2VXaWR0aCA6IGFycm93RGF0YS5pbWFnZS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGFycm93RGF0YS5pbWFnZUhlaWdodCAhPSBudWxsID8gYXJyb3dEYXRhLmltYWdlSGVpZ2h0IDogYXJyb3dEYXRhLmltYWdlLmhlaWdodDtcbiAgICAgICAgYXJyb3dEYXRhLmltYWdlLmRyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCAxLCAvLyBzY2FsZVxuICAgICAgICAtd2lkdGggLyAyLCAvLyB4XG4gICAgICAgIDAsIC8vIHlcbiAgICAgICAgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2U7XG59KEVuZFBvaW50KTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBhcnJvdyBlbmRwb2ludC5cclxuICovXG5cblxudmFyIEFycm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW5kUG9pbnQyKSB7XG4gIGluaGVyaXRzKEFycm93LCBfRW5kUG9pbnQyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlciRpKEFycm93KTtcblxuICBmdW5jdGlvbiBBcnJvdygpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBcnJvdyk7XG5cbiAgICByZXR1cm4gX3N1cGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQXJyb3csIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcblxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMC45LFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXJyb3c7XG59KEVuZFBvaW50KTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjcm93IGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgQ3JvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENyb3coKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3Jvdyk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhDcm93LCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG5cbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNCxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3Jvdztcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjdXJ2ZSBlbmRwb2ludC5cclxuICovXG5cblxudmFyIEN1cnZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3VydmUoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VydmUpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQ3VydmUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcblxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiAtMC40LFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50LCBhcnJvd0RhdGEpOyAvLyBVcGRhdGUgZW5kcG9pbnQgc3R5bGUgZm9yIGRyYXdpbmcgdHJhbnNwYXJlbnQgYXJjLlxuXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAwKVwiOyAvLyBEZWZpbmUgY3VydmUgZW5kcG9pbnQgYXMgc2VtaWNpcmNsZS5cblxuICAgICAgdmFyIHBpID0gTWF0aC5QSTtcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlIC0gcGkgLyAyO1xuICAgICAgdmFyIGVuZEFuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlICsgcGkgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZmFsc2UpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1cnZlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGludmVydGVkIGN1cnZlIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgSW52ZXJ0ZWRDdXJ2ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludmVydGVkQ3VydmUoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSW52ZXJ0ZWRDdXJ2ZSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhJbnZlcnRlZEN1cnZlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG5cbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogLTAuMyxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludCwgYXJyb3dEYXRhKTsgLy8gVXBkYXRlIGVuZHBvaW50IHN0eWxlIGZvciBkcmF3aW5nIHRyYW5zcGFyZW50IGFyYy5cblxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMClcIjsgLy8gRGVmaW5lIGludmVydGVkIGN1cnZlIGVuZHBvaW50IGFzIHNlbWljaXJjbGUuXG5cbiAgICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IGFycm93RGF0YS5hbmdsZSArIHBpIC8gMjtcbiAgICAgIHZhciBlbmRBbmdsZSA9IGFycm93RGF0YS5hbmdsZSArIDMgKiBwaSAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIGFycm93RGF0YS5sZW5ndGggKiAwLjQsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW52ZXJ0ZWRDdXJ2ZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSB0cmluYWdsZSBlbmRwb2ludC5cclxuICovXG5cblxudmFyIFRyaWFuZ2xlJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmlhbmdsZSgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmlhbmdsZSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUcmlhbmdsZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMC4wMixcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJpYW5nbGU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgaW52ZXJ0ZWQgdHJpbmFnbGUgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBJbnZlcnRlZFRyaWFuZ2xlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW52ZXJ0ZWRUcmlhbmdsZSgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJbnZlcnRlZFRyaWFuZ2xlKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKEludmVydGVkVHJpYW5nbGUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcblxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW52ZXJ0ZWRUcmlhbmdsZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjaXJjbGUgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBDaXJjbGUkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGUpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoQ2lyY2xlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG5cbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogLTAuNCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludCwgYXJyb3dEYXRhKTtcbiAgICAgIGRyYXdDaXJjbGUoY3R4LCBwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjbGU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgYmFyIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgQmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJhcik7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhCYXIsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcblxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLypcclxuICAgICAgdmFyIHBvaW50cyA9IFtcclxuICAgICAgICB7eDowLCB5OjAuNX0sXHJcbiAgICAgICAge3g6MCwgeTotMC41fVxyXG4gICAgICBdO1xyXG4gICAgICAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xyXG4gICAgICBjdHgubGluZVRvKHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XHJcbiAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgKi9cbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLjVcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogLTAuNVxuICAgICAgfSwge1xuICAgICAgICB4OiAtMC4xNSxcbiAgICAgICAgeTogLTAuNVxuICAgICAgfSwge1xuICAgICAgICB4OiAtMC4xNSxcbiAgICAgICAgeTogMC41XG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFyO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGJveCBlbmRwb2ludC5cclxuICovXG5cblxudmFyIEJveCQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQm94KCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJveCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhCb3gsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcblxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjYsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNixcbiAgICAgICAgeTogMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm94O1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGRpYW1vbmQgZW5kcG9pbnQuXHJcbiAqL1xuXG5cbnZhciBEaWFtb25kJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaWFtb25kKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERpYW1vbmQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoRGlhbW9uZCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMC41LFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjUsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERpYW1vbmQ7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgdmVlIGVuZHBvaW50LlxyXG4gKi9cblxuXG52YXIgVmVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmVlKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZlZSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhWZWUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcblxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNSxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmVlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGVuZHBvaW50cy5cclxuICovXG5cblxudmFyIEVuZFBvaW50cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVuZFBvaW50cygpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBFbmRQb2ludHMpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoRW5kUG9pbnRzLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG5cbiAgICAvKipcclxuICAgICAqIERyYXcgYW4gZW5kcG9pbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3csIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICB2YXIgdHlwZTtcblxuICAgICAgaWYgKGFycm93RGF0YS50eXBlKSB7XG4gICAgICAgIHR5cGUgPSBhcnJvd0RhdGEudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgcmV0dXJuIEltYWdlJDIuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgIHJldHVybiBDaXJjbGUkMS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiYm94XCI6XG4gICAgICAgICAgcmV0dXJuIEJveCQxLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJjcm93XCI6XG4gICAgICAgICAgcmV0dXJuIENyb3cuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImN1cnZlXCI6XG4gICAgICAgICAgcmV0dXJuIEN1cnZlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICAgICAgcmV0dXJuIERpYW1vbmQkMS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcblxuICAgICAgICBjYXNlIFwiaW52X2N1cnZlXCI6XG4gICAgICAgICAgcmV0dXJuIEludmVydGVkQ3VydmUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcInRyaWFuZ2xlXCI6XG4gICAgICAgICAgcmV0dXJuIFRyaWFuZ2xlJDEuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgICAgY2FzZSBcImludl90cmlhbmdsZVwiOlxuICAgICAgICAgIHJldHVybiBJbnZlcnRlZFRyaWFuZ2xlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJiYXJcIjpcbiAgICAgICAgICByZXR1cm4gQmFyLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJ2ZWVcIjpcbiAgICAgICAgICByZXR1cm4gVmVlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuXG4gICAgICAgIGNhc2UgXCJhcnJvd1wiOiAvLyBmYWxsLXRocm91Z2hcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBBcnJvdy5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRW5kUG9pbnRzO1xufSgpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDQob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IGtleXMkMyhvYmplY3QpOyBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzJDIpIHsgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMihvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBmaWx0ZXIkMihzeW1ib2xzKS5jYWxsKHN5bWJvbHMsIGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyB2YXIgX2NvbnRleHQyOyBmb3JFYWNoJDIoX2NvbnRleHQyID0gb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpLCB0cnVlKSkuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkNyh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDIpIHsgZGVmaW5lUHJvcGVydGllcyQxKHRhcmdldCwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQyKHNvdXJjZSkpOyB9IGVsc2UgeyB2YXIgX2NvbnRleHQzOyBmb3JFYWNoJDIoX2NvbnRleHQzID0gb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpKSkuY2FsbChfY29udGV4dDMsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkMih0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMoc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogVGhlIEJhc2UgQ2xhc3MgZm9yIGFsbCBlZGdlcy5cclxuICovXG5cbnZhciBFZGdlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIF9ib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIF9sYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gRWRnZUJhc2Uob3B0aW9ucywgX2JvZHksIF9sYWJlbE1vZHVsZSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VCYXNlKTtcblxuICAgIHRoaXMuX2JvZHkgPSBfYm9keTtcbiAgICB0aGlzLl9sYWJlbE1vZHVsZSA9IF9sYWJlbE1vZHVsZTtcbiAgICB0aGlzLmNvbG9yID0ge307XG4gICAgdGhpcy5jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmhvdmVyV2lkdGggPSAxLjU7XG4gICAgdGhpcy5zZWxlY3Rpb25XaWR0aCA9IDI7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuZnJvbVBvaW50ID0gdGhpcy5mcm9tO1xuICAgIHRoaXMudG9Qb2ludCA9IHRoaXMudG87XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBjcmVhdGVDbGFzcyhFZGdlQmFzZSwgW3tcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbmV3IGVkZ2Ugb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBuZXcgZWRnZSBvcHRpb25zIG9iamVjdC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLmZyb20gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXTtcbiAgICAgIHRoaXMudG8gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMaW5lKGN0eCwgdmFsdWVzLCBfc2VsZWN0ZWQsIF9ob3Zlcikge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRoaXMuZ2V0VmlhTm9kZSgpO1xuICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldENvbG9yKGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMud2lkdGg7XG5cbiAgICAgIGlmICh2YWx1ZXMuZGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9kcmF3RGFzaGVkTGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kcmF3TGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGxpbmUgd2l0aCBnaXZlbiBzdHlsZSBiZXR3ZWVuIHR3byBub2RlcyB0aHJvdWdoIHN1cHBsaWVkIG5vZGUocykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgbGlrZSBjb2xvciwgb3BhY2l0eSBvciBzaGFkb3cuXHJcbiAgICAgKiBAcGFyYW0gdmlhTm9kZSAtIEFkZGl0aW9uYWwgY29udHJvbCBwb2ludChzKSBmb3IgdGhlIGVkZ2UuXHJcbiAgICAgKiBAcGFyYW0gZnJvbVBvaW50IC0gVE9ETzogU2VlbXMgaWdub3JlZCwgcmVtb3ZlP1xyXG4gICAgICogQHBhcmFtIHRvUG9pbnQgLSBUT0RPOiBTZWVtcyBpZ25vcmVkLCByZW1vdmU/XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3TGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUsIGZyb21Qb2ludCwgdG9Qb2ludCkge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlLCBmcm9tUG9pbnQsIHRvUG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGEyID0gc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YSwgMyksXG4gICAgICAgICAgICB4ID0gX3RoaXMkX2dldENpcmNsZURhdGEyWzBdLFxuICAgICAgICAgICAgeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlsxXSxcbiAgICAgICAgICAgIHJhZGl1cyA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlsyXTtcblxuICAgICAgICB0aGlzLl9jaXJjbGUoY3R4LCB2YWx1ZXMsIHgsIHksIHJhZGl1cyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGRhc2hlZCBsaW5lIHdpdGggZ2l2ZW4gc3R5bGUgYmV0d2VlbiB0d28gbm9kZXMgdGhyb3VnaCBzdXBwbGllZCBub2RlKHMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGxpa2UgY29sb3IsIG9wYWNpdHkgb3Igc2hhZG93LlxyXG4gICAgICogQHBhcmFtIHZpYU5vZGUgLSBBZGRpdGlvbmFsIGNvbnRyb2wgcG9pbnQocykgZm9yIHRoZSBlZGdlLlxyXG4gICAgICogQHBhcmFtIF9mcm9tUG9pbnQgLSBJZ25vcmVkIChUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSkuXHJcbiAgICAgKiBAcGFyYW0gX3RvUG9pbnQgLSBJZ25vcmVkIChUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSkuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3RGFzaGVkTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0Rhc2hlZExpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUsIF9mcm9tUG9pbnQsIF90b1BvaW50KSB7XG4gICAgICBjdHgubGluZUNhcCA9IFwicm91bmRcIjtcbiAgICAgIHZhciBwYXR0ZXJuID0gaXNBcnJheSQ1KHZhbHVlcy5kYXNoZXMpID8gdmFsdWVzLmRhc2hlcyA6IFs1LCA1XTsgLy8gb25seSBmaXJlZm94IGFuZCBjaHJvbWUgc3VwcG9ydCB0aGlzIG1ldGhvZCwgZWxzZSB3ZSB1c2UgdGhlIGxlZ2FjeSBvbmUuXG5cbiAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguc2F2ZSgpOyAvLyBzZXQgZGFzaCBzZXR0aW5ncyBmb3IgY2hyb21lIG9yIGZpcmVmb3hcblxuICAgICAgICBjdHguc2V0TGluZURhc2gocGF0dGVybik7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7IC8vIGRyYXcgdGhlIGxpbmVcblxuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICB0aGlzLl9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGEzID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTQgPSBzbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhMywgMyksXG4gICAgICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTRbMF0sXG4gICAgICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTRbMV0sXG4gICAgICAgICAgICAgIHJhZGl1cyA9IF90aGlzJF9nZXRDaXJjbGVEYXRhNFsyXTtcblxuICAgICAgICAgIHRoaXMuX2NpcmNsZShjdHgsIHZhbHVlcywgeCwgeSwgcmFkaXVzKTtcbiAgICAgICAgfSAvLyByZXN0b3JlIHRoZSBkYXNoIHNldHRpbmdzLlxuXG5cbiAgICAgICAgY3R4LnNldExpbmVEYXNoKFswXSk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1bnN1cHBvcnRpbmcgc21vb3RoIGxpbmVzXG4gICAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICAgIGRyYXdEYXNoZWRMaW5lKGN0eCwgdGhpcy5mcm9tLngsIHRoaXMuZnJvbS55LCB0aGlzLnRvLngsIHRoaXMudG8ueSwgcGF0dGVybik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhNSA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSxcbiAgICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGE2ID0gc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YTUsIDMpLFxuICAgICAgICAgICAgICBfeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhNlswXSxcbiAgICAgICAgICAgICAgX3kgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTZbMV0sXG4gICAgICAgICAgICAgIF9yYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTZbMl07XG5cbiAgICAgICAgICB0aGlzLl9jaXJjbGUoY3R4LCB2YWx1ZXMsIF94LCBfeSwgX3JhZGl1cyk7XG4gICAgICAgIH0gLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuXG5cbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7IC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIChlaXRoZXIgZnJvbSBvciB0byBub2RlIG9mIHRoZSBlZGdlKS5cclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRCb3JkZXJQb3NpdGlvbihub2RlLCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5vZGUsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKG5vZGUsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEJvcmRlclBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQm9yZGVyUG9zaXRpb25zKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHRoaXMuZnJvbSwgY3R4KSxcbiAgICAgICAgICB0bzogdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKHRoaXMudG8sIGN0eClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGEkID0gc2xpY2UkNShfY29udGV4dCA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSkuY2FsbChfY29udGV4dCwgMCwgMiksXG4gICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSQyID0gc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YSQsIDIpLFxuICAgICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhJDJbMF0sXG4gICAgICAgICAgICB5ID0gX3RoaXMkX2dldENpcmNsZURhdGEkMlsxXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZyb206IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IDAuMjUsXG4gICAgICAgICAgICBoaWdoOiAwLjYsXG4gICAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdG86IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IDAuNixcbiAgICAgICAgICAgIGhpZ2g6IDAuOCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogMVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgY2VudGVyIHBvaW50IGFuZCByYWRpdXMgb2YgYW4gZWRnZSBjb25uZWN0ZWQgdG8gdGhlIHNhbWUgbm9kZSBhdCBib3RoIGVuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYFt4LCB5LCByYWRpdXNdYFxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2lyY2xlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2lyY2xlRGF0YShjdHgpIHtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplO1xuXG4gICAgICBpZiAoY3R4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5zaGFwZS53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5mcm9tLnNoYXBlLnJlc2l6ZShjdHgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGdldCBjaXJjbGUgY29vcmRpbmF0ZXNcblxuXG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZXRTZWxmUmVmQ29vcmRpbmF0ZXMoY3R4LCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSwgcmFkaXVzLCB0aGlzLmZyb20pO1xuICAgICAgcmV0dXJuIFtjb29yZGluYXRlcy54LCBjb29yZGluYXRlcy55LCByYWRpdXNdO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCBhIHBvaW50IG9uIGEgY2lyY2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSByYWRpdXMgLSBSYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIFZhbHVlIGJldHdlZW4gMCAobGluZSBzdGFydCkgYW5kIDEgKGxpbmUgZW5kKS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgcmVxdWVzdGVkIHBvaW50IG9uIHRoZSBjaXJjbGUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wb2ludE9uQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgcG9zaXRpb24pIHtcbiAgICAgIHZhciBhbmdsZSA9IHBvc2l0aW9uICogMiAqIE1hdGguUEk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGNpcmNsZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5lYXJOb2RlIC0gVGhlIG5vZGUgKGVpdGhlciBmcm9tIG9yIHRvIG5vZGUgb2YgdGhlIGVkZ2UpLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgb2YgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUobmVhck5vZGUsIGN0eCwgb3B0aW9ucykge1xuICAgICAgdmFyIHggPSBvcHRpb25zLng7XG4gICAgICB2YXIgeSA9IG9wdGlvbnMueTtcbiAgICAgIHZhciBsb3cgPSBvcHRpb25zLmxvdztcbiAgICAgIHZhciBoaWdoID0gb3B0aW9ucy5oaWdoO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplO1xuICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDU7XG4gICAgICB2YXIgcG9zO1xuICAgICAgdmFyIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcbiAgICAgIHZhciBlbmRQb2ludE9mZnNldCA9IDA7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgZW5kUG9pbnRPZmZzZXQgPSB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICBlbmRQb2ludE9mZnNldCA9IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldC50bztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0aW9uID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG4gICAgICAgIHBvcyA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBtaWRkbGUpO1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5lYXJOb2RlLnkgLSBwb3MueSwgbmVhck5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Cb3JkZXIgPSBuZWFyTm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpICsgZW5kUG9pbnRPZmZzZXQ7XG4gICAgICAgIHZhciBkaXN0YW5jZVRvUG9pbnQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9zLnggLSBuZWFyTm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbmVhck5vZGUueSwgMikpO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IGRpc3RhbmNlVG9Cb3JkZXIgLSBkaXN0YW5jZVRvUG9pbnQ7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmZlcmVuY2UpIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgYnJlYWs7IC8vIGZvdW5kXG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA+IDApIHtcbiAgICAgICAgICAvLyBkaXN0YW5jZSB0byBub2RlcyBpcyBsYXJnZXIgdGhhbiBkaXN0YW5jZSB0byBib3JkZXIgLS0+IHQgbmVlZHMgdG8gYmUgYmlnZ2VyIGlmIHdlJ3JlIGxvb2tpbmcgYXQgdGhlIHRvIG5vZGUuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICArK2l0ZXJhdGlvbjtcbiAgICAgIH0gd2hpbGUgKGxvdyA8PSBoaWdoICYmIGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnMpO1xuXG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQyKF9vYmplY3RTcHJlYWQkMih7fSwgcG9zKSwge30sIHtcbiAgICAgICAgdDogbWlkZGxlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxpbmUgd2lkdGggb2YgdGhlIGVkZ2UuIERlcGVuZHMgb24gd2lkdGggYW5kIHdoZXRoZXIgb25lIG9mIHRoZSBjb25uZWN0ZWQgbm9kZXMgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlbGVjdGVkIC0gRGV0ZXJtaW5lcyB3aGV0ZXIgdGhlIGxpbmUgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gaG92ZXIgLSBEZXRlcm1pbmVzIHdoZXRlciB0aGUgbGluZSBpcyBiZWluZyBob3ZlcmVkLCBvbmx5IGFwcGxpZXMgaWYgc2VsZWN0ZWQgaXMgZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHdpZHRoIG9mIHRoZSBsaW5lLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRMaW5lV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZVdpZHRoKHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnNlbGVjdGlvbldpZHRoLCAwLjMgLyB0aGlzLl9ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfSBlbHNlIGlmIChob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5ob3ZlcldpZHRoLCAwLjMgLyB0aGlzLl9ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub3B0aW9ucy53aWR0aCwgMC4zIC8gdGhpcy5fYm9keS52aWV3LnNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBjb2xvciBvciBncmFkaWVudCBmb3IgZ2l2ZW4gZWRnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBsaWtlIGNvbG9yLCBvcGFjaXR5IG9yIHNoYWRvdy5cclxuICAgICAqIEBwYXJhbSBfc2VsZWN0ZWQgLSBJZ25vcmVkIChUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSkuXHJcbiAgICAgKiBAcGFyYW0gX2hvdmVyIC0gSWdub3JlZCAoVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIENvbG9yIHN0cmluZyBpZiBzaW5nbGUgY29sb3IgaXMgaW5oZXJpdGVkIG9yIGdyYWRpZW50IGlmIHR3by5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29sb3IoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuaW5oZXJpdHNDb2xvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gd2hlbiB0aGlzIGlzIGEgbG9vcCBlZGdlLCBqdXN0IHVzZSB0aGUgJ2Zyb20nIG1ldGhvZFxuICAgICAgICBpZiAodmFsdWVzLmluaGVyaXRzQ29sb3IgPT09IFwiYm90aFwiICYmIHRoaXMuZnJvbS5pZCAhPT0gdGhpcy50by5pZCkge1xuICAgICAgICAgIHZhciBncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQodGhpcy5mcm9tLngsIHRoaXMuZnJvbS55LCB0aGlzLnRvLngsIHRoaXMudG8ueSk7XG4gICAgICAgICAgdmFyIGZyb21Db2xvciA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXI7XG4gICAgICAgICAgdmFyIHRvQ29sb3IgPSB0aGlzLnRvLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcblxuICAgICAgICAgIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IGZhbHNlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmcm9tQ29sb3IgPSBvdmVycmlkZU9wYWNpdHkodGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgICAgICB0b0NvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXIsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gdHJ1ZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9Db2xvciA9IHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IGZhbHNlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGZyb21Db2xvciA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAsIGZyb21Db2xvcik7XG4gICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgxLCB0b0NvbG9yKTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gdGhpcyByZXR1cm5zIC0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgICAgICAgICByZXR1cm4gZ3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcy5pbmhlcml0c0NvbG9yID09PSBcInRvXCIpIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVPcGFjaXR5KHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXIsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBcImZyb21cIlxuICAgICAgICAgIHJldHVybiBvdmVycmlkZU9wYWNpdHkodGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZU9wYWNpdHkodmFsdWVzLmNvbG9yLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGxpbmUgZnJvbSBhIG5vZGUgdG8gaXRzZWxmLCBhIGNpcmNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBsaWtlIGNvbG9yLCBvcGFjaXR5IG9yIHNoYWRvdy5cclxuICAgICAqIEBwYXJhbSB4IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSByYWRpdXMgLSBSYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2lyY2xlKGN0eCwgdmFsdWVzLCB4LCB5LCByYWRpdXMpIHtcbiAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTsgLy9mdWxsIGNpcmNsZVxuXG4gICAgICB2YXIgYW5nbGVGcm9tID0gMDtcbiAgICAgIHZhciBhbmdsZVRvID0gTWF0aC5QSSAqIDI7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UucmVuZGVyQmVoaW5kVGhlTm9kZSkge1xuICAgICAgICAvL3JlbmRlciBvbmx5IHBhcnRzIHdoaWNoIGFyZSBub3Qgb3ZlcmxhcGluZyB3aXRoIHBhcmVudCBub2RlXG4gICAgICAgIC8vbmVlZCB0byBmaW5kIHgseSBvZiBmcm9tIHBvaW50IGFuZCB4LHkgdG8gcG9pbnRcbiAgICAgICAgLy9jYWxjdWxhdGluZyByYWRpYW5zXG4gICAgICAgIHZhciBsb3cgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZTtcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSArIE1hdGguUEk7XG5cbiAgICAgICAgdmFyIHBvaW50VEZyb20gPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGUodGhpcy5mcm9tLCBjdHgsIHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgbG93OiBsb3csXG4gICAgICAgICAgaGlnaDogaGlnaCxcbiAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwb2ludFRUbyA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBsb3c6IGxvdyxcbiAgICAgICAgICBoaWdoOiBoaWdoLFxuICAgICAgICAgIGRpcmVjdGlvbjogMVxuICAgICAgICB9KTtcblxuICAgICAgICBhbmdsZUZyb20gPSBNYXRoLmF0YW4yKHBvaW50VEZyb20ueSAtIHksIHBvaW50VEZyb20ueCAtIHgpO1xuICAgICAgICBhbmdsZVRvID0gTWF0aC5hdGFuMihwb2ludFRUby55IC0geSwgcG9pbnRUVG8ueCAtIHgpO1xuICAgICAgfSAvLyBkcmF3IGEgY2lyY2xlXG5cblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGFuZ2xlRnJvbSwgYW5nbGVUbywgZmFsc2UpO1xuICAgICAgY3R4LnN0cm9rZSgpOyAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuXG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0RG9jXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ5MjExL3Nob3J0ZXN0LWRpc3RhbmNhZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWEtbGluZS1zZWdtZW50XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGE3ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YSh1bmRlZmluZWQpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGE4ID0gc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YTcsIDMpLFxuICAgICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhOFswXSxcbiAgICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YThbMV0sXG4gICAgICAgICAgICByYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YThbMl07XG5cbiAgICAgICAgdmFyIGR4ID0geCAtIHgzO1xuICAgICAgICB2YXIgZHkgPSB5IC0geTM7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC0gcmFkaXVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCAoeDMsIHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbSAoeDEsIHkxKSB0byAoeDIsIHkyKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geDEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB4MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geDMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsaW5lIHNlZ21lbnQgYW5kIHRoZSBwb2ludC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9MaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvTGluZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgcHggPSB4MiAtIHgxO1xuICAgICAgdmFyIHB5ID0geTIgLSB5MTtcbiAgICAgIHZhciBzb21ldGhpbmcgPSBweCAqIHB4ICsgcHkgKiBweTtcbiAgICAgIHZhciB1ID0gKCh4MyAtIHgxKSAqIHB4ICsgKHkzIC0geTEpICogcHkpIC8gc29tZXRoaW5nO1xuXG4gICAgICBpZiAodSA+IDEpIHtcbiAgICAgICAgdSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHUgPCAwKSB7XG4gICAgICAgIHUgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IHgxICsgdSAqIHB4O1xuICAgICAgdmFyIHkgPSB5MSArIHUgKiBweTtcbiAgICAgIHZhciBkeCA9IHggLSB4MztcbiAgICAgIHZhciBkeSA9IHkgLSB5MzsgLy8jIE5vdGU6IElmIHRoZSBhY3R1YWwgZGlzdGFuY2UgZG9lcyBub3QgbWF0dGVyLFxuICAgICAgLy8jIGlmIHlvdSBvbmx5IHdhbnQgdG8gY29tcGFyZSB3aGF0IHRoaXMgZnVuY3Rpb25cbiAgICAgIC8vIyByZXR1cm5zIHRvIG90aGVyIHJlc3VsdHMgb2YgdGhpcyBmdW5jdGlvbiwgeW91XG4gICAgICAvLyMgY2FuIGp1c3QgcmV0dXJuIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGluc3RlYWRcbiAgICAgIC8vIyAoaS5lLiByZW1vdmUgdGhlIHNxcnQpIHRvIGdhaW4gYSBsaXR0bGUgcGVyZm9ybWFuY2VcblxuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXJyb3dEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFycm93RGF0YShjdHgsIHBvc2l0aW9uLCB2aWFOb2RlLCBfc2VsZWN0ZWQsIF9ob3ZlciwgdmFsdWVzKSB7XG4gICAgICAvLyBzZXQgbGV0c1xuICAgICAgdmFyIGFuZ2xlO1xuICAgICAgdmFyIGFycm93UG9pbnQ7XG4gICAgICB2YXIgbm9kZTE7XG4gICAgICB2YXIgbm9kZTI7XG4gICAgICB2YXIgcmV2ZXJzZWQ7XG4gICAgICB2YXIgc2NhbGVGYWN0b3I7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIHZhciBsaW5lV2lkdGggPSB2YWx1ZXMud2lkdGg7XG5cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJmcm9tXCIpIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgIG5vZGUyID0gdGhpcy50bztcbiAgICAgICAgcmV2ZXJzZWQgPSB2YWx1ZXMuZnJvbUFycm93U2NhbGUgPCAwO1xuICAgICAgICBzY2FsZUZhY3RvciA9IE1hdGguYWJzKHZhbHVlcy5mcm9tQXJyb3dTY2FsZSk7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMuZnJvbUFycm93VHlwZTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwidG9cIikge1xuICAgICAgICBub2RlMSA9IHRoaXMudG87XG4gICAgICAgIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgICByZXZlcnNlZCA9IHZhbHVlcy50b0Fycm93U2NhbGUgPCAwO1xuICAgICAgICBzY2FsZUZhY3RvciA9IE1hdGguYWJzKHZhbHVlcy50b0Fycm93U2NhbGUpO1xuICAgICAgICB0eXBlID0gdmFsdWVzLnRvQXJyb3dUeXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgICBub2RlMiA9IHRoaXMuZnJvbTtcbiAgICAgICAgcmV2ZXJzZWQgPSB2YWx1ZXMubWlkZGxlQXJyb3dTY2FsZSA8IDA7XG4gICAgICAgIHNjYWxlRmFjdG9yID0gTWF0aC5hYnModmFsdWVzLm1pZGRsZUFycm93U2NhbGUpO1xuICAgICAgICB0eXBlID0gdmFsdWVzLm1pZGRsZUFycm93VHlwZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IDE1ICogc2NhbGVGYWN0b3IgKyAzICogbGluZVdpZHRoOyAvLyAzKiBsaW5lV2lkdGggaXMgdGhlIHdpZHRoIG9mIHRoZSBlZGdlLlxuICAgICAgLy8gaWYgbm90IGNvbm5lY3RlZCB0byBpdHNlbGZcblxuICAgICAgaWYgKG5vZGUxICE9IG5vZGUyKSB7XG4gICAgICAgIHZhciBhcHByb3hpbWF0ZUVkZ2VMZW5ndGggPSBoeXBvdCQyKG5vZGUxLnggLSBub2RlMi54LCBub2RlMS55IC0gbm9kZTIueSk7XG5cbiAgICAgICAgdmFyIHJlbGF0aXZlTGVuZ3RoID0gbGVuZ3RoIC8gYXBwcm94aW1hdGVFZGdlTGVuZ3RoO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gXCJtaWRkbGVcIikge1xuICAgICAgICAgIC8vIGRyYXcgYXJyb3cgaGVhZFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBwb2ludFQgPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24obm9kZTEsIGN0eCwge1xuICAgICAgICAgICAgICB2aWE6IHZpYU5vZGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgZ3VpZGVQb3MgPSB0aGlzLmdldFBvaW50KHBvaW50VC50ICsgcmVsYXRpdmVMZW5ndGggKiAocG9zaXRpb24gPT09IFwiZnJvbVwiID8gMSA6IC0xKSwgdmlhTm9kZSk7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIocG9pbnRULnkgLSBndWlkZVBvcy55LCBwb2ludFQueCAtIGd1aWRlUG9zLngpO1xuICAgICAgICAgICAgYXJyb3dQb2ludCA9IHBvaW50VDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOZWdhdGl2ZSBoYWxmIGxlbmd0aCByZXZlcnNlcyBhcnJvdyBkaXJlY3Rpb24uXG4gICAgICAgICAgdmFyIGhhbGZMZW5ndGggPSAocmV2ZXJzZWQgPyAtcmVsYXRpdmVMZW5ndGggOiByZWxhdGl2ZUxlbmd0aCkgLyAyO1xuICAgICAgICAgIHZhciBndWlkZVBvczEgPSB0aGlzLmdldFBvaW50KDAuNSArIGhhbGZMZW5ndGgsIHZpYU5vZGUpO1xuICAgICAgICAgIHZhciBndWlkZVBvczIgPSB0aGlzLmdldFBvaW50KDAuNSAtIGhhbGZMZW5ndGgsIHZpYU5vZGUpO1xuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihndWlkZVBvczEueSAtIGd1aWRlUG9zMi55LCBndWlkZVBvczEueCAtIGd1aWRlUG9zMi54KTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5nZXRQb2ludCgwLjUsIHZpYU5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcmF3IGNpcmNsZVxuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGE5ID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YShjdHgpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGExMCA9IHNsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGE5LCAzKSxcbiAgICAgICAgICAgIHggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTEwWzBdLFxuICAgICAgICAgICAgeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMTBbMV0sXG4gICAgICAgICAgICByYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTEwWzJdO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJmcm9tXCIpIHtcbiAgICAgICAgICB2YXIgbG93ID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGU7XG4gICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSArIE1hdGguUEk7XG5cbiAgICAgICAgICB2YXIgX3BvaW50VCA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IGxvdyxcbiAgICAgICAgICAgIGhpZ2g6IGhpZ2gsXG4gICAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBhbmdsZSA9IF9wb2ludFQudCAqIC0yICogTWF0aC5QSSArIDEuNSAqIE1hdGguUEkgKyAwLjEgKiBNYXRoLlBJO1xuICAgICAgICAgIGFycm93UG9pbnQgPSBfcG9pbnRUO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcInRvXCIpIHtcbiAgICAgICAgICB2YXIgX2xvdyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlO1xuXG4gICAgICAgICAgdmFyIF9oaWdoID0gdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUgKyBNYXRoLlBJO1xuXG4gICAgICAgICAgdmFyIF9wb2ludFQyID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIGxvdzogX2xvdyxcbiAgICAgICAgICAgIGhpZ2g6IF9oaWdoLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAxXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBhbmdsZSA9IF9wb2ludFQyLnQgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJIC0gMS4xICogTWF0aC5QSTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gX3BvaW50VDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gdGhpcy5fcG9pbnRPbkNpcmNsZSh4LCB5LCByYWRpdXMsIHBvcyk7XG4gICAgICAgICAgYW5nbGUgPSBwb3MgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJICsgMC4xICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgeGkgPSBhcnJvd1BvaW50LnggLSBsZW5ndGggKiAwLjkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgeWkgPSBhcnJvd1BvaW50LnkgLSBsZW5ndGggKiAwLjkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB2YXIgYXJyb3dDb3JlID0ge1xuICAgICAgICB4OiB4aSxcbiAgICAgICAgeTogeWlcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogYXJyb3dQb2ludCxcbiAgICAgICAgY29yZTogYXJyb3dDb3JlLFxuICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdBcnJvd0hlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0Fycm93SGVhZChjdHgsIHZhbHVlcywgX3NlbGVjdGVkLCBfaG92ZXIsIGFycm93RGF0YSkge1xuICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldENvbG9yKGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICBjdHgubGluZVdpZHRoID0gdmFsdWVzLndpZHRoO1xuICAgICAgdmFyIGNhbkZpbGwgPSBFbmRQb2ludHMuZHJhdyhjdHgsIGFycm93RGF0YSk7XG5cbiAgICAgIGlmIChjYW5GaWxsKSB7XG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuXG4gICAgICAgIGZpbGwkMihjdHgpLmNhbGwoY3R4KTsgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cblxuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzaGFkb3cgZm9ybWF0dGluZyB2YWx1ZXMgaW4gdGhlIGNvbnRleHQgaWYgZW5hYmxlZCwgZG8gbm90aGluZyBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgZm9yIHRoZSBzaGFkb3cuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVNoYWRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSB0cnVlKSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHZhbHVlcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB2YWx1ZXMuc2hhZG93U2l6ZTtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB2YWx1ZXMuc2hhZG93WDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB2YWx1ZXMuc2hhZG93WTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgc2hhZG93IGZvcm1hdHRpbmcgdmFsdWVzIGluIHRoZSBjb250ZXh0IGlmIGVuYWJsZWQsIGRvIG5vdGhpbmcgb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGZvciB0aGUgc2hhZG93LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSB0cnVlKSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwicmdiYSgwLDAsMCwwKVwiO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlbmRlciB0aGUgYmFja2dyb3VuZCBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdHRpbmcgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGZvciB0aGUgYmFja2dyb3VuZC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0JhY2tncm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0JhY2tncm91bmQoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuYmFja2dyb3VuZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gc2F2ZSBvcmlnaW5hbCBsaW5lIGF0dHJzXG4gICAgICAgIHZhciBvcmlnQ3R4QXR0ciA9IHtcbiAgICAgICAgICBzdHJva2VTdHlsZTogY3R4LnN0cm9rZVN0eWxlLFxuICAgICAgICAgIGxpbmVXaWR0aDogY3R4LmxpbmVXaWR0aCxcbiAgICAgICAgICBkYXNoZXM6IGN0eC5kYXNoZXNcbiAgICAgICAgfTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlcy5iYWNrZ3JvdW5kU2l6ZTtcbiAgICAgICAgdGhpcy5zZXRTdHJva2VEYXNoZWQoY3R4LCB2YWx1ZXMuYmFja2dyb3VuZERhc2hlcyk7XG4gICAgICAgIGN0eC5zdHJva2UoKTsgLy8gcmVzdG9yZSBvcmlnaW5hbCBsaW5lIGF0dHJzXG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3JpZ0N0eEF0dHIuc3Ryb2tlU3R5bGU7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcmlnQ3R4QXR0ci5saW5lV2lkdGg7XG4gICAgICAgIGN0eC5kYXNoZXMgPSBvcmlnQ3R4QXR0ci5kYXNoZXM7XG4gICAgICAgIHRoaXMuc2V0U3Ryb2tlRGFzaGVkKGN0eCwgdmFsdWVzLmRhc2hlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBsaW5lIGRhc2ggcGF0dGVybiBpZiBzdXBwb3J0ZWQuIExvZ3MgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlIGlmIGl0IGlzbid0IHN1cHBvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSBkYXNoZXMgLSBUaGUgcGF0dGVybiBbbGluZSwgc3BhY2UsIGxpbmXigKZdLCB0cnVlIGZvciBkZWZhdWx0IGRhc2hlZCBsaW5lIG9yIGZhbHNlIGZvciBub3JtYWwgbGluZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U3Ryb2tlRGFzaGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0cm9rZURhc2hlZChjdHgsIGRhc2hlcykge1xuICAgICAgaWYgKGRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBpc0FycmF5JDUoZGFzaGVzKSA/IGRhc2hlcyA6IFs1LCA1XTtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2gocGF0dGVybik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0TGluZURhc2ggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFRoZSBkYXNoZWQgc3Ryb2tlIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBzdHJva2UgY2Fubm90IGJlIHVzZWQuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVkZ2VCYXNlO1xufSgpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDUob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IGtleXMkMyhvYmplY3QpOyBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzJDIpIHsgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMihvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBmaWx0ZXIkMihzeW1ib2xzKS5jYWxsKHN5bWJvbHMsIGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQzKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyB2YXIgX2NvbnRleHQ7IGZvckVhY2gkMihfY29udGV4dCA9IG93bktleXMkNShPYmplY3Qoc291cmNlKSwgdHJ1ZSkpLmNhbGwoX2NvbnRleHQsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkNyh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDIpIHsgZGVmaW5lUHJvcGVydGllcyQxKHRhcmdldCwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyQyKHNvdXJjZSkpOyB9IGVsc2UgeyB2YXIgX2NvbnRleHQyOyBmb3JFYWNoJDIoX2NvbnRleHQyID0gb3duS2V5cyQ1KE9iamVjdChzb3VyY2UpKSkuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkkMih0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMoc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRqKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGooKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRqKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcclxuICogVGhlIEJhc2UgQ2xhc3MgZm9yIGFsbCBCZXppZXIgZWRnZXMuXHJcbiAqIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWwgY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuXHJcbiAqL1xuXG52YXIgQmV6aWVyRWRnZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FZGdlQmFzZSkge1xuICBpbmhlcml0cyhCZXppZXJFZGdlQmFzZSwgX0VkZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGooQmV6aWVyRWRnZUJhc2UpO1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEJlemllckVkZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZUJhc2UpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcclxuICAgKiBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgKlxyXG4gICAqIEByZW1hcmtzXHJcbiAgICogVGhpcyBmdW5jdGlvbiB1c2VzIGJpbmFyeSBzZWFyY2ggdG8gbG9vayBmb3IgdGhlIHBvaW50IHdoZXJlIHRoZSBiZXppZXIgY3VydmUgY3Jvc3NlcyB0aGUgYm9yZGVyIG9mIHRoZSBub2RlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5lYXJOb2RlIC0gVGhlIG5vZGUgKGVpdGhlciBmcm9tIG9yIHRvIG5vZGUgb2YgdGhlIGVkZ2UpLlxyXG4gICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAqIEBwYXJhbSB2aWFOb2RlIC0gQWRkaXRpb25hbCBub2RlKHMpIHRoZSBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKEJlemllckVkZ2VCYXNlLCBbe1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCkge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMjtcbiAgICAgIHZhciBmcm9tID0gZmFsc2U7XG4gICAgICB2YXIgaGlnaCA9IDE7XG4gICAgICB2YXIgbG93ID0gMDtcbiAgICAgIHZhciBub2RlID0gdGhpcy50bztcbiAgICAgIHZhciBwb3M7XG4gICAgICB2YXIgbWlkZGxlO1xuICAgICAgdmFyIGVuZFBvaW50T2Zmc2V0ID0gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0ID8gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvIDogMDtcblxuICAgICAgaWYgKG5lYXJOb2RlLmlkID09PSB0aGlzLmZyb20uaWQpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuZnJvbTtcbiAgICAgICAgZnJvbSA9IHRydWU7XG4gICAgICAgIGVuZFBvaW50T2Zmc2V0ID0gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0ID8gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20gOiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFycm93U3RyaWtldGhyb3VnaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZW5kUG9pbnRPZmZzZXQgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0aW9uID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICBtaWRkbGUgPSAobG93ICsgaGlnaCkgKiAwLjU7XG4gICAgICAgIHBvcyA9IHRoaXMuZ2V0UG9pbnQobWlkZGxlLCB2aWFOb2RlKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihub2RlLnkgLSBwb3MueSwgbm9kZS54IC0gcG9zLngpO1xuICAgICAgICB2YXIgZGlzdGFuY2VUb0JvcmRlciA9IG5vZGUuZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSArIGVuZFBvaW50T2Zmc2V0O1xuICAgICAgICB2YXIgZGlzdGFuY2VUb1BvaW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvcy54IC0gbm9kZS54LCAyKSArIE1hdGgucG93KHBvcy55IC0gbm9kZS55LCAyKSk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gZGlzdGFuY2VUb0JvcmRlciAtIGRpc3RhbmNlVG9Qb2ludDtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICBicmVhazsgLy8gZm91bmRcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIG5vZGVzIGlzIGxhcmdlciB0aGFuIGRpc3RhbmNlIHRvIGJvcmRlciAtLT4gdCBuZWVkcyB0byBiZSBiaWdnZXIgaWYgd2UncmUgbG9va2luZyBhdCB0aGUgdG8gbm9kZS5cbiAgICAgICAgICBpZiAoZnJvbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZyb20gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3cgPSBtaWRkbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgKytpdGVyYXRpb247XG4gICAgICB9IHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKTtcblxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIHBvcyksIHt9LCB7XG4gICAgICAgIHQ6IG1pZGRsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbSAoeDEseTEpIHRvICh4Mix5MikuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ5MjExL3Nob3J0ZXN0LWRpc3RhbmNhZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWEtbGluZS1zZWdtZW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHgxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MSAtIEZpcnN0IGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geDIgLSBTZWNvbmQgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHgzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geTMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB2aWEgLSBUaGUgY29udHJvbCBwb2ludCBmb3IgdGhlIGVkZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxpbmUgc2VnbWVudCBhbmQgdGhlIHBvaW50LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYSkge1xuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICB2YXIgbWluRGlzdGFuY2UgPSAxZTk7XG4gICAgICB2YXIgZGlzdGFuY2U7XG4gICAgICB2YXIgaSwgdCwgeCwgeTtcbiAgICAgIHZhciBsYXN0WCA9IHgxO1xuICAgICAgdmFyIGxhc3RZID0geTE7XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHQgPSAwLjEgKiBpO1xuICAgICAgICB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogeDEgKyAyICogdCAqICgxIC0gdCkgKiB2aWEueCArIE1hdGgucG93KHQsIDIpICogeDI7XG4gICAgICAgIHkgPSBNYXRoLnBvdygxIC0gdCwgMikgKiB5MSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYS55ICsgTWF0aC5wb3codCwgMikgKiB5MjtcblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGxhc3RYLCBsYXN0WSwgeCwgeSwgeDMsIHkzKTtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgPyBkaXN0YW5jZSA6IG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICBsYXN0WSA9IHk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaW5EaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgYSBiZXppZXIgY3VydmUgYmV0d2VlbiB0d28gbm9kZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoZSBtZXRob2QgYWNjZXB0cyB6ZXJvLCBvbmUgb3IgdHdvIGNvbnRyb2wgcG9pbnRzLlxyXG4gICAgICogUGFzc2luZyB6ZXJvIGNvbnRyb2wgcG9pbnRzIGp1c3QgZHJhd3MgYSBzdHJhaWdodCBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFN0eWxlIG9wdGlvbnMgZm9yIGVkZ2UgZHJhd2luZy5cclxuICAgICAqIEBwYXJhbSB2aWFOb2RlMSAtIEZpcnN0IGNvbnRyb2wgcG9pbnQgZm9yIGN1cnZlIGRyYXdpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmlhTm9kZTIgLSBTZWNvbmQgY29udHJvbCBwb2ludCBmb3IgY3VydmUgZHJhd2luZy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JlemllckN1cnZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZTEsIHZpYU5vZGUyKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsIHRoaXMuZnJvbVBvaW50LnkpO1xuXG4gICAgICBpZiAodmlhTm9kZTEgIT0gbnVsbCAmJiB2aWFOb2RlMS54ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHZpYU5vZGUyICE9IG51bGwgJiYgdmlhTm9kZTIueCAhPSBudWxsKSB7XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8odmlhTm9kZTEueCwgdmlhTm9kZTEueSwgdmlhTm9kZTIueCwgdmlhTm9kZTIueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh2aWFOb2RlMS54LCB2aWFOb2RlMS55LCB0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmYWxsYmFjayB0byBub3JtYWwgc3RyYWlnaHQgZWRnZVxuICAgICAgICBjdHgubGluZVRvKHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICB9IC8vIGRyYXcgYSBiYWNrZ3JvdW5kXG5cblxuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChjdHgsIHZhbHVlcyk7IC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcblxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmV6aWVyRWRnZUJhc2U7XG59KEVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGsoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mJDUoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mJDUodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdCQzKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGsoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0JDMpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdCQzLnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25zdHJ1Y3QkMyhEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIER5bmFtaWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWxcclxuICogY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuIFRoZSBEeW5hbWljIHBpZWNlIHJlZmVycyB0byBob3cgdGhlIGN1cnZlXHJcbiAqIHJlYWN0cyB0byBwaHlzaWNzIGNoYW5nZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBCZXppZXJFZGdlQmFzZVxyXG4gKi9cblxudmFyIEJlemllckVkZ2VEeW5hbWljID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgaW5oZXJpdHMoQmV6aWVyRWRnZUR5bmFtaWMsIF9CZXppZXJFZGdlQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRrKEJlemllckVkZ2VEeW5hbWljKTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBCZXppZXJFZGdlRHluYW1pYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJlemllckVkZ2VEeW5hbWljKTtcblxuICAgIC8vdGhpcy52aWEgPSB1bmRlZmluZWQ7IC8vIEhlcmUgZm9yIGNvbXBsZXRlbmVzcyBidXQgbm90IGFsbG93ZWQgdG8gZGVmaW5lZCBiZWZvcmUgc3VwZXIoKSBpcyBpbnZva2VkLlxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpOyAvLyAtLT4gdGhpcyBjYWxscyB0aGUgc2V0T3B0aW9ucyBiZWxvd1xuXG4gICAgX3RoaXMudmlhID0gX3RoaXMudmlhOyAvLyBjb25zdHJ1Y3RvciDihpIgc3VwZXIg4oaSIHN1cGVyIOKGkiBzZXRPcHRpb25zIOKGkiBzZXR1cFN1cHBvcnROb2RlXG5cbiAgICBfdGhpcy5fYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgIH07XG5cbiAgICBfdGhpcy5fYm9keS5lbWl0dGVyLm9uKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLCBfdGhpcy5fYm91bmRGdW5jdGlvbik7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBjcmVhdGVDbGFzcyhCZXppZXJFZGdlRHluYW1pYywgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGdldCQ1KGdldFByb3RvdHlwZU9mJDUoQmV6aWVyRWRnZUR5bmFtaWMucHJvdG90eXBlKSwgXCJzZXRPcHRpb25zXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0aW9ucyk7IC8vIGNoZWNrIGlmIHRoZSBwaHlzaWNzIGhhcyBjaGFuZ2VkLlxuXG5cbiAgICAgIHZhciBwaHlzaWNzQ2hhbmdlID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGh5c2ljcyAhPT0gb3B0aW9ucy5waHlzaWNzKSB7XG4gICAgICAgIHBoeXNpY3NDaGFuZ2UgPSB0cnVlO1xuICAgICAgfSAvLyBzZXQgdGhlIG9wdGlvbnMgYW5kIHRoZSB0byBhbmQgZnJvbSBub2Rlc1xuXG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dOyAvLyBzZXR1cCB0aGUgc3VwcG9ydCBub2RlIGFuZCBjb25uZWN0XG5cbiAgICAgIHRoaXMuc2V0dXBTdXBwb3J0Tm9kZSgpO1xuICAgICAgdGhpcy5jb25uZWN0KCk7IC8vIHdoZW4gd2UgY2hhbmdlIHRoZSBwaHlzaWNzIHN0YXRlIG9mIHRoZSBlZGdlLCB3ZSByZXBvc2l0aW9uIHRoZSBzdXBwb3J0IG5vZGUuXG5cbiAgICAgIGlmIChwaHlzaWNzQ2hhbmdlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoe1xuICAgICAgICAgIHBoeXNpY3M6IHRoaXMub3B0aW9ucy5waHlzaWNzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQmV6aWVyTm9kZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLmZyb21dO1xuICAgICAgdGhpcy50byA9IHRoaXMuX2JvZHkubm9kZXNbdGhpcy5vcHRpb25zLnRvXTtcblxuICAgICAgaWYgKHRoaXMuZnJvbSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudG8gPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMucGh5c2ljcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaXggd2VpcmQgYmVoYXZpb3VyIHdoZXJlIGEgc2VsZiByZWZlcmVuY2luZyBub2RlIGhhcyBwaHlzaWNzIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5pZCA9PT0gdGhpcy50by5pZCkge1xuICAgICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHBoeXNpY3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHRoaXMuX2JvZHkuZW1pdHRlci5vZmYoXCJfcmVwb3NpdGlvbkJlemllck5vZGVzXCIsIHRoaXMuX2JvdW5kRnVuY3Rpb24pO1xuXG4gICAgICBpZiAodGhpcy52aWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fYm9keS5ub2Rlc1t0aGlzLnZpYS5pZF07XG4gICAgICAgIHRoaXMudmlhID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbmQgYWRkIGEgc3VwcG9ydCBub2RlIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIEJlemllciBjdXJ2ZXMgcmVxdWlyZSBhbiBhbmNob3IgcG9pbnQgdG8gY2FsY3VsYXRlIHRoZSBzbW9vdGggZmxvdy5cclxuICAgICAqIFRoZXNlIHBvaW50cyBhcmUgbm9kZXMuXHJcbiAgICAgKiBUaGVzZSBub2RlcyBhcmUgaW52aXNpYmxlIGJ1dCBhcmUgdXNlZCBmb3IgdGhlIGZvcmNlIGNhbGN1bGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBjaGFuZ2VkIGRhdGEgaXMgbm90IGNhbGxlZCwgaWYgbmVlZGVkLCBpdCBpcyByZXR1cm5lZCBieSB0aGUgbWFpbiBlZGdlIGNvbnN0cnVjdG9yLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cFN1cHBvcnROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwU3VwcG9ydE5vZGUoKSB7XG4gICAgICBpZiAodGhpcy52aWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZUlkID0gXCJlZGdlSWQ6XCIgKyB0aGlzLmlkO1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZSh7XG4gICAgICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgICAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICAgICAgICBwaHlzaWNzOiB0cnVlLFxuICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9ib2R5Lm5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgICB0aGlzLnZpYSA9IG5vZGU7XG4gICAgICAgIHRoaXMudmlhLnBhcmVudEVkZ2VJZCA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gYmV6aWVyIG5vZGUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBvc2l0aW9uQmV6aWVyTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbkJlemllck5vZGUoKSB7XG4gICAgICBpZiAodGhpcy52aWEgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZyb20gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52aWEueCA9IDAuNSAqICh0aGlzLmZyb20ueCArIHRoaXMudG8ueCk7XG4gICAgICAgIHRoaXMudmlhLnkgPSAwLjUgKiAodGhpcy5mcm9tLnkgKyB0aGlzLnRvLnkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudmlhLnggPSAwO1xuICAgICAgICB0aGlzLnZpYS55ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSkge1xuICAgICAgdGhpcy5fYmV6aWVyQ3VydmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaWFDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWE7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlhTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlhO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBvc2l0aW9uKSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52aWE7XG5cbiAgICAgIGlmICh0aGlzLmZyb20gPT09IHRoaXMudG8pIHtcbiAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YSgpLFxuICAgICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGEyID0gc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YSwgMyksXG4gICAgICAgICAgICBjeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlswXSxcbiAgICAgICAgICAgIGN5ID0gX3RoaXMkX2dldENpcmNsZURhdGEyWzFdLFxuICAgICAgICAgICAgY3IgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTJbMl07XG5cbiAgICAgICAgdmFyIGEgPSAyICogTWF0aC5QSSAqICgxIC0gcG9zaXRpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGN4ICsgY3IgKiBNYXRoLnNpbihhKSxcbiAgICAgICAgICB5OiBjeSArIGNyIC0gY3IgKiAoMSAtIE1hdGguY29zKGEpKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLnBvdygxIC0gcG9zaXRpb24sIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiBwb3NpdGlvbiAqICgxIC0gcG9zaXRpb24pICogdmlhTm9kZS54ICsgTWF0aC5wb3cocG9zaXRpb24sIDIpICogdGhpcy50b1BvaW50LngsXG4gICAgICAgICAgeTogTWF0aC5wb3coMSAtIHBvc2l0aW9uLCAyKSAqIHRoaXMuZnJvbVBvaW50LnkgKyAyICogcG9zaXRpb24gKiAoMSAtIHBvc2l0aW9uKSAqIHZpYU5vZGUueSArIE1hdGgucG93KHBvc2l0aW9uLCAyKSAqIHRoaXMudG9Qb2ludC55XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCwgdGhpcy52aWEpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdGhpcy52aWEpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCZXppZXJFZGdlRHluYW1pYztcbn0oQmV6aWVyRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2YkNShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2YkNSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0JDMoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QkMykgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0JDMuc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbnN0cnVjdCQzKERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgU3RhdGljIEJlemllciBFZGdlLiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxyXG4gKi9cblxudmFyIEJlemllckVkZ2VTdGF0aWMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICBpbmhlcml0cyhCZXppZXJFZGdlU3RhdGljLCBfQmV6aWVyRWRnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkbChCZXppZXJFZGdlU3RhdGljKTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBCZXppZXJFZGdlU3RhdGljKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZVN0YXRpYyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoQmV6aWVyRWRnZVN0YXRpYywgW3tcbiAgICBrZXk6IFwiX2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpIHtcbiAgICAgIHRoaXMuX2JlemllckN1cnZlKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdmlhIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFdlIGRvIG5vdCB1c2UgdGhlIHRvIGFuZCBmcm9tUG9pbnRzIGhlcmUgdG8gbWFrZSB0aGUgdmlhIG5vZGVzIHRoZSBzYW1lIGFzIGVkZ2VzIHdpdGhvdXQgYXJyb3dzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgdmlhIG5vZGUuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaWFDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICAvLyBBc3N1bXB0aW9uOiB4L3kgY29vcmRpbmF0ZXMgaW4gZnJvbS90byBhbHdheXMgZGVmaW5lZFxuICAgICAgdmFyIGZhY3RvciA9IHRoaXMub3B0aW9ucy5zbW9vdGgucm91bmRuZXNzO1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnR5cGU7XG4gICAgICB2YXIgZHggPSBNYXRoLmFicyh0aGlzLmZyb20ueCAtIHRoaXMudG8ueCk7XG4gICAgICB2YXIgZHkgPSBNYXRoLmFicyh0aGlzLmZyb20ueSAtIHRoaXMudG8ueSk7XG5cbiAgICAgIGlmICh0eXBlID09PSBcImRpc2NyZXRlXCIgfHwgdHlwZSA9PT0gXCJkaWFnb25hbENyb3NzXCIpIHtcbiAgICAgICAgdmFyIHN0ZXBYO1xuICAgICAgICB2YXIgc3RlcFk7XG5cbiAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgc3RlcFggPSBzdGVwWSA9IGZhY3RvciAqIGR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ZXBYID0gc3RlcFkgPSBmYWN0b3IgKiBkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgIHN0ZXBYID0gLXN0ZXBYO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkge1xuICAgICAgICAgIHN0ZXBZID0gLXN0ZXBZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhWaWEgPSB0aGlzLmZyb20ueCArIHN0ZXBYO1xuICAgICAgICB2YXIgeVZpYSA9IHRoaXMuZnJvbS55ICsgc3RlcFk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZGlzY3JldGVcIikge1xuICAgICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgICAgeFZpYSA9IGR4IDwgZmFjdG9yICogZHkgPyB0aGlzLmZyb20ueCA6IHhWaWE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlWaWEgPSBkeSA8IGZhY3RvciAqIGR4ID8gdGhpcy5mcm9tLnkgOiB5VmlhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeFZpYSxcbiAgICAgICAgICB5OiB5VmlhXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic3RyYWlnaHRDcm9zc1wiKSB7XG4gICAgICAgIHZhciBfc3RlcFggPSAoMSAtIGZhY3RvcikgKiBkeDtcblxuICAgICAgICB2YXIgX3N0ZXBZID0gKDEgLSBmYWN0b3IpICogZHk7XG5cbiAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgLy8gdXAgLSBkb3duXG4gICAgICAgICAgX3N0ZXBYID0gMDtcblxuICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgICAgX3N0ZXBZID0gLV9zdGVwWTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGVmdCAtIHJpZ2h0XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDwgdGhpcy50by54KSB7XG4gICAgICAgICAgICBfc3RlcFggPSAtX3N0ZXBYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9zdGVwWSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMudG8ueCArIF9zdGVwWCxcbiAgICAgICAgICB5OiB0aGlzLnRvLnkgKyBfc3RlcFlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgdmFyIF9zdGVwWDIgPSAoMSAtIGZhY3RvcikgKiBkeDtcblxuICAgICAgICBpZiAodGhpcy5mcm9tLnggPCB0aGlzLnRvLngpIHtcbiAgICAgICAgICBfc3RlcFgyID0gLV9zdGVwWDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMudG8ueCArIF9zdGVwWDIsXG4gICAgICAgICAgeTogdGhpcy5mcm9tLnlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgIHZhciBfc3RlcFkyID0gKDEgLSBmYWN0b3IpICogZHk7XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSB7XG4gICAgICAgICAgX3N0ZXBZMiA9IC1fc3RlcFkyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLmZyb20ueCxcbiAgICAgICAgICB5OiB0aGlzLnRvLnkgKyBfc3RlcFkyXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY3VydmVkQ1dcIikge1xuICAgICAgICBkeCA9IHRoaXMudG8ueCAtIHRoaXMuZnJvbS54O1xuICAgICAgICBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgdmFyIHBpID0gTWF0aC5QSTtcbiAgICAgICAgdmFyIG9yaWdpbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgICAgIHZhciBteUFuZ2xlID0gKG9yaWdpbmFsQW5nbGUgKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHBpKSAlICgyICogcGkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMuZnJvbS54ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiByYWRpdXMgKiBNYXRoLnNpbihteUFuZ2xlKSxcbiAgICAgICAgICB5OiB0aGlzLmZyb20ueSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcmFkaXVzICogTWF0aC5jb3MobXlBbmdsZSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjdXJ2ZWRDQ1dcIikge1xuICAgICAgICBkeCA9IHRoaXMudG8ueCAtIHRoaXMuZnJvbS54O1xuICAgICAgICBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuXG4gICAgICAgIHZhciBfcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICB2YXIgX3BpID0gTWF0aC5QSTtcblxuICAgICAgICB2YXIgX29yaWdpbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG5cbiAgICAgICAgdmFyIF9teUFuZ2xlID0gKF9vcmlnaW5hbEFuZ2xlICsgKC1mYWN0b3IgKiAwLjUgKyAwLjUpICogX3BpKSAlICgyICogX3BpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMuZnJvbS54ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiBfcmFkaXVzICogTWF0aC5zaW4oX215QW5nbGUpLFxuICAgICAgICAgIHk6IHRoaXMuZnJvbS55ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiBfcmFkaXVzICogTWF0aC5jb3MoX215QW5nbGUpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb250aW51b3VzXG4gICAgICAgIHZhciBfc3RlcFgzO1xuXG4gICAgICAgIHZhciBfc3RlcFkzO1xuXG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIF9zdGVwWDMgPSBfc3RlcFkzID0gZmFjdG9yICogZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3N0ZXBYMyA9IF9zdGVwWTMgPSBmYWN0b3IgKiBkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZyb20ueCA+IHRoaXMudG8ueCkge1xuICAgICAgICAgIF9zdGVwWDMgPSAtX3N0ZXBYMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIHtcbiAgICAgICAgICBfc3RlcFkzID0gLV9zdGVwWTM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3hWaWEgPSB0aGlzLmZyb20ueCArIF9zdGVwWDM7XG5cbiAgICAgICAgdmFyIF95VmlhID0gdGhpcy5mcm9tLnkgKyBfc3RlcFkzO1xuXG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueCA8PSB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgIF94VmlhID0gdGhpcy50by54IDwgX3hWaWEgPyB0aGlzLnRvLnggOiBfeFZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3hWaWEgPSB0aGlzLnRvLnggPiBfeFZpYSA/IHRoaXMudG8ueCA6IF94VmlhO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgICBfeVZpYSA9IHRoaXMudG8ueSA+IF95VmlhID8gdGhpcy50by55IDogX3lWaWE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF95VmlhID0gdGhpcy50by55IDwgX3lWaWEgPyB0aGlzLnRvLnkgOiBfeVZpYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IF94VmlhLFxuICAgICAgICAgIHk6IF95VmlhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCwgb3B0aW9ucy52aWEpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWFOb2RlKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwb3NpdGlvbikge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgdCA9IHBvc2l0aW9uO1xuICAgICAgdmFyIHggPSBNYXRoLnBvdygxIC0gdCwgMikgKiB0aGlzLmZyb21Qb2ludC54ICsgMiAqIHQgKiAoMSAtIHQpICogdmlhTm9kZS54ICsgTWF0aC5wb3codCwgMikgKiB0aGlzLnRvUG9pbnQueDtcbiAgICAgIHZhciB5ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueSArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lnk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCZXppZXJFZGdlU3RhdGljO1xufShCZXppZXJFZGdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRtKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG0oKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRtKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcclxuICogQSBCYXNlIENsYXNzIGZvciBhbGwgQ3ViaWMgQmV6aWVyIEVkZ2VzLiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsXHJcbiAqIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgQmV6aWVyRWRnZUJhc2VcclxuICovXG5cbnZhciBDdWJpY0JlemllckVkZ2VCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgaW5oZXJpdHMoQ3ViaWNCZXppZXJFZGdlQmFzZSwgX0JlemllckVkZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJG0oQ3ViaWNCZXppZXJFZGdlQmFzZSk7XG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQ3ViaWNCZXppZXJFZGdlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEN1YmljQmV6aWVyRWRnZUJhc2UpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCAoeDMseTMpIGFuZCBhIGxpbmUgc2VnbWVudCBmcm9tICh4MSx5MSkgdG8gKHgyLHkyKS5cclxuICAgKlxyXG4gICAqIEByZW1hcmtzXHJcbiAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2FlLWJldHdlZW4tYS1wb2ludC1hbmQtYS1saW5lLXNlZ21lbnRcclxuICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHgxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHggYXhpcy5cclxuICAgKiBAcGFyYW0geTEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAqIEBwYXJhbSB4MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB5MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAqIEBwYXJhbSB4MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB5MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzLlxyXG4gICAqIEBwYXJhbSB2aWExIC0gVGhlIGZpcnN0IHBvaW50IHRoaXMgZWRnZSBwYXNzZXMgdGhyb3VnaC5cclxuICAgKiBAcGFyYW0gdmlhMiAtIFRoZSBzZWNvbmQgcG9pbnQgdGhpcyBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxpbmUgc2VnbWVudCBhbmQgdGhlIHBvaW50LlxyXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoQ3ViaWNCZXppZXJFZGdlQmFzZSwgW3tcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9CZXppZXJFZGdlMlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UyKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYTEsIHZpYTIpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgdmFyIG1pbkRpc3RhbmNlID0gMWU5O1xuICAgICAgdmFyIGxhc3RYID0geDE7XG4gICAgICB2YXIgbGFzdFkgPSB5MTtcbiAgICAgIHZhciB2ZWMgPSBbMCwgMCwgMCwgMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgICAgICB2YXIgdCA9IDAuMSAqIGk7XG4gICAgICAgIHZlY1swXSA9IE1hdGgucG93KDEgLSB0LCAzKTtcbiAgICAgICAgdmVjWzFdID0gMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMik7XG4gICAgICAgIHZlY1syXSA9IDMgKiBNYXRoLnBvdyh0LCAyKSAqICgxIC0gdCk7XG4gICAgICAgIHZlY1szXSA9IE1hdGgucG93KHQsIDMpO1xuICAgICAgICB2YXIgeCA9IHZlY1swXSAqIHgxICsgdmVjWzFdICogdmlhMS54ICsgdmVjWzJdICogdmlhMi54ICsgdmVjWzNdICogeDI7XG4gICAgICAgIHZhciB5ID0gdmVjWzBdICogeTEgKyB2ZWNbMV0gKiB2aWExLnkgKyB2ZWNbMl0gKiB2aWEyLnkgKyB2ZWNbM10gKiB5MjtcblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLl9nZXREaXN0YW5jZVRvTGluZShsYXN0WCwgbGFzdFksIHgsIHksIHgzLCB5Myk7XG5cbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgPyBkaXN0YW5jZSA6IG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICBsYXN0WSA9IHk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaW5EaXN0YW5jZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3ViaWNCZXppZXJFZGdlQmFzZTtcbn0oQmV6aWVyRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRuKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2YkNShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2YkNSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0JDMoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QkMykgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0JDMuc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbnN0cnVjdCQzKERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgQ3ViaWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWwgY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuXHJcbiAqL1xuXG52YXIgQ3ViaWNCZXppZXJFZGdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ3ViaWNCZXppZXJFZGdlQmFzZSkge1xuICBpbmhlcml0cyhDdWJpY0JlemllckVkZ2UsIF9DdWJpY0JlemllckVkZ2VCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJG4oQ3ViaWNCZXppZXJFZGdlKTtcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBDdWJpY0JlemllckVkZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDdWJpY0JlemllckVkZ2UpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKEN1YmljQmV6aWVyRWRnZSwgW3tcbiAgICBrZXk6IFwiX2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGVzKSB7XG4gICAgICAvLyBnZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBzdXBwb3J0IHBvaW50cy5cbiAgICAgIHZhciB2aWExID0gdmlhTm9kZXNbMF07XG4gICAgICB2YXIgdmlhMiA9IHZpYU5vZGVzWzFdO1xuXG4gICAgICB0aGlzLl9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhMSwgdmlhMik7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgYWRkaXRpb25hbCBwb2ludHMgdGhlIGVkZ2UgcGFzc2VzIHRocm91Z2guXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludHMgdGhlIGVkZ2UgcGFzc2VzIHRocm91Z2guXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaWFDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICB2YXIgZHggPSB0aGlzLmZyb20ueCAtIHRoaXMudG8ueDtcbiAgICAgIHZhciBkeSA9IHRoaXMuZnJvbS55IC0gdGhpcy50by55O1xuICAgICAgdmFyIHgxO1xuICAgICAgdmFyIHkxO1xuICAgICAgdmFyIHgyO1xuICAgICAgdmFyIHkyO1xuICAgICAgdmFyIHJvdW5kbmVzcyA9IHRoaXMub3B0aW9ucy5zbW9vdGgucm91bmRuZXNzOyAvLyBob3Jpem9udGFsIGlmIHggPiB5IG9yIGlmIGRpcmVjdGlvbiBpcyBmb3JjZWQgb3IgaWYgZGlyZWN0aW9uIGlzIGhvcml6b250YWxcblxuICAgICAgaWYgKChNYXRoLmFicyhkeCkgPiBNYXRoLmFicyhkeSkgfHwgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuc21vb3RoLmZvcmNlRGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIikgJiYgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiAhPT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgIHkxID0gdGhpcy5mcm9tLnk7XG4gICAgICAgIHkyID0gdGhpcy50by55O1xuICAgICAgICB4MSA9IHRoaXMuZnJvbS54IC0gcm91bmRuZXNzICogZHg7XG4gICAgICAgIHgyID0gdGhpcy50by54ICsgcm91bmRuZXNzICogZHg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHRoaXMuZnJvbS55IC0gcm91bmRuZXNzICogZHk7XG4gICAgICAgIHkyID0gdGhpcy50by55ICsgcm91bmRuZXNzICogZHk7XG4gICAgICAgIHgxID0gdGhpcy5mcm9tLng7XG4gICAgICAgIHgyID0gdGhpcy50by54O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgeDogeDEsXG4gICAgICAgIHk6IHkxXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHgyLFxuICAgICAgICB5OiB5MlxuICAgICAgfV07XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlhTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEJvcmRlclBvc2l0aW9uKG5lYXJOb2RlLCBjdHgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSxcbiAgICAgICAgICBfcmVmMiA9IHNsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgdmlhMSA9IF9yZWYyWzBdLFxuICAgICAgICAgIHZpYTIgPSBfcmVmMlsxXTtcblxuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UyKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYTEsIHZpYTIpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBvc2l0aW9uKSB7XG4gICAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCksXG4gICAgICAgICAgX3JlZjQgPSBzbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICB2aWExID0gX3JlZjRbMF0sXG4gICAgICAgICAgdmlhMiA9IF9yZWY0WzFdO1xuXG4gICAgICB2YXIgdCA9IHBvc2l0aW9uO1xuICAgICAgdmFyIHZlYyA9IFtNYXRoLnBvdygxIC0gdCwgMyksIDMgKiB0ICogTWF0aC5wb3coMSAtIHQsIDIpLCAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpLCBNYXRoLnBvdyh0LCAzKV07XG4gICAgICB2YXIgeCA9IHZlY1swXSAqIHRoaXMuZnJvbVBvaW50LnggKyB2ZWNbMV0gKiB2aWExLnggKyB2ZWNbMl0gKiB2aWEyLnggKyB2ZWNbM10gKiB0aGlzLnRvUG9pbnQueDtcbiAgICAgIHZhciB5ID0gdmVjWzBdICogdGhpcy5mcm9tUG9pbnQueSArIHZlY1sxXSAqIHZpYTEueSArIHZlY1syXSAqIHZpYTIueSArIHZlY1szXSAqIHRoaXMudG9Qb2ludC55O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3ViaWNCZXppZXJFZGdlO1xufShDdWJpY0JlemllckVkZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJG8oRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mJDUoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mJDUodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdCQzKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG8oKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0JDMpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdCQzLnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25zdHJ1Y3QkMyhEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxyXG4gKiBBIFN0cmFpZ2h0IEVkZ2UuXHJcbiAqL1xuXG52YXIgU3RyYWlnaHRFZGdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZUJhc2UpIHtcbiAgaW5oZXJpdHMoU3RyYWlnaHRFZGdlLCBfRWRnZUJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkbyhTdHJhaWdodEVkZ2UpO1xuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFN0cmFpZ2h0RWRnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmFpZ2h0RWRnZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoU3RyYWlnaHRFZGdlLCBbe1xuICAgIGtleTogXCJfbGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGluZShjdHgsIHZhbHVlcykge1xuICAgICAgLy8gZHJhdyBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5mcm9tUG9pbnQueCwgdGhpcy5mcm9tUG9pbnQueSk7XG4gICAgICBjdHgubGluZVRvKHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7IC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcblxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWFOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpYU5vZGUoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoMSAtIHBvc2l0aW9uKSAqIHRoaXMuZnJvbVBvaW50LnggKyBwb3NpdGlvbiAqIHRoaXMudG9Qb2ludC54LFxuICAgICAgICB5OiAoMSAtIHBvc2l0aW9uKSAqIHRoaXMuZnJvbVBvaW50LnkgKyBwb3NpdGlvbiAqIHRoaXMudG9Qb2ludC55XG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICB2YXIgbm9kZTEgPSB0aGlzLnRvO1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5mcm9tO1xuXG4gICAgICBpZiAobmVhck5vZGUuaWQgPT09IHRoaXMuZnJvbS5pZCkge1xuICAgICAgICBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICB2YXIgZHggPSBub2RlMS54IC0gbm9kZTIueDtcbiAgICAgIHZhciBkeSA9IG5vZGUxLnkgLSBub2RlMi55O1xuICAgICAgdmFyIGVkZ2VTZWdtZW50TGVuZ3RoID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIHZhciB0b0JvcmRlckRpc3QgPSBuZWFyTm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgdmFyIHRvQm9yZGVyUG9pbnQgPSAoZWRnZVNlZ21lbnRMZW5ndGggLSB0b0JvcmRlckRpc3QpIC8gZWRnZVNlZ21lbnRMZW5ndGg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoMSAtIHRvQm9yZGVyUG9pbnQpICogbm9kZTIueCArIHRvQm9yZGVyUG9pbnQgKiBub2RlMS54LFxuICAgICAgICB5OiAoMSAtIHRvQm9yZGVyUG9pbnQpICogbm9kZTIueSArIHRvQm9yZGVyUG9pbnQgKiBub2RlMS55LFxuICAgICAgICB0OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgLy8geDMseTMgaXMgdGhlIHBvaW50XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2VUb0xpbmUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0cmFpZ2h0RWRnZTtcbn0oRWRnZUJhc2UpO1xuXG4vKipcbiAqIEFuIGVkZ2UgY29ubmVjdHMgdHdvIG5vZGVzIGFuZCBoYXMgYSBzcGVjaWZpYyBkaXJlY3Rpb24uXG4gKi9cblxudmFyIEVkZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICAgIHZhbHVlcyBzcGVjaWZpYyB0byB0aGlzIGVkZ2UsIG11c3QgY29udGFpbiBhdCBsZWFzdCAnZnJvbScgYW5kICd0bydcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHkgICAgICAgICAgIHNoYXJlZCBzdGF0ZSBmcm9tIE5ldHdvcmsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOZXR3b3JrLkltYWdlc30gaW1hZ2VsaXN0ICBBIGxpc3Qgd2l0aCBpbWFnZXMuIE9ubHkgbmVlZGVkIHdoZW4gdGhlIGVkZ2UgaGFzIGltYWdlIGFycm93cy5cbiAgICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnMgIG9wdGlvbnMgZnJvbSB0aGUgRWRnZXNIYW5kbGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0T3B0aW9ucyBkZWZhdWx0IG9wdGlvbnMgZnJvbSB0aGUgRWRnZUhhbmRsZXIgaW5zdGFuY2UuIFZhbHVlIGFuZCByZWZlcmVuY2UgYXJlIGNvbnN0YW50XG4gICAqL1xuICBmdW5jdGlvbiBFZGdlKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ2xvYmFsT3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlKTtcblxuICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGJvZHkgcHJvdmlkZWRcIik7XG4gICAgfSAvLyBTaW5jZSBnbG9iYWxPcHRpb25zIGlzIGNvbnN0YW50IGluIHZhbHVlcyBhcyB3ZWxsIGFzIHJlZmVyZW5jZSxcbiAgICAvLyBGb2xsb3dpbmcgbmVlZHMgdG8gYmUgZG9uZSBvbmx5IG9uY2UuXG5cblxuICAgIHRoaXMub3B0aW9ucyA9IGJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zKTtcbiAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBnbG9iYWxPcHRpb25zO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuaW1hZ2VsaXN0ID0gaW1hZ2VsaXN0OyAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuXG4gICAgdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZyb21JZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG92ZXIgPSBmYWxzZTtcbiAgICB0aGlzLmxhYmVsRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuYmFzZVdpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoO1xuICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5vcHRpb25zLmZvbnQuc2l6ZTtcbiAgICB0aGlzLmZyb20gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuXG4gICAgdGhpcy50byA9IHVuZGVmaW5lZDsgLy8gYSBub2RlXG5cbiAgICB0aGlzLmVkZ2VUeXBlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5sYWJlbE1vZHVsZSA9IG5ldyBMYWJlbCh0aGlzLmJvZHksIHRoaXMub3B0aW9ucywgdHJ1ZVxuICAgIC8qIEl0J3MgYW4gZWRnZSBsYWJlbCAqL1xuICAgICk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgb3Igb3ZlcndyaXRlIG9wdGlvbnMgZm9yIHRoZSBlZGdlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBhbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gdW5kZWZpbmVkIGlmIG5vIG9wdGlvbnMsIHRydWUgaWYgbGF5b3V0IGFmZmVjdGluZyBkYXRhIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhFZGdlLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRm9sbG93aW5nIG9wdGlvbnMgaWYgY2hhbmdlZCBhZmZlY3QgdGhlIGxheW91dC5cblxuXG4gICAgICB2YXIgYWZmZWN0c0xheW91dCA9IHR5cGVvZiBvcHRpb25zLnBoeXNpY3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5vcHRpb25zLnBoeXNpY3MgIT09IG9wdGlvbnMucGh5c2ljcyB8fCB0eXBlb2Ygb3B0aW9ucy5oaWRkZW4gIT09IFwidW5kZWZpbmVkXCIgJiYgKHRoaXMub3B0aW9ucy5oaWRkZW4gfHwgZmFsc2UpICE9PSAob3B0aW9ucy5oaWRkZW4gfHwgZmFsc2UpIHx8IHR5cGVvZiBvcHRpb25zLmZyb20gIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5vcHRpb25zLmZyb20gIT09IG9wdGlvbnMuZnJvbSB8fCB0eXBlb2Ygb3B0aW9ucy50byAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLm9wdGlvbnMudG8gIT09IG9wdGlvbnMudG87XG4gICAgICBFZGdlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZ2xvYmFsT3B0aW9ucyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmZyb21JZCA9IG9wdGlvbnMuZnJvbTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRvSWQgPSBvcHRpb25zLnRvO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50aXRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMudmFsdWUgPSBfcGFyc2VGbG9hdCQyKG9wdGlvbnMudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGlsZSA9IFtvcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnNdO1xuICAgICAgdGhpcy5jaG9vc2VyID0gY2hvb3NpZnkoXCJlZGdlXCIsIHBpbGUpOyAvLyB1cGRhdGUgbGFiZWwgTW9kdWxlXG5cbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucyk7IC8vIFVwZGF0ZSBlZGdlIHR5cGUsIHRoaXMgaWYgY2hhbmdlZCBhZmZlY3RzIHRoZSBsYXlvdXQuXG5cbiAgICAgIGFmZmVjdHNMYXlvdXQgPSB0aGlzLnVwZGF0ZUVkZ2VUeXBlKCkgfHwgYWZmZWN0c0xheW91dDsgLy8gaWYgYW55dGhpbmcgaGFzIGJlZW4gdXBkYXRlcywgcmVzZXQgdGhlIHNlbGVjdGlvbiB3aWR0aCBhbmQgdGhlIGhvdmVyIHdpZHRoXG5cbiAgICAgIHRoaXMuX3NldEludGVyYWN0aW9uV2lkdGhzKCk7IC8vIEEgbm9kZSBpcyBjb25uZWN0ZWQgd2hlbiBpdCBoYXMgYSBmcm9tIGFuZCB0byBub2RlIHRoYXQgYm90aCBleGlzdCBpbiB0aGUgbmV0d29yay5ib2R5Lm5vZGVzLlxuXG5cbiAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIGFmZmVjdHNMYXlvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FsbG93RGVsZXRpb249ZmFsc2VdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtnbG9iYWxPcHRpb25zPXt9XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvcHlGcm9tR2xvYmFscz1mYWxzZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdHRpbmdWYWx1ZXNcIixcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Fycm93T3B0aW9uc31cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpIHtcbiAgICAgIHZhciB0b0Fycm93ID0gdGhpcy5vcHRpb25zLmFycm93cy50byA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPT09IHRydWU7XG4gICAgICB2YXIgZnJvbUFycm93ID0gdGhpcy5vcHRpb25zLmFycm93cy5mcm9tID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5lbmFibGVkID09PSB0cnVlO1xuICAgICAgdmFyIG1pZGRsZUFycm93ID0gdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUgPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuZW5hYmxlZCA9PT0gdHJ1ZTtcbiAgICAgIHZhciBpbmhlcml0c0NvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmluaGVyaXQ7XG4gICAgICB2YXIgdmFsdWVzID0ge1xuICAgICAgICB0b0Fycm93OiB0b0Fycm93LFxuICAgICAgICB0b0Fycm93U2NhbGU6IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uc2NhbGVGYWN0b3IsXG4gICAgICAgIHRvQXJyb3dUeXBlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnR5cGUsXG4gICAgICAgIHRvQXJyb3dTcmM6IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uc3JjLFxuICAgICAgICB0b0Fycm93SW1hZ2VXaWR0aDogdGhpcy5vcHRpb25zLmFycm93cy50by5pbWFnZVdpZHRoLFxuICAgICAgICB0b0Fycm93SW1hZ2VIZWlnaHQ6IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uaW1hZ2VIZWlnaHQsXG4gICAgICAgIG1pZGRsZUFycm93OiBtaWRkbGVBcnJvdyxcbiAgICAgICAgbWlkZGxlQXJyb3dTY2FsZTogdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuc2NhbGVGYWN0b3IsXG4gICAgICAgIG1pZGRsZUFycm93VHlwZTogdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUudHlwZSxcbiAgICAgICAgbWlkZGxlQXJyb3dTcmM6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnNyYyxcbiAgICAgICAgbWlkZGxlQXJyb3dJbWFnZVdpZHRoOiB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5pbWFnZVdpZHRoLFxuICAgICAgICBtaWRkbGVBcnJvd0ltYWdlSGVpZ2h0OiB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5pbWFnZUhlaWdodCxcbiAgICAgICAgZnJvbUFycm93OiBmcm9tQXJyb3csXG4gICAgICAgIGZyb21BcnJvd1NjYWxlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uc2NhbGVGYWN0b3IsXG4gICAgICAgIGZyb21BcnJvd1R5cGU6IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS50eXBlLFxuICAgICAgICBmcm9tQXJyb3dTcmM6IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5zcmMsXG4gICAgICAgIGZyb21BcnJvd0ltYWdlV2lkdGg6IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5pbWFnZVdpZHRoLFxuICAgICAgICBmcm9tQXJyb3dJbWFnZUhlaWdodDogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLmltYWdlSGVpZ2h0LFxuICAgICAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHRoaXMub3B0aW9ucy5hcnJvd1N0cmlrZXRocm91Z2gsXG4gICAgICAgIGNvbG9yOiBpbmhlcml0c0NvbG9yID8gdW5kZWZpbmVkIDogdGhpcy5vcHRpb25zLmNvbG9yLmNvbG9yLFxuICAgICAgICBpbmhlcml0c0NvbG9yOiBpbmhlcml0c0NvbG9yLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLm9wdGlvbnMuY29sb3Iub3BhY2l0eSxcbiAgICAgICAgaGlkZGVuOiB0aGlzLm9wdGlvbnMuaGlkZGVuLFxuICAgICAgICBsZW5ndGg6IHRoaXMub3B0aW9ucy5sZW5ndGgsXG4gICAgICAgIHNoYWRvdzogdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkLFxuICAgICAgICBzaGFkb3dDb2xvcjogdGhpcy5vcHRpb25zLnNoYWRvdy5jb2xvcixcbiAgICAgICAgc2hhZG93U2l6ZTogdGhpcy5vcHRpb25zLnNoYWRvdy5zaXplLFxuICAgICAgICBzaGFkb3dYOiB0aGlzLm9wdGlvbnMuc2hhZG93LngsXG4gICAgICAgIHNoYWRvd1k6IHRoaXMub3B0aW9ucy5zaGFkb3cueSxcbiAgICAgICAgZGFzaGVzOiB0aGlzLm9wdGlvbnMuZGFzaGVzLFxuICAgICAgICB3aWR0aDogdGhpcy5vcHRpb25zLndpZHRoLFxuICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5lbmFibGVkLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLmNvbG9yLFxuICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogdGhpcy5vcHRpb25zLmJhY2tncm91bmQuc2l6ZSxcbiAgICAgICAgYmFja2dyb3VuZERhc2hlczogdGhpcy5vcHRpb25zLmJhY2tncm91bmQuZGFzaGVzXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZCB8fCB0aGlzLmhvdmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNob29zZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkV2lkdGggPSB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ZWRXaWR0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IHNlbGVjdGVkV2lkdGgodmFsdWVzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGVjdGVkV2lkdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLndpZHRoICs9IHNlbGVjdGVkV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IE1hdGgubWF4KHZhbHVlcy53aWR0aCwgMC4zIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgICAgICAgdmFsdWVzLmNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhvdmVyKSB7XG4gICAgICAgICAgICB2YXIgaG92ZXJXaWR0aCA9IHRoaXMub3B0aW9ucy5ob3ZlcldpZHRoO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGhvdmVyV2lkdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBob3ZlcldpZHRoKHZhbHVlcy53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBob3ZlcldpZHRoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCArPSBob3ZlcldpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBNYXRoLm1heCh2YWx1ZXMud2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5ob3ZlcjtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNob29zZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuY2hvb3Nlcih2YWx1ZXMsIHRoaXMub3B0aW9ucy5pZCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG5cbiAgICAgICAgICBpZiAodmFsdWVzLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlcy5pbmhlcml0c0NvbG9yID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLnNoYWRvd0NvbG9yICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yIHx8IHZhbHVlcy5zaGFkb3dTaXplICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUgfHwgdmFsdWVzLnNoYWRvd1ggIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueCB8fCB2YWx1ZXMuc2hhZG93WSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy55KSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgdmFsdWVzLndpZHRoID0gTWF0aC5tYXgodmFsdWVzLndpZHRoLCAwLjMgLyB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgb3B0aW9ucyBpbiB0aGUgbGFiZWwgbW9kdWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlTGFiZWxNb2R1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucykge1xuICAgICAgdmFyIHBpbGUgPSBbb3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmdsb2JhbE9wdGlvbnMsIC8vIEN1cnJlbnRseSBzZXQgZ2xvYmFsIGVkZ2Ugb3B0aW9uc1xuICAgICAgdGhpcy5kZWZhdWx0T3B0aW9uc107XG4gICAgICB0aGlzLmxhYmVsTW9kdWxlLnVwZGF0ZSh0aGlzLm9wdGlvbnMsIHBpbGUpO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5sYWJlbE1vZHVsZS5iYXNlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBlZGdlIHR5cGUsIHNldCB0aGUgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFZGdlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFZGdlVHlwZSgpIHtcbiAgICAgIHZhciBzbW9vdGggPSB0aGlzLm9wdGlvbnMuc21vb3RoO1xuICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgY2hhbmdlSW5UeXBlID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEJlemllckVkZ2VEeW5hbWljICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlID09PSBcImR5bmFtaWNcIiB8fCB0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgQ3ViaWNCZXppZXJFZGdlICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlID09PSBcImN1YmljQmV6aWVyXCIgfHwgdGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEJlemllckVkZ2VTdGF0aWMgJiYgc21vb3RoLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoLnR5cGUgIT09IFwiZHluYW1pY1wiICYmIHNtb290aC50eXBlICE9PSBcImN1YmljQmV6aWVyXCIgfHwgdGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIFN0cmFpZ2h0RWRnZSAmJiBzbW9vdGgudHlwZS5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIGNoYW5nZUluVHlwZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZUluVHlwZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUluVHlwZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoc21vb3RoLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoc21vb3RoLnR5cGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IEJlemllckVkZ2VEeW5hbWljKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNtb290aC50eXBlID09PSBcImN1YmljQmV6aWVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgQ3ViaWNCZXppZXJFZGdlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBCZXppZXJFZGdlU3RhdGljKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBTdHJhaWdodEVkZ2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBub3RoaW5nIGNoYW5nZXMsIHdlIGp1c3Qgc2V0IHRoZSBvcHRpb25zLlxuICAgICAgICB0aGlzLmVkZ2VUeXBlLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFDaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IGFuIGVkZ2UgdG8gaXRzIG5vZGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF0gfHwgdW5kZWZpbmVkO1xuICAgICAgdGhpcy50byA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRvSWRdIHx8IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gdGhpcy5mcm9tICE9PSB1bmRlZmluZWQgJiYgdGhpcy50byAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodGhpcy5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5mcm9tLmF0dGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIHRoaXMudG8uYXR0YWNoRWRnZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20pIHtcbiAgICAgICAgICB0aGlzLmZyb20uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgICAgdGhpcy50by5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZVR5cGUuY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGFuIGVkZ2UgZnJvbSBpdHMgbm9kZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgIGlmICh0aGlzLmZyb20pIHtcbiAgICAgICAgdGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIHRoaXMuZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG8pIHtcbiAgICAgICAgdGhpcy50by5kZXRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB0aGlzLnRvID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHRpdGxlIG9mIHRoaXMgZWRnZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRpdGxlICAgIFRoZSB0aXRsZSBvZiB0aGUgZWRnZSwgb3IgdW5kZWZpbmVkIHdoZW4gbm8gdGl0bGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBiZWVuIHNldC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRpdGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpdGxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIHRoaXMgbm9kZSBpcyBzZWxlY3RlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gc2VsZWN0ZWQgICBUcnVlIGlmIG5vZGUgaXMgc2VsZWN0ZWQsIGVsc2UgZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzU2VsZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIGVkZ2UuIENhbiBiZSB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIGVkZ2UuIFRoZSBlZGdlIHdpbGwgYWRqdXN0IGl0J3Mgd2lkdGhcbiAgICAgKiBiYXNlZCBvbiBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VmFsdWVSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZVJhbmdlKG1pbiwgbWF4LCB0b3RhbCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIHZhciB3aWR0aERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW47XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgZm9udERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW47XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbiArIHNjYWxlICogZm9udERpZmY7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5taW4gKyBzY2FsZSAqIHdpZHRoRGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMuYmFzZVdpZHRoO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5iYXNlRm9udFNpemU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldEludGVyYWN0aW9uV2lkdGhzKCk7XG5cbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEludGVyYWN0aW9uV2lkdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRJbnRlcmFjdGlvbldpZHRocygpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmhvdmVyV2lkdGggPSB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCh0aGlzLm9wdGlvbnMud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5ob3ZlcldpZHRoID0gdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggKyB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNlbGVjdGlvbldpZHRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5zZWxlY3Rpb25XaWR0aCA9IHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCh0aGlzLm9wdGlvbnMud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5zZWxlY3Rpb25XaWR0aCA9IHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCArIHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IGEgZWRnZVxuICAgICAqIERyYXcgdGhpcyBlZGdlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuXG4gICAgICBpZiAodmFsdWVzLmhpZGRlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGdldCB0aGUgdmlhIG5vZGUgZnJvbSB0aGUgZWRnZSB0eXBlXG5cblxuICAgICAgdmFyIHZpYU5vZGUgPSB0aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKTsgLy8gZHJhdyBsaW5lIGFuZCBsYWJlbFxuXG4gICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdMaW5lKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2aWFOb2RlKTtcbiAgICAgIHRoaXMuZHJhd0xhYmVsKGN0eCwgdmlhTm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhcnJvd3NcbiAgICAgKiBEcmF3IHRoaXMgYXJyb3dzIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0Fycm93c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3dzKGN0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Rm9ybWF0dGluZ1ZhbHVlcygpO1xuXG4gICAgICBpZiAodmFsdWVzLmhpZGRlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGdldCB0aGUgdmlhIG5vZGUgZnJvbSB0aGUgZWRnZSB0eXBlXG5cblxuICAgICAgdmFyIHZpYU5vZGUgPSB0aGlzLmVkZ2VUeXBlLmdldFZpYU5vZGUoKTtcbiAgICAgIHZhciBhcnJvd0RhdGEgPSB7fTsgLy8gcmVzdG9yZSBlZGdlIHRhcmdldHMgdG8gZGVmYXVsdHNcblxuICAgICAgdGhpcy5lZGdlVHlwZS5mcm9tUG9pbnQgPSB0aGlzLmVkZ2VUeXBlLmZyb207XG4gICAgICB0aGlzLmVkZ2VUeXBlLnRvUG9pbnQgPSB0aGlzLmVkZ2VUeXBlLnRvOyAvLyBmcm9tIGFuZCB0byBhcnJvd3MgZ2l2ZSBhIGRpZmZlcmVudCBlbmQgcG9pbnQgZm9yIGVkZ2VzLiB3ZSBzZXQgdGhlbSBoZXJlXG5cbiAgICAgIGlmICh2YWx1ZXMuZnJvbUFycm93KSB7XG4gICAgICAgIGFycm93RGF0YS5mcm9tID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCBcImZyb21cIiwgdmlhTm9kZSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKTtcbiAgICAgICAgaWYgKHZhbHVlcy5hcnJvd1N0cmlrZXRocm91Z2ggPT09IGZhbHNlKSB0aGlzLmVkZ2VUeXBlLmZyb21Qb2ludCA9IGFycm93RGF0YS5mcm9tLmNvcmU7XG5cbiAgICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3dTcmMpIHtcbiAgICAgICAgICBhcnJvd0RhdGEuZnJvbS5pbWFnZSA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodmFsdWVzLmZyb21BcnJvd1NyYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLmZyb21BcnJvd0ltYWdlV2lkdGgpIHtcbiAgICAgICAgICBhcnJvd0RhdGEuZnJvbS5pbWFnZVdpZHRoID0gdmFsdWVzLmZyb21BcnJvd0ltYWdlV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLmZyb21BcnJvd0ltYWdlSGVpZ2h0KSB7XG4gICAgICAgICAgYXJyb3dEYXRhLmZyb20uaW1hZ2VIZWlnaHQgPSB2YWx1ZXMuZnJvbUFycm93SW1hZ2VIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlcy50b0Fycm93KSB7XG4gICAgICAgIGFycm93RGF0YS50byA9IHRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKGN0eCwgXCJ0b1wiLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWVzLmFycm93U3RyaWtldGhyb3VnaCA9PT0gZmFsc2UpIHRoaXMuZWRnZVR5cGUudG9Qb2ludCA9IGFycm93RGF0YS50by5jb3JlO1xuXG4gICAgICAgIGlmICh2YWx1ZXMudG9BcnJvd1NyYykge1xuICAgICAgICAgIGFycm93RGF0YS50by5pbWFnZSA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodmFsdWVzLnRvQXJyb3dTcmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcy50b0Fycm93SW1hZ2VXaWR0aCkge1xuICAgICAgICAgIGFycm93RGF0YS50by5pbWFnZVdpZHRoID0gdmFsdWVzLnRvQXJyb3dJbWFnZVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlcy50b0Fycm93SW1hZ2VIZWlnaHQpIHtcbiAgICAgICAgICBhcnJvd0RhdGEudG8uaW1hZ2VIZWlnaHQgPSB2YWx1ZXMudG9BcnJvd0ltYWdlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9IC8vIHRoZSBtaWRkbGUgYXJyb3cgZGVwZW5kcyBvbiB0aGUgbGluZSwgd2hpY2ggY2FuIGRlcGVuZCBvbiB0aGUgdG8gYW5kIGZyb20gYXJyb3dzIHNvIHdlIGRvIHRoaXMgb25lIGxhc3RseS5cblxuXG4gICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93KSB7XG4gICAgICAgIGFycm93RGF0YS5taWRkbGUgPSB0aGlzLmVkZ2VUeXBlLmdldEFycm93RGF0YShjdHgsIFwibWlkZGxlXCIsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcyk7XG5cbiAgICAgICAgaWYgKHZhbHVlcy5taWRkbGVBcnJvd1NyYykge1xuICAgICAgICAgIGFycm93RGF0YS5taWRkbGUuaW1hZ2UgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHZhbHVlcy5taWRkbGVBcnJvd1NyYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93SW1hZ2VXaWR0aCkge1xuICAgICAgICAgIGFycm93RGF0YS5taWRkbGUuaW1hZ2VXaWR0aCA9IHZhbHVlcy5taWRkbGVBcnJvd0ltYWdlV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93SW1hZ2VIZWlnaHQpIHtcbiAgICAgICAgICBhcnJvd0RhdGEubWlkZGxlLmltYWdlSGVpZ2h0ID0gdmFsdWVzLm1pZGRsZUFycm93SW1hZ2VIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3cpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEuZnJvbSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3cpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEubWlkZGxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlcy50b0Fycm93KSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0Fycm93SGVhZChjdHgsIHZhbHVlcywgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgYXJyb3dEYXRhLnRvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFOb2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3TGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xhYmVsKGN0eCwgdmlhTm9kZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHNldCBzdHlsZVxuICAgICAgICB2YXIgbm9kZTEgPSB0aGlzLmZyb207XG4gICAgICAgIHZhciBub2RlMiA9IHRoaXMudG87XG5cbiAgICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUuZGlmZmVyZW50U3RhdGUodGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlcikpIHtcbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnQ7XG5cbiAgICAgICAgaWYgKG5vZGUxLmlkICE9IG5vZGUyLmlkKSB7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5wb2ludFRvU2VsZiA9IGZhbHNlO1xuICAgICAgICAgIHBvaW50ID0gdGhpcy5lZGdlVHlwZS5nZXRQb2ludCgwLjUsIHZpYU5vZGUpO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICB2YXIgcm90YXRpb25Qb2ludCA9IHRoaXMuX2dldFJvdGF0aW9uKGN0eCk7XG5cbiAgICAgICAgICBpZiAocm90YXRpb25Qb2ludC5hbmdsZSAhPSAwKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHJvdGF0aW9uUG9pbnQueCwgcm90YXRpb25Qb2ludC55KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocm90YXRpb25Qb2ludC5hbmdsZSk7XG4gICAgICAgICAgfSAvLyBkcmF3IHRoZSBsYWJlbFxuXG5cbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCBwb2ludC54LCBwb2ludC55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcbiAgICAgICAgICAvKlxuICAgICAgICAgIC8vIFVzZWZ1bCBkZWJ1ZyBjb2RlOiBkcmF3IGEgYm9yZGVyIGFyb3VuZCB0aGUgbGFiZWxcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCAqKm5vdCoqIGJlIGVuYWJsZWQgaW4gcHJvZHVjdGlvbiFcbiAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpOzsgLy8gOzsgaW50ZW50aW9uYWwgc28gbGludCBjYXRjaGVzIGl0XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCIjZmYwMDAwXCI7XG4gICAgICAgICAgY3R4LnN0cm9rZVJlY3Qoc2l6ZS5sZWZ0LCBzaXplLnRvcCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgIC8vIEVuZCAgZGVidWcgY29kZVxuICAgICAgICAgICovXG5cbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElnbm9yZSB0aGUgb3JpZW50YXRpb25zLlxuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUucG9pbnRUb1NlbGYgPSB0cnVlOyAvLyBnZXQgY2lyY2xlIGNvb3JkaW5hdGVzXG5cbiAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZXRTZWxmUmVmQ29vcmRpbmF0ZXMoY3R4LCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSwgdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2Uuc2l6ZSwgbm9kZTEpO1xuICAgICAgICAgIHBvaW50ID0gdGhpcy5fcG9pbnRPbkNpcmNsZShjb29yZGluYXRlcy54LCBjb29yZGluYXRlcy55LCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5zaXplLCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSk7XG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB2aXN1YWwgZWxlbWVudHMgb2YgdGhpcyBlZGdlIGluc3RhbmNlLCBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICAgKiBwb2ludCBmYWxscyB3aXRoaW4gdGhlIGJvdW5kaW5nIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPGVkZ2VDbGlja0l0ZW18ZWRnZUxhYmVsQ2xpY2tJdGVtPn0gbGlzdCB3aXRoIHRoZSBpdGVtcyB3aGljaCBhcmUgb24gdGhlIHBvaW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJdGVtc09uUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbXNPblBvaW50KHBvaW50KSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLnZpc2libGUoKSkge1xuICAgICAgICB2YXIgcm90YXRpb25Qb2ludCA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG5cbiAgICAgICAgaWYgKHBvaW50SW5SZWN0KHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpLCBwb2ludCwgcm90YXRpb25Qb2ludCkpIHtcbiAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICBlZGdlSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBsYWJlbElkOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgbGVmdDogcG9pbnQueCxcbiAgICAgICAgdG9wOiBwb2ludC55XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5pc092ZXJsYXBwaW5nV2l0aChvYmopKSB7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICBlZGdlSWQ6IHRoaXMuaWRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IGlzIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByb3ZpZGVkIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAgIGFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICBUcnVlIGlmIGxvY2F0aW9uIGlzIGxvY2F0ZWQgb24gdGhlIGVkZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHZhciBkaXN0TWF4ID0gMTA7XG4gICAgICAgIHZhciB4RnJvbSA9IHRoaXMuZnJvbS54O1xuICAgICAgICB2YXIgeUZyb20gPSB0aGlzLmZyb20ueTtcbiAgICAgICAgdmFyIHhUbyA9IHRoaXMudG8ueDtcbiAgICAgICAgdmFyIHlUbyA9IHRoaXMudG8ueTtcbiAgICAgICAgdmFyIHhPYmogPSBvYmoubGVmdDtcbiAgICAgICAgdmFyIHlPYmogPSBvYmoudG9wO1xuICAgICAgICB2YXIgZGlzdCA9IHRoaXMuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoeEZyb20sIHlGcm9tLCB4VG8sIHlUbywgeE9iaiwgeU9iaik7XG4gICAgICAgIHJldHVybiBkaXN0IDwgZGlzdE1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSByb3RhdGlvbiBwb2ludCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjdHhdIGlmIHBhc3NlZCwgZG8gYSByZWNhbGN1bGF0aW9uIG9mIHRoZSBsYWJlbCBzaXplXG4gICAgICogQHJldHVybnMge3JvdGF0aW9uUG9pbnR9IHRoZSBwb2ludCB0byByb3RhdGUgYXJvdW5kIGFuZCB0aGUgYW5nbGUgaW4gcmFkaWFucyB0byByb3RhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFJvdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRSb3RhdGlvbihjdHgpIHtcbiAgICAgIHZhciB2aWFOb2RlID0gdGhpcy5lZGdlVHlwZS5nZXRWaWFOb2RlKCk7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmVkZ2VUeXBlLmdldFBvaW50KDAuNSwgdmlhTm9kZSk7XG5cbiAgICAgIGlmIChjdHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICB5OiB0aGlzLmxhYmVsTW9kdWxlLnNpemUueUxpbmUsXG4gICAgICAgIGFuZ2xlOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoIXRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiByZXQ7IC8vIERvbid0IGV2ZW4gYm90aGVyIGRvaW5nIHRoZSBhdGFuMiwgdGhlcmUncyBub3RoaW5nIHRvIGRyYXdcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb250LmFsaWduID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICByZXR1cm4gcmV0OyAvLyBObyBuZWVkIHRvIGNhbGN1bGF0ZSBhbmdsZVxuICAgICAgfVxuXG4gICAgICB2YXIgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgIHZhciBkeCA9IHRoaXMuZnJvbS54IC0gdGhpcy50by54O1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpOyAvLyByYWRpYW5zXG4gICAgICAvLyByb3RhdGUgc28gdGhhdCBsYWJlbCBpcyByZWFkYWJsZVxuXG4gICAgICBpZiAoYW5nbGUgPCAtMSAmJiBkeCA8IDAgfHwgYW5nbGUgPiAwICYmIGR4IDwgMCkge1xuICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xuICAgICAgfVxuXG4gICAgICByZXQuYW5nbGUgPSBhbmdsZTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHBvaW50IG9uIGEgY2lyY2xlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wb2ludE9uQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgYW5nbGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IHkgLSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0ZWQgc3RhdGUgdG8gdHJ1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGVkIHN0YXRlIHRvIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2xlYW5zIGFsbCByZXF1aXJlZCB0aGluZ3Mgb24gZGVsZXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVkZ2VUeXBlLmNsZWFudXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGVkZ2UgZnJvbSB0aGUgbGlzdCBhbmQgcGVyZm9ybSBuZWNlc3NhcnkgY2xlYW51cC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1t0aGlzLmlkXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYm90aCBjb25uZWN0aW5nIG5vZGVzIGV4aXN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuZFBvaW50c1ZhbGlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZFBvaW50c1ZhbGlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbdGhpcy50b0lkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZU9wdGlvbnMocGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucykge1xuICAgICAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgdmFyIGNvcHlGcm9tR2xvYmFscyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG4gICAgICB2YXIgZmllbGRzID0gW1wiZW5kUG9pbnRPZmZzZXRcIiwgXCJhcnJvd1N0cmlrZXRocm91Z2hcIiwgXCJpZFwiLCBcImZyb21cIiwgXCJoaWRkZW5cIiwgXCJob3ZlcldpZHRoXCIsIFwibGFiZWxIaWdobGlnaHRCb2xkXCIsIFwibGVuZ3RoXCIsIFwibGluZVwiLCBcIm9wYWNpdHlcIiwgXCJwaHlzaWNzXCIsIFwic2NhbGluZ1wiLCBcInNlbGVjdGlvbldpZHRoXCIsIFwic2VsZlJlZmVyZW5jZVNpemVcIiwgXCJzZWxmUmVmZXJlbmNlXCIsIFwidG9cIiwgXCJ0aXRsZVwiLCBcInZhbHVlXCIsIFwid2lkdGhcIiwgXCJmb250XCIsIFwiY2hvc2VuXCIsIFwid2lkdGhDb25zdHJhaW50XCJdOyAvLyBvbmx5IGRlZXAgZXh0ZW5kIHRoZSBpdGVtcyBpbiB0aGUgZmllbGQgYXJyYXkuIFRoZXNlIGRvIG5vdCBoYXZlIHNob3J0aGFuZC5cblxuICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGFsbG93RGVsZXRpb24pOyAvLyBPbmx5IHVzZSBlbmRQb2ludE9mZnNldCB2YWx1ZXMgKGZyb20gYW5kIHRvKSBpZiBpdCdzIHZhbGlkIHZhbHVlc1xuXG4gICAgICBpZiAobmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChfaXNGaW5pdGUkMihuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20pKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tID0gbmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSA9IGdsb2JhbE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSAhPT0gdW5kZWZpbmVkID8gZ2xvYmFsT3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tIDogMDtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZW5kUG9pbnRPZmZzZXQuZnJvbSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKF9pc0Zpbml0ZSQyKG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8pKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC50byA9IG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC50byA9IGdsb2JhbE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8gIT09IHVuZGVmaW5lZCA/IGdsb2JhbE9wdGlvbnMuZW5kUG9pbnRPZmZzZXQudG8gOiAwO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlbmRQb2ludE9mZnNldC50byBpcyBub3QgYSB2YWxpZCBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gT25seSBjb3B5IGxhYmVsIGlmIGl0J3MgYSBsZWdhbCB2YWx1ZS5cblxuXG4gICAgICBpZiAoaXNWYWxpZExhYmVsKG5ld09wdGlvbnMubGFiZWwpKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMubGFiZWwgPSBuZXdPcHRpb25zLmxhYmVsO1xuICAgICAgfSBlbHNlIGlmICghaXNWYWxpZExhYmVsKHBhcmVudE9wdGlvbnMubGFiZWwpKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMubGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcInNtb290aFwiLCBnbG9iYWxPcHRpb25zKTtcbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcInNoYWRvd1wiLCBnbG9iYWxPcHRpb25zKTtcbiAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBcImJhY2tncm91bmRcIiwgZ2xvYmFsT3B0aW9ucyk7XG5cbiAgICAgIGlmIChuZXdPcHRpb25zLmRhc2hlcyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZGFzaGVzICE9PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZGFzaGVzID0gbmV3T3B0aW9ucy5kYXNoZXM7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5kYXNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5kYXNoZXMgPSBjcmVhdGUkMihnbG9iYWxPcHRpb25zLmRhc2hlcyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICB9IC8vIHNldCB0aGUgc2NhbGluZyBuZXdPcHRpb25zXG5cblxuICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuc2NhbGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nLm1pbiA9IG5ld09wdGlvbnMuc2NhbGluZy5taW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nLm1heCA9IG5ld09wdGlvbnMuc2NhbGluZy5tYXg7XG4gICAgICAgIH1cblxuICAgICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5zY2FsaW5nLCBuZXdPcHRpb25zLnNjYWxpbmcsIFwibGFiZWxcIiwgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLnNjYWxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nID0gY3JlYXRlJDIoZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgIH0gLy8gaGFuZGxlIG11bHRpcGxlIGlucHV0IGNhc2VzIGZvciBhcnJvd3NcblxuXG4gICAgICBpZiAobmV3T3B0aW9ucy5hcnJvd3MgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmFycm93cyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wdGlvbnMuYXJyb3dzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFyIGFycm93cyA9IG5ld09wdGlvbnMuYXJyb3dzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5hcnJvd3MudG8uZW5hYmxlZCA9IGluZGV4T2YkMyhhcnJvd3MpLmNhbGwoYXJyb3dzLCBcInRvXCIpICE9IC0xO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLm1pZGRsZS5lbmFibGVkID0gaW5kZXhPZiQzKGFycm93cykuY2FsbChhcnJvd3MsIFwibWlkZGxlXCIpICE9IC0xO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9IGluZGV4T2YkMyhhcnJvd3MpLmNhbGwoYXJyb3dzLCBcImZyb21cIikgIT0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZl8xKG5ld09wdGlvbnMuYXJyb3dzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsIFwidG9cIiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsIFwibWlkZGxlXCIsIGdsb2JhbE9wdGlvbnMuYXJyb3dzKTtcbiAgICAgICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5hcnJvd3MsIG5ld09wdGlvbnMuYXJyb3dzLCBcImZyb21cIiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcnJvdyBuZXdPcHRpb25zIGNhbiBvbmx5IGJlIGFuIG9iamVjdCBvciBhIHN0cmluZy4gUmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24uIFlvdSB1c2VkOlwiICsgc3RyaW5naWZ5JDIobmV3T3B0aW9ucy5hcnJvd3MpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuYXJyb3dzID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzID0gY3JlYXRlJDIoZ2xvYmFsT3B0aW9ucy5hcnJvd3MpOyAvLyB0aGlzIHNldHMgdGhlIHBvaW50ZXIgb2YgdGhlIG9wdGlvbiBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uLlxuICAgICAgfSAvLyBoYW5kbGUgbXVsdGlwbGUgaW5wdXQgY2FzZXMgZm9yIGNvbG9yXG5cblxuICAgICAgaWYgKG5ld09wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmNvbG9yICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBmcm9tQ29sb3IgPSBpc1N0cmluZyhuZXdPcHRpb25zLmNvbG9yKSA/IHtcbiAgICAgICAgICBjb2xvcjogbmV3T3B0aW9ucy5jb2xvcixcbiAgICAgICAgICBoaWdobGlnaHQ6IG5ld09wdGlvbnMuY29sb3IsXG4gICAgICAgICAgaG92ZXI6IG5ld09wdGlvbnMuY29sb3IsXG4gICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9IDogbmV3T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgdmFyIHRvQ29sb3IgPSBwYXJlbnRPcHRpb25zLmNvbG9yOyAvLyBJZiBwYXNzZWQsIGZpbGwgaW4gdmFsdWVzIGZyb20gZGVmYXVsdCBvcHRpb25zIC0gcmVxdWlyZWQgaW4gdGhlIGNhc2Ugb2Ygbm8gcHJvdG90eXBlIGJyaWRnaW5nXG5cbiAgICAgICAgaWYgKGNvcHlGcm9tR2xvYmFscykge1xuICAgICAgICAgIGRlZXBFeHRlbmQodG9Db2xvciwgZ2xvYmFsT3B0aW9ucy5jb2xvciwgZmFsc2UsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENsZWFyIGxvY2FsIHByb3BlcnRpZXMgLSBuZWVkIHRvIGRvIGl0IGxpa2UgdGhpcyBpbiBvcmRlciB0byByZXRhaW4gcHJvdG90eXBlIGJyaWRnZXNcbiAgICAgICAgICBmb3IgKHZhciBpIGluIHRvQ29sb3IpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodG9Db2xvciwgaSkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRvQ29sb3JbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU3RyaW5nKHRvQ29sb3IpKSB7XG4gICAgICAgICAgdG9Db2xvci5jb2xvciA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5oaWdobGlnaHQgPSB0b0NvbG9yO1xuICAgICAgICAgIHRvQ29sb3IuaG92ZXIgPSB0b0NvbG9yO1xuICAgICAgICAgIHRvQ29sb3IuaW5oZXJpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGZyb21Db2xvci5vcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3Iub3BhY2l0eSA9IDEuMDsgLy8gc2V0IGRlZmF1bHRcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbG9yc0RlZmluZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5jb2xvciA9IGZyb21Db2xvci5jb2xvcjtcbiAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuaGlnaGxpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuaGlnaGxpZ2h0ID0gZnJvbUNvbG9yLmhpZ2hsaWdodDtcbiAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuaG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5ob3ZlciA9IGZyb21Db2xvci5ob3ZlcjtcbiAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuaW5oZXJpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLmluaGVyaXQgPSBmcm9tQ29sb3IuaW5oZXJpdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5vcGFjaXR5ID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZnJvbUNvbG9yLm9wYWNpdHkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29sb3JzRGVmaW5lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b0NvbG9yLmluaGVyaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0b0NvbG9yLmluaGVyaXQgPSBcImZyb21cIjsgLy8gU2V0IGRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5jb2xvcik7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZm9udCA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmZvbnQgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5mb250KTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXdPcHRpb25zLCBcInNlbGZSZWZlcmVuY2VTaXplXCIpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBzZWxmUmVmZXJlbmNlU2l6ZSBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHNlbGZSZWZlcmVuY2UgcHJvcGVydHkgaW5zdGVhZC4gVGhlIHNlbGZSZWZlcmVuY2UgY2FuIGJlIHNldCBsaWtlIHRoaXNlIHNlbGZSZWZlcmVuY2U6e3NpemU6MzAsIGFuZ2xlOk1hdGguUEkgLyA0fVwiKTtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemUgPSBuZXdPcHRpb25zLnNlbGZSZWZlcmVuY2VTaXplO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFZGdlO1xufSgpO1xuXG4vKipcbiAqIEhhbmRsZXIgZm9yIEVkZ2VzXG4gKi9cblxudmFyIEVkZ2VzSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxJbWFnZT59IGltYWdlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxHcm91cD59IGdyb3Vwc1xuICAgKi9cbiAgZnVuY3Rpb24gRWRnZXNIYW5kbGVyKGJvZHksIGltYWdlcywgZ3JvdXBzKSB7XG4gICAgdmFyIF9jb250ZXh0LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlc0hhbmRsZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICB0aGlzLmdyb3VwcyA9IGdyb3VwczsgLy8gY3JlYXRlIHRoZSBlZGdlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcblxuICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZSA9IGJpbmQkMihfY29udGV4dCA9IHRoaXMuY3JlYXRlKS5jYWxsKF9jb250ZXh0LCB0aGlzKTtcbiAgICB0aGlzLmVkZ2VzTGlzdGVuZXJzID0ge1xuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy5hZGQocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYXJyb3dzOiB7XG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgc2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICAgIH0sXG4gICAgICAgIC8vIGJvb2xlYW4gLyB7YXJyb3dTY2FsZUZhY3RvcjoxfSAvIHtlbmFibGVkOiBmYWxzZSwgYXJyb3dTY2FsZUZhY3RvcjoxfVxuICAgICAgICBtaWRkbGU6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBzY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5kUG9pbnRPZmZzZXQ6IHtcbiAgICAgICAgZnJvbTogMCxcbiAgICAgICAgdG86IDBcbiAgICAgIH0sXG4gICAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHRydWUsXG4gICAgICBjb2xvcjoge1xuICAgICAgICBjb2xvcjogXCIjODQ4NDg0XCIsXG4gICAgICAgIGhpZ2hsaWdodDogXCIjODQ4NDg0XCIsXG4gICAgICAgIGhvdmVyOiBcIiM4NDg0ODRcIixcbiAgICAgICAgaW5oZXJpdDogXCJmcm9tXCIsXG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfSxcbiAgICAgIGRhc2hlczogZmFsc2UsXG4gICAgICBmb250OiB7XG4gICAgICAgIGNvbG9yOiBcIiMzNDM0MzRcIixcbiAgICAgICAgc2l6ZTogMTQsXG4gICAgICAgIC8vIHB4XG4gICAgICAgIGZhY2U6IFwiYXJpYWxcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAvLyBweFxuICAgICAgICBzdHJva2VDb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICAgIGFsaWduOiBcImhvcml6b250YWxcIixcbiAgICAgICAgbXVsdGk6IGZhbHNlLFxuICAgICAgICB2YWRqdXN0OiAwLFxuICAgICAgICBib2xkOiB7XG4gICAgICAgICAgbW9kOiBcImJvbGRcIlxuICAgICAgICB9LFxuICAgICAgICBib2xkaXRhbDoge1xuICAgICAgICAgIG1vZDogXCJib2xkIGl0YWxpY1wiXG4gICAgICAgIH0sXG4gICAgICAgIGl0YWw6IHtcbiAgICAgICAgICBtb2Q6IFwiaXRhbGljXCJcbiAgICAgICAgfSxcbiAgICAgICAgbW9ubzoge1xuICAgICAgICAgIG1vZDogXCJcIixcbiAgICAgICAgICBzaXplOiAxNSxcbiAgICAgICAgICAvLyBweFxuICAgICAgICAgIGZhY2U6IFwiY291cmllciBuZXdcIixcbiAgICAgICAgICB2YWRqdXN0OiAyXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgaG92ZXJXaWR0aDogMS41LFxuICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAgIGxlbmd0aDogdW5kZWZpbmVkLFxuICAgICAgcGh5c2ljczogdHJ1ZSxcbiAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgbWluOiAxLFxuICAgICAgICBtYXg6IDE1LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbWluOiAxNCxcbiAgICAgICAgICBtYXg6IDMwLFxuICAgICAgICAgIG1heFZpc2libGU6IDMwLFxuICAgICAgICAgIGRyYXdUaHJlc2hvbGQ6IDVcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiBmdW5jdGlvbiBjdXN0b21TY2FsaW5nRnVuY3Rpb24obWluLCBtYXgsIHRvdGFsLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gMSAvIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2VsZWN0aW9uV2lkdGg6IDEuNSxcbiAgICAgIHNlbGZSZWZlcmVuY2U6IHtcbiAgICAgICAgc2l6ZTogMjAsXG4gICAgICAgIGFuZ2xlOiBNYXRoLlBJIC8gNCxcbiAgICAgICAgcmVuZGVyQmVoaW5kVGhlTm9kZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICAgIHNpemU6IDEwLFxuICAgICAgICB4OiA1LFxuICAgICAgICB5OiA1XG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IFwicmdiYSgxMTEsMTExLDExMSwxKVwiLFxuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgZGFzaGVzOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNtb290aDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICB0eXBlOiBcImR5bmFtaWNcIixcbiAgICAgICAgZm9yY2VEaXJlY3Rpb246IFwibm9uZVwiLFxuICAgICAgICByb3VuZG5lc3M6IDAuNVxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGRlZXBFeHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhFZGdlc0hhbmRsZXIsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcyxcbiAgICAgICAgICBfY29udGV4dDIsXG4gICAgICAgICAgX2NvbnRleHQzO1xuXG4gICAgICAvLyB0aGlzIGFsbG93cyBleHRlcm5hbCBtb2R1bGVzIHRvIGZvcmNlIGFsbCBkeW5hbWljIGN1cnZlcyB0byB0dXJuIHN0YXRpYy5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIiwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgdHlwZSA9IFwiY29udGludW91c1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIF90aGlzMi5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfdGhpczIuYm9keS5lZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczIuYm9keS5lZGdlc1tlZGdlSWRdO1xuXG4gICAgICAgICAgICB2YXIgZWRnZURhdGEgPSBfdGhpczIuYm9keS5kYXRhLmVkZ2VzLmdldChlZGdlSWQpOyAvLyBvbmx5IGZvcmNpYmx5IHJlbW92ZSB0aGUgc21vb3RoIGN1cnZlIGlmIHRoZSBkYXRhIGhhcyBiZWVuIHNldCBvZiB0aGUgZWRnZSBoYXMgdGhlIHNtb290aCBjdXJ2ZXMgZGVmaW5lZC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBhIGNoYW5nZSBpbiB0aGUgZ2xvYmFsIHdvdWxkIG5vdCBhZmZlY3QgdGhlc2UgY3VydmVzLlxuXG5cbiAgICAgICAgICAgIGlmIChlZGdlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBzbW9vdGhPcHRpb25zID0gZWRnZURhdGEuc21vb3RoO1xuXG4gICAgICAgICAgICAgIGlmIChzbW9vdGhPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoT3B0aW9ucy5lbmFibGVkID09PSB0cnVlICYmIHNtb290aE9wdGlvbnMudHlwZSA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICBzbW9vdGg6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVtaXQgPT09IHRydWUgJiYgZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIG9wdGlvbnMgb2YgRVhJU1RJTkcgbm9kZXMgb3IgZWRnZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IE5vdCB0cnVlLCBjYWxsZWQgd2hlbiBvcHRpb25zIGhhdmUgTk9UIGNoYW5nZWQsIGZvciBib3RoIGV4aXN0aW5nIGFzIHdlbGwgYXMgbmV3IG5vZGVzLlxuICAgICAgLy8gICAgICAgU2VlIHVwZGF0ZSgpIGZvciBsb2dpYy5cbiAgICAgIC8vIFRPRE86IFZlcmlmeSBhbmQgZXhhbWluZSB0aGUgY29uc2VxdWVuY2VzIG9mIHRoaXMuIEl0IG1pZ2h0IHN0aWxsIHRyaWdnZXIgd2hlblxuICAgICAgLy8gICAgICAgbm9uLW9wdGlvbiBmaWVsZHMgaGF2ZSBjaGFuZ2VkLCBidXQgdGhlbiByZWNvbm5lY3RpbmcgZWRnZXMgaXMgc3RpbGwgdXNlbGVzcy5cbiAgICAgIC8vICAgICAgIEFsdGVybmF0aXZlbHksIGl0IG1pZ2h0IGFsc28gYmUgY2FsbGVkIHdoZW4gZWRnZXMgYXJlIHJlbW92ZWQuXG4gICAgICAvL1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhVXBkYXRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5yZWNvbm5lY3RFZGdlcygpO1xuICAgICAgfSk7IC8vIHJlZnJlc2ggdGhlIGVkZ2VzLiBVc2VkIHdoZW4gcmV2ZXJ0aW5nIGZyb20gaGllcmFyY2hpY2FsIGxheW91dFxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlZnJlc2hFZGdlc1wiLCBiaW5kJDIoX2NvbnRleHQyID0gdGhpcy5yZWZyZXNoKS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoXCIsIGJpbmQkMihfY29udGV4dDMgPSB0aGlzLnJlZnJlc2gpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3JFYWNoJDMoX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5ib2R5LmRhdGEuZWRnZXMpIF90aGlzMi5ib2R5LmRhdGEuZWRnZXMub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2U7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMuYWRkO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLnVwZGF0ZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy5yZW1vdmU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnM7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBwYXJzZXIgZnJvbSB0aGUgRWRnZSBjbGFzcyB0byBmaWxsIGluIGFsbCBzaG9ydGhhbmQgbm90YXRpb25zXG4gICAgICAgIEVkZ2UucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgdHJ1ZSwgdGhpcy5kZWZhdWx0T3B0aW9ucywgdHJ1ZSk7IC8vIHVwZGF0ZSBzbW9vdGggc2V0dGluZ3MgaW4gYWxsIGVkZ2VzXG5cbiAgICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc21vb3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLnVwZGF0ZUVkZ2VUeXBlKCkgfHwgZGF0YUNoYW5nZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSBmb250cyBpbiBhbGwgZWRnZXNcblxuXG4gICAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIF9lZGdlSWQgaW4gdGhpcy5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcywgX2VkZ2VJZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW19lZGdlSWRdLnVwZGF0ZUxhYmVsTW9kdWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIHZhcmlhYmxlcyBpZiBuZWVkZWRcblxuXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkIHx8IGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIGVkZ2VzIGJ5IHJlYWRpbmcgdGhlIGRhdGEgdGFibGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IGVkZ2VzICAgIFRoZSBkYXRhIGNvbnRhaW5pbmcgdGhlIGVkZ2VzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90RW1pdD1mYWxzZV0gLSBTdXBwcmVzcyBkYXRhIGNoYW5nZWQgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShlZGdlcykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIG9sZEVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuXG4gICAgICBpZiAoaXNEYXRhVmlld0xpa2UoXCJpZFwiLCBlZGdlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBlZGdlcztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQ1KGVkZ2VzKSkge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmFkZChlZGdlcyk7XG4gICAgICB9IGVsc2UgaWYgKCFlZGdlcykge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcyA9IG5ldyBEYXRhU2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXkgb3IgRGF0YVNldCBleHBlY3RlZFwiKTtcbiAgICAgIH0gLy8gVE9ETzogaXMgdGhpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZT9cblxuXG4gICAgICBpZiAob2xkRWRnZXNEYXRhKSB7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gb2xkIGRhdGFzZXRcbiAgICAgICAgZm9yRWFjaCQzKHRoaXMuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBvbGRFZGdlc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyByZW1vdmUgZHJhd24gZWRnZXNcblxuXG4gICAgICB0aGlzLmJvZHkuZWRnZXMgPSB7fTsgLy8gVE9ETzogaXMgdGhpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBmYWxzZT9cblxuICAgICAgaWYgKHRoaXMuYm9keS5kYXRhLmVkZ2VzKSB7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgICBmb3JFYWNoJDModGhpcy5lZGdlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmRhdGEuZWRnZXMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7IC8vIGRyYXcgYWxsIG5ldyBub2Rlc1xuXG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXRJZHMoKTtcbiAgICAgICAgdGhpcy5hZGQoaWRzLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiKTtcblxuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90RW1pdD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpZHMpIHtcbiAgICAgIHZhciBkb05vdEVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBvbGRFZGdlID0gZWRnZXNbaWRdO1xuXG4gICAgICAgIGlmIChvbGRFZGdlKSB7XG4gICAgICAgICAgb2xkRWRnZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IGVkZ2VzRGF0YS5nZXQoaWQsIHtcbiAgICAgICAgICBzaG93SW50ZXJuYWxJZHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGVkZ2VzW2lkXSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIpO1xuXG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhpc3RpbmcgZWRnZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShpZHMpIHtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBlZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcbiAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBkYXRhID0gZWRnZXNEYXRhLmdldChpZCk7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuXG4gICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgZWRnZVxuICAgICAgICAgIGVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIGRhdGFDaGFuZ2VkID0gZWRnZS5zZXRPcHRpb25zKGRhdGEpIHx8IGRhdGFDaGFuZ2VkOyAvLyBpZiBhIHN1cHBvcnQgbm9kZSBpcyBhZGRlZCwgZGF0YSBjYW4gYmUgY2hhbmdlZC5cblxuICAgICAgICAgIGVkZ2UuY29ubmVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSBlZGdlXG4gICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2lkXSA9IHRoaXMuY3JlYXRlKGRhdGEpO1xuICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBleGlzdGluZyBlZGdlcy4gTm9uIGV4aXN0aW5nIGlkcyB3aWxsIGJlIGlnbm9yZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gaWRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZW1pdD10cnVlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGlkcykge1xuICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBlYXJseSBvdXRcblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgZm9yRWFjaCQzKGlkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuXG4gICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIEVkZ2UgSGFuZGxlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGZvckVhY2gkMyh0aGlzLmJvZHkuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfdGhpczQuYm9keS5kYXRhLmVkZ2VzLmdldChlZGdlSWQpO1xuXG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybnMge0VkZ2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgRWRnZShwcm9wZXJ0aWVzLCB0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvbm5lY3QgYWxsIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVjb25uZWN0RWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb25uZWN0RWRnZXMoKSB7XG4gICAgICB2YXIgaWQ7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG5cbiAgICAgIGZvciAoaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlcywgaWQpKSB7XG4gICAgICAgICAgbm9kZXNbaWRdLmVkZ2VzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpZCBpbiBlZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVkZ2VzLCBpZCkpIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2lkXTtcbiAgICAgICAgICBlZGdlLmZyb20gPSBudWxsO1xuICAgICAgICAgIGVkZ2UudG8gPSBudWxsO1xuICAgICAgICAgIGVkZ2UuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlLmlkfSBlZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25uZWN0ZWROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWROb2RlcyhlZGdlSWQpIHtcbiAgICAgIHZhciBub2RlTGlzdCA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdO1xuXG4gICAgICAgIGlmIChlZGdlLmZyb21JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLmZyb21JZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWRnZS50b0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UudG9JZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGVyZSBpcyBubyBkaXJlY3QgcmVsYXRpb24gYmV0d2VlbiB0aGUgbm9kZXMgYW5kIHRoZSBlZGdlcyBEYXRhU2V0LFxuICAgICAqIHNvIHRoZSByaWdodCBwbGFjZSB0byBkbyBjYWxsIHRoaXMgaXMgaW4gdGhlIGhhbmRsZXIgZm9yIGV2ZW50IGBfZGF0YVVwZGF0ZWRgLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVTdGF0ZSgpIHtcbiAgICAgIHRoaXMuX2FkZE1pc3NpbmdFZGdlcygpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVJbnZhbGlkRWRnZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbiBmb3IgbWlzc2luZyBub2RlcyBhbmQgcmVtb3ZlIGNvcnJlc3BvbmRpbmcgZWRnZXMsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlSW52YWxpZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVJbnZhbGlkRWRnZXMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGVkZ2VzVG9EZWxldGUgPSBbXTtcbiAgICAgIGZvckVhY2gkMyh0aGlzLmJvZHkuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBpZCkge1xuICAgICAgICB2YXIgdG9Ob2RlID0gX3RoaXM1LmJvZHkubm9kZXNbZWRnZS50b0lkXTtcbiAgICAgICAgdmFyIGZyb21Ob2RlID0gX3RoaXM1LmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdOyAvLyBTa2lwIGNsdXN0ZXJpbmcgZWRnZXMgaGVyZSwgbGV0IHRoZSBDbHVzdGVyaW5nIG1vZHVsZSBoYW5kbGUgdGhvc2VcblxuICAgICAgICBpZiAodG9Ob2RlICE9PSB1bmRlZmluZWQgJiYgdG9Ob2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSB8fCBmcm9tTm9kZSAhPT0gdW5kZWZpbmVkICYmIGZyb21Ob2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b05vZGUgPT09IHVuZGVmaW5lZCB8fCBmcm9tTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZXNUb0RlbGV0ZS5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbW92ZShlZGdlc1RvRGVsZXRlLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFkZCBhbGwgZWRnZXMgZnJvbSBkYXRhc2V0IHRoYXQgYXJlIG5vdCBpbiB0aGUgY2FjaGVkIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZE1pc3NpbmdFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkTWlzc2luZ0VkZ2VzKCkge1xuICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuXG4gICAgICBpZiAoZWRnZXNEYXRhID09PSB1bmRlZmluZWQgfHwgZWRnZXNEYXRhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjsgLy8gTm8gZWRnZXMgRGF0YVNldCB5ZXQ7IGNhbiBoYXBwZW4gb24gc3RhcnR1cFxuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgYWRkSWRzID0gW107XG5cbiAgICAgIGZvckVhY2gkMihlZGdlc0RhdGEpLmNhbGwoZWRnZXNEYXRhLCBmdW5jdGlvbiAoZWRnZURhdGEsIGVkZ2VJZCkge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZElkcy5wdXNoKGVkZ2VJZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFkZChhZGRJZHMsIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFZGdlc0hhbmRsZXI7XG59KCk7XG5cbi8qKlxuICogQmFybmVzIEh1dCBTb2x2ZXJcbiAqL1xuXG52YXIgQmFybmVzSHV0U29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEJhcm5lc0h1dFNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJhcm5lc0h1dFNvbHZlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLmJhcm5lc0h1dFRyZWU7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuX3JuZyA9IEFsZWEoXCJCQVJORVMgSFVUIFNPTFZFUlwiKTsgLy8gZGVidWc6IHNob3cgZ3JpZFxuICAgIC8vIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiYWZ0ZXJEcmF3aW5nXCIsIChjdHgpID0+IHt0aGlzLl9kZWJ1ZyhjdHgsJyNmZjAwMDAnKX0pXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoQmFybmVzSHV0U29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMudGhldGFJbnZlcnNlZCA9IDEgLyB0aGlzLm9wdGlvbnMudGhldGE7IC8vIGlmIDEgdGhlbiBtaW4gZGlzdGFuY2UgPSAwLjUsIGlmIDAuNSB0aGVuIG1pbiBkaXN0YW5jZSA9IDAuNSArIDAuNSpub2RlLnNoYXBlLnJhZGl1c1xuXG4gICAgICB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPSAxIC0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy5vcHRpb25zLmF2b2lkT3ZlcmxhcCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIGdyYXZpdGF0aW9uYWwgbW9kZWwuXG4gICAgICogVGhlIEJhcm5lcyBIdXQgbWV0aG9kIGlzIHVzZWQgdG8gc3BlZWQgdXAgdGhpcyBOLWJvZHkgc2ltdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICE9PSAwICYmIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlQ291bnQgPSBub2RlSW5kaWNlcy5sZW5ndGg7IC8vIGNyZWF0ZSB0aGUgdHJlZVxuXG4gICAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0gdGhpcy5fZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKTsgLy8gZm9yIGRlYnVnZ2luZ1xuXG5cbiAgICAgICAgdGhpcy5iYXJuZXNIdXRUcmVlID0gYmFybmVzSHV0VHJlZTsgLy8gcGxhY2UgdGhlIG5vZGVzIG9uZSBieSBvbmUgcmVjdXJzaXZlbHlcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcblxuICAgICAgICAgIGlmIChub2RlLm9wdGlvbnMubWFzcyA+IDApIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHdpdGggcm9vdCBpcyBpcnJlbGV2YW50LCBpdCBuZXZlciBwYXNzZXMgdGhlIEJhcm5lc0h1dFNvbHZlciBjb25kaXRpb25cbiAgICAgICAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9ucyhiYXJuZXNIdXRUcmVlLnJvb3QsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRGb3JjZUNvbnRyaWJ1dGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZvcmNlQ29udHJpYnV0aW9ucyhwYXJlbnRCcmFuY2gsIG5vZGUpIHtcbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5OVywgbm9kZSk7XG5cbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5ORSwgbm9kZSk7XG5cbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5TVywgbm9kZSk7XG5cbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5TRSwgbm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdHJhdmVyc2VzIHRoZSBiYXJuZXNIdXRUcmVlLiBJdCBjaGVja3Mgd2hlbiBpdCBjYW4gYXBwcm94aW1hdGUgZGlzdGFudCBub2RlcyB3aXRoIHRoZWlyIGNlbnRlciBvZiBtYXNzLlxuICAgICAqIElmIGEgcmVnaW9uIGNvbnRhaW5zIGEgc2luZ2xlIG5vZGUsIHdlIGNoZWNrIGlmIGl0IGlzIG5vdCBpdHNlbGYsIHRoZW4gd2UgYXBwbHkgdGhlIGZvcmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Rm9yY2VDb250cmlidXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgLy8gd2UgZ2V0IG5vIGZvcmNlIGNvbnRyaWJ1dGlvbiBmcm9tIGFuIGVtcHR5IHJlZ2lvblxuICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbkNvdW50ID4gMCkge1xuICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBub2RlLlxuICAgICAgICB2YXIgZHggPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnggLSBub2RlLng7XG4gICAgICAgIHZhciBkeSA9IHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueSAtIG5vZGUueTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTsgLy8gQmFybmVzSHV0U29sdmVyIGNvbmRpdGlvblxuICAgICAgICAvLyBvcmlnaW5hbCBjb25kaXRpb24gOiBzL2QgPCB0aGV0YSA9IHBhc3NlZCAgPT09ICBkL3MgPiAxL3RoZXRhID0gcGFzc2VkXG4gICAgICAgIC8vIGNhbGNTaXplID0gMS9zIC0tPiBkICogMS9zID4gMS90aGV0YSA9IHBhc3NlZFxuXG4gICAgICAgIGlmIChkaXN0YW5jZSAqIHBhcmVudEJyYW5jaC5jYWxjU2l6ZSA+IHRoaXMudGhldGFJbnZlcnNlZCkge1xuICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZUZvcmNlcyhkaXN0YW5jZSwgZHgsIGR5LCBub2RlLCBwYXJlbnRCcmFuY2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpZCBub3QgcGFzcyB0aGUgY29uZGl0aW9uLCBnbyBpbnRvIGNoaWxkcmVuIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb25zKHBhcmVudEJyYW5jaCwgbm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcmVudEJyYW5jaCBtdXN0IGhhdmUgb25seSBvbmUgbm9kZSwgaWYgaXQgd2FzIGVtcHR5IHdlIHdvdWxkbnQgYmUgaGVyZVxuICAgICAgICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5kYXRhLmlkICE9IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgbm90IHNlbGZcbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCkge1xuICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgIGRpc3RhbmNlID0gMC4xO1xuICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yIDwgMSAmJiBub2RlLnNoYXBlLnJhZGl1cykge1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGgubWF4KDAuMSArIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciAqIG5vZGUuc2hhcGUucmFkaXVzLCBkaXN0YW5jZSAtIG5vZGUuc2hhcGUucmFkaXVzKTtcbiAgICAgIH0gLy8gdGhlIGRpdmlkaW5nIGJ5IHRoZSBkaXN0YW5jZSBjdWJlZCBpbnN0ZWFkIG9mIHNxdWFyZWQgYWxsb3dzIHVzIHRvIGdldCB0aGUgZnggYW5kIGZ5IGNvbXBvbmVudHMgd2l0aG91dCBzaW5lcyBhbmQgY29zaW5lc1xuICAgICAgLy8gaXQgaXMgc2hvcnRoYW5kIGZvciBncmF2aXR5Zm9yY2Ugd2l0aCBkaXN0YW5jZSBzcXVhcmVkIGFuZCBmeCA9IGR4L2Rpc3RhbmNlICogZ3Jhdml0eUZvcmNlXG5cblxuICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgKiBwYXJlbnRCcmFuY2gubWFzcyAqIG5vZGUub3B0aW9ucy5tYXNzIC8gTWF0aC5wb3coZGlzdGFuY2UsIDMpO1xuICAgICAgdmFyIGZ4ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICB2YXIgZnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnggKz0gZng7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS55ICs9IGZ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnN0cnVjdHMgdGhlIGJhcm5lc0h1dCB0cmVlIHJlY3Vyc2l2ZWx5LiBJdCBjcmVhdGVzIHRoZSByb290LCBzcGxpdHMgaXQgYW5kIHN0YXJ0cyBwbGFjaW5nIHRoZSBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG5vZGVJbmRpY2VzXG4gICAgICogQHJldHVybnMge3tyb290OiB7Y2VudGVyT2ZNYXNzOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LCBtYXNzOiBudW1iZXIsIHJhbmdlOiB7bWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyfSwgc2l6ZTogbnVtYmVyLCBjYWxjU2l6ZTogbnVtYmVyLCBjaGlsZHJlbjoge2RhdGE6IG51bGx9LCBtYXhXaWR0aDogbnVtYmVyLCBsZXZlbDogbnVtYmVyLCBjaGlsZHJlbkNvdW50OiBudW1iZXJ9fX0gQmFybmVzSHV0VHJlZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZm9ybUJhcm5lc0h1dFRyZWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Zvcm1CYXJuZXNIdXRUcmVlKG5vZGVzLCBub2RlSW5kaWNlcykge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgdmFyIG1pblggPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueDtcbiAgICAgIHZhciBtaW5ZID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLnk7XG4gICAgICB2YXIgbWF4WCA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS54O1xuICAgICAgdmFyIG1heFkgPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueTsgLy8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgbm9kZXNcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIHZhciB4ID0gX25vZGUueDtcbiAgICAgICAgdmFyIHkgPSBfbm9kZS55O1xuXG4gICAgICAgIGlmIChfbm9kZS5vcHRpb25zLm1hc3MgPiAwKSB7XG4gICAgICAgICAgaWYgKHggPCBtaW5YKSB7XG4gICAgICAgICAgICBtaW5YID0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICAgIG1heFggPSB4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgbWluWSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgICBtYXhZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbWFrZSB0aGUgcmFuZ2UgYSBzcXVhcmVcblxuXG4gICAgICB2YXIgc2l6ZURpZmYgPSBNYXRoLmFicyhtYXhYIC0gbWluWCkgLSBNYXRoLmFicyhtYXhZIC0gbWluWSk7IC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBYIGFuZCBZXG5cbiAgICAgIGlmIChzaXplRGlmZiA+IDApIHtcbiAgICAgICAgbWluWSAtPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgbWF4WSArPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgIH0gLy8geFNpemUgPiB5U2l6ZVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgbWluWCArPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgICBtYXhYIC09IDAuNSAqIHNpemVEaWZmO1xuICAgICAgICB9IC8vIHhTaXplIDwgeVNpemVcblxuXG4gICAgICB2YXIgbWluaW11bVRyZWVTaXplID0gMWUtNTtcbiAgICAgIHZhciByb290U2l6ZSA9IE1hdGgubWF4KG1pbmltdW1UcmVlU2l6ZSwgTWF0aC5hYnMobWF4WCAtIG1pblgpKTtcbiAgICAgIHZhciBoYWxmUm9vdFNpemUgPSAwLjUgKiByb290U2l6ZTtcbiAgICAgIHZhciBjZW50ZXJYID0gMC41ICogKG1pblggKyBtYXhYKSxcbiAgICAgICAgICBjZW50ZXJZID0gMC41ICogKG1pblkgKyBtYXhZKTsgLy8gY29uc3RydWN0IHRoZSBiYXJuZXNIdXRUcmVlXG5cbiAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0ge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgY2VudGVyT2ZNYXNzOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFzczogMCxcbiAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgbWluWDogY2VudGVyWCAtIGhhbGZSb290U2l6ZSxcbiAgICAgICAgICAgIG1heFg6IGNlbnRlclggKyBoYWxmUm9vdFNpemUsXG4gICAgICAgICAgICBtaW5ZOiBjZW50ZXJZIC0gaGFsZlJvb3RTaXplLFxuICAgICAgICAgICAgbWF4WTogY2VudGVyWSArIGhhbGZSb290U2l6ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2l6ZTogcm9vdFNpemUsXG4gICAgICAgICAgY2FsY1NpemU6IDEgLyByb290U2l6ZSxcbiAgICAgICAgICBjaGlsZHJlbjoge1xuICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgY2hpbGRyZW5Db3VudDogNFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zcGxpdEJyYW5jaChiYXJuZXNIdXRUcmVlLnJvb3QpOyAvLyBwbGFjZSB0aGUgbm9kZXMgb25lIGJ5IG9uZSByZWN1cnNpdmVseVxuXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlQ291bnQ7IF9pKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW19pXV07XG5cbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGJhcm5lc0h1dFRyZWUucm9vdCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbWFrZSBnbG9iYWxcblxuXG4gICAgICByZXR1cm4gYmFybmVzSHV0VHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhpcyB1cGRhdGVzIHRoZSBtYXNzIG9mIGEgYnJhbmNoLiB0aGlzIGlzIGluY3JlYXNlZCBieSBhZGRpbmcgYSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQnJhbmNoTWFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2gsIG5vZGUpIHtcbiAgICAgIHZhciBjZW50ZXJPZk1hc3MgPSBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzO1xuICAgICAgdmFyIHRvdGFsTWFzcyA9IHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICB2YXIgdG90YWxNYXNzSW52ID0gMSAvIHRvdGFsTWFzcztcbiAgICAgIGNlbnRlck9mTWFzcy54ID0gY2VudGVyT2ZNYXNzLnggKiBwYXJlbnRCcmFuY2gubWFzcyArIG5vZGUueCAqIG5vZGUub3B0aW9ucy5tYXNzO1xuICAgICAgY2VudGVyT2ZNYXNzLnggKj0gdG90YWxNYXNzSW52O1xuICAgICAgY2VudGVyT2ZNYXNzLnkgPSBjZW50ZXJPZk1hc3MueSAqIHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS55ICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICBjZW50ZXJPZk1hc3MueSAqPSB0b3RhbE1hc3NJbnY7XG4gICAgICBwYXJlbnRCcmFuY2gubWFzcyA9IHRvdGFsTWFzcztcbiAgICAgIHZhciBiaWdnZXN0U2l6ZSA9IE1hdGgubWF4KE1hdGgubWF4KG5vZGUuaGVpZ2h0LCBub2RlLnJhZGl1cyksIG5vZGUud2lkdGgpO1xuICAgICAgcGFyZW50QnJhbmNoLm1heFdpZHRoID0gcGFyZW50QnJhbmNoLm1heFdpZHRoIDwgYmlnZ2VzdFNpemUgPyBiaWdnZXN0U2l6ZSA6IHBhcmVudEJyYW5jaC5tYXhXaWR0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGV0ZXJtaW5lIGluIHdoaWNoIGJyYW5jaCB0aGUgbm9kZSB3aWxsIGJlIHBsYWNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBNYXNzVXBkYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZUluVHJlZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLCBub2RlLCBza2lwTWFzc1VwZGF0ZSkge1xuICAgICAgaWYgKHNraXBNYXNzVXBkYXRlICE9IHRydWUgfHwgc2tpcE1hc3NVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIG1hc3Mgb2YgdGhlIGJyYW5jaC5cbiAgICAgICAgdGhpcy5fdXBkYXRlQnJhbmNoTWFzcyhwYXJlbnRCcmFuY2gsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2UgPSBwYXJlbnRCcmFuY2guY2hpbGRyZW4uTlcucmFuZ2U7XG4gICAgICB2YXIgcmVnaW9uO1xuXG4gICAgICBpZiAocmFuZ2UubWF4WCA+IG5vZGUueCkge1xuICAgICAgICAvLyBpbiBOVyBvciBTV1xuICAgICAgICBpZiAocmFuZ2UubWF4WSA+IG5vZGUueSkge1xuICAgICAgICAgIHJlZ2lvbiA9IFwiTldcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWdpb24gPSBcIlNXXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluIE5FIG9yIFNFXG4gICAgICAgIGlmIChyYW5nZS5tYXhZID4gbm9kZS55KSB7XG4gICAgICAgICAgcmVnaW9uID0gXCJORVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZ2lvbiA9IFwiU0VcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgcmVnaW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWN0dWFsbHkgcGxhY2UgdGhlIG5vZGUgaW4gYSByZWdpb24gKG9yIGJyYW5jaClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0geydOVyd8ICdORScgfCAnU1cnIHwgJ1NFJ30gcmVnaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZUluUmVnaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUluUmVnaW9uKHBhcmVudEJyYW5jaCwgbm9kZSwgcmVnaW9uKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXTtcblxuICAgICAgc3dpdGNoIChjaGlsZHJlbi5jaGlsZHJlbkNvdW50KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAvLyBwbGFjZSBub2RlIGhlcmVcbiAgICAgICAgICBjaGlsZHJlbi5jaGlsZHJlbi5kYXRhID0gbm9kZTtcbiAgICAgICAgICBjaGlsZHJlbi5jaGlsZHJlbkNvdW50ID0gMTtcblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJyYW5jaE1hc3MoY2hpbGRyZW4sIG5vZGUpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIGNvbnZlcnQgaW50byBjaGlsZHJlblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gbm9kZXMgZXhhY3RseSBvdmVybGFwcGluZyAob24gaW5pdCwgb24gb3BlbmluZyBvZiBjbHVzdGVyIGV0Yy4pXG4gICAgICAgICAgLy8gd2UgbW92ZSBvbmUgbm9kZSBhIGxpdHRsZSBiaXQgYW5kIHdlIGRvIG5vdCBwdXQgaXQgaW4gdGhlIHRyZWUuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmNoaWxkcmVuLmRhdGEueCA9PT0gbm9kZS54ICYmIGNoaWxkcmVuLmNoaWxkcmVuLmRhdGEueSA9PT0gbm9kZS55KSB7XG4gICAgICAgICAgICBub2RlLnggKz0gdGhpcy5fcm5nKCk7XG4gICAgICAgICAgICBub2RlLnkgKz0gdGhpcy5fcm5nKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0QnJhbmNoKGNoaWxkcmVuKTtcblxuICAgICAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUoY2hpbGRyZW4sIG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAvLyBwbGFjZSBpbiBicmFuY2hcbiAgICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShjaGlsZHJlbiwgbm9kZSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhpcyBmdW5jdGlvbiBzcGxpdHMgYSBicmFuY2ggaW50byA0IHN1YiBicmFuY2hlcy4gSWYgdGhlIGJyYW5jaCBjb250YWluZWQgYSBub2RlLCB3ZSBwbGFjZSBpdCBpbiB0aGUgc3ViYnJhbmNoXG4gICAgICogYWZ0ZXIgdGhlIHNwbGl0IGlzIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3BsaXRCcmFuY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NwbGl0QnJhbmNoKHBhcmVudEJyYW5jaCkge1xuICAgICAgLy8gaWYgdGhlIGJyYW5jaCBpcyBzaGFkZWQgd2l0aCBhIG5vZGUsIHJlcGxhY2UgdGhlIG5vZGUgaW4gdGhlIG5ldyBzdWJzZXQuXG4gICAgICB2YXIgY29udGFpbmVkTm9kZSA9IG51bGw7XG5cbiAgICAgIGlmIChwYXJlbnRCcmFuY2guY2hpbGRyZW5Db3VudCA9PT0gMSkge1xuICAgICAgICBjb250YWluZWROb2RlID0gcGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGE7XG4gICAgICAgIHBhcmVudEJyYW5jaC5tYXNzID0gMDtcbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy54ID0gMDtcbiAgICAgICAgcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55ID0gMDtcbiAgICAgIH1cblxuICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPSA0O1xuICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGEgPSBudWxsO1xuXG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCBcIk5XXCIpO1xuXG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCBcIk5FXCIpO1xuXG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCBcIlNXXCIpO1xuXG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCBcIlNFXCIpO1xuXG4gICAgICBpZiAoY29udGFpbmVkTm9kZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKHBhcmVudEJyYW5jaCwgY29udGFpbmVkTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3ViZGl2aWRlcyB0aGUgcmVnaW9uIGludG8gZm91ciBuZXcgc2VnbWVudHMuXG4gICAgICogU3BlY2lmaWNhbGx5LCB0aGlzIGluc2VydHMgYSBzaW5nbGUgbmV3IHNlZ21lbnQuXG4gICAgICogSXQgZmlsbHMgdGhlIGNoaWxkcmVuIHNlY3Rpb24gb2YgdGhlIHBhcmVudEJyYW5jaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7J05XJ3wgJ05FJyB8ICdTVycgfCAnU0UnfSByZWdpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luc2VydFJlZ2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgcmVnaW9uKSB7XG4gICAgICB2YXIgbWluWCwgbWF4WCwgbWluWSwgbWF4WTtcbiAgICAgIHZhciBjaGlsZFNpemUgPSAwLjUgKiBwYXJlbnRCcmFuY2guc2l6ZTtcblxuICAgICAgc3dpdGNoIChyZWdpb24pIHtcbiAgICAgICAgY2FzZSBcIk5XXCI6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJORVwiOlxuICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFg7XG4gICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZO1xuICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiU1dcIjpcbiAgICAgICAgICBtaW5YID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblg7XG4gICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWSArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtYXhZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1heFk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlNFXCI6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WDtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRCcmFuY2guY2hpbGRyZW5bcmVnaW9uXSA9IHtcbiAgICAgICAgY2VudGVyT2ZNYXNzOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1hc3M6IDAsXG4gICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgbWluWDogbWluWCxcbiAgICAgICAgICBtYXhYOiBtYXhYLFxuICAgICAgICAgIG1pblk6IG1pblksXG4gICAgICAgICAgbWF4WTogbWF4WVxuICAgICAgICB9LFxuICAgICAgICBzaXplOiAwLjUgKiBwYXJlbnRCcmFuY2guc2l6ZSxcbiAgICAgICAgY2FsY1NpemU6IDIgKiBwYXJlbnRCcmFuY2guY2FsY1NpemUsXG4gICAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgbGV2ZWw6IHBhcmVudEJyYW5jaC5sZXZlbCArIDEsXG4gICAgICAgIGNoaWxkcmVuQ291bnQ6IDBcbiAgICAgIH07XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgREVCVUdHSU5HIEJFTE9XICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VkLCBpdCBkcmF3cyB0aGUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlYnVnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWJ1ZyhjdHgsIGNvbG9yKSB7XG4gICAgICBpZiAodGhpcy5iYXJuZXNIdXRUcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaCh0aGlzLmJhcm5lc0h1dFRyZWUucm9vdCwgY3R4LCBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gSXQgZHJhd3MgdGhlIGJyYW5jaGVzIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJyYW5jaFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdCcmFuY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdCcmFuY2goYnJhbmNoLCBjdHgsIGNvbG9yKSB7XG4gICAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2xvciA9IFwiI0ZGMDAwMFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnJhbmNoLmNoaWxkcmVuQ291bnQgPT09IDQpIHtcbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uTlcsIGN0eCk7XG5cbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uTkUsIGN0eCk7XG5cbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uU0UsIGN0eCk7XG5cbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uU1csIGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgLypcbiAgICAgICBpZiAoYnJhbmNoLm1hc3MgPiAwKSB7XG4gICAgICAgY3R4LmNpcmNsZShicmFuY2guY2VudGVyT2ZNYXNzLngsIGJyYW5jaC5jZW50ZXJPZk1hc3MueSwgMypicmFuY2gubWFzcyk7XG4gICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgIH1cbiAgICAgICAqL1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXJuZXNIdXRTb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogUmVwdWxzaW9uIFNvbHZlclxuICovXG5cbnZhciBSZXB1bHNpb25Tb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gUmVwdWxzaW9uU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwdWxzaW9uU29sdmVyKTtcblxuICAgIHRoaXMuX3JuZyA9IEFsZWEoXCJSRVBVTFNJT04gU09MVkVSXCIpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhSZXB1bHNpb25Tb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyB0aGUgbm9kZXMgYXBwbHkgb24gZWFjaCBvdGhlciBiYXNlZCBvbiBhIHJlcHVsc2lvbiBmaWVsZC5cbiAgICAgKiBUaGlzIGZpZWxkIGlzIGxpbmVhcmx5IGFwcHJveGltYXRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBkeCwgZHksIGRpc3RhbmNlLCBmeCwgZnksIHJlcHVsc2luZ0ZvcmNlLCBub2RlMSwgbm9kZTI7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlczsgLy8gcmVwdWxzaW5nIGZvcmNlcyBiZXR3ZWVuIG5vZGVzXG5cbiAgICAgIHZhciBub2RlRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlOyAvLyBhcHByb3hpbWF0aW9uIGNvbnN0YW50c1xuXG4gICAgICB2YXIgYSA9IC0yIC8gMyAvIG5vZGVEaXN0YW5jZTtcbiAgICAgIHZhciBiID0gNCAvIDM7IC8vIHdlIGxvb3AgZnJvbSBpIG92ZXIgYWxsIGJ1dCB0aGUgbGFzdCBlbnRyZWUgaW4gdGhlIGFycmF5XG4gICAgICAvLyBqIGxvb3BzIGZyb20gaSsxIHRvIHRoZSBsYXN0LiBUaGlzIHdheSB3ZSBkbyBub3QgZG91YmxlIGNvdW50IGFueSBvZiB0aGUgaW5kaWNlcywgbm9yIGkgPT09IGpcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbm9kZTEgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbm9kZUluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBub2RlMiA9IG5vZGVzW25vZGVJbmRpY2VzW2pdXTtcbiAgICAgICAgICBkeCA9IG5vZGUyLnggLSBub2RlMS54O1xuICAgICAgICAgIGR5ID0gbm9kZTIueSAtIG5vZGUxLnk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpOyAvLyBzYW1lIGNvbmRpdGlvbiBhcyBCYXJuZXNIdXRTb2x2ZXIsIG1ha2luZyBzdXJlIG5vZGVzIGFyZSBuZXZlciAxMDAlIG92ZXJsYXBwaW5nLlxuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IDAuMSAqIHRoaXMuX3JuZygpO1xuICAgICAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAyICogbm9kZURpc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAwLjUgKiBub2RlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAxLjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IGEgKiBkaXN0YW5jZSArIGI7IC8vIGxpbmVhciBhcHByb3ggb2YgIDEgLyAoMSArIE1hdGguZXhwKChkaXN0YW5jZSAvIG5vZGVEaXN0YW5jZSAtIDEpICogc3RlZXBuZXNzKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSByZXB1bHNpbmdGb3JjZSAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgZnggPSBkeCAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgZnkgPSBkeSAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS54IC09IGZ4O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS55IC09IGZ5O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS54ICs9IGZ4O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS55ICs9IGZ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXB1bHNpb25Tb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIFJlcHVsc2lvbiBTb2x2ZXJcbiAqL1xudmFyIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0aGlzLm9wdGlvbnMuYXZvaWRPdmVybGFwIHx8IDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgdGhlIG5vZGVzIGFwcGx5IG9uIGVhY2ggb3RoZXIgYmFzZWQgb24gYSByZXB1bHNpb24gZmllbGQuXG4gICAgICogVGhpcyBmaWVsZCBpcyBsaW5lYXJseSBhcHByb3hpbWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBmb3JjZXMgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlczsgLy8gcmVwdWxzaW5nIGZvcmNlcyBiZXR3ZWVuIG5vZGVzXG5cbiAgICAgIHZhciBub2RlRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlOyAvLyB3ZSBsb29wIGZyb20gaSBvdmVyIGFsbCBidXQgdGhlIGxhc3QgZW50cmVlIGluIHRoZSBhcnJheVxuICAgICAgLy8gaiBsb29wcyBmcm9tIGkrMSB0byB0aGUgbGFzdC4gVGhpcyB3YXkgd2UgZG8gbm90IGRvdWJsZSBjb3VudCBhbnkgb2YgdGhlIGluZGljZXMsIG5vciBpID09PSBqXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlMSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBub2RlSW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBub2RlMiA9IG5vZGVzW25vZGVJbmRpY2VzW2pdXTsgLy8gbm9kZXMgb25seSBhZmZlY3Qgbm9kZXMgb24gdGhlaXIgbGV2ZWxcblxuICAgICAgICAgIGlmIChub2RlMS5sZXZlbCA9PT0gbm9kZTIubGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciB0aGVzZU5vZGVzRGlzdGFuY2UgPSBub2RlRGlzdGFuY2UgKyB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgKiAoKG5vZGUxLnNoYXBlLnJhZGl1cyB8fCAwKSAvIDIgKyAobm9kZTIuc2hhcGUucmFkaXVzIHx8IDApIC8gMik7XG4gICAgICAgICAgICB2YXIgZHggPSBub2RlMi54IC0gbm9kZTEueDtcbiAgICAgICAgICAgIHZhciBkeSA9IG5vZGUyLnkgLSBub2RlMS55O1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIHZhciBzdGVlcG5lc3MgPSAwLjA1O1xuICAgICAgICAgICAgdmFyIHJlcHVsc2luZ0ZvcmNlID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCB0aGVzZU5vZGVzRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAtTWF0aC5wb3coc3RlZXBuZXNzICogZGlzdGFuY2UsIDIpICsgTWF0aC5wb3coc3RlZXBuZXNzICogdGhlc2VOb2Rlc0Rpc3RhbmNlLCAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcHVsc2luZ0ZvcmNlID0gMDtcbiAgICAgICAgICAgIH0gLy8gbm9ybWFsaXplIGZvcmNlIHdpdGhcblxuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgIT09IDApIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSByZXB1bHNpbmdGb3JjZSAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZnggPSBkeCAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgdmFyIGZ5ID0gZHkgKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyO1xufSgpO1xuXG4vKipcbiAqIFNwcmluZyBTb2x2ZXJcbiAqL1xudmFyIFNwcmluZ1NvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBTcHJpbmdTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTcHJpbmdTb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKFNwcmluZ1NvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3ByaW5nZm9yY2VzIG9uIHRoZSBub2RlcywgYWNjb3VudGluZyBmb3IgdGhlIHN1cHBvcnQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZWRnZUxlbmd0aCwgZWRnZTtcbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIG5vZGUxLCBub2RlMiwgbm9kZTM7IC8vIGZvcmNlcyBjYXVzZWQgYnkgdGhlIGVkZ2VzLCBtb2RlbGxlZCBhcyBzcHJpbmdzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW2ldXTtcblxuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUgJiYgZWRnZS50b0lkICE9PSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgIC8vIG9ubHkgY2FsY3VsYXRlIGZvcmNlcyBpZiBub2RlcyBhcmUgaW4gdGhlIHNhbWUgc2VjdG9yXG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5lZGdlVHlwZS52aWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBlZGdlTGVuZ3RoID0gZWRnZS5vcHRpb25zLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aCA6IGVkZ2Uub3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgIG5vZGUxID0gZWRnZS50bztcbiAgICAgICAgICAgICAgbm9kZTIgPSBlZGdlLmVkZ2VUeXBlLnZpYTtcbiAgICAgICAgICAgICAgbm9kZTMgPSBlZGdlLmZyb207XG5cbiAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3ByaW5nRm9yY2Uobm9kZTEsIG5vZGUyLCAwLjUgKiBlZGdlTGVuZ3RoKTtcblxuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMiwgbm9kZTMsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdGhlICogMS41IGlzIGhlcmUgc28gdGhlIGVkZ2UgbG9va3MgYXMgbGFyZ2UgYXMgYSBzbW9vdGggZWRnZS4gSXQgZG9lcyBub3QgaW5pdGlhbGx5IGJlY2F1c2UgdGhlIHNtb290aCBlZGdlcyB1c2VcbiAgICAgICAgICAgICAgLy8gdGhlIHN1cHBvcnQgbm9kZXMgd2hpY2ggZXhlcnQgYSByZXB1bHNpdmUgZm9yY2Ugb24gdGhlIHRvIGFuZCBmcm9tIG5vZGVzLCBtYWtpbmcgdGhlIGVkZ2UgYXBwZWFyIGxhcmdlci5cbiAgICAgICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggKiAxLjUgOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlKGVkZ2UuZnJvbSwgZWRnZS50bywgZWRnZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGNvZGUgYWN0dWFsbHkgcGVyZm9ybWluZyB0aGUgY2FsY3VsYXRpb24gZm9yIHRoZSBmdW5jdGlvbiBhYm92ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VMZW5ndGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZVNwcmluZ0ZvcmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMSwgbm9kZTIsIGVkZ2VMZW5ndGgpIHtcbiAgICAgIHZhciBkeCA9IG5vZGUxLnggLSBub2RlMi54O1xuICAgICAgdmFyIGR5ID0gbm9kZTEueSAtIG5vZGUyLnk7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLCAwLjAxKTsgLy8gdGhlIDEvZGlzdGFuY2UgaXMgc28gdGhlIGZ4IGFuZCBmeSBjYW4gYmUgY2FsY3VsYXRlZCB3aXRob3V0IHNpbmUgb3IgY29zaW5lLlxuXG4gICAgICB2YXIgc3ByaW5nRm9yY2UgPSB0aGlzLm9wdGlvbnMuc3ByaW5nQ29uc3RhbnQgKiAoZWRnZUxlbmd0aCAtIGRpc3RhbmNlKSAvIGRpc3RhbmNlO1xuICAgICAgdmFyIGZ4ID0gZHggKiBzcHJpbmdGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogc3ByaW5nRm9yY2U7IC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBvbmUgbm9kZSBpcyBub3QgcGFydCBvZiB0aGUgcGh5c2Npc1xuXG4gICAgICBpZiAodGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTEuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTEuaWRdLnggKz0gZng7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXS55ICs9IGZ5O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTIuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTIuaWRdLnggLT0gZng7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXS55IC09IGZ5O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTcHJpbmdTb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIFNwcmluZyBTb2x2ZXJcbiAqL1xudmFyIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3ByaW5nZm9yY2VzIG9uIHRoZSBub2RlcywgYWNjb3VudGluZyBmb3IgdGhlIHN1cHBvcnQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZWRnZUxlbmd0aCwgZWRnZTtcbiAgICAgIHZhciBkeCwgZHksIGZ4LCBmeSwgc3ByaW5nRm9yY2UsIGRpc3RhbmNlO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGZhY3RvciA9IDAuNTtcbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7IC8vIGluaXRpYWxpemUgdGhlIHNwcmluZyBmb3JjZSBjb3VudGVyc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgZm9yY2VzW25vZGVJZF0uc3ByaW5nRnggPSAwO1xuICAgICAgICBmb3JjZXNbbm9kZUlkXS5zcHJpbmdGeSA9IDA7XG4gICAgICB9IC8vIGZvcmNlcyBjYXVzZWQgYnkgdGhlIGVkZ2VzLCBtb2RlbGxlZCBhcyBzcHJpbmdzXG5cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcblxuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBlZGdlTGVuZ3RoID0gZWRnZS5vcHRpb25zLmxlbmd0aCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNwcmluZ0xlbmd0aCA6IGVkZ2Uub3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgZHggPSBlZGdlLmZyb20ueCAtIGVkZ2UudG8ueDtcbiAgICAgICAgICBkeSA9IGVkZ2UuZnJvbS55IC0gZWRnZS50by55O1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlID09PSAwID8gMC4wMSA6IGRpc3RhbmNlOyAvLyB0aGUgMS9kaXN0YW5jZSBpcyBzbyB0aGUgZnggYW5kIGZ5IGNhbiBiZSBjYWxjdWxhdGVkIHdpdGhvdXQgc2luZSBvciBjb3NpbmUuXG5cbiAgICAgICAgICBzcHJpbmdGb3JjZSA9IHRoaXMub3B0aW9ucy5zcHJpbmdDb25zdGFudCAqIChlZGdlTGVuZ3RoIC0gZGlzdGFuY2UpIC8gZGlzdGFuY2U7XG4gICAgICAgICAgZnggPSBkeCAqIHNwcmluZ0ZvcmNlO1xuICAgICAgICAgIGZ5ID0gZHkgKiBzcHJpbmdGb3JjZTtcblxuICAgICAgICAgIGlmIChlZGdlLnRvLmxldmVsICE9IGVkZ2UuZnJvbS5sZXZlbCkge1xuICAgICAgICAgICAgaWYgKGZvcmNlc1tlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0uc3ByaW5nRnggLT0gZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnNwcmluZ0Z5IC09IGZ5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9yY2VzW2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0uc3ByaW5nRnggKz0gZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLmZyb21JZF0uc3ByaW5nRnkgKz0gZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnggLT0gZmFjdG9yICogZng7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnkgLT0gZmFjdG9yICogZnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS54ICs9IGZhY3RvciAqIGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnkgKz0gZmFjdG9yICogZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIG5vcm1hbGl6ZSBzcHJpbmcgZm9yY2VzXG5cblxuICAgICAgc3ByaW5nRm9yY2UgPSAxO1xuICAgICAgdmFyIHNwcmluZ0Z4LCBzcHJpbmdGeTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgX25vZGVJZCA9IG5vZGVJbmRpY2VzW19pMl07XG4gICAgICAgIHNwcmluZ0Z4ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z4KSk7XG4gICAgICAgIHNwcmluZ0Z5ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z5KSk7XG4gICAgICAgIGZvcmNlc1tfbm9kZUlkXS54ICs9IHNwcmluZ0Z4O1xuICAgICAgICBmb3JjZXNbX25vZGVJZF0ueSArPSBzcHJpbmdGeTtcbiAgICAgIH0gLy8gcmV0YWluIGVuZXJneSBiYWxhbmNlXG5cblxuICAgICAgdmFyIHRvdGFsRnggPSAwO1xuICAgICAgdmFyIHRvdGFsRnkgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2RlSW5kaWNlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIHZhciBfbm9kZUlkMiA9IG5vZGVJbmRpY2VzW19pM107XG4gICAgICAgIHRvdGFsRnggKz0gZm9yY2VzW19ub2RlSWQyXS54O1xuICAgICAgICB0b3RhbEZ5ICs9IGZvcmNlc1tfbm9kZUlkMl0ueTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvcnJlY3Rpb25GeCA9IHRvdGFsRnggLyBub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICB2YXIgY29ycmVjdGlvbkZ5ID0gdG90YWxGeSAvIG5vZGVJbmRpY2VzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIgX25vZGVJZDMgPSBub2RlSW5kaWNlc1tfaTRdO1xuICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnggLT0gY29ycmVjdGlvbkZ4O1xuICAgICAgICBmb3JjZXNbX25vZGVJZDNdLnkgLT0gY29ycmVjdGlvbkZ5O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogQ2VudHJhbCBHcmF2aXR5IFNvbHZlclxuICovXG52YXIgQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2VudHJhbEdyYXZpdHlTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGh5c2ljc0JvZHkgPSBwaHlzaWNzQm9keTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGZvcmNlcyBmb3IgZWFjaCBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBkeCwgZHksIGRpc3RhbmNlLCBub2RlO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJbmRpY2VzW2ldO1xuICAgICAgICBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgZHggPSAtbm9kZS54O1xuICAgICAgICBkeSA9IC1ub2RlLnk7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgYmFzZWQgb24gdGhlIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAgICogQHBhcmFtIHtvYmplY3Q8Tm9kZS5pZCwgdmlzLk5vZGU+fSBmb3JjZXNcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSkge1xuICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IGRpc3RhbmNlID09PSAwID8gMCA6IHRoaXMub3B0aW9ucy5jZW50cmFsR3Jhdml0eSAvIGRpc3RhbmNlO1xuICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIGZvcmNlc1tub2RlLmlkXS55ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENlbnRyYWxHcmF2aXR5U29sdmVyO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRwKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2YkNShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2YkNSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0JDMoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QkMykgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0JDMuc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbnN0cnVjdCQzKERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBAYXVnbWVudHMgQmFybmVzSHV0U29sdmVyXG4gKi9cblxudmFyIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXJuZXNIdXRTb2x2ZXIpIHtcbiAgaW5oZXJpdHMoRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlciwgX0Jhcm5lc0h1dFNvbHZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRwKEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge3twaHlzaWNzTm9kZUluZGljZXM6IEFycmF5LCBwaHlzaWNzRWRnZUluZGljZXM6IEFycmF5LCBmb3JjZXM6IHt9LCB2ZWxvY2l0aWVzOiB7fX19IHBoeXNpY3NCb2R5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICBfdGhpcy5fcm5nID0gQWxlYShcIkZPUkNFIEFUTEFTIDIgQkFTRUQgUkVQVUxTSU9OIFNPTFZFUlwiKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyLCBbe1xuICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKSB7XG4gICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgZGlzdGFuY2UgPSAwLjEgKiB0aGlzLl9ybmcoKTtcbiAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA8IDEgJiYgbm9kZS5zaGFwZS5yYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLm1heCgwLjEgKyB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgKiBub2RlLnNoYXBlLnJhZGl1cywgZGlzdGFuY2UgLSBub2RlLnNoYXBlLnJhZGl1cyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWdyZWUgPSBub2RlLmVkZ2VzLmxlbmd0aCArIDE7IC8vIHRoZSBkaXZpZGluZyBieSB0aGUgZGlzdGFuY2UgY3ViZWQgaW5zdGVhZCBvZiBzcXVhcmVkIGFsbG93cyB1cyB0byBnZXQgdGhlIGZ4IGFuZCBmeSBjb21wb25lbnRzIHdpdGhvdXQgc2luZXMgYW5kIGNvc2luZXNcbiAgICAgIC8vIGl0IGlzIHNob3J0aGFuZCBmb3IgZ3Jhdml0eWZvcmNlIHdpdGggZGlzdGFuY2Ugc3F1YXJlZCBhbmQgZnggPSBkeC9kaXN0YW5jZSAqIGdyYXZpdHlGb3JjZVxuXG4gICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCAqIHBhcmVudEJyYW5jaC5tYXNzICogbm9kZS5vcHRpb25zLm1hc3MgKiBkZWdyZWUgLyBNYXRoLnBvdyhkaXN0YW5jZSwgMik7XG4gICAgICB2YXIgZnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueCArPSBmeDtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnkgKz0gZnk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXI7XG59KEJhcm5lc0h1dFNvbHZlcik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRxKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZiQ1KERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZiQ1KHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBjb25zdHJ1Y3QkMyhTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIWNvbnN0cnVjdCQzKSByZXR1cm4gZmFsc2U7IGlmIChjb25zdHJ1Y3QkMy5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29uc3RydWN0JDMoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKipcbiAqIEBhdWdtZW50cyBDZW50cmFsR3Jhdml0eVNvbHZlclxuICovXG5cbnZhciBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DZW50cmFsR3Jhdml0eVNvbHZlcikge1xuICBpbmhlcml0cyhGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIF9DZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRxKEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAqIEBwYXJhbSB7b2JqZWN0PE5vZGUuaWQsIE5vZGU+fSBmb3JjZXNcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyLCBbe1xuICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKSB7XG4gICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgIHZhciBkZWdyZWUgPSBub2RlLmVkZ2VzLmxlbmd0aCArIDE7XG4gICAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgKiBkZWdyZWUgKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyO1xufShDZW50cmFsR3Jhdml0eVNvbHZlcik7XG5cbi8qKlxuICogVGhlIHBoeXNpY3MgZW5naW5lXG4gKi9cblxudmFyIFBoeXNpY3NFbmdpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIFBoeXNpY3NFbmdpbmUoYm9keSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBoeXNpY3NFbmdpbmUpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0ge1xuICAgICAgcGh5c2ljc05vZGVJbmRpY2VzOiBbXSxcbiAgICAgIHBoeXNpY3NFZGdlSW5kaWNlczogW10sXG4gICAgICBmb3JjZXM6IHt9LFxuICAgICAgdmVsb2NpdGllczoge31cbiAgICB9O1xuICAgIHRoaXMucGh5c2ljc0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuc2ltdWxhdGlvbkludGVydmFsID0gMTAwMCAvIDYwO1xuICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICB0aGlzLnByZXZpb3VzU3RhdGVzID0ge307XG4gICAgdGhpcy5yZWZlcmVuY2VTdGF0ZSA9IHt9O1xuICAgIHRoaXMuZnJlZXplQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkOyAvLyBwYXJhbWV0ZXJzIGZvciB0aGUgYWRhcHRpdmUgdGltZXN0ZXBcblxuICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IDA7XG4gICAgdGhpcy5hZGFwdGl2ZUludGVydmFsID0gMztcbiAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlOyAvLyB3aWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBzdGFiaWxpemVcbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcblxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgYmFybmVzSHV0OiB7XG4gICAgICAgIHRoZXRhOiAwLjUsXG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogLTIwMDAsXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjMsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogOTUsXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjA0LFxuICAgICAgICBkYW1waW5nOiAwLjA5LFxuICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgIH0sXG4gICAgICBmb3JjZUF0bGFzMkJhc2VkOiB7XG4gICAgICAgIHRoZXRhOiAwLjUsXG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogLTUwLFxuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4wMSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDgsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogMTAwLFxuICAgICAgICBkYW1waW5nOiAwLjQsXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgfSxcbiAgICAgIHJlcHVsc2lvbjoge1xuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4yLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDIwMCxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDUsXG4gICAgICAgIG5vZGVEaXN0YW5jZTogMTAwLFxuICAgICAgICBkYW1waW5nOiAwLjA5LFxuICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgIH0sXG4gICAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMCxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiAxMDAsXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjAxLFxuICAgICAgICBub2RlRGlzdGFuY2U6IDEyMCxcbiAgICAgICAgZGFtcGluZzogMC4wOVxuICAgICAgfSxcbiAgICAgIG1heFZlbG9jaXR5OiA1MCxcbiAgICAgIG1pblZlbG9jaXR5OiAwLjc1LFxuICAgICAgLy8gcHgvc1xuICAgICAgc29sdmVyOiBcImJhcm5lc0h1dFwiLFxuICAgICAgc3RhYmlsaXphdGlvbjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwLFxuICAgICAgICAvLyBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb24gdG8gc3RhYmlsaXplXG4gICAgICAgIHVwZGF0ZUludGVydmFsOiA1MCxcbiAgICAgICAgb25seUR5bmFtaWNFZGdlczogZmFsc2UsXG4gICAgICAgIGZpdDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHRpbWVzdGVwOiAwLjUsXG4gICAgICBhZGFwdGl2ZVRpbWVzdGVwOiB0cnVlLFxuICAgICAgd2luZDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLnRpbWVzdGVwID0gMC41O1xuICAgIHRoaXMubGF5b3V0RmFpbGVkID0gZmFsc2U7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoUGh5c2ljc0VuZ2luZSwgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFBoeXNpY3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5pbml0UGh5c2ljcygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9sYXlvdXRGYWlsZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5sYXlvdXRGYWlsZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInJlc2V0UGh5c2ljc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG5cbiAgICAgICAgX3RoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkaXNhYmxlUGh5c2ljc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZXN0b3JlUGh5c2ljc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnNldE9wdGlvbnMoX3RoaXMub3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKF90aGlzLnJlYWR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgX3RoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJzdGFydFNpbXVsYXRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInN0b3BTaW11bGF0aW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oZmFsc2UpO1xuXG4gICAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5vZmYoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOb2RlcyBhbmQvb3IgZWRnZXMgaGF2ZSBiZWVuIGFkZGVkIG9yIHJlbW92ZWQsIHVwZGF0ZSBzaG9ydGN1dCBsaXN0cy5cbiAgICAgICAgX3RoaXMudXBkYXRlUGh5c2ljc0RhdGEoKTtcbiAgICAgIH0pOyAvLyBkZWJ1Zzogc2hvdyBmb3JjZXNcbiAgICAgIC8vIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiYWZ0ZXJEcmF3aW5nXCIsIChjdHgpID0+IHt0aGlzLl9kcmF3Rm9yY2VzKGN0eCk7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgcGh5c2ljcyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZWxlY3RpdmVOb3REZWVwRXh0ZW5kKFtcInN0YWJpbGl6YXRpb25cIl0sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgXCJzdGFiaWxpemF0aW9uXCIpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3aW5kID0gdGhpcy5vcHRpb25zLndpbmQ7XG5cbiAgICAgICAgICBpZiAod2luZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kLnggIT09IFwibnVtYmVyXCIgfHwgaXNOYW4kMih3aW5kLngpKSB7XG4gICAgICAgICAgICAgIHdpbmQueCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZC55ICE9PSBcIm51bWJlclwiIHx8IGlzTmFuJDIod2luZC55KSkge1xuICAgICAgICAgICAgICB3aW5kLnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gc2V0IHRoZSB0aW1lc3RlcFxuXG5cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25maWd1cmUgdGhlIGVuZ2luZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBvcHRpb25zO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gXCJmb3JjZUF0bGFzMkJhc2VkXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5mb3JjZUF0bGFzMkJhc2VkO1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBTcHJpbmdTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc29sdmVyID09PSBcInJlcHVsc2lvblwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMucmVwdWxzaW9uO1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IFJlcHVsc2lvblNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIikge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbFJlcHVsc2lvbjtcbiAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IENlbnRyYWxHcmF2aXR5U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBiYXJuZXNIdXRcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5iYXJuZXNIdXQ7XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgQmFybmVzSHV0U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgU3ByaW5nU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBDZW50cmFsR3Jhdml0eVNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vZGVsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemUgdGhlIGVuZ2luZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFBoeXNpY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFBoeXNpY3MoKSB7XG4gICAgICBpZiAodGhpcy5waHlzaWNzRW5hYmxlZCA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc3RhYmlsaXplKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiLCB7fSwgdGhpcy5sYXlvdXRGYWlsZWQpOyAvLyBpZiB0aGUgbGF5b3V0IGZhaWxlZCwgd2UgdXNlIHRoZSBhcHByb3hpbWF0aW9uIGZvciB0aGUgem9vbVxuXG4gICAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBzaW11bGF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFNpbXVsYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRTaW11bGF0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGh5c2ljc0VuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7IC8vIHdoZW4gdmlzaWJsZSwgYWRhcHRpdml0eSBpcyBkaXNhYmxlZC5cblxuICAgICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPSBmYWxzZTsgLy8gdGhpcyBzZXRzIHRoZSB3aWR0aCBvZiBhbGwgbm9kZXMgaW5pdGlhbGx5IHdoaWNoIGNvdWxkIGJlIHJlcXVpcmVkIGZvciB0aGUgYXZvaWRPdmVybGFwXG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKTtcblxuICAgICAgICBpZiAodGhpcy52aWV3RnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gYmluZCQyKF9jb250ZXh0ID0gdGhpcy5zaW11bGF0aW9uU3RlcCkuY2FsbChfY29udGV4dCwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0YXJ0UmVuZGVyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgc2ltdWxhdGlvbiwgZm9yY2Ugc3RhYmlsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VtaXQ9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0b3BTaW11bGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BTaW11bGF0aW9uKCkge1xuICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICB0aGlzLnN0YWJpbGl6ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoZW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9lbWl0U3RhYmlsaXplZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52aWV3RnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGVtaXQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHZpZXdGdW5jdGlvbiBpbnNlcnRzIHRoaXMgc3RlcCBpbnRvIGVhY2ggcmVuZGVyIGxvb3AuIEl0IGNhbGxzIHRoZSBwaHlzaWNzIHRpY2sgYW5kIGhhbmRsZXMgdGhlIGNsZWFudXAgYXQgc3RhYmlsaXplZC5cbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2ltdWxhdGlvblN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2ltdWxhdGlvblN0ZXAoKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgcGh5c2ljcyBoYXZlIHNldHRsZWRcbiAgICAgIHZhciBzdGFydFRpbWUgPSBub3ckMigpO1xuXG4gICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG4gICAgICB2YXIgcGh5c2ljc1RpbWUgPSBub3ckMigpIC0gc3RhcnRUaW1lOyAvLyBydW4gZG91YmxlIHNwZWVkIGlmIGl0IGlzIGEgbGl0dGxlIGdyYXBoXG5cbiAgICAgIGlmICgocGh5c2ljc1RpbWUgPCAwLjQgKiB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCB8fCB0aGlzLnJ1bkRvdWJsZVNwZWVkID09PSB0cnVlKSAmJiB0aGlzLnN0YWJpbGl6ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc1RpY2soKTsgLy8gdGhpcyBtYWtlcyBzdXJlIHRoZXJlIGlzIG5vIGppdHRlci4gVGhlIGRlY2lzaW9uIGlzIHRha2VuIG9uY2UgdG8gcnVuIGl0IGF0IGRvdWJsZSBzcGVlZC5cblxuICAgICAgICB0aGlzLnJ1bkRvdWJsZVNwZWVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRyaWdnZXIgdGhlIHN0YWJpbGl6ZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Ftb3VudE9mSXRlcmF0aW9ucz10aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdFN0YWJpbGl6ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRTdGFiaWxpemVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBhbW91bnRPZkl0ZXJhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnM7XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID4gMSB8fCB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHNldFRpbWVvdXQkMihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhYmlsaXplZFwiLCB7XG4gICAgICAgICAgICBpdGVyYXRpb25zOiBhbW91bnRPZkl0ZXJhdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF90aGlzMi5zdGFydGVkU3RhYmlsaXphdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzMi5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBmb3Igb25lIHBoeXNpY3MgaXRlcmF0aW9uIGFuZCBtb3ZlIHRoZSBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwaHlzaWNzU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaHlzaWNzU3RlcCgpIHtcbiAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5ub2Rlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5lZGdlc1NvbHZlci5zb2x2ZSgpO1xuICAgICAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBkeW5hbWljIGFkanVzdG1lbnRzIHRvIHRoZSB0aW1lc3RlcCwgYmFzZWQgb24gY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcGh5c2ljc1RpY2soKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RUaW1lU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RUaW1lU3RlcCgpIHtcbiAgICAgIHZhciBmYWN0b3IgPSAxLjI7IC8vIEZhY3RvciBmb3IgaW5jcmVhc2luZyB0aGUgdGltZXN0ZXAgb24gc3VjY2Vzcy5cbiAgICAgIC8vIHdlIGNvbXBhcmUgdGhlIHR3byBzdGVwcy4gaWYgaXQgaXMgYWNjZXB0YWJsZSB3ZSBkb3VibGUgdGhlIHN0ZXAuXG5cbiAgICAgIGlmICh0aGlzLl9ldmFsdWF0ZVN0ZXBRdWFsaXR5KCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy50aW1lc3RlcCA9IGZhY3RvciAqIHRoaXMudGltZXN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBub3QsIHdlIGRlY3JlYXNlIHRoZSBzdGVwIHRvIGEgbWluaW11bSBvZiB0aGUgb3B0aW9ucyB0aW1lc3RlcC5cbiAgICAgICAgLy8gaWYgdGhlIGRlY3JlYXNlZCB0aW1lc3RlcCBpcyBzbWFsbGVyIHRoYW4gdGhlIG9wdGlvbnMgc3RlcCwgd2UgZG8gbm90IHJlc2V0IHRoZSBjb3VudGVyXG4gICAgICAgIC8vIHdlIGFzc3VtZSB0aGF0IHRoZSBvcHRpb25zIHRpbWVzdGVwIGlzIHN0YWJsZSBlbm91Z2guXG4gICAgICAgIGlmICh0aGlzLnRpbWVzdGVwIC8gZmFjdG9yIDwgdGhpcy5vcHRpb25zLnRpbWVzdGVwKSB7XG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IHRoaXMub3B0aW9ucy50aW1lc3RlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB0aGUgdGltZXN0ZXAgd2FzIGxhcmdlciB0aGFuIDIgdGltZXMgdGhlIG9wdGlvbiBvbmUgd2UgY2hlY2sgdGhlIGFkYXB0aXZpdHkgYWdhaW4gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCBsYXJnZSBpbnN0YWJpbGl0aWVzIGRvIG5vdCBmb3JtLlxuICAgICAgICAgIHRoaXMuYWRhcHRpdmVDb3VudGVyID0gLTE7IC8vIGNoZWNrIGFnYWluIG5leHQgaXRlcmF0aW9uXG5cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gTWF0aC5tYXgodGhpcy5vcHRpb25zLnRpbWVzdGVwLCB0aGlzLnRpbWVzdGVwIC8gZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNpbmdsZSBzaW11bGF0aW9uIHN0ZXAgKG9yICd0aWNrJykgaW4gdGhlIHBoeXNpY3Mgc2ltdWxhdGlvblxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBoeXNpY3NUaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBoeXNpY3NUaWNrKCkge1xuICAgICAgdGhpcy5fc3RhcnRTdGFiaWxpemluZygpOyAvLyB0aGlzIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBubyBzdGFydCBldmVudCB3aGVuIHRoZSBuZXR3b3JrIGlzIGFscmVhZHkgc3RhYmxlLlxuXG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHJldHVybjsgLy8gYWRhcHRpdml0eSBtZWFucyB0aGUgdGltZXN0ZXAgYWRhcHRzIHRvIHRoZSBzaXR1YXRpb24sIG9ubHkgYXBwbGljYWJsZSBmb3Igc3RhYmlsaXphdGlvblxuXG4gICAgICBpZiAodGhpcy5hZGFwdGl2ZVRpbWVzdGVwID09PSB0cnVlICYmIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gdGltZXN0ZXAgcmVtYWlucyBzdGFibGUgZm9yIFwiaW50ZXJ2YWxcIiBpdGVyYXRpb25zLlxuICAgICAgICB2YXIgZG9BZGFwdGl2ZSA9IHRoaXMuYWRhcHRpdmVDb3VudGVyICUgdGhpcy5hZGFwdGl2ZUludGVydmFsID09PSAwO1xuXG4gICAgICAgIGlmIChkb0FkYXB0aXZlKSB7XG4gICAgICAgICAgLy8gZmlyc3QgdGhlIGJpZyBzdGVwIGFuZCByZXZlcnQuXG4gICAgICAgICAgdGhpcy50aW1lc3RlcCA9IDIgKiB0aGlzLnRpbWVzdGVwO1xuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTtcbiAgICAgICAgICB0aGlzLnJldmVydCgpOyAvLyBzYXZlcyB0aGUgcmVmZXJlbmNlIHN0YXRlXG4gICAgICAgICAgLy8gbm93IHRoZSBub3JtYWwgc3RlcC4gU2luY2UgdGhpcyBpcyB0aGUgbGFzdCBzdGVwLCBpdCBpcyB0aGUgbW9yZSBzdGFibGUgb25lIGFuZCB3ZSB3aWxsIHRha2UgdGhpcy5cblxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSAwLjUgKiB0aGlzLnRpbWVzdGVwOyAvLyBzaW5jZSBpdCdzIGhhbGYgdGhlIHN0ZXAsIHdlIGRvIGl0IHR3aWNlLlxuXG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpO1xuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTtcbiAgICAgICAgICB0aGlzLmFkanVzdFRpbWVTdGVwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpOyAvLyBub3JtYWwgc3RlcCwga2VlcGluZyB0aW1lc3RlcCBjb25zdGFudFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc2UgZm9yIHRoZSBzdGF0aWMgdGltZXN0ZXAsIHdlIHJlc2V0IGl0IHRvIHRoZSBvbmUgaW4gb3B0aW9ucyBhbmQgdGFrZSBhIG5vcm1hbCBzdGVwLlxuICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHRoaXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zKys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vZGVzIGFuZCBlZGdlcyBjYW4gaGF2ZSB0aGUgcGh5c2ljcyB0b2dnbGVzIG9uIG9yIG9mZi4gQSBjb2xsZWN0aW9uIG9mIGluZGljZXMgaXMgY3JlYXRlZCBoZXJlIHNvIHdlIGNhbiBza2lwIHRoZSBjaGVjayBhbGwgdGhlIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUGh5c2ljc0RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUGh5c2ljc0RhdGEoKSB7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlcyA9IHt9O1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMgPSBbXTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzID0gW107XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7IC8vIGdldCBub2RlIGluZGljZXMgZm9yIHBoeXNpY3NcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLnB1c2gobm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGdldCBlZGdlIGluZGljZXMgZm9yIHBoeXNpY3NcblxuXG4gICAgICBmb3IgKHZhciBlZGdlSWQgaW4gZWRnZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXMucHVzaChlZGdlc1tlZGdlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZ2V0IHRoZSB2ZWxvY2l0eSBhbmQgdGhlIGZvcmNlcyB2ZWN0b3JcblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZUlkID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXNbaV07XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW19ub2RlSWRdID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9OyAvLyBmb3JjZXMgY2FuIGJlIHJlc2V0IGJlY2F1c2UgdGhleSBhcmUgcmVjYWxjdWxhdGVkLiBWZWxvY2l0aWVzIGhhdmUgdG8gcGVyc2lzdC5cblxuICAgICAgICBpZiAodGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbX25vZGVJZF0gPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY2xlYW4gZGVsZXRlZCBub2RlcyBmcm9tIHRoZSB2ZWxvY2l0eSB2ZWN0b3JcblxuXG4gICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzW19ub2RlSWQyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllc1tfbm9kZUlkMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2ZXJ0IHRoZSBzaW11bGF0aW9uIG9uZSBzdGVwLiBUaGlzIGlzIGRvbmUgc28gYWZ0ZXIgc3RhYmlsaXphdGlvbiwgZXZlcnkgbmV3IHN0YXJ0IG9mIHRoZSBzaW11bGF0aW9uIHdpbGwgYWxzbyBzYXkgc3RhYmlsaXplZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJldmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnQoKSB7XG4gICAgICB2YXIgbm9kZUlkcyA9IGtleXMkMyh0aGlzLnByZXZpb3VzU3RhdGVzKTtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIHZlbG9jaXRpZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXM7XG4gICAgICB0aGlzLnJlZmVyZW5jZVN0YXRlID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUlkc1tpXTtcblxuICAgICAgICBpZiAobm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0ub3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZVN0YXRlW25vZGVJZF0gPSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICAgICAgICAgIHg6IG5vZGVzW25vZGVJZF0ueCxcbiAgICAgICAgICAgICAgICB5OiBub2Rlc1tub2RlSWRdLnlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZlbG9jaXRpZXNbbm9kZUlkXS54ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLnZ4O1xuICAgICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnkgPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0udnk7XG4gICAgICAgICAgICBub2Rlc1tub2RlSWRdLnggPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0ueDtcbiAgICAgICAgICAgIG5vZGVzW25vZGVJZF0ueSA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgY29tcGFyZXMgdGhlIHJlZmVyZW5jZSBzdGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmFsdWF0ZVN0ZXBRdWFsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmFsdWF0ZVN0ZXBRdWFsaXR5KCkge1xuICAgICAgdmFyIGR4LCBkeSwgZHBvcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciByZWZlcmVuY2UgPSB0aGlzLnJlZmVyZW5jZVN0YXRlO1xuICAgICAgdmFyIHBvc1RocmVzaG9sZCA9IDAuMztcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMucmVmZXJlbmNlU3RhdGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnJlZmVyZW5jZVN0YXRlLCBub2RlSWQpICYmIG5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGR4ID0gbm9kZXNbbm9kZUlkXS54IC0gcmVmZXJlbmNlW25vZGVJZF0ucG9zaXRpb25zLng7XG4gICAgICAgICAgZHkgPSBub2Rlc1tub2RlSWRdLnkgLSByZWZlcmVuY2Vbbm9kZUlkXS5wb3NpdGlvbnMueTtcbiAgICAgICAgICBkcG9zID0gTWF0aC5zcXJ0KE1hdGgucG93KGR4LCAyKSArIE1hdGgucG93KGR5LCAyKSk7XG5cbiAgICAgICAgICBpZiAoZHBvcyA+IHBvc1RocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbW92ZSB0aGUgbm9kZXMgb25lIHRpbWVzdGVwIGFuZCBjaGVjayBpZiB0aGV5IGFyZSBzdGFiaWxpemVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgbWF4Tm9kZVZlbG9jaXR5ID0gMDtcbiAgICAgIHZhciBhdmVyYWdlTm9kZVZlbG9jaXR5ID0gMDsgLy8gdGhlIHZlbG9jaXR5IHRocmVzaG9sZCAoZW5lcmd5IGluIHRoZSBzeXN0ZW0pIGZvciB0aGUgYWRhcHRpdml0eSB0b2dnbGVcblxuICAgICAgdmFyIHZlbG9jaXR5QWRhcHRpdmVUaHJlc2hvbGQgPSA1O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlSW5kaWNlc1tpXTtcblxuICAgICAgICB2YXIgbm9kZVZlbG9jaXR5ID0gdGhpcy5fcGVyZm9ybVN0ZXAobm9kZUlkKTsgLy8gc3RhYmlsaXplZCBpcyB0cnVlIGlmIHN0YWJpbGl6ZWQgaXMgdHJ1ZSBhbmQgdmVsb2NpdHkgaXMgc21hbGxlciB0aGFuIHZtaW4gLS0+IGFsbCBub2RlcyBtdXN0IGJlIHN0YWJpbGl6ZWRcblxuXG4gICAgICAgIG1heE5vZGVWZWxvY2l0eSA9IE1hdGgubWF4KG1heE5vZGVWZWxvY2l0eSwgbm9kZVZlbG9jaXR5KTtcbiAgICAgICAgYXZlcmFnZU5vZGVWZWxvY2l0eSArPSBub2RlVmVsb2NpdHk7XG4gICAgICB9IC8vIGV2YWx1YXRpbmcgdGhlIHN0YWJpbGl6ZWQgYW5kIGFkYXB0aXZlVGltZXN0ZXBFbmFibGVkIGNvbmRpdGlvbnNcblxuXG4gICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkID0gYXZlcmFnZU5vZGVWZWxvY2l0eSAvIG5vZGVJbmRpY2VzLmxlbmd0aCA8IHZlbG9jaXR5QWRhcHRpdmVUaHJlc2hvbGQ7XG4gICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBtYXhOb2RlVmVsb2NpdHkgPCB0aGlzLm9wdGlvbnMubWluVmVsb2NpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBuZXcgdmVsb2NpdHkgZm9yIGEgY29vcmRpbmF0ZSBkaXJlY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2ICB2ZWxvY2l0eSBmb3IgY3VycmVudCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGYgIHJlZ3VsYXIgZm9yY2UgZm9yIGN1cnJlbnQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtICBtYXNzIG9mIGN1cnJlbnQgbm9kZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG5ldyB2ZWxvY2l0eSBmb3IgY3VycmVudCBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5KHYsIGYsIG0pIHtcbiAgICAgIHZhciBkZiA9IHRoaXMubW9kZWxPcHRpb25zLmRhbXBpbmcgKiB2OyAvLyBkYW1waW5nIGZvcmNlXG5cbiAgICAgIHZhciBhID0gKGYgLSBkZikgLyBtOyAvLyBhY2NlbGVyYXRpb25cblxuICAgICAgdiArPSBhICogdGhpcy50aW1lc3RlcDsgLy8gUHV0IGEgbGltaXQgb24gdGhlIHZlbG9jaXRpZXMgaWYgaXQgaXMgcmVhbGx5IGhpZ2hcblxuICAgICAgdmFyIG1heFYgPSB0aGlzLm9wdGlvbnMubWF4VmVsb2NpdHkgfHwgMWU5O1xuXG4gICAgICBpZiAoTWF0aC5hYnModikgPiBtYXhWKSB7XG4gICAgICAgIHYgPSB2ID4gMCA/IG1heFYgOiAtbWF4VjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gdGhlIGFjdHVhbCBzdGVwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBuZXcgdmVsb2NpdHkgb2YgZ2l2ZW4gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGVyZm9ybVN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1TdGVwKG5vZGVJZCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgIHZhciBmb3JjZSA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGVJZF07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMud2luZCkge1xuICAgICAgICBmb3JjZS54ICs9IHRoaXMub3B0aW9ucy53aW5kLng7XG4gICAgICAgIGZvcmNlLnkgKz0gdGhpcy5vcHRpb25zLndpbmQueTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW25vZGVJZF07IC8vIHN0b3JlIHRoZSBzdGF0ZSBzbyB3ZSBjYW4gcmV2ZXJ0XG5cbiAgICAgIHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXSA9IHtcbiAgICAgICAgeDogbm9kZS54LFxuICAgICAgICB5OiBub2RlLnksXG4gICAgICAgIHZ4OiB2ZWxvY2l0eS54LFxuICAgICAgICB2eTogdmVsb2NpdHkueVxuICAgICAgfTtcblxuICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC54ID09PSBmYWxzZSkge1xuICAgICAgICB2ZWxvY2l0eS54ID0gdGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2ZWxvY2l0eS54LCBmb3JjZS54LCBub2RlLm9wdGlvbnMubWFzcyk7XG4gICAgICAgIG5vZGUueCArPSB2ZWxvY2l0eS54ICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlLnggPSAwO1xuICAgICAgICB2ZWxvY2l0eS54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICB2ZWxvY2l0eS55ID0gdGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2ZWxvY2l0eS55LCBmb3JjZS55LCBub2RlLm9wdGlvbnMubWFzcyk7XG4gICAgICAgIG5vZGUueSArPSB2ZWxvY2l0eS55ICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlLnkgPSAwO1xuICAgICAgICB2ZWxvY2l0eS55ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsVmVsb2NpdHkgPSBNYXRoLnNxcnQoTWF0aC5wb3codmVsb2NpdHkueCwgMikgKyBNYXRoLnBvdyh2ZWxvY2l0eS55LCAyKSk7XG4gICAgICByZXR1cm4gdG90YWxWZWxvY2l0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiBpbml0aWFsaXppbmcgYW5kIHN0YWJpbGl6aW5nLCB3ZSBjYW4gZnJlZXplIG5vZGVzIHdpdGggYSBwcmVkZWZpbmVkIHBvc2l0aW9uLlxuICAgICAqIFRoaXMgZ3JlYXRseSBzcGVlZHMgdXAgc3RhYmlsaXphdGlvbiBiZWNhdXNlIG9ubHkgdGhlIHN1cHBvcnRub2RlcyBmb3IgdGhlIHNtb290aEN1cnZlcyBoYXZlIHRvIHNldHRsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZnJlZXplTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZyZWV6ZU5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBpZCkpIHtcbiAgICAgICAgICBpZiAobm9kZXNbaWRdLnggJiYgbm9kZXNbaWRdLnkpIHtcbiAgICAgICAgICAgIHZhciBmaXhlZCA9IG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkO1xuICAgICAgICAgICAgdGhpcy5mcmVlemVDYWNoZVtpZF0gPSB7XG4gICAgICAgICAgICAgIHg6IGZpeGVkLngsXG4gICAgICAgICAgICAgIHk6IGZpeGVkLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmaXhlZC54ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZpeGVkLnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmZyZWV6ZXMgdGhlIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIGZyb3plbiBieSBfZnJlZXplRGVmaW5lZE5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXN0b3JlRnJvemVuTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmVGcm96ZW5Ob2RlcygpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlcywgaWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJlZXplQ2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnggPSB0aGlzLmZyZWV6ZUNhY2hlW2lkXS54O1xuICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueSA9IHRoaXMuZnJlZXplQ2FjaGVbaWRdLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZnJlZXplQ2FjaGUgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhIHN0YWJsZSBwb3NpdGlvbiBmb3IgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2l0ZXJhdGlvbnM9dGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9uc11cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YWJpbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFiaWxpemUoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLml0ZXJhdGlvbnM7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0aW9ucyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpdGVyYXRpb25zID0gdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9ucztcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZSBzdGFiaWxpemUgbWV0aG9kIG5lZWRzIGEgbnVtZXJpYyBhbW91bnQgb2YgaXRlcmF0aW9ucy4gU3dpdGNoaW5nIHRvIGRlZmF1bHQ6IFwiLCBpdGVyYXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBlbmFibGUgYWRhcHRpdmUgdGltZXN0ZXBzXG5cblxuICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gIHRoaXMub3B0aW9ucy5hZGFwdGl2ZVRpbWVzdGVwOyAvLyB0aGlzIHNldHMgdGhlIHdpZHRoIG9mIGFsbCBub2RlcyBpbml0aWFsbHkgd2hpY2ggY291bGQgYmUgcmVxdWlyZWQgZm9yIHRoZSBhdm9pZE92ZXJsYXBcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKTtcbiAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTsgLy8gc3RvcCB0aGUgcmVuZGVyIGxvb3BcblxuICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7IC8vIGJsb2NrIHJlZHJhdyByZXF1ZXN0c1xuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2Jsb2NrUmVkcmF3XCIpO1xuICAgICAgdGhpcy50YXJnZXRJdGVyYXRpb25zID0gaXRlcmF0aW9uczsgLy8gc3RhcnQgdGhlIHN0YWJpbGl6YXRpb25cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZnJlZXplTm9kZXMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG5cbiAgICAgIHNldFRpbWVvdXQkMihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuX3N0YWJpbGl6YXRpb25CYXRjaCgpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIG5vdCBhbHJlYWR5IHN0YWJpbGl6aW5nLCBzdGFydCBpdCBhbmQgZW1pdCBhIHN0YXJ0IGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc3RhYmlsaXphdGlvbiBzdGFydGVkIHdpdGggdGhpcyBjYWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFN0YWJpbGl6aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFN0YWJpbGl6aW5nKCkge1xuICAgICAgaWYgKHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPT09IHRydWUpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFN0YWJpbGl6aW5nXCIpO1xuICAgICAgdGhpcy5zdGFydGVkU3RhYmlsaXphdGlvbiA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25lIGJhdGNoIG9mIHN0YWJpbGl6YXRpb25cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RhYmlsaXphdGlvbkJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFiaWxpemF0aW9uQmF0Y2goKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHJ1bm5pbmcgPSBmdW5jdGlvbiBydW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM0LnN0YWJpbGl6ZWQgPT09IGZhbHNlICYmIF90aGlzNC5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA8IF90aGlzNC50YXJnZXRJdGVyYXRpb25zO1xuICAgICAgfTtcblxuICAgICAgdmFyIHNlbmRQcm9ncmVzcyA9IGZ1bmN0aW9uIHNlbmRQcm9ncmVzcygpIHtcbiAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KFwic3RhYmlsaXphdGlvblByb2dyZXNzXCIsIHtcbiAgICAgICAgICBpdGVyYXRpb25zOiBfdGhpczQuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMsXG4gICAgICAgICAgdG90YWw6IF90aGlzNC50YXJnZXRJdGVyYXRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX3N0YXJ0U3RhYmlsaXppbmcoKSkge1xuICAgICAgICBzZW5kUHJvZ3Jlc3MoKTsgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHN0YXJ0IGV2ZW50LlxuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICB3aGlsZSAocnVubmluZygpICYmIGNvdW50IDwgdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24udXBkYXRlSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuXG4gICAgICBzZW5kUHJvZ3Jlc3MoKTtcblxuICAgICAgaWYgKHJ1bm5pbmcoKSkge1xuICAgICAgICB2YXIgX2NvbnRleHQyO1xuXG4gICAgICAgIHNldFRpbWVvdXQkMihiaW5kJDIoX2NvbnRleHQyID0gdGhpcy5fc3RhYmlsaXphdGlvbkJhdGNoKS5jYWxsKF9jb250ZXh0MiwgdGhpcyksIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVTdGFiaWxpemF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXAgdXAgdGhlIHN0YWJpbGl6YXRpb24sIGZpdCBhbmQgZW1pdCB0aGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maW5hbGl6ZVN0YWJpbGl6YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmFsaXplU3RhYmlsaXphdGlvbigpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYWxsb3dSZWRyYXdcIik7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5maXQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImZpdFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fcmVzdG9yZUZyb3plbk5vZGVzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFiaWxpemF0aW9uSXRlcmF0aW9uc0RvbmVcIik7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG5cbiAgICAgIGlmICh0aGlzLnN0YWJpbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZW1pdFN0YWJpbGl6ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRTaW11bGF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIERFQlVHR0lORyBCRUxPVyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIERlYnVnIGZ1bmN0aW9uIHRoYXQgZGlzcGxheSBhcnJvd3MgZm9yIHRoZSBmb3JjZXMgY3VycmVudGx5IGFjdGl2ZSBpbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHdoZW4gZGVidWdnaW5nIG9ubHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3Rm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3Rm9yY2VzKGN0eCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlc1tpXTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaW5kZXhdO1xuICAgICAgICB2YXIgZm9yY2UgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tpbmRleF07XG4gICAgICAgIHZhciBmYWN0b3IgPSAyMDtcbiAgICAgICAgdmFyIGNvbG9yRmFjdG9yID0gMC4wMztcbiAgICAgICAgdmFyIGZvcmNlU2l6ZSA9IE1hdGguc3FydChNYXRoLnBvdyhmb3JjZS54LCAyKSArIE1hdGgucG93KGZvcmNlLngsIDIpKTtcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihNYXRoLm1heCg1LCBmb3JjZVNpemUpLCAxNSk7XG4gICAgICAgIHZhciBhcnJvd1NpemUgPSAzICogc2l6ZTtcbiAgICAgICAgdmFyIGNvbG9yID0gSFNWVG9IZXgoKDE4MCAtIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGNvbG9yRmFjdG9yICogZm9yY2VTaXplKSkgKiAxODApIC8gMzYwLCAxLCAxKTtcbiAgICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICAgIHg6IG5vZGUueCArIGZhY3RvciAqIGZvcmNlLngsXG4gICAgICAgICAgeTogbm9kZS55ICsgZmFjdG9yICogZm9yY2UueVxuICAgICAgICB9O1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc2l6ZTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhub2RlLngsIG5vZGUueSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihmb3JjZS55LCBmb3JjZS54KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBFbmRQb2ludHMuZHJhdyhjdHgsIHtcbiAgICAgICAgICB0eXBlOiBcImFycm93XCIsXG4gICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICBsZW5ndGg6IGFycm93U2l6ZVxuICAgICAgICB9KTtcblxuICAgICAgICBmaWxsJDIoY3R4KS5jYWxsKGN0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBoeXNpY3NFbmdpbmU7XG59KCk7XG5cbnZhciBuYXRpdmVSZXZlcnNlID0gW10ucmV2ZXJzZTtcbnZhciB0ZXN0JDEgPSBbMSwgMl07IC8vIGBBcnJheS5wcm90b3R5cGUucmV2ZXJzZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmV2ZXJzZVxuLy8gZml4IGZvciBTYWZhcmkgMTIuMCBidWdcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODg3OTRcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogU3RyaW5nKHRlc3QkMSkgPT09IFN0cmluZyh0ZXN0JDEucmV2ZXJzZSgpKVxufSwge1xuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIGlmIChpc0FycmF5KHRoaXMpKSB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHJldHVybiBuYXRpdmVSZXZlcnNlLmNhbGwodGhpcyk7XG4gIH1cbn0pO1xuXG52YXIgcmV2ZXJzZSA9IGVudHJ5VmlydHVhbCgnQXJyYXknKS5yZXZlcnNlO1xuXG52YXIgQXJyYXlQcm90b3R5cGUkYyA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHJldmVyc2VfMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQucmV2ZXJzZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRjIHx8IGl0IGluc3RhbmNlb2YgQXJyYXkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRjLnJldmVyc2UgPyByZXZlcnNlIDogb3duO1xufTtcblxudmFyIHJldmVyc2UkMSA9IHJldmVyc2VfMTtcblxudmFyIHJldmVyc2UkMiA9IHJldmVyc2UkMTtcblxuLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4vLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmZ1bmN0aW9uIHJuZygpIHtcbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn1cblxudmFyIFJFR0VYID0gL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5JDMoYXJyKSB7XG4gIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7IC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuXG4gIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeSQzKHJuZHMpO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgQ2xhc3NcbiAqL1xuXG52YXIgTmV0d29ya1V0aWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gTmV0d29ya1V0aWwoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTmV0d29ya1V0aWwpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIHRoZSBjZW50ZXIgcG9zaXRpb24gb2YgdGhlIG5ldHdvcmsgY29uc2lkZXJpbmcgdGhlIGJvdW5kaW5nIGJveGVzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBhbGxOb2Rlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gW3NwZWNpZmljTm9kZXM9W11dXG4gICAqIEByZXR1cm5zIHt7bWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyfX1cbiAgICogQHN0YXRpY1xuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKE5ldHdvcmtVdGlsLCBudWxsLCBbe1xuICAgIGtleTogXCJnZXRSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZShhbGxOb2Rlcykge1xuICAgICAgdmFyIHNwZWNpZmljTm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgICAgdmFyIG1pblkgPSAxZTksXG4gICAgICAgICAgbWF4WSA9IC0xZTksXG4gICAgICAgICAgbWluWCA9IDFlOSxcbiAgICAgICAgICBtYXhYID0gLTFlOSxcbiAgICAgICAgICBub2RlO1xuXG4gICAgICBpZiAoc3BlY2lmaWNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY2lmaWNOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBhbGxOb2Rlc1tzcGVjaWZpY05vZGVzW2ldXTtcblxuICAgICAgICAgIGlmIChtaW5YID4gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0KSB7XG4gICAgICAgICAgICBtaW5YID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5sZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXhYIDwgbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodCkge1xuICAgICAgICAgICAgbWF4WCA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gucmlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1pblkgPiBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnRvcCkge1xuICAgICAgICAgICAgbWluWSA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gudG9wO1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcblxuXG4gICAgICAgICAgaWYgKG1heFkgPCBub2RlLnNoYXBlLmJvdW5kaW5nQm94LmJvdHRvbSkge1xuICAgICAgICAgICAgbWF4WSA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tO1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW5YID09PSAxZTkgJiYgbWF4WCA9PT0gLTFlOSAmJiBtaW5ZID09PSAxZTkgJiYgbWF4WSA9PT0gLTFlOSkge1xuICAgICAgICBtaW5ZID0gMCwgbWF4WSA9IDAsIG1pblggPSAwLCBtYXhYID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogbWluWCxcbiAgICAgICAgbWF4WDogbWF4WCxcbiAgICAgICAgbWluWTogbWluWSxcbiAgICAgICAgbWF4WTogbWF4WVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gYWxsTm9kZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gW3NwZWNpZmljTm9kZXM9W11dXG4gICAgICogQHJldHVybnMge3ttaW5YOiBudW1iZXIsIG1heFg6IG51bWJlciwgbWluWTogbnVtYmVyLCBtYXhZOiBudW1iZXJ9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFJhbmdlQ29yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZUNvcmUoYWxsTm9kZXMpIHtcbiAgICAgIHZhciBzcGVjaWZpY05vZGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHZhciBtaW5ZID0gMWU5LFxuICAgICAgICAgIG1heFkgPSAtMWU5LFxuICAgICAgICAgIG1pblggPSAxZTksXG4gICAgICAgICAgbWF4WCA9IC0xZTksXG4gICAgICAgICAgbm9kZTtcblxuICAgICAgaWYgKHNwZWNpZmljTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gYWxsTm9kZXNbc3BlY2lmaWNOb2Rlc1tpXV07XG5cbiAgICAgICAgICBpZiAobWluWCA+IG5vZGUueCkge1xuICAgICAgICAgICAgbWluWCA9IG5vZGUueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF4WCA8IG5vZGUueCkge1xuICAgICAgICAgICAgbWF4WCA9IG5vZGUueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWluWSA+IG5vZGUueSkge1xuICAgICAgICAgICAgbWluWSA9IG5vZGUueTtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG5cblxuICAgICAgICAgIGlmIChtYXhZIDwgbm9kZS55KSB7XG4gICAgICAgICAgICBtYXhZID0gbm9kZS55O1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW5YID09PSAxZTkgJiYgbWF4WCA9PT0gLTFlOSAmJiBtaW5ZID09PSAxZTkgJiYgbWF4WSA9PT0gLTFlOSkge1xuICAgICAgICBtaW5ZID0gMCwgbWF4WSA9IDAsIG1pblggPSAwLCBtYXhYID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogbWluWCxcbiAgICAgICAgbWF4WDogbWF4WCxcbiAgICAgICAgbWluWTogbWluWSxcbiAgICAgICAgbWF4WTogbWF4WVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJhbmdlID0ge21pblg6IG1pblgsIG1heFg6IG1heFgsIG1pblk6IG1pblksIG1heFk6IG1heFl9O1xuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbmRDZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZENlbnRlcihyYW5nZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMC41ICogKHJhbmdlLm1heFggKyByYW5nZS5taW5YKSxcbiAgICAgICAgeTogMC41ICogKHJhbmdlLm1heFkgKyByYW5nZS5taW5ZKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyByZXR1cm5zIGEgY2xvbmUgb2YgdGhlIG9wdGlvbnMgb3Igb3B0aW9ucyBvZiB0aGUgZWRnZSBvciBub2RlIHRvIGJlIHVzZWQgZm9yIGNvbnN0cnVjdGlvbiBvZiBuZXcgZWRnZXMgb3IgY2hlY2sgZnVuY3Rpb25zIGZvciBuZXcgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5JdGVtfSBpdGVtXG4gICAgICogQHBhcmFtIHsnbm9kZSd8dW5kZWZpbmVkfSB0eXBlXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb25lT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZU9wdGlvbnMoaXRlbSwgdHlwZSkge1xuICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSB7fTtcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcIm5vZGVcIikge1xuICAgICAgICBkZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGl0ZW0ub3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGNsb25lZE9wdGlvbnMueCA9IGl0ZW0ueDtcbiAgICAgICAgY2xvbmVkT3B0aW9ucy55ID0gaXRlbS55O1xuICAgICAgICBjbG9uZWRPcHRpb25zLmFtb3VudE9mQ29ubmVjdGlvbnMgPSBpdGVtLmVkZ2VzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgaXRlbS5vcHRpb25zLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lZE9wdGlvbnM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5ldHdvcmtVdGlsO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRyKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2YkNShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2YkNSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gY29uc3RydWN0JDMoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFjb25zdHJ1Y3QkMykgcmV0dXJuIGZhbHNlOyBpZiAoY29uc3RydWN0JDMuc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbnN0cnVjdCQzKERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBBIENsdXN0ZXIgaXMgYSBzcGVjaWFsIE5vZGUgdGhhdCBhbGxvd3MgYSBncm91cCBvZiBOb2RlcyBwb3NpdGlvbmVkIGNsb3NlbHkgdG9nZXRoZXJcbiAqIHRvIGJlIHJlcHJlc2VudGVkIGJ5IGEgc2luZ2xlIENsdXN0ZXIgTm9kZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZVxuICovXG5cbnZhciBDbHVzdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBpbmhlcml0cyhDbHVzdGVyLCBfTm9kZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRyKENsdXN0ZXIpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxIVE1MSW1hZ2VFbGVtZW50Pn1pbWFnZWxpc3RcbiAgICogQHBhcmFtIHtBcnJheX0gZ3JvdXBsaXN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxPcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0T3B0aW9ucyAgICAgR2xvYmFsIGRlZmF1bHQgb3B0aW9ucyBmb3Igbm9kZXNcbiAgICovXG4gIGZ1bmN0aW9uIENsdXN0ZXIob3B0aW9ucywgYm9keSwgaW1hZ2VsaXN0LCBncm91cGxpc3QsIGdsb2JhbE9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2x1c3Rlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgX3RoaXMuaXNDbHVzdGVyID0gdHJ1ZTtcbiAgICBfdGhpcy5jb250YWluZWROb2RlcyA9IHt9O1xuICAgIF90aGlzLmNvbnRhaW5lZEVkZ2VzID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2ZlciBjaGlsZCBjbHVzdGVyIGRhdGEgdG8gY3VycmVudCBhbmQgZGlzY29ubmVjdCB0aGUgY2hpbGQgY2x1c3Rlci5cbiAgICpcbiAgICogUGxlYXNlIGNvbnN1bHQgdGhlIGhlYWRlciBjb21tZW50IGluICdDbHVzdGVyaW5nLmpzJyBmb3IgdGhlIGZpZWxkcyBzZXQgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBjaGlsZENsdXN0ZXJJZCAgaWQgb2YgY2hpbGQgY2x1c3RlciB0byBvcGVuXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoQ2x1c3RlciwgW3tcbiAgICBrZXk6IFwiX29wZW5DaGlsZENsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5DaGlsZENsdXN0ZXIoY2hpbGRDbHVzdGVySWQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hpbGRDbHVzdGVyID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkQ2x1c3RlcklkXTtcblxuICAgICAgaWYgKHRoaXMuY29udGFpbmVkTm9kZXNbY2hpbGRDbHVzdGVySWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9kZSB3aXRoIGlkOiBcIiArIGNoaWxkQ2x1c3RlcklkICsgXCIgbm90IGluIGN1cnJlbnQgY2x1c3RlclwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGlsZENsdXN0ZXIuaXNDbHVzdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vZGUgd2l0aCBpZDogXCIgKyBjaGlsZENsdXN0ZXJJZCArIFwiIGlzIG5vdCBhIGNsdXN0ZXJcIik7XG4gICAgICB9IC8vIERpc2Nvbm5lY3QgY2hpbGQgY2x1c3RlciBmcm9tIGN1cnJlbnQgY2x1c3RlclxuXG5cbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnRhaW5lZE5vZGVzW2NoaWxkQ2x1c3RlcklkXTtcbiAgICAgIGZvckVhY2gkMyhjaGlsZENsdXN0ZXIuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuY29udGFpbmVkRWRnZXNbZWRnZS5pZF07XG4gICAgICB9KTsgLy8gVHJhbnNmZXIgbm9kZXMgYW5kIGVkZ2VzXG5cbiAgICAgIGZvckVhY2gkMyhjaGlsZENsdXN0ZXIuY29udGFpbmVkTm9kZXMsIGZ1bmN0aW9uIChub2RlLCBub2RlSWQpIHtcbiAgICAgICAgX3RoaXMyLmNvbnRhaW5lZE5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgfSk7XG4gICAgICBjaGlsZENsdXN0ZXIuY29udGFpbmVkTm9kZXMgPSB7fTtcbiAgICAgIGZvckVhY2gkMyhjaGlsZENsdXN0ZXIuY29udGFpbmVkRWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgX3RoaXMyLmNvbnRhaW5lZEVkZ2VzW2VkZ2VJZF0gPSBlZGdlO1xuICAgICAgfSk7XG4gICAgICBjaGlsZENsdXN0ZXIuY29udGFpbmVkRWRnZXMgPSB7fTsgLy8gVHJhbnNmZXIgZWRnZXMgd2l0aGluIGNsdXN0ZXIgZWRnZXMgd2hpY2ggYXJlIGNsdXN0ZXJlZFxuXG4gICAgICBmb3JFYWNoJDMoY2hpbGRDbHVzdGVyLmVkZ2VzLCBmdW5jdGlvbiAoY2x1c3RlckVkZ2UpIHtcbiAgICAgICAgZm9yRWFjaCQzKF90aGlzMi5lZGdlcywgZnVuY3Rpb24gKHBhcmVudENsdXN0ZXJFZGdlKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0LCBfY29udGV4dDI7XG5cbiAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBhIGNsdXN0ZXJlZCBlZGdlIGNhbiBvbmx5IGJlIHByZXNlbnQgaW4gYSBzaW5nbGUgY2x1c3RlcmluZyBlZGdlXG4gICAgICAgICAgLy8gTm90IHRlc3RlZCBoZXJlXG4gICAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhPZiQzKF9jb250ZXh0ID0gcGFyZW50Q2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMpLmNhbGwoX2NvbnRleHQsIGNsdXN0ZXJFZGdlLmlkKTtcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgICBmb3JFYWNoJDMoY2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMsIGZ1bmN0aW9uIChzcmNJZCkge1xuICAgICAgICAgICAgcGFyZW50Q2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMucHVzaChzcmNJZCk7IC8vIE1haW50YWluIGNvcnJlY3QgYm9va2tlZXBpbmcgZm9yIHRyYW5zZmVycmVkIGVkZ2VcblxuICAgICAgICAgICAgX3RoaXMyLmJvZHkuZWRnZXNbc3JjSWRdLmVkZ2VSZXBsYWNlZEJ5SWQgPSBwYXJlbnRDbHVzdGVyRWRnZS5pZDtcbiAgICAgICAgICB9KTsgLy8gUmVtb3ZlIGNsdXN0ZXIgZWRnZSBmcm9tIHBhcmVudCBjbHVzdGVyIGVkZ2VcblxuICAgICAgICAgIHNwbGljZSQyKF9jb250ZXh0MiA9IHBhcmVudENsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzKS5jYWxsKF9jb250ZXh0MiwgaW5kZXgsIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmVkZ2VzID0gW107XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENsdXN0ZXI7XG59KE5vZGUpO1xuXG4vKipcbiAqIFRoZSBjbHVzdGVyaW5nIGVuZ2luZVxuICovXG5cbnZhciBDbHVzdGVyRW5naW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBDbHVzdGVyRW5naW5lKGJvZHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2x1c3RlckVuZ2luZSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2x1c3RlcmVkTm9kZXMgPSB7fTsgLy8ga2V5OiBub2RlIGlkLCB2YWx1ZTogeyBjbHVzdGVySWQ6IDxpZCBvZiBjbHVzdGVyPiwgbm9kZTogPG5vZGUgaW5zdGFuY2U+fVxuXG4gICAgdGhpcy5jbHVzdGVyZWRFZGdlcyA9IHt9OyAvLyBrZXk6IGVkZ2UgaWQsIHZhbHVlOiByZXN0b3JlIGluZm9ybWF0aW9uIGZvciBnaXZlbiBlZGdlXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge307XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzZXREYXRhXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsdXN0ZXJlZE5vZGVzID0ge307XG4gICAgICBfdGhpcy5jbHVzdGVyZWRFZGdlcyA9IHt9O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaHVic2l6ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKENsdXN0ZXJFbmdpbmUsIFt7XG4gICAga2V5OiBcImNsdXN0ZXJCeUh1YnNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2x1c3RlckJ5SHVic2l6ZShodWJzaXplLCBvcHRpb25zKSB7XG4gICAgICBpZiAoaHVic2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGh1YnNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2ZfMShodWJzaXplKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5fY2hlY2tPcHRpb25zKGh1YnNpemUpO1xuICAgICAgICBodWJzaXplID0gdGhpcy5fZ2V0SHViU2l6ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZXNUb0NsdXN0ZXIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcblxuICAgICAgICBpZiAobm9kZS5lZGdlcy5sZW5ndGggPj0gaHVic2l6ZSkge1xuICAgICAgICAgIG5vZGVzVG9DbHVzdGVyLnB1c2gobm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVzVG9DbHVzdGVyLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0aGlzLmNsdXN0ZXJCeUNvbm5lY3Rpb24obm9kZXNUb0NsdXN0ZXJbX2ldLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbG9vcCBvdmVyIGFsbCBub2RlcywgY2hlY2sgaWYgdGhleSBhZGhlcmUgdG8gdGhlIGNvbmRpdGlvbiBhbmQgY2x1c3RlciBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgY2x1c3RlckJ5Tm9kZURhdGEgd2l0aG91dCBhIGpvaW5Db25kaXRpb24gZnVuY3Rpb24gaW4gdGhlIG9wdGlvbnMuXCIpO1xuICAgICAgfSAvLyBjaGVjayBpZiB0aGUgb3B0aW9ucyBvYmplY3QgaXMgZmluZSwgYXBwZW5kIGlmIG5lZWRlZFxuXG5cbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTsgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG5cbiAgICAgIGZvckVhY2gkMyh0aGlzLmJvZHkubm9kZXMsIGZ1bmN0aW9uIChub2RlLCBub2RlSWQpIHtcbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucyAmJiBvcHRpb25zLmpvaW5Db25kaXRpb24obm9kZS5vcHRpb25zKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNoaWxkTm9kZXNPYmpbbm9kZUlkXSA9IG5vZGU7IC8vIGNvbGxlY3QgdGhlIGVkZ2VzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuXG4gICAgICAgICAgZm9yRWFjaCQzKG5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9jbHVzdGVyKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2x1c3RlciBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmsgdGhhdCBoYXZlIG9ubHkgWCBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VDb3VudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJCeUVkZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlFZGdlQ291bnQoZWRnZUNvdW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHZhciBjbHVzdGVycyA9IFtdO1xuICAgICAgdmFyIHVzZWROb2RlcyA9IHt9O1xuICAgICAgdmFyIGVkZ2UsIGVkZ2VzLCByZWxldmFudEVkZ2VDb3VudDsgLy8gY29sbGVjdCB0aGUgbm9kZXMgdGhhdCB3aWxsIGJlIGluIHRoZSBjbHVzdGVyXG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXNPYmogPSB7fTtcbiAgICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTtcbiAgICAgICAgdmFyIG5vZGVJZCA9IF90aGlzMy5ib2R5Lm5vZGVJbmRpY2VzW2ldO1xuICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF07IC8vIGlmIHRoaXMgbm9kZSBpcyBhbHJlYWR5IHVzZWQgaW4gYW5vdGhlciBjbHVzdGVyIHRoaXMgc2Vzc2lvbiwgd2UgZG8gbm90IGhhdmUgdG8gcmUtZXZhbHVhdGUgaXQuXG5cbiAgICAgICAgaWYgKHVzZWROb2Rlc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZWxldmFudEVkZ2VDb3VudCA9IDA7XG4gICAgICAgICAgZWRnZXMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZWRnZSA9IG5vZGUuZWRnZXNbal07XG5cbiAgICAgICAgICAgIGlmIChfdGhpczMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkICE9PSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgICAgIHJlbGV2YW50RWRnZUNvdW50Kys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gdGhpcyBub2RlIHF1YWxpZmllcywgd2UgY29sbGVjdCBpdHMgbmVpZ2hib3VycyB0byBzdGFydCB0aGUgY2x1c3RlcmluZyBwcm9jZXNzLlxuXG5cbiAgICAgICAgICBpZiAocmVsZXZhbnRFZGdlQ291bnQgPT09IGVkZ2VDb3VudCkge1xuICAgICAgICAgICAgdmFyIGNoZWNrSm9pbkNvbmRpdGlvbiA9IGZ1bmN0aW9uIGNoZWNrSm9pbkNvbmRpdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5qb2luQ29uZGl0aW9uKGNsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGdhdGhlcmluZ1N1Y2Nlc3NmdWwgPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgZWRnZXMubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgIGVkZ2UgPSBlZGdlc1tfal07XG5cbiAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gX3RoaXMzLl9nZXRDb25uZWN0ZWRJZChlZGdlLCBub2RlSWQpOyAvLyBhZGQgdGhlIG5vZGVzIHRvIHRoZSBsaXN0IGJ5IHRoZSBqb2luIGNvbmRpdGlvbi5cblxuXG4gICAgICAgICAgICAgIGlmIChjaGVja0pvaW5Db25kaXRpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzT2JqW25vZGVJZF0gPSBub2RlO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gX3RoaXMzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICAgIHVzZWROb2Rlc1tub2RlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG5vZGUgZG9lcyBub3QgcXVhbGlmeSBhZnRlciBhbGwuXG4gICAgICAgICAgICAgICAgZ2F0aGVyaW5nU3VjY2Vzc2Z1bCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGFkZCB0byB0aGUgY2x1c3RlciBxdWV1ZVxuXG5cbiAgICAgICAgICAgIGlmIChrZXlzJDMoY2hpbGROb2Rlc09iaikubGVuZ3RoID4gMCAmJiBrZXlzJDMoY2hpbGRFZGdlc09iaikubGVuZ3RoID4gMCAmJiBnYXRoZXJpbmdTdWNjZXNzZnVsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZWFyY2ggZm9yIGNsdXN0ZXIgZGF0YSB0aGF0IGNvbnRhaW5zIGFueSBvZiB0aGUgbm9kZSBpZCdzXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIG5vIGpvaW5Db25kaXRpb24sIG90aGVyd2lzZSByZXR1cm4gdmFsdWUgb2Ygam9pbkNvbmRpdGlvblxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgdmFyIGZpbmRDbHVzdGVyRGF0YSA9IGZ1bmN0aW9uIGZpbmRDbHVzdGVyRGF0YSgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNsdXN0ZXJzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIGEgY2x1c3RlciBjb250YWluaW5nIGFueSBvZiB0aGUgbm9kZSBpZCdzXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsdXN0ZXJzW25dLm5vZGVzW21dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2x1c3RlcnNbbl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9OyAvLyBJZiBhbnkgb2YgdGhlIGZvdW5kIG5vZGVzIGlzIHBhcnQgb2YgYSBjbHVzdGVyIGZvdW5kIGluIHRoaXMgbWV0aG9kLFxuICAgICAgICAgICAgICAvLyBhZGQgdGhlIGN1cnJlbnQgdmFsdWVzIHRvIHRoYXQgY2x1c3RlclxuXG5cbiAgICAgICAgICAgICAgdmFyIGZvdW5kQ2x1c3RlciA9IGZpbmRDbHVzdGVyRGF0YSgpO1xuXG4gICAgICAgICAgICAgIGlmIChmb3VuZENsdXN0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBub2RlcyB0byBmb3VuZCBjbHVzdGVyIGlmIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZm91bmRDbHVzdGVyLm5vZGVzW21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDbHVzdGVyLm5vZGVzW21dID0gY2hpbGROb2Rlc09ialttXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIEFkZCBlZGdlcyB0byBmb3VuZCBjbHVzdGVyLCBpZiBub3QgcHJlc2VudFxuXG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbSBpbiBjaGlsZEVkZ2VzT2JqKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZm91bmRDbHVzdGVyLmVkZ2VzW19tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQ2x1c3Rlci5lZGdlc1tfbV0gPSBjaGlsZEVkZ2VzT2JqW19tXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNsdXN0ZXIgZ3JvdXBcbiAgICAgICAgICAgICAgICBjbHVzdGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG5vZGVzOiBjaGlsZE5vZGVzT2JqLFxuICAgICAgICAgICAgICAgICAgZWRnZXM6IGNoaWxkRWRnZXNPYmpcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX2xvb3AoaSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNsdXN0ZXJzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdGhpcy5fY2x1c3RlcihjbHVzdGVyc1tfaTJdLm5vZGVzLCBjbHVzdGVyc1tfaTJdLmVkZ2VzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSAxIGVkZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJPdXRsaWVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyT3V0bGllcnMob3B0aW9ucykge1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdGhpcy5jbHVzdGVyQnlFZGdlQ291bnQoMSwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSAyIGVkZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJCcmlkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCcmlkZ2VzKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHRoaXMuY2x1c3RlckJ5RWRnZUNvdW50KDIsIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc3VjayBhbGwgY29ubmVjdGVkIG5vZGVzIG9mIGEgbm9kZSBpbnRvIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyQnlDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCeUNvbm5lY3Rpb24obm9kZUlkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX2NvbnRleHQ7XG5cbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICAgICAgLy8ga2lsbCBjb25kaXRpb25zXG4gICAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbm9kZUlkIHN1cHBsaWVkIHRvIGNsdXN0ZXJCeUNvbm5lY3Rpb24hXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbm9kZUlkIGdpdmVuIHRvIGNsdXN0ZXJCeUNvbm5lY3Rpb24gZG9lcyBub3QgZXhpc3QhXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhvcHRpb25zLCBub2RlKTtcblxuICAgICAgaWYgKG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID0gbm9kZS54O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPSBub2RlLnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkID0ge307XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkLnggPSBub2RlLm9wdGlvbnMuZml4ZWQueDtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQueSA9IG5vZGUub3B0aW9ucy5maXhlZC55O1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgdmFyIGNoaWxkRWRnZXNPYmogPSB7fTtcbiAgICAgIHZhciBwYXJlbnROb2RlSWQgPSBub2RlLmlkO1xuICAgICAgdmFyIHBhcmVudENsb25lZE9wdGlvbnMgPSBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMobm9kZSk7XG4gICAgICBjaGlsZE5vZGVzT2JqW3BhcmVudE5vZGVJZF0gPSBub2RlOyAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcblxuICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gdGhpcy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgcGFyZW50Tm9kZUlkKTsgLy8gaWYgdGhlIGNoaWxkIG5vZGUgaXMgbm90IGluIGEgY2x1c3RlclxuXG5cbiAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWROb2Rlc1tjaGlsZE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZUlkICE9PSBwYXJlbnROb2RlSWQpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNsb25lIHRoZSBvcHRpb25zIGFuZCBpbnNlcnQgc29tZSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdGhhdCBjb3VsZCBiZSBpbnRlcmVzdGluZy5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRDbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKHRoaXMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbihwYXJlbnRDbG9uZWRPcHRpb25zLCBjaGlsZENsb25lZE9wdGlvbnMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHN3YWxsb3cgdGhlIGVkZ2UgaWYgaXQgaXMgc2VsZi1yZWZlcmVuY2luZy5cbiAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZE5vZGVJRHMgPSBtYXAkMihfY29udGV4dCA9IGtleXMkMyhjaGlsZE5vZGVzT2JqKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVdLmlkO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGNoaWxkTm9kZUtleSBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkTm9kZXNPYmosIGNoaWxkTm9kZUtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVLZXldO1xuXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2hpbGROb2RlLmVkZ2VzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkRWRnZSA9IGNoaWxkTm9kZS5lZGdlc1t5XTtcblxuICAgICAgICAgIGlmIChpbmRleE9mJDMoY2hpbGROb2RlSURzKS5jYWxsKGNoaWxkTm9kZUlEcywgdGhpcy5fZ2V0Q29ubmVjdGVkSWQoY2hpbGRFZGdlLCBjaGlsZE5vZGUuaWQpKSA+IC0xKSB7XG4gICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2NoaWxkRWRnZS5pZF0gPSBjaGlsZEVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgdGhlIGVkZ2VzIHRoYXQgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgY2x1c3RlclxuICAgICAqIEl0IGxvb2tzIGZvciBlZGdlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhlIG5vZGVzIGZyb20gdGhlIFwib3V0c2lkZScgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3tOb2RlLmlkOiB2aXMuTm9kZX19IGNoaWxkTm9kZXNPYmpcbiAgICAgKiBAcGFyYW0ge3t2aXMuRWRnZS5pZDogdmlzLkVkZ2V9fSBjaGlsZEVkZ2VzT2JqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsdXN0ZXJOb2RlUHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbHVzdGVyRWRnZVByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUNsdXN0ZXJFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgZWRnZSwgY2hpbGROb2RlSWQsIGNoaWxkTm9kZSwgdG9JZCwgZnJvbUlkLCBvdGhlck5vZGVJZDsgLy8gbG9vcCBvdmVyIGFsbCBjaGlsZCBub2RlcyBhbmQgdGhlaXIgZWRnZXMgdG8gZmluZCBlZGdlcyBnb2luZyBvdXQgb2YgdGhlIGNsdXN0ZXJcbiAgICAgIC8vIHRoZXNlIGVkZ2VzIHdpbGwgYmUgcmVwbGFjZWQgYnkgY2x1c3RlckVkZ2VzLlxuXG4gICAgICB2YXIgY2hpbGRLZXlzID0ga2V5cyQzKGNoaWxkTm9kZXNPYmopO1xuXG4gICAgICB2YXIgY3JlYXRlRWRnZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGROb2RlSWQgPSBjaGlsZEtleXNbaV07XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdOyAvLyBjb25zdHJ1Y3QgbmV3IGVkZ2VzIGZyb20gdGhlIGNsdXN0ZXIgdG8gb3RoZXJzXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGUuZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBlZGdlID0gY2hpbGROb2RlLmVkZ2VzW2pdOyAvLyB3ZSBvbmx5IGhhbmRsZSBlZGdlcyB0aGF0IGFyZSB2aXNpYmxlIHRvIHRoZSBzeXN0ZW0sIG5vdCB0aGUgZGlzYWJsZWQgb25lcyBmcm9tIHRoZSBjbHVzdGVyaW5nIHByb2Nlc3MuXG5cbiAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZWxmLXJlZmVyZW5jaW5nIGVkZ2VzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFwiaGlkZGVuXCIgbGlzdFxuICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHNldCB1cCB0aGUgZnJvbSBhbmQgdG8uXG4gICAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gY2hpbGROb2RlSWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgZG91YmxlIGVxdWFscyBiZWNhdXNlIGludHMgYW5kIHN0cmluZ3MgY2FuIGJlIGludGVyY2hhbmdlZCBoZXJlLlxuICAgICAgICAgICAgICAgIHRvSWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG4gICAgICAgICAgICAgICAgZnJvbUlkID0gZWRnZS5mcm9tSWQ7XG4gICAgICAgICAgICAgICAgb3RoZXJOb2RlSWQgPSBmcm9tSWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9JZCA9IGVkZ2UudG9JZDtcbiAgICAgICAgICAgICAgICBmcm9tSWQgPSBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQ7XG4gICAgICAgICAgICAgICAgb3RoZXJOb2RlSWQgPSB0b0lkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIE9ubHkgZWRnZXMgZnJvbSB0aGUgY2x1c3RlciBvdXR3YXJkcyBhcmUgYmVpbmcgcmVwbGFjZWQuXG5cblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmpbb3RoZXJOb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3JlYXRlRWRnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWRnZTogZWRnZSxcbiAgICAgICAgICAgICAgICBmcm9tSWQ6IGZyb21JZCxcbiAgICAgICAgICAgICAgICB0b0lkOiB0b0lkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvL1xuICAgICAgLy8gSGVyZSB3ZSBhY3R1YWxseSBjcmVhdGUgdGhlIHJlcGxhY2VtZW50IGVkZ2VzLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIGNvdWxkIG5vdCBkbyB0aGlzIGluIHRoZSBsb29wIGFib3ZlIGFzIHRoZSBjcmVhdGlvbiBwcm9jZXNzXG4gICAgICAvLyB3b3VsZCBhZGQgYW4gZWRnZSB0byB0aGUgZWRnZXMgYXJyYXkgd2UgYXJlIGl0ZXJhdGluZyBvdmVyLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IGEgY2x1c3RlcmVkIGVkZ2UgY2FuIGhhdmUgbXVsdGlwbGUgYmFzZSBlZGdlcyFcbiAgICAgIC8vXG5cblxuICAgICAgdmFyIG5ld0VkZ2VzID0gW107XG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgYSBjbHVzdGVyIGVkZ2Ugd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gY3JlYXRlZCBlZGdlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7dmlzLkVkZ2V9IGNyZWF0ZWRFZGdlXG4gICAgICAgKiBAcmV0dXJucyB7dmlzLkVkZ2V9XG4gICAgICAgKi9cblxuICAgICAgdmFyIGdldE5ld0VkZ2UgPSBmdW5jdGlvbiBnZXROZXdFZGdlKGNyZWF0ZWRFZGdlKSB7XG4gICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG5ld0VkZ2VzLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgbmV3RWRnZSA9IG5ld0VkZ2VzW19qMl07IC8vIFdlIHJlcGxhY2UgYm90aCB0byBhbmQgZnJvbSBlZGdlcyB3aXRoIGEgc2luZ2xlIGNsdXN0ZXIgZWRnZVxuXG4gICAgICAgICAgdmFyIG1hdGNoVG9EaXJlY3Rpb24gPSBjcmVhdGVkRWRnZS5mcm9tSWQgPT09IG5ld0VkZ2UuZnJvbUlkICYmIGNyZWF0ZWRFZGdlLnRvSWQgPT09IG5ld0VkZ2UudG9JZDtcbiAgICAgICAgICB2YXIgbWF0Y2hGcm9tRGlyZWN0aW9uID0gY3JlYXRlZEVkZ2UuZnJvbUlkID09PSBuZXdFZGdlLnRvSWQgJiYgY3JlYXRlZEVkZ2UudG9JZCA9PT0gbmV3RWRnZS5mcm9tSWQ7XG5cbiAgICAgICAgICBpZiAobWF0Y2hUb0RpcmVjdGlvbiB8fCBtYXRjaEZyb21EaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdFZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgX2ozID0gMDsgX2ozIDwgY3JlYXRlRWRnZXMubGVuZ3RoOyBfajMrKykge1xuICAgICAgICB2YXIgY3JlYXRlZEVkZ2UgPSBjcmVhdGVFZGdlc1tfajNdO1xuICAgICAgICB2YXIgX2VkZ2UgPSBjcmVhdGVkRWRnZS5lZGdlO1xuICAgICAgICB2YXIgbmV3RWRnZSA9IGdldE5ld0VkZ2UoY3JlYXRlZEVkZ2UpO1xuXG4gICAgICAgIGlmIChuZXdFZGdlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgY2x1c3RlcmVkIGVkZ2UgZm9yIHRoaXMgY29ubmVjdGlvblxuICAgICAgICAgIG5ld0VkZ2UgPSB0aGlzLl9jcmVhdGVDbHVzdGVyZWRFZGdlKGNyZWF0ZWRFZGdlLmZyb21JZCwgY3JlYXRlZEVkZ2UudG9JZCwgX2VkZ2UsIGNsdXN0ZXJFZGdlUHJvcGVydGllcyk7XG4gICAgICAgICAgbmV3RWRnZXMucHVzaChuZXdFZGdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLnB1c2goX2VkZ2UuaWQpO1xuICAgICAgICB9IC8vIGFsc28gcmVmZXJlbmNlIHRoZSBuZXcgZWRnZSBpbiB0aGUgb2xkIGVkZ2VcblxuXG4gICAgICAgIHRoaXMuYm9keS5lZGdlc1tfZWRnZS5pZF0uZWRnZVJlcGxhY2VkQnlJZCA9IG5ld0VkZ2UuaWQ7IC8vIGhpZGUgdGhlIHJlcGxhY2VkIGVkZ2VcblxuICAgICAgICB0aGlzLl9iYWNrdXBFZGdlT3B0aW9ucyhfZWRnZSk7XG5cbiAgICAgICAgX2VkZ2Uuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIHRoZSBvcHRpb25zIHRoYXQgY2FuIGJlIHN1cHBsaWVkIHRvIHRoZSBkaWZmZXJlbnQgY2x1c3RlciBmdW5jdGlvbnNcbiAgICAgKiBmb3IgY2VydGFpbiBmaWVsZHMgYW5kIGluc2VydHMgZGVmYXVsdHMgaWYgbmVlZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja09wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICBjaGlsZE5vZGVzT2JqICAgICAgICAgfCBvYmplY3Qgd2l0aCBub2RlIG9iamVjdHMsIGlkIGFzIGtleXMsIHNhbWUgYXMgY2hpbGROb2RlcyBleGNlcHQgaXQgYWxzbyBjb250YWlucyBhIHNvdXJjZSBub2RlXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgIGNoaWxkRWRnZXNPYmogICAgICAgICB8IG9iamVjdCB3aXRoIGVkZ2Ugb2JqZWN0cywgaWQgYXMga2V5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgICBvcHRpb25zICAgICAgICAgICAgICAgfCBvYmplY3Qgd2l0aCB7Y2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMsIHByb2Nlc3NQcm9wZXJ0aWVzfVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gICByZWZyZXNoRGF0YSB8IHdoZW4gdHJ1ZSwgZG8gbm90IHdyYXAgdXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsdXN0ZXIoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgICAgLy8gUmVtb3ZlIG5vZGVzIHdoaWNoIGFyZSBhbHJlYWR5IGNsdXN0ZXJlZFxuICAgICAgdmFyIHRtcE5vZGVzVG9SZW1vdmUgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZE5vZGVzT2JqLCBub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0bXBOb2Rlc1RvUmVtb3ZlLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0bXBOb2Rlc1RvUmVtb3ZlLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGRlbGV0ZSBjaGlsZE5vZGVzT2JqW3RtcE5vZGVzVG9SZW1vdmVbbl1dO1xuICAgICAgfSAvLyBraWxsIGNvbmRpdGlvbjogbm8gbm9kZXMgZG9uJ3QgYm90aGVyXG5cblxuICAgICAgaWYgKGtleXMkMyhjaGlsZE5vZGVzT2JqKS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGFsbG93IGNsdXN0ZXJzIG9mIDEgaWYgb3B0aW9ucyBhbGxvd1xuXG5cbiAgICAgIGlmIChrZXlzJDMoY2hpbGROb2Rlc09iaikubGVuZ3RoID09IDEgJiYgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuYWxsb3dTaW5nbGVOb2RlQ2x1c3RlciAhPSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IGRlZXBFeHRlbmQoe30sIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzKTsgLy8gY29uc3RydWN0IHRoZSBjbHVzdGVyTm9kZVByb3BlcnRpZXNcblxuICAgICAgaWYgKG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBnZXQgdGhlIGNoaWxkTm9kZSBvcHRpb25zXG4gICAgICAgIHZhciBjaGlsZE5vZGVzT3B0aW9ucyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9ub2RlSWQgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGROb2Rlc09iaiwgX25vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGNoaWxkTm9kZXNPYmpbX25vZGVJZF0pO1xuICAgICAgICAgICAgY2hpbGROb2Rlc09wdGlvbnMucHVzaChjbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZ2V0IGNsdXN0ZXIgcHJvcGVydGllcyBiYXNlZCBvbiBjaGlsZE5vZGVzXG5cblxuICAgICAgICB2YXIgY2hpbGRFZGdlc09wdGlvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY2hpbGRFZGdlc09iaikge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGRFZGdlc09iaiwgZWRnZUlkKSkge1xuICAgICAgICAgICAgLy8gdGhlc2UgY2x1c3RlciBlZGdlcyB3aWxsIGJlIHJlbW92ZWQgb24gY3JlYXRpb24gb2YgdGhlIGNsdXN0ZXIuXG4gICAgICAgICAgICBpZiAoZWRnZUlkLnN1YnN0cigwLCAxMikgIT09IFwiY2x1c3RlckVkZ2U6XCIpIHtcbiAgICAgICAgICAgICAgdmFyIF9jbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGNoaWxkRWRnZXNPYmpbZWRnZUlkXSwgXCJlZGdlXCIpO1xuXG4gICAgICAgICAgICAgIGNoaWxkRWRnZXNPcHRpb25zLnB1c2goX2Nsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcyA9IG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjaGlsZE5vZGVzT3B0aW9ucywgY2hpbGRFZGdlc09wdGlvbnMpO1xuXG4gICAgICAgIGlmICghY2x1c3Rlck5vZGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb2Nlc3NQcm9wZXJ0aWVzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBwcm9wZXJ0aWVzIVwiKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjaGVjayBpZiB3ZSBoYXZlIGFuIHVuaXF1ZSBpZDtcblxuXG4gICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID0gXCJjbHVzdGVyOlwiICsgdjQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsdXN0ZXJJZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcblxuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5sYWJlbCA9IFwiY2x1c3RlclwiO1xuICAgICAgfSAvLyBnaXZlIHRoZSBjbHVzdGVyTm9kZSBhIHBvc2l0aW9uIGlmIGl0IGRvZXMgbm90IGhhdmUgb25lLlxuXG5cbiAgICAgIHZhciBwb3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvcyA9IHRoaXMuX2dldENsdXN0ZXJQb3NpdGlvbihjaGlsZE5vZGVzT2JqKTtcbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPSBwb3MueDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsdXN0ZXJOb2RlUHJvcGVydGllcy55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q2x1c3RlclBvc2l0aW9uKGNoaWxkTm9kZXNPYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPSBwb3MueTtcbiAgICAgIH0gLy8gZm9yY2UgdGhlIElEIHRvIHJlbWFpbiB0aGUgc2FtZVxuXG5cbiAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IGNsdXN0ZXJJZDsgLy8gY3JlYXRlIHRoZSBjbHVzdGVyIE5vZGVcbiAgICAgIC8vIE5vdGUgdGhhdCBhbGxvd1NpbmdsZU5vZGVDbHVzdGVyLCBpZiBwcmVzZW50LCBpcyBzdG9yZWQgaW4gdGhlIG9wdGlvbnMgYXMgd2VsbFxuXG4gICAgICB2YXIgY2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBDbHVzdGVyKTtcbiAgICAgIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzID0gY2hpbGROb2Rlc09iajtcbiAgICAgIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzID0gY2hpbGRFZGdlc09iajsgLy8gY2FjaGUgYSBjb3B5IGZyb20gdGhlIGNsdXN0ZXIgZWRnZSBwcm9wZXJ0aWVzIGlmIHdlIGhhdmUgdG8gcmVjb25uZWN0IG90aGVycyBsYXRlciBvblxuXG4gICAgICBjbHVzdGVyTm9kZS5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPSBvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllczsgLy8gZmluYWxseSBwdXQgdGhlIGNsdXN0ZXIgbm9kZSBpbnRvIGdsb2JhbFxuXG4gICAgICB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkXSA9IGNsdXN0ZXJOb2RlO1xuXG4gICAgICB0aGlzLl9jbHVzdGVyRWRnZXMoY2hpbGROb2Rlc09iaiwgY2hpbGRFZGdlc09iaiwgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBvcHRpb25zLmNsdXN0ZXJFZGdlUHJvcGVydGllcyk7IC8vIHNldCBJRCB0byB1bmRlZmluZWQgc28gbm8gZHVwbGljYXRlcyBhcmlzZVxuXG5cbiAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IHVuZGVmaW5lZDsgLy8gd3JhcCB1cFxuXG4gICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JhY2t1cEVkZ2VPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iYWNrdXBFZGdlT3B0aW9ucyhlZGdlKSB7XG4gICAgICBpZiAodGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPSB7XG4gICAgICAgICAgcGh5c2ljczogZWRnZS5vcHRpb25zLnBoeXNpY3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc3RvcmVFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN0b3JlRWRnZShlZGdlKSB7XG4gICAgICB2YXIgb3JpZ2luYWxPcHRpb25zID0gdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlLmlkXTtcblxuICAgICAgaWYgKG9yaWdpbmFsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgcGh5c2ljczogb3JpZ2luYWxPcHRpb25zLnBoeXNpY3NcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzQ2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NsdXN0ZXIobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaXNDbHVzdGVyID09PSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGUgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGNsdXN0ZXIgbm9kZSBiYXNlZCBvbiB3aGF0J3MgaW5zaWRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2hpbGROb2Rlc09iaiAgICB8IG9iamVjdCB3aXRoIG5vZGUgb2JqZWN0cywgaWQgYXMga2V5c1xuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2x1c3RlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaikge1xuICAgICAgdmFyIGNoaWxkS2V5cyA9IGtleXMkMyhjaGlsZE5vZGVzT2JqKTtcblxuICAgICAgdmFyIG1pblggPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueDtcbiAgICAgIHZhciBtYXhYID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLng7XG4gICAgICB2YXIgbWluWSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS55O1xuICAgICAgdmFyIG1heFkgPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueTtcbiAgICAgIHZhciBub2RlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoaWxkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbaV1dO1xuICAgICAgICBtaW5YID0gbm9kZS54IDwgbWluWCA/IG5vZGUueCA6IG1pblg7XG4gICAgICAgIG1heFggPSBub2RlLnggPiBtYXhYID8gbm9kZS54IDogbWF4WDtcbiAgICAgICAgbWluWSA9IG5vZGUueSA8IG1pblkgPyBub2RlLnkgOiBtaW5ZO1xuICAgICAgICBtYXhZID0gbm9kZS55ID4gbWF4WSA/IG5vZGUueSA6IG1heFk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAuNSAqIChtaW5YICsgbWF4WCksXG4gICAgICAgIHk6IDAuNSAqIChtaW5ZICsgbWF4WSlcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gYSBjbHVzdGVyIGJ5IGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9ICBjbHVzdGVyTm9kZUlkIHwgdGhlIElEIG9mIHRoZSBjbHVzdGVyIG5vZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVmcmVzaERhdGEgfCB3cmFwIHVwIGFmdGVyd2FyZHMgaWYgbm90IHRydWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5DbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5DbHVzdGVyKGNsdXN0ZXJOb2RlSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICAgICAgLy8ga2lsbCBjb25kaXRpb25zXG4gICAgICBpZiAoY2x1c3Rlck5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNsdXN0ZXJOb2RlSWQgc3VwcGxpZWQgdG8gb3BlbkNsdXN0ZXIuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF07XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjbHVzdGVyTm9kZUlkIHN1cHBsaWVkIHRvIG9wZW5DbHVzdGVyIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsdXN0ZXJOb2RlLmlzQ2x1c3RlciAhPT0gdHJ1ZSB8fCBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcyA9PT0gdW5kZWZpbmVkIHx8IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5vZGU6XCIgKyBjbHVzdGVyTm9kZUlkICsgXCIgaXMgbm90IGEgdmFsaWQgY2x1c3Rlci5cIik7XG4gICAgICB9IC8vIENoZWNrIGlmIGN1cnJlbnQgY2x1c3RlciBpcyBjbHVzdGVyZWQgaXRzZWxmXG5cblxuICAgICAgdmFyIHN0YWNrID0gdGhpcy5maW5kTm9kZShjbHVzdGVyTm9kZUlkKTtcbiAgICAgIHZhciBwYXJlbnRJbmRleCA9IGluZGV4T2YkMyhzdGFjaykuY2FsbChzdGFjaywgY2x1c3Rlck5vZGVJZCkgLSAxO1xuXG4gICAgICBpZiAocGFyZW50SW5kZXggPj0gMCkge1xuICAgICAgICAvLyBDdXJyZW50IGNsdXN0ZXIgaXMgY2x1c3RlcmVkOyB0cmFuc2ZlciBjb250YWluZWQgbm9kZXMgYW5kIGVkZ2VzIHRvIHBhcmVudFxuICAgICAgICB2YXIgcGFyZW50Q2x1c3Rlck5vZGVJZCA9IHN0YWNrW3BhcmVudEluZGV4XTtcbiAgICAgICAgdmFyIHBhcmVudENsdXN0ZXJOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3BhcmVudENsdXN0ZXJOb2RlSWRdOyAvLyBjbHVzdGVyaW5nLmNsdXN0ZXJlZE5vZGVzIGFuZCBjbHVzdGVyaW5nLmNsdXN0ZXJlZEVkZ2VzIHJlbWFpbiB1bmNoYW5nZWRcblxuICAgICAgICBwYXJlbnRDbHVzdGVyTm9kZS5fb3BlbkNoaWxkQ2x1c3RlcihjbHVzdGVyTm9kZUlkKTsgLy8gQWxsIGNvbXBvbmVudHMgb2YgY2hpbGQgY2x1c3RlciBub2RlIGhhdmUgYmVlbiB0cmFuc2ZlcnJlZC4gSXQgY2FuIGRpZSBub3cuXG5cblxuICAgICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuXG4gICAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1haW4gYm9keVxuXG5cbiAgICAgIHZhciBjb250YWluZWROb2RlcyA9IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzO1xuICAgICAgdmFyIGNvbnRhaW5lZEVkZ2VzID0gY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXM7IC8vIGFsbG93IHRoZSB1c2VyIHRvIHBvc2l0aW9uIHRoZSBub2RlcyBhZnRlciByZWxlYXNlLlxuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgY2x1c3RlclBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGNsdXN0ZXJOb2RlLngsXG4gICAgICAgICAgeTogY2x1c3Rlck5vZGUueVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkTm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZWROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBwb3NpdGlvbnNbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgICAgeDogY29udGFpbmVkTm9kZS54LFxuICAgICAgICAgICAgICB5OiBjb250YWluZWROb2RlLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9ucyA9IG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uKGNsdXN0ZXJQb3NpdGlvbiwgcG9zaXRpb25zKTtcblxuICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkTm9kZXMsIF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgdmFyIF9jb250YWluZWROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQyXTtcblxuICAgICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uc1tfbm9kZUlkMl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBfY29udGFpbmVkTm9kZS54ID0gbmV3UG9zaXRpb25zW19ub2RlSWQyXS54ID09PSB1bmRlZmluZWQgPyBjbHVzdGVyTm9kZS54IDogbmV3UG9zaXRpb25zW19ub2RlSWQyXS54O1xuICAgICAgICAgICAgICBfY29udGFpbmVkTm9kZS55ID0gbmV3UG9zaXRpb25zW19ub2RlSWQyXS55ID09PSB1bmRlZmluZWQgPyBjbHVzdGVyTm9kZS55IDogbmV3UG9zaXRpb25zW19ub2RlSWQyXS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29weSB0aGUgcG9zaXRpb24gZnJvbSB0aGUgY2x1c3RlclxuICAgICAgICBmb3JFYWNoJDMoY29udGFpbmVkTm9kZXMsIGZ1bmN0aW9uIChjb250YWluZWROb2RlKSB7XG4gICAgICAgICAgLy8gaW5oZXJpdCBwb3NpdGlvblxuICAgICAgICAgIGlmIChjb250YWluZWROb2RlLm9wdGlvbnMuZml4ZWQueCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lZE5vZGUueCA9IGNsdXN0ZXJOb2RlLng7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRhaW5lZE5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGFpbmVkTm9kZS55ID0gY2x1c3Rlck5vZGUueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyByZWxlYXNlIG5vZGVzXG5cblxuICAgICAgZm9yICh2YXIgX25vZGVJZDMgaW4gY29udGFpbmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250YWluZWROb2RlcywgX25vZGVJZDMpKSB7XG4gICAgICAgICAgdmFyIF9jb250YWluZWROb2RlMiA9IHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkM107IC8vIGluaGVyaXQgc3BlZWRcblxuICAgICAgICAgIF9jb250YWluZWROb2RlMi52eCA9IGNsdXN0ZXJOb2RlLnZ4O1xuICAgICAgICAgIF9jb250YWluZWROb2RlMi52eSA9IGNsdXN0ZXJOb2RlLnZ5O1xuXG4gICAgICAgICAgX2NvbnRhaW5lZE5vZGUyLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcGh5c2ljczogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVsZXRlIHRoaXMuY2x1c3RlcmVkTm9kZXNbX25vZGVJZDNdO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNvcHkgdGhlIGNsdXN0ZXJOb2RlIGVkZ2VzIGJlY2F1c2Ugd2UgY2Fubm90IGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QgdGhhdCB3ZSBhZGQgb3IgcmVtb3ZlIGZyb20uXG5cblxuICAgICAgdmFyIGVkZ2VzVG9CZURlbGV0ZWQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVyTm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlZGdlc1RvQmVEZWxldGVkLnB1c2goY2x1c3Rlck5vZGUuZWRnZXNbaV0pO1xuICAgICAgfSAvLyBhY3R1YWxseSBoYW5kbGluZyB0aGUgZGVsZXRpbmcuXG5cblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXNUb0JlRGVsZXRlZC5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNUb0JlRGVsZXRlZFtfaTNdO1xuXG4gICAgICAgIHZhciBvdGhlck5vZGVJZCA9IHRoaXMuX2dldENvbm5lY3RlZElkKGVkZ2UsIGNsdXN0ZXJOb2RlSWQpO1xuXG4gICAgICAgIHZhciBvdGhlck5vZGUgPSB0aGlzLmNsdXN0ZXJlZE5vZGVzW290aGVyTm9kZUlkXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgdHJhbnNmZXJJZCA9IGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHNbal07XG4gICAgICAgICAgdmFyIHRyYW5zZmVyRWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0cmFuc2ZlcklkXTtcbiAgICAgICAgICBpZiAodHJhbnNmZXJFZGdlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlOyAvLyBpZiB0aGUgb3RoZXIgbm9kZSBpcyBpbiBhbm90aGVyIGNsdXN0ZXIsIHdlIHRyYW5zZmVyIG93bmVyc2hpcCBvZiB0aGlzIGVkZ2UgdG8gdGhlIG90aGVyIGNsdXN0ZXJcblxuICAgICAgICAgIGlmIChvdGhlck5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdHJhbnNmZXIgb3duZXJzaGlwOlxuICAgICAgICAgICAgdmFyIG90aGVyQ2x1c3RlciA9IHRoaXMuYm9keS5ub2Rlc1tvdGhlck5vZGUuY2x1c3RlcklkXTtcbiAgICAgICAgICAgIG90aGVyQ2x1c3Rlci5jb250YWluZWRFZGdlc1t0cmFuc2ZlckVkZ2UuaWRdID0gdHJhbnNmZXJFZGdlOyAvLyBkZWxldGUgbG9jYWwgcmVmZXJlbmNlXG5cbiAgICAgICAgICAgIGRlbGV0ZSBjb250YWluZWRFZGdlc1t0cmFuc2ZlckVkZ2UuaWRdOyAvLyBnZXQgdG8gYW5kIGZyb21cblxuICAgICAgICAgICAgdmFyIGZyb21JZCA9IHRyYW5zZmVyRWRnZS5mcm9tSWQ7XG4gICAgICAgICAgICB2YXIgdG9JZCA9IHRyYW5zZmVyRWRnZS50b0lkO1xuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJFZGdlLnRvSWQgPT0gb3RoZXJOb2RlSWQpIHtcbiAgICAgICAgICAgICAgdG9JZCA9IG90aGVyTm9kZS5jbHVzdGVySWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tSWQgPSBvdGhlck5vZGUuY2x1c3RlcklkO1xuICAgICAgICAgICAgfSAvLyBjcmVhdGUgbmV3IGNsdXN0ZXIgZWRnZSBmcm9tIHRoZSBvdGhlckNsdXN0ZXJcblxuXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVDbHVzdGVyZWRFZGdlKGZyb21JZCwgdG9JZCwgdHJhbnNmZXJFZGdlLCBvdGhlckNsdXN0ZXIuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICAgICAgICAgIHBoeXNpY3M6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN0b3JlRWRnZSh0cmFuc2ZlckVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgICB9IC8vIGhhbmRsZSB0aGUgcmVsZWFzaW5nIG9mIHRoZSBlZGdlc1xuXG5cbiAgICAgIGZvciAodmFyIGVkZ2VJZCBpbiBjb250YWluZWRFZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZEVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgdGhpcy5fcmVzdG9yZUVkZ2UoY29udGFpbmVkRWRnZXNbZWRnZUlkXSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcmVtb3ZlIGNsdXN0ZXJOb2RlXG5cblxuICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyTm9kZUlkXTtcblxuICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDbHVzdGVyLmlkfSBjbHVzdGVySWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE5vZGUuaWQ+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZXNJbkNsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZXNJbkNsdXN0ZXIoY2x1c3RlcklkKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5pc0NsdXN0ZXIoY2x1c3RlcklkKSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgY29udGFpbmVkTm9kZXMgPSB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcklkXS5jb250YWluZWROb2RlcztcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gY29udGFpbmVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZE5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICBub2Rlc0FycmF5LnB1c2godGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZXNBcnJheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGFjayBjbHVzdGVySWQncyB0aGF0IGEgY2VydGFpbiBub2RlIHJlc2lkZXMgaW4uIGNsdXN0ZXIgQSAtPiBjbHVzdGVyIEIgLT4gY2x1c3RlciBDIC0+IG5vZGVcbiAgICAgKlxuICAgICAqIElmIGEgbm9kZSBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgY2hhaW4sIHJldHVybiBhbiBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbm9kZUlkXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZE5vZGUobm9kZUlkKSB7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBtYXggPSAxMDA7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgbm9kZTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkICYmIGNvdW50ZXIgPCBtYXgpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgICAgIHN0YWNrLnB1c2gobm9kZS5pZCk7XG4gICAgICAgIG5vZGVJZCA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXS5jbHVzdGVySWQ7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICAgICAgc3RhY2sucHVzaChub2RlLmlkKTtcblxuICAgICAgcmV2ZXJzZSQyKHN0YWNrKS5jYWxsKHN0YWNrKTtcblxuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2luZyBhIGNsdXN0ZXJlZCBub2RlSWQsIHVwZGF0ZSB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBjbHVzdGVyZWROb2RlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQ2x1c3RlcmVkTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDbHVzdGVyZWROb2RlKGNsdXN0ZXJlZE5vZGVJZCwgbmV3T3B0aW9ucykge1xuICAgICAgaWYgKGNsdXN0ZXJlZE5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlLlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld09wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBuZXdPcHRpb25zIHN1cHBsaWVkIHRvIHVwZGF0ZUNsdXN0ZXJlZE5vZGUuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJlZE5vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY2x1c3RlcmVkTm9kZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUNsdXN0ZXJlZE5vZGUgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcmVkTm9kZUlkXS5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgYSBiYXNlIGVkZ2VJZCwgdXBkYXRlIGFsbCByZWxhdGVkIGNsdXN0ZXJlZCBlZGdlcyB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gc3RhcnRFZGdlSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFZGdlKHN0YXJ0RWRnZUlkLCBuZXdPcHRpb25zKSB7XG4gICAgICBpZiAoc3RhcnRFZGdlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdGFydEVkZ2VJZCBzdXBwbGllZCB0byB1cGRhdGVFZGdlLlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld09wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBuZXdPcHRpb25zIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW3N0YXJ0RWRnZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdGFydEVkZ2VJZCBzdXBwbGllZCB0byB1cGRhdGVFZGdlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFsbEVkZ2VJZHMgPSB0aGlzLmdldENsdXN0ZXJlZEVkZ2VzKHN0YXJ0RWRnZUlkKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW2FsbEVkZ2VJZHNbaV1dO1xuICAgICAgICBlZGdlLnNldE9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHN0YWNrIG9mIGNsdXN0ZXJFZGdlSWQncyAoK2Jhc2UgZWRnZWlkKSB0aGF0IGEgYmFzZSBlZGdlIGlzIHRoZSBzYW1lIGFzLiBjbHVzdGVyIGVkZ2UgQyAtPiBjbHVzdGVyIGVkZ2UgQiAtPiBjbHVzdGVyIGVkZ2UgQSAtPiBiYXNlIGVkZ2UoZWRnZUlkKVxuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZS5pZH0gZWRnZUlkXG4gICAgICogQHJldHVybnMge0FycmF5Ljx2aXMuRWRnZS5pZD59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDbHVzdGVyZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbHVzdGVyZWRFZGdlcyhlZGdlSWQpIHtcbiAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgICAgd2hpbGUgKGVkZ2VJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQgJiYgY291bnRlciA8IG1heCkge1xuICAgICAgICBzdGFjay5wdXNoKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLmlkKTtcbiAgICAgICAgZWRnZUlkID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0uZWRnZVJlcGxhY2VkQnlJZDtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuXG4gICAgICByZXZlcnNlJDIoc3RhY2spLmNhbGwoc3RhY2spO1xuXG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYmFzZSBlZGdlIGlkIG9mIGNsdXN0ZXJFZGdlSWQuIGNsdXN0ZXIgZWRnZSAoY2x1c3RlcmVkRWRnZUlkKSAtPiBjbHVzdGVyIGVkZ2UgQiAtPiBjbHVzdGVyIGVkZ2UgQyAtPiBiYXNlIGVkZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGNsdXN0ZXJlZEVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHt2aXMuRWRnZS5pZH0gYmFzZUVkZ2VJZFxuICAgICAqXG4gICAgICogVE9ETzogZGVwcmVjYXRlIGluIDUuMC4wLiBNZXRob2QgZ2V0QmFzZUVkZ2VzKCkgaXMgdGhlIGNvcnJlY3Qgb25lIHRvIHVzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VFZGdlKGNsdXN0ZXJlZEVkZ2VJZCkge1xuICAgICAgLy8gSnVzdCBrbHVkZ2UgdGhpcyBieSByZXR1cm5pbmcgdGhlIGZpcnN0IGJhc2UgZWRnZSBpZCBmb3VuZFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QmFzZUVkZ2VzKGNsdXN0ZXJlZEVkZ2VJZClbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVndWxhciBlZGdlcyBmb3IgdGhpcyBjbHVzdGVyZWQgZWRnZSBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGNsdXN0ZXJlZEVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48dmlzLkVkZ2UuaWQ+fSBhbGwgYmFzZUVkZ2VJZCdzIHVuZGVyIHRoaXMgY2x1c3RlcmVkIGVkZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlRWRnZXMoY2x1c3RlcmVkRWRnZUlkKSB7XG4gICAgICB2YXIgSWRzVG9IYW5kbGUgPSBbY2x1c3RlcmVkRWRnZUlkXTtcbiAgICAgIHZhciBkb25lSWRzID0gW107XG4gICAgICB2YXIgZm91bmRJZHMgPSBbXTtcbiAgICAgIHZhciBtYXggPSAxMDA7XG4gICAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICAgIHdoaWxlIChJZHNUb0hhbmRsZS5sZW5ndGggPiAwICYmIGNvdW50ZXIgPCBtYXgpIHtcbiAgICAgICAgdmFyIG5leHRJZCA9IElkc1RvSGFuZGxlLnBvcCgpO1xuICAgICAgICBpZiAobmV4dElkID09PSB1bmRlZmluZWQpIGNvbnRpbnVlOyAvLyBQYXJhbm9pYSBoZXJlIGFuZCBvbndhcmRzXG5cbiAgICAgICAgdmFyIG5leHRFZGdlID0gdGhpcy5ib2R5LmVkZ2VzW25leHRJZF07XG4gICAgICAgIGlmIChuZXh0RWRnZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgICB2YXIgcmVwbGFjaW5nSWRzID0gbmV4dEVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHM7XG5cbiAgICAgICAgaWYgKHJlcGxhY2luZ0lkcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gbmV4dElkIGlzIGEgYmFzZSBpZFxuICAgICAgICAgIGZvdW5kSWRzLnB1c2gobmV4dElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbm90aGVyIGNsdXN0ZXIgZWRnZSwgdW5yYXZlbCB0aGlzIG9uZSBhcyB3ZWxsXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNpbmdJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNpbmdJZCA9IHJlcGxhY2luZ0lkc1tpXTsgLy8gRG9uJ3QgYWRkIGlmIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICAgICAgLy8gVE9ETzogbmV2ZXIgdHJpZ2dlcnM7IGZpbmQgYSB0ZXN0LWNhc2Ugd2hpY2ggZG9lc1xuXG4gICAgICAgICAgICBpZiAoaW5kZXhPZiQzKElkc1RvSGFuZGxlKS5jYWxsKElkc1RvSGFuZGxlLCByZXBsYWNpbmdJZHMpICE9PSAtMSB8fCBpbmRleE9mJDMoZG9uZUlkcykuY2FsbChkb25lSWRzLCByZXBsYWNpbmdJZHMpICE9PSAtMSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgSWRzVG9IYW5kbGUucHVzaChyZXBsYWNpbmdJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZG9uZUlkcy5wdXNoKG5leHRJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3VuZElkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBJZCB0aGUgbm9kZSBpcyBjb25uZWN0ZWQgdG9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2V9IGVkZ2VcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q29ubmVjdGVkSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbm5lY3RlZElkKGVkZ2UsIG5vZGVJZCkge1xuICAgICAgaWYgKGVkZ2UudG9JZCAhPSBub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UudG9JZDtcbiAgICAgIH0gZWxzZSBpZiAoZWRnZS5mcm9tSWQgIT0gbm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBlZGdlLmZyb21JZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlZGdlLmZyb21JZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2UgZGV0ZXJtaW5lIGhvdyBtYW55IGNvbm5lY3Rpb25zIGRlbm90ZSBhbiBpbXBvcnRhbnQgaHViLlxuICAgICAqIFdlIHRha2UgdGhlIG1lYW4gKyAyKnN0ZCBhcyB0aGUgaW1wb3J0YW50IGh1YiBzaXplLiAoQXNzdW1pbmcgYSBub3JtYWwgZGlzdHJpYnV0aW9uIG9mIGRhdGEsIH4yLjIlKVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEh1YlNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEh1YlNpemUoKSB7XG4gICAgICB2YXIgYXZlcmFnZSA9IDA7XG4gICAgICB2YXIgYXZlcmFnZVNxdWFyZWQgPSAwO1xuICAgICAgdmFyIGh1YkNvdW50ZXIgPSAwO1xuICAgICAgdmFyIGxhcmdlc3RIdWIgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmJvZHkubm9kZUluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmIChub2RlLmVkZ2VzLmxlbmd0aCA+IGxhcmdlc3RIdWIpIHtcbiAgICAgICAgICBsYXJnZXN0SHViID0gbm9kZS5lZGdlcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBhdmVyYWdlICs9IG5vZGUuZWRnZXMubGVuZ3RoO1xuICAgICAgICBhdmVyYWdlU3F1YXJlZCArPSBNYXRoLnBvdyhub2RlLmVkZ2VzLmxlbmd0aCwgMik7XG4gICAgICAgIGh1YkNvdW50ZXIgKz0gMTtcbiAgICAgIH1cblxuICAgICAgYXZlcmFnZSA9IGF2ZXJhZ2UgLyBodWJDb3VudGVyO1xuICAgICAgYXZlcmFnZVNxdWFyZWQgPSBhdmVyYWdlU3F1YXJlZCAvIGh1YkNvdW50ZXI7XG4gICAgICB2YXIgdmFyaWFuY2UgPSBhdmVyYWdlU3F1YXJlZCAtIE1hdGgucG93KGF2ZXJhZ2UsIDIpO1xuICAgICAgdmFyIHN0YW5kYXJkRGV2aWF0aW9uID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgICAgIHZhciBodWJUaHJlc2hvbGQgPSBNYXRoLmZsb29yKGF2ZXJhZ2UgKyAyICogc3RhbmRhcmREZXZpYXRpb24pOyAvLyBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgdG8gY2x1c3RlclxuXG4gICAgICBpZiAoaHViVGhyZXNob2xkID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICBodWJUaHJlc2hvbGQgPSBsYXJnZXN0SHViO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaHViVGhyZXNob2xkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gZWRnZSBmb3IgdGhlIGNsdXN0ZXIgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGZyb21JZFxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gdG9JZFxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2V9IGJhc2VFZGdlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsdXN0ZXJFZGdlUHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBleHRyYU9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7RWRnZX0gbmV3bHkgY3JlYXRlZCBjbHVzdGVyZWQgZWRnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQ2x1c3RlcmVkRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlcmVkRWRnZShmcm9tSWQsIHRvSWQsIGJhc2VFZGdlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMsIGV4dHJhT3B0aW9ucykge1xuICAgICAgLy8gY29weSB0aGUgb3B0aW9ucyBvZiB0aGUgZWRnZSB3ZSB3aWxsIHJlcGxhY2VcbiAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGJhc2VFZGdlLCBcImVkZ2VcIik7IC8vIG1ha2Ugc3VyZSB0aGUgcHJvcGVydGllcyBvZiBjbHVzdGVyRWRnZXMgYXJlIHN1cGVyaW1wb3NlZCBvbiBpdFxuXG4gICAgICBkZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGNsdXN0ZXJFZGdlUHJvcGVydGllcyk7IC8vIHNldCB1cCB0aGUgZWRnZVxuXG4gICAgICBjbG9uZWRPcHRpb25zLmZyb20gPSBmcm9tSWQ7XG4gICAgICBjbG9uZWRPcHRpb25zLnRvID0gdG9JZDtcbiAgICAgIGNsb25lZE9wdGlvbnMuaWQgPSBcImNsdXN0ZXJFZGdlOlwiICsgdjQoKTsgLy8gYXBwbHkgdGhlIGVkZ2Ugc3BlY2lmaWMgb3B0aW9ucyB0byBpdCBpZiBzcGVjaWZpZWRcblxuICAgICAgaWYgKGV4dHJhT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0VkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2UoY2xvbmVkT3B0aW9ucyk7XG4gICAgICBuZXdFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzID0gW2Jhc2VFZGdlLmlkXTtcbiAgICAgIG5ld0VkZ2UuY29ubmVjdCgpOyAvLyBSZWdpc3RlciB0aGUgbmV3IGVkZ2VcblxuICAgICAgdGhpcy5ib2R5LmVkZ2VzW25ld0VkZ2UuaWRdID0gbmV3RWRnZTtcbiAgICAgIHJldHVybiBuZXdFZGdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHBhc3NlZCBjaGlsZCBub2RlcyBhbmQgZWRnZXMgdG8gdGhlIGdpdmVuIGNsdXN0ZXIgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgTm9kZX0gY2hpbGROb2RlcyAgaGFzaCBvZiBub2RlcyBvciBzaW5nbGUgbm9kZSB0byBhZGQgaW4gY2x1c3RlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgRWRnZX0gY2hpbGRFZGdlcyAgaGFzaCBvZiBlZGdlcyBvciBzaW5nbGUgZWRnZSB0byB0YWtlIGludG8gYWNjb3VudCB3aGVuIGNsdXN0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNsdXN0ZXJOb2RlICBjbHVzdGVyIG5vZGUgdG8gYWRkIG5vZGVzIGFuZCBlZGdlcyB0b1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2x1c3RlckVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbHVzdGVyRWRnZXMoY2hpbGROb2RlcywgY2hpbGRFZGdlcywgY2x1c3Rlck5vZGUsIGNsdXN0ZXJFZGdlUHJvcGVydGllcykge1xuICAgICAgaWYgKGNoaWxkRWRnZXMgaW5zdGFuY2VvZiBFZGdlKSB7XG4gICAgICAgIHZhciBlZGdlID0gY2hpbGRFZGdlcztcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICBjaGlsZEVkZ2VzID0gb2JqO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGROb2RlcyBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjaGlsZE5vZGVzO1xuICAgICAgICB2YXIgX29iaiA9IHt9O1xuICAgICAgICBfb2JqW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgY2hpbGROb2RlcyA9IF9vYmo7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbHVzdGVyTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGNsdXN0ZXJOb2RlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9jbHVzdGVyRWRnZXM6IHBhcmFtZXRlciBjbHVzdGVyTm9kZSByZXF1aXJlZFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsdXN0ZXJFZGdlUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRha2UgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMgZnJvbSB0aGUgY2x1c3RlciBub2RlXG4gICAgICAgIGNsdXN0ZXJFZGdlUHJvcGVydGllcyA9IGNsdXN0ZXJOb2RlLmNsdXN0ZXJFZGdlUHJvcGVydGllcztcbiAgICAgIH0gLy8gY3JlYXRlIHRoZSBuZXcgZWRnZXMgdGhhdCB3aWxsIGNvbm5lY3QgdG8gdGhlIGNsdXN0ZXIuXG4gICAgICAvLyBBbGwgc2VsZi1yZWZlcmVuY2luZyBlZGdlcyB3aWxsIGJlIGFkZGVkIHRvIGNoaWxkRWRnZXMgaGVyZS5cblxuXG4gICAgICB0aGlzLl9jcmVhdGVDbHVzdGVyRWRnZXMoY2hpbGROb2RlcywgY2hpbGRFZGdlcywgY2x1c3Rlck5vZGUsIGNsdXN0ZXJFZGdlUHJvcGVydGllcyk7IC8vIGRpc2FibGUgdGhlIGNoaWxkRWRnZXNcblxuXG4gICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY2hpbGRFZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkRWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIF9lZGdlMiA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdOyAvLyBjYWNoZSB0aGUgb3B0aW9ucyBiZWZvcmUgY2hhbmdpbmdcblxuICAgICAgICAgICAgdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMoX2VkZ2UyKTsgLy8gZGlzYWJsZSBwaHlzaWNzIGFuZCBoaWRlIHRoZSBlZGdlXG5cblxuICAgICAgICAgICAgX2VkZ2UyLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICBwaHlzaWNzOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGRpc2FibGUgdGhlIGNoaWxkTm9kZXNcblxuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gY2hpbGROb2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkTm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICB0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0gPSB7XG4gICAgICAgICAgICBjbHVzdGVySWQ6IGNsdXN0ZXJOb2RlLmlkLFxuICAgICAgICAgICAgbm9kZTogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaW4gd2hpY2ggY2x1c3RlciBnaXZlbiBub2RlSWQgcmVzaWRlcy5cbiAgICAgKlxuICAgICAqIElmIG5vdCBpbiBjbHVzdGVyLCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogTk9URTogSWYgeW91IGtub3cgYSBjbGVhbmVyIHdheSB0byBkbyB0aGlzLCBwbGVhc2UgZW5saWdodGVuIG1lICh3aW1yaWpuZGVycykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtOb2RlfHVuZGVmaW5lZH0gTm9kZSBpbnN0YW5jZSBmb3IgY2x1c3RlciwgaWYgcHJlc2VudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbHVzdGVyTm9kZUZvck5vZGUobm9kZUlkKSB7XG4gICAgICBpZiAobm9kZUlkID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2x1c3RlcmVkTm9kZSA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXTsgLy8gTk9URTogSWYgbm8gY2x1c3RlciBpbmZvIGZvdW5kLCBpdCBzaG91bGQgYWN0dWFsbHkgYmUgYW4gZXJyb3JcblxuICAgICAgaWYgKGNsdXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBjbHVzdGVySWQgPSBjbHVzdGVyZWROb2RlLmNsdXN0ZXJJZDtcbiAgICAgIGlmIChjbHVzdGVySWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcklkXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBjb25kaXRpb25hbGx5IHJlbW92aW5nIGl0ZW1zIGluIGFycmF5XG4gICAgICpcbiAgICAgKiBEb25lIGxpa2UgdGhpcyBiZWNhdXNlIEFycmF5LmZpbHRlcigpIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgYnkgYWxsIElFJ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlsdGVyKGFyciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIGZvckVhY2gkMyhhcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhpdGVtKSkge1xuICAgICAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYW4gYWxsIGVkZ2VzIGZvciBjaGFuZ2VzIGluIGNsdXN0ZXJpbmcgYW5kIGFkanVzdCB0aGlzIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIENhbGwgdGhpcyAoaW50ZXJuYWxseSkgYWZ0ZXIgdGhlcmUgaGFzIGJlZW4gYSBjaGFuZ2UgaW4gbm9kZSBvciBlZGdlIGRhdGEuXG4gICAgICpcbiAgICAgKiBQcmU6IFN0YXRlcyBvZiB0aGlzLmJvZHkubm9kZXMgYW5kIHRoaXMuYm9keS5lZGdlcyBjb25zaXN0ZW50XG4gICAgICogUHJlOiB0aGlzLmNsdXN0ZXJlZE5vZGVzIGFuZCB0aGlzLmNsdXN0ZXJlZEVkZ2UgY29uc2lzdGVudCB3aXRoIGNvbnRhaW5lZE5vZGVzIGFuZCBjb250YWluZWRFZGdlc1xuICAgICAqICAgICAgb2YgY2x1c3RlciBub2Rlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU3RhdGUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIG5vZGVJZDtcbiAgICAgIHZhciBkZWxldGVkTm9kZUlkcyA9IFtdO1xuICAgICAgdmFyIGRlbGV0ZWRFZGdlSWRzID0ge307XG4gICAgICAvKipcbiAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGNsdXN0ZXJpbmcgbm9kZXMgb25seVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGNsdXN0ZXIgbm9kZVxuICAgICAgICovXG5cbiAgICAgIHZhciBlYWNoQ2x1c3Rlck5vZGUgPSBmdW5jdGlvbiBlYWNoQ2x1c3Rlck5vZGUoY2FsbGJhY2spIHtcbiAgICAgICAgZm9yRWFjaCQzKF90aGlzNC5ib2R5Lm5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07IC8vXG4gICAgICAvLyBSZW1vdmUgZGVsZXRlZCByZWd1bGFyIG5vZGVzIGZyb20gY2x1c3RlcmluZ1xuICAgICAgLy9cbiAgICAgIC8vIERldGVybWluZSB0aGUgZGVsZXRlZCBub2Rlc1xuXG5cbiAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuY2x1c3RlcmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jbHVzdGVyZWROb2Rlcywgbm9kZUlkKSkgY29udGludWU7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZWROb2RlSWRzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgbm9kZXMgZnJvbSBjbHVzdGVyIG5vZGVzXG5cblxuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRlbGV0ZWROb2RlSWRzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgZGVsZXRlIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzW2RlbGV0ZWROb2RlSWRzW25dXTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFJlbW92ZSBub2RlcyBmcm9tIGNsdXN0ZXIgbGlzdFxuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRlbGV0ZWROb2RlSWRzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNsdXN0ZXJlZE5vZGVzW2RlbGV0ZWROb2RlSWRzW25dXTtcbiAgICAgIH0gLy9cbiAgICAgIC8vIFJlbW92ZSBkZWxldGVkIGVkZ2VzIGZyb20gY2x1c3RlcmluZ1xuICAgICAgLy9cbiAgICAgIC8vIEFkZCB0aGUgZGVsZXRlZCBjbHVzdGVyZWQgZWRnZXMgdG8gdGhlIGxpc3RcblxuXG4gICAgICBmb3JFYWNoJDModGhpcy5jbHVzdGVyZWRFZGdlcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICB2YXIgZWRnZSA9IF90aGlzNC5ib2R5LmVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCB8fCAhZWRnZS5lbmRQb2ludHNWYWxpZCgpKSB7XG4gICAgICAgICAgZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSA9IGVkZ2VJZDtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIENsdXN0ZXIgbm9kZXMgY2FuIGFsc28gY29udGFpbiBlZGdlcyB3aGljaCBhcmUgbm90IGNsdXN0ZXJlZCxcbiAgICAgIC8vIGkuZS4gbm9kZXMgMS0yIHdpdGhpbiBjbHVzdGVyIHdpdGggYW4gZWRnZSBpbiBiZXR3ZWVuLlxuICAgICAgLy8gU28gdGhlIGNsdXN0ZXIgbm9kZXMgYWxzbyBuZWVkIHRvIGJlIHNjYW5uZWQgZm9yIGludmFsaWQgZWRnZXNcblxuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3JFYWNoJDMoY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgICBpZiAoIWVkZ2UuZW5kUG9pbnRzVmFsaWQoKSAmJiAhZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSkge1xuICAgICAgICAgICAgZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSA9IGVkZ2VJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIEFsc28gc2NhbiBmb3IgY2x1c3RlciBlZGdlcyB3aGljaCBuZWVkIHRvIGJlIHJlbW92ZWQgaW4gdGhlIGFjdGl2ZSBsaXN0LlxuICAgICAgLy8gUmVndWxhciBlZGdlcyBoYXZlIGJlZW4gcmVtb3ZlZCBiZWZvcmVoYW5kLCBzbyB0aGlzIG9ubHkgcGlja3MgdXAgdGhlIGNsdXN0ZXIgZWRnZXMuXG5cbiAgICAgIGZvckVhY2gkMyh0aGlzLmJvZHkuZWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgLy8gRXhwbGljaXRseSBzY2FuIHRoZSBjb250YWluZWQgZWRnZXMgZm9yIHZhbGlkaXR5XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJlcGxhY2VkSWRzID0gZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcztcblxuICAgICAgICBpZiAocmVwbGFjZWRJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBudW1WYWxpZCA9IDA7XG4gICAgICAgICAgZm9yRWFjaCQzKHJlcGxhY2VkSWRzLCBmdW5jdGlvbiAoY29udGFpbmVkRWRnZUlkKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVkRWRnZSA9IF90aGlzNC5ib2R5LmVkZ2VzW2NvbnRhaW5lZEVkZ2VJZF07XG5cbiAgICAgICAgICAgIGlmIChjb250YWluZWRFZGdlICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVkRWRnZS5lbmRQb2ludHNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIG51bVZhbGlkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaXNWYWxpZCA9IG51bVZhbGlkID4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZWRnZS5lbmRQb2ludHNWYWxpZCgpIHx8ICFpc1ZhbGlkKSB7XG4gICAgICAgICAgZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSA9IGVkZ2VJZDtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFJlbW92ZSBlZGdlcyBmcm9tIGNsdXN0ZXIgbm9kZXNcblxuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3JFYWNoJDMoZGVsZXRlZEVkZ2VJZHMsIGZ1bmN0aW9uIChkZWxldGVkRWRnZUlkKSB7XG4gICAgICAgICAgZGVsZXRlIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzW2RlbGV0ZWRFZGdlSWRdO1xuICAgICAgICAgIGZvckVhY2gkMyhjbHVzdGVyTm9kZS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIG0pIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmlkID09PSBkZWxldGVkRWRnZUlkKSB7XG4gICAgICAgICAgICAgIGNsdXN0ZXJOb2RlLmVkZ2VzW21dID0gbnVsbDsgLy8gRG9uJ3Qgd2FudCB0byBkaXJlY3RseSBkZWxldGUgaGVyZSwgYmVjYXVzZSBpbiB0aGUgbG9vcFxuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcyA9IF90aGlzNC5fZmlsdGVyKGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gIWRlbGV0ZWRFZGdlSWRzW2lkXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pOyAvLyBDbGVhbiB1cCB0aGUgbnVsbHNcblxuICAgICAgICAgIGNsdXN0ZXJOb2RlLmVkZ2VzID0gX3RoaXM0Ll9maWx0ZXIoY2x1c3Rlck5vZGUuZWRnZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbSAhPT0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gUmVtb3ZlIGZyb20gY2x1c3RlciBsaXN0XG5cbiAgICAgIGZvckVhY2gkMyhkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICBkZWxldGUgX3RoaXM0LmNsdXN0ZXJlZEVkZ2VzW2VkZ2VJZF07XG4gICAgICB9KTsgLy8gUmVtb3ZlIGNsdXN0ZXIgZWRnZXMgZnJvbSBhY3RpdmUgbGlzdCAodGhpcy5ib2R5LmVkZ2VzKS5cbiAgICAgIC8vIGRlbGV0ZWRFZGdlSWRzIHN0aWxsIGNvbnRhaW5zIGlkIG9mIHJlZ3VsYXIgZWRnZXMsIGJ1dCB0aGVzZSBzaG91bGQgYWxsXG4gICAgICAvLyBiZSBnb25lIHdoZW4geW91IHJlYWNoIGhlcmUuXG5cbiAgICAgIGZvckVhY2gkMyhkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICBkZWxldGUgX3RoaXM0LmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgIH0pOyAvL1xuICAgICAgLy8gQ2hlY2sgY2hhbmdlZCBjbHVzdGVyIHN0YXRlIG9mIGVkZ2VzXG4gICAgICAvL1xuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIga2V5cyBoZXJlLCBiZWNhdXNlIGVkZ2VzIG1heSBiZSByZW1vdmVkIGluIHRoZSBsb29wXG5cbiAgICAgIHZhciBpZHMgPSBrZXlzJDModGhpcy5ib2R5LmVkZ2VzKTtcblxuICAgICAgZm9yRWFjaCQzKGlkcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICB2YXIgZWRnZSA9IF90aGlzNC5ib2R5LmVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgdmFyIHNob3VsZEJlQ2x1c3RlcmVkID0gX3RoaXM0Ll9pc0NsdXN0ZXJlZE5vZGUoZWRnZS5mcm9tSWQpIHx8IF90aGlzNC5faXNDbHVzdGVyZWROb2RlKGVkZ2UudG9JZCk7XG5cbiAgICAgICAgaWYgKHNob3VsZEJlQ2x1c3RlcmVkID09PSBfdGhpczQuX2lzQ2x1c3RlcmVkRWRnZShlZGdlLmlkKSkge1xuICAgICAgICAgIHJldHVybjsgLy8gYWxsIGlzIHdlbGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRCZUNsdXN0ZXJlZCkge1xuICAgICAgICAgIC8vIGFkZCBlZGdlIHRvIGNsdXN0ZXJpbmdcbiAgICAgICAgICB2YXIgY2x1c3RlckZyb20gPSBfdGhpczQuX2dldENsdXN0ZXJOb2RlRm9yTm9kZShlZGdlLmZyb21JZCk7XG5cbiAgICAgICAgICBpZiAoY2x1c3RlckZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXM0Ll9jbHVzdGVyRWRnZXMoX3RoaXM0LmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdLCBlZGdlLCBjbHVzdGVyRnJvbSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNsdXN0ZXJUbyA9IF90aGlzNC5fZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlKGVkZ2UudG9JZCk7XG5cbiAgICAgICAgICBpZiAoY2x1c3RlclRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5fY2x1c3RlckVkZ2VzKF90aGlzNC5ib2R5Lm5vZGVzW2VkZ2UudG9JZF0sIGVkZ2UsIGNsdXN0ZXJUbyk7XG4gICAgICAgICAgfSAvLyBUT0RPOiBjaGVjayB0aGF0IGl0IHdvcmtzIGZvciBib3RoIGVkZ2VzIGNsdXN0ZXJlZFxuICAgICAgICAgIC8vICAgICAgIChUaGlzIG1pZ2h0IGJlIHBhcmFub2lhKVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIF90aGlzNC5fY2x1c3RlckVkZ2VzW2VkZ2VJZF07XG5cbiAgICAgICAgICBfdGhpczQuX3Jlc3RvcmVFZGdlKGVkZ2UpOyAvLyBUaGlzIHNob3VsZCBub3QgYmUgaGFwcGVuaW5nLCB0aGUgc3RhdGUgc2hvdWxkXG4gICAgICAgICAgLy8gYmUgcHJvcGVybHkgdXBkYXRlZCBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWYgaXQgKmlzKiByZWFjaGVkIGR1cmluZyBub3JtYWwgb3BlcmF0aW9uLCB0aGVuIHdlIGhhdmUgdG8gaW1wbGVtZW50XG4gICAgICAgICAgLy8gdW5kbyBjbHVzdGVyaW5nIGZvciB0aGlzIGVkZ2UgaGVyZS5cbiAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZSBlZGdlIGZyb20gY2x1c3RlcmluZyBub3QgaW1wbGVtZW50ZWQhJylcblxuICAgICAgICB9XG4gICAgICB9KTsgLy8gQ2x1c3RlcnMgbWF5IGJlIG5lc3RlZCB0byBhbnkgbGV2ZWwuIEtlZXAgb24gb3BlbmluZyB1bnRpbCBub3RoaW5nIHRvIG9wZW5cblxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjb250aW51ZUxvb3AgPSB0cnVlO1xuXG4gICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKCkge1xuICAgICAgICB2YXIgY2x1c3RlcnNUb09wZW4gPSBbXTsgLy8gRGV0ZXJtaW5lIHRoZSBpZCdzIG9mIGNsdXN0ZXJzIHRoYXQgbmVlZCBvcGVuaW5nXG5cbiAgICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICAgIHZhciBudW1Ob2RlcyA9IGtleXMkMyhjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcykubGVuZ3RoO1xuXG4gICAgICAgICAgdmFyIGFsbG93U2luZ2xlID0gY2x1c3Rlck5vZGUub3B0aW9ucy5hbGxvd1NpbmdsZU5vZGVDbHVzdGVyID09PSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGFsbG93U2luZ2xlICYmIG51bU5vZGVzIDwgMSB8fCAhYWxsb3dTaW5nbGUgJiYgbnVtTm9kZXMgPCAyKSB7XG4gICAgICAgICAgICBjbHVzdGVyc1RvT3Blbi5wdXNoKGNsdXN0ZXJOb2RlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBPcGVuIHRoZW1cblxuICAgICAgICBmb3IgKHZhciBfbiA9IDA7IF9uIDwgY2x1c3RlcnNUb09wZW4ubGVuZ3RoOyArK19uKSB7XG4gICAgICAgICAgX3RoaXM0Lm9wZW5DbHVzdGVyKGNsdXN0ZXJzVG9PcGVuW19uXSwge30sIGZhbHNlXG4gICAgICAgICAgLyogRG9uJ3QgcmVmcmVzaCwgd2UncmUgaW4gYW4gcmVmcmVzaC91cGRhdGUgYWxyZWFkeSAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZUxvb3AgPSBjbHVzdGVyc1RvT3Blbi5sZW5ndGggPiAwO1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBjb250aW51ZUxvb3A7XG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAoY29udGludWVMb29wKSB7XG4gICAgICAgIF9sb29wMigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSgpOyAvLyBSZWRvIHRoaXMgbWV0aG9kIChyZWN1cnNpb24gcG9zc2libGUhIHNob3VsZCBiZSBzYWZlKVxuXG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBub2RlIHdpdGggZ2l2ZW4gaWQgaXMgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHBhcnQgb2YgYSBjbHVzdGVyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzQ2x1c3RlcmVkTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDbHVzdGVyZWROb2RlKG5vZGVJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgZWRnZSB3aXRoIGdpdmVuIGlkIGlzIG5vdCB2aXNpYmxlIGR1ZSB0byBjbHVzdGVyaW5nLlxuICAgICAqXG4gICAgICogQW4gZWRnZSBpcyBjb25zaWRlcmVkIGNsdXN0ZXJlZCBpZjpcbiAgICAgKiAtIGl0IGlzIGRpcmVjdGx5IHJlcGxhY2VkIGJ5IGEgY2x1c3RlcmluZyBlZGdlXG4gICAgICogLSBhbnkgb2YgaXRzIGNvbm5lY3Rpbmcgbm9kZXMgaXMgaW4gYSBjbHVzdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBlZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBwYXJ0IG9mIGEgY2x1c3Rlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pc0NsdXN0ZXJlZEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQ2x1c3RlcmVkRWRnZShlZGdlSWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2VJZF0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2x1c3RlckVuZ2luZTtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2Ygc3ltYm9sJDQgPT09IFwidW5kZWZpbmVkXCIgfHwgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSA9PSBudWxsKSB7IGlmIChpc0FycmF5JDUobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBnZXRJdGVyYXRvciQxKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMyhvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0NDsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZSQ1KF9jb250ZXh0NCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDQsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb21fMSQyKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQzKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXG4gKiBJbml0aWFsaXplcyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgdG8gYSB1c2FibGUgZm9ybS5cbiAqXG4gKiBTcGVjaWZpY2FsbHksIHNldCB1cCB0aGlzIG1ldGhvZCBmb3IgdGhlIGNhc2Ugb2YgcnVubmluZyBvbiBub2RlLmpzIHdpdGgganNkb20gZW5hYmxlZC5cbiAqXG4gKiBOT1RFUzpcbiAqXG4gKiAqIE9uIG5vZGUuanMsIHdoZW4gY2FsbGluZyB0aGlzIGRpcmVjdGx5IG91dHNpZGUgb2YgdGhpcyBjbGFzcywgYHdpbmRvd2AgaXMgbm90IGRlZmluZWQuXG4gKiAgIFRoaXMgaGFwcGVucyBldmVuIGlmIGpzZG9tIGlzIHVzZWQuXG4gKiAqIEZvciBub2RlLmpzICsganNkb20sIGB3aW5kb3dgIGlzIGF2YWlsYWJsZSBhdCB0aGUgbW9tZW50IHRoZSBjb25zdHJ1Y3RvciBpcyBjYWxsZWQuXG4gKiAgIEZvciB0aGlzIHJlYXNvbiwgdGhlIGNhbGxlZCBpcyBwbGFjZWQgd2l0aGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqICogRXZlbiB0aGVuLCBgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgpYCBpcyBub3QgZGVmaW5lZCwgc28gaXQgc3RpbGwgbmVlZHMgdG8gYmUgYWRkZWQuXG4gKiAqIER1cmluZyB1bml0IHRlc3RpbmcsIGl0IGhhcHBlbnMgdGhhdCB0aGUgd2luZG93IG9iamVjdCBpcyByZXNldCBkdXJpbmcgZXhlY3V0aW9uLCBjYXVzaW5nXG4gKiAgIGEgcnVudGltZSBlcnJvciBkdWUgdG8gbWlzc2luZyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKClgLiBUaGlzIG5lZWRzIHRvIGJlIGNvbXBlbnNhdGVkIGZvcixcbiAqICAgc2VlIGBfcmVxdWVzdE5leHRGcmFtZSgpYC5cbiAqICogU2luY2UgdGhpcyBpcyBhIGdsb2JhbCBvYmplY3QsIGl0IG1heSBhZmZlY3Qgb3RoZXIgbW9kdWxlcyBiZXNpZGVzIGBOZXR3b3JrYC4gV2l0aCBub3JtYWxcbiAqICAgdXNhZ2UsIHRoaXMgZG9lcyBub3QgY2F1c2UgYW55IHByb2JsZW1zLiBEdXJpbmcgdW5pdCB0ZXN0aW5nLCBlcnJvcnMgbWF5IG9jY3VyLiBUaGVzZSBoYXZlXG4gKiAgIGJlZW4gY29tcGVuc2F0ZWQgZm9yLCBzZWUgY29tbWVudCBibG9jayBpbiBfcmVxdWVzdE5leHRGcmFtZSgpLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2luaXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB7XG4gIHZhciBmdW5jO1xuXG4gIGlmICh3aW5kb3cgIT09IHVuZGVmaW5lZCkge1xuICAgIGZ1bmMgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIH1cblxuICBpZiAoZnVuYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gd2luZG93IG9yIG1ldGhvZCBub3QgcHJlc2VudCwgc2V0dGluZyBtb2NrIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJDYWxsZWQgbW9jayByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIik7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmM7XG4gIH1cbn1cbi8qKlxuICogVGhlIGNhbnZhcyByZW5kZXJlclxuICovXG5cblxudmFyIENhbnZhc1JlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGJvZHksIGNhbnZhcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc1JlbmRlcmVyKTtcblxuICAgIF9pbml0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclJlcXVlc3RzID0gMDtcbiAgICB0aGlzLmFsbG93UmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGhpZGVFZGdlc09uRHJhZzogZmFsc2UsXG4gICAgICBoaWRlRWRnZXNPblpvb206IGZhbHNlLFxuICAgICAgaGlkZU5vZGVzT25EcmFnOiBmYWxzZVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZGV0ZXJtaW5lQnJvd3Nlck1ldGhvZCgpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoQ2FudmFzUmVuZGVyZXIsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIF9jb250ZXh0MjtcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkcmFnU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZHJhZ0VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiem9vbVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KF90aGlzLnpvb21UaW1lb3V0SWQpO1xuICAgICAgICBfdGhpcy56b29tVGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgICAgIF90aGlzLnpvb21pbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dCA9IF90aGlzLl9yZXF1ZXN0UmVkcmF3KS5jYWxsKF9jb250ZXh0LCBfdGhpcykoKTtcbiAgICAgICAgfSwgMjUwKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzaXplTm9kZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fcmVzaXplTm9kZXMoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBfdGhpcy5fcmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfYmxvY2tSZWRyYXdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9hbGxvd1JlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMucmVkcmF3UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlcXVlc3RSZWRyYXdcIiwgYmluZCQyKF9jb250ZXh0MiA9IHRoaXMuX3JlcXVlc3RSZWRyYXcpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9zdGFydFJlbmRlcmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzICs9IDE7XG4gICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgX3RoaXMuX3N0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3N0b3BSZW5kZXJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyAtPSAxO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBfdGhpcy5yZW5kZXJSZXF1ZXN0cyA+IDA7XG4gICAgICAgIF90aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW5kZXJSZXF1ZXN0cyA9IDA7XG4gICAgICAgIF90aGlzLmFsbG93UmVkcmF3ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChfdGhpcy5yZXF1aXJlc1RpbWVvdXQgPT09IHRydWUpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMucmVuZGVyVGltZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShfdGhpcy5yZW5kZXJUaW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtcImhpZGVFZGdlc09uRHJhZ1wiLCBcImhpZGVFZGdlc09uWm9vbVwiLCBcImhpZGVOb2Rlc09uRHJhZ1wiXTtcbiAgICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGRyYXdpbmcgb2YgdGhlIG5leHQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBDYWxscyB0aGUgY2FsbGJhY2sgd2hlbiB0aGUgbmV4dCBmcmFtZSBjYW4gb3Igd2lsbCBiZSBkcmF3bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gdGltZW91dCBjYXNlIG9ubHksIHdhaXQgdGhpcyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9uIHwgdW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVxdWVzdE5leHRGcmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdE5leHRGcmFtZShjYWxsYmFjaywgZGVsYXkpIHtcbiAgICAgIC8vIER1cmluZyB1bml0IHRlc3RpbmcsIGl0IGhhcHBlbnMgdGhhdCB0aGUgbW9jayB3aW5kb3cgb2JqZWN0IGlzIHJlc2V0IHdoaWxlXG4gICAgICAvLyB0aGUgbmV4dCBmcmFtZSBpcyBzdGlsbCBwZW5kaW5nLiBUaGVuLCBlaXRoZXIgJ3dpbmRvdycgaXMgbm90IHByZXNlbnQsIG9yXG4gICAgICAvLyAncmVxdWVzdEFuaW1hdGlvbkZyYW1lKCknIGlzIG5vdCBwcmVzZW50IGJlY2F1c2UgaXQgaXMgbm90IGRlZmluZWQgb24gdGhlXG4gICAgICAvLyBtb2NrIHdpbmRvdyBvYmplY3QuXG4gICAgICAvL1xuICAgICAgLy8gQXMgYSBjb25zZXF1ZW5jZSwgdW5yZWxhdGVkIHVuaXQgdGVzdHMgbWF5IGFwcGVhciB0byBmYWlsLCBldmVuIGlmIHRoZSBwcm9ibGVtXG4gICAgICAvLyBkZXNjcmliZWQgaGFwcGVucyBpbiB0aGUgY3VycmVudCB1bml0IHRlc3QuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBub3Qgc29tZXRoaW5nIHRoYXQgd2lsbCBoYXBwZW4gaW4gbm9ybWFsIG9wZXJhdGlvbiwgYnV0IHdlIHN0aWxsIG5lZWRcbiAgICAgIC8vIHRvIHRha2UgaXQgaW50byBhY2NvdW50LlxuICAgICAgLy9cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47IC8vIERvaW5nIGBpZiAod2luZG93ID09PSB1bmRlZmluZWQpYCBkb2VzIG5vdCB3b3JrIGhlcmUhXG5cbiAgICAgIHZhciB0aW1lcjtcbiAgICAgIHZhciBteVdpbmRvdyA9IHdpbmRvdzsgLy8gR3JhYiBhIHJlZmVyZW5jZSB0byByZWR1Y2UgdGhlIHBvc3NpYmlsaXR5IHRoYXQgJ3dpbmRvdycgaXMgcmVzZXRcbiAgICAgIC8vIHdoaWxlIHJ1bm5pbmcgdGhpcyBtZXRob2QuXG5cbiAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyB3YWl0IGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYW5kIHBlcmZvcm0gdGhlIGFuaW1hdGlvbiBzdGVwIGZ1bmN0aW9uXG4gICAgICAgIHRpbWVyID0gbXlXaW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG15V2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgIHRpbWVyID0gbXlXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGltZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFJlbmRlcmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRSZW5kZXJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgICB0aGlzLnJlbmRlclRpbWVyID0gdGhpcy5fcmVxdWVzdE5leHRGcmFtZShiaW5kJDIoX2NvbnRleHQzID0gdGhpcy5fcmVuZGVyU3RlcCkuY2FsbChfY29udGV4dDMsIHRoaXMpLCB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbmRlclN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlclN0ZXAoKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gcmVzZXQgdGhlIHJlbmRlclRpbWVyIHNvIGEgbmV3IHNjaGVkdWxlZCBhbmltYXRpb24gc3RlcCBjYW4gYmUgc2V0XG4gICAgICAgIHRoaXMucmVuZGVyVGltZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNUaW1lb3V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gdGhpcyBzY2hlZHVsZXMgYSBuZXcgc2ltdWxhdGlvbiBzdGVwXG4gICAgICAgICAgdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZHJhdygpO1xuXG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyB0aGlzIHNjaGVkdWxlcyBhIG5ldyBzaW11bGF0aW9uIHN0ZXBcbiAgICAgICAgICB0aGlzLl9zdGFydFJlbmRlcmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgKiBjaGFydCB3aWxsIGJlIHJlc2l6ZWQgdG9vLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzZXRTaXplXCIpO1xuXG4gICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IHRoZSBuZXR3b3JrIHdpdGggdGhlIGN1cnJlbnQgZGF0YVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXF1ZXN0UmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1ZXN0UmVkcmF3KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnJlZHJhd1JlcXVlc3RlZCAhPT0gdHJ1ZSAmJiB0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5hbGxvd1JlZHJhdyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fcmVxdWVzdE5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLl9yZWRyYXcoZmFsc2UpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IHRoZSBuZXR3b3JrIHdpdGggdGhlIGN1cnJlbnQgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGlkZGVuPWZhbHNlXSB8IFVzZWQgdG8gZ2V0IHRoZSBmaXJzdCBlc3RpbWF0ZSBvZiB0aGUgbm9kZSBzaXplcy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSB0aGUgbm9kZXMgYXJlIGRyYXduIGFmdGVyIHdoaWNoIHRoZXkgYXJlIHF1aWNrbHkgZHJhd24gb3Zlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVkcmF3KCkge1xuICAgICAgdmFyIGhpZGRlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmFsbG93UmVkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJpbml0UmVkcmF3XCIpO1xuICAgICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZHJhd0xhdGVyID0ge1xuICAgICAgICAgIGRyYXdFeHRlcm5hbExhYmVsczogbnVsbFxuICAgICAgICB9OyAvLyB3aGVuIHRoZSBjb250YWluZXIgZGl2IHdhcyBoaWRkZW4sIHRoaXMgZml4ZXMgaXQgYmFjayB1cCFcblxuICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLndpZHRoID09PSAwIHx8IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoKTsgLy8gY2xlYXIgdGhlIGNhbnZhc1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaCA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7IC8vIGlmIHRoZSBkaXYgaXMgaGlkZGVuLCB3ZSBzdG9wIHRoZSByZWRyYXcgaGVyZSBmb3IgcGVyZm9ybWFuY2UuXG5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzLmZyYW1lLmNsaWVudFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIHNldCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuXG5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLCB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImJlZm9yZURyYXdpbmdcIiwgY3R4KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGlmIChoaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPbkRyYWcgPT09IGZhbHNlKSAmJiAodGhpcy56b29taW5nID09PSBmYWxzZSB8fCB0aGlzLnpvb21pbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uWm9vbSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3RWRnZXMoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZU5vZGVzT25EcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBfdGhpcyRfZHJhd05vZGVzID0gdGhpcy5fZHJhd05vZGVzKGN0eCwgaGlkZGVuKSxcbiAgICAgICAgICAgICAgZHJhd0V4dGVybmFsTGFiZWxzID0gX3RoaXMkX2RyYXdOb2Rlcy5kcmF3RXh0ZXJuYWxMYWJlbHM7XG5cbiAgICAgICAgICBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWxzID0gZHJhd0V4dGVybmFsTGFiZWxzO1xuICAgICAgICB9IC8vIGRyYXcgdGhlIGFycm93cyBsYXN0IHNvIHRoZXkgd2lsbCBiZSBhdCB0aGUgdG9wXG5cblxuICAgICAgICBpZiAoaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIGlmICgodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25EcmFnID09PSBmYWxzZSkgJiYgKHRoaXMuem9vbWluZyA9PT0gZmFsc2UgfHwgdGhpcy56b29taW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPblpvb20gPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd0Fycm93cyhjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgICBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWxzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2RyYXdTZWxlY3Rpb25Cb3goY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFmdGVyRHJhd2luZ1wiLCBjdHgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7IC8vIHJlc3RvcmUgb3JpZ2luYWwgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIGlmIChoaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhbGwgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Fsd2F5c1Nob3ddXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNpemVOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplTm9kZXMoKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KTtcbiAgICAgIGN0eC5zY2FsZSh0aGlzLmJvZHkudmlldy5zY2FsZSwgdGhpcy5ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIG5vZGU7IC8vIHJlc2l6ZSBhbGwgbm9kZXNcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICBub2RlLnJlc2l6ZShjdHgpO1xuICAgICAgICAgIG5vZGUudXBkYXRlQm91bmRpbmdCb3goY3R4LCBub2RlLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyByZXN0b3JlIG9yaWdpbmFsIHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG5cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFsbCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgMkQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWx3YXlzU2hvd11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH0gQ2FsbGJhY2tzIHRvIGRyYXcgbGF0ZXIgb24gaGlnaGVyIGxheWVycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3Tm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdOb2RlcyhjdHgpIHtcbiAgICAgIHZhciBhbHdheXNTaG93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlO1xuICAgICAgdmFyIHNlbGVjdGVkID0gW107XG4gICAgICB2YXIgaG92ZXJlZCA9IFtdO1xuICAgICAgdmFyIG1hcmdpbiA9IDIwO1xuICAgICAgdmFyIHRvcExlZnQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IC1tYXJnaW4sXG4gICAgICAgIHk6IC1tYXJnaW5cbiAgICAgIH0pO1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggKyBtYXJnaW4sXG4gICAgICAgIHk6IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKyBtYXJnaW5cbiAgICAgIH0pO1xuICAgICAgdmFyIHZpZXdhYmxlQXJlYSA9IHtcbiAgICAgICAgdG9wOiB0b3BMZWZ0LnksXG4gICAgICAgIGxlZnQ6IHRvcExlZnQueCxcbiAgICAgICAgYm90dG9tOiBib3R0b21SaWdodC55LFxuICAgICAgICByaWdodDogYm90dG9tUmlnaHQueFxuICAgICAgfTtcbiAgICAgIHZhciBfZHJhd0V4dGVybmFsTGFiZWxzID0gW107IC8vIGRyYXcgdW5zZWxlY3RlZCBub2RlcztcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbX2ldXTsgLy8gc2V0IHNlbGVjdGVkIGFuZCBob3ZlcmVkIG5vZGVzIGFzaWRlXG5cbiAgICAgICAgaWYgKG5vZGUuaG92ZXIpIHtcbiAgICAgICAgICBob3ZlcmVkLnB1c2gobm9kZUluZGljZXNbX2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgIHNlbGVjdGVkLnB1c2gobm9kZUluZGljZXNbX2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWx3YXlzU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGRyYXdMYXRlciA9IG5vZGUuZHJhdyhjdHgpO1xuXG4gICAgICAgICAgICBpZiAoZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgX2RyYXdFeHRlcm5hbExhYmVscy5wdXNoKGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgodmlld2FibGVBcmVhKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9kcmF3TGF0ZXIgPSBub2RlLmRyYXcoY3R4KTtcblxuICAgICAgICAgICAgaWYgKF9kcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBfZHJhd0V4dGVybmFsTGFiZWxzLnB1c2goX2RyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUudXBkYXRlQm91bmRpbmdCb3goY3R4LCBub2RlLnNlbGVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBzZWxlY3RlZC5sZW5ndGg7XG4gICAgICB2YXIgaG92ZXJlZExlbmd0aCA9IGhvdmVyZWQubGVuZ3RoOyAvLyBkcmF3IHRoZSBzZWxlY3RlZCBub2RlcyBvbiB0b3BcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdGVkTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW3NlbGVjdGVkW2ldXTtcblxuICAgICAgICB2YXIgX2RyYXdMYXRlcjIgPSBub2RlLmRyYXcoY3R4KTtcblxuICAgICAgICBpZiAoX2RyYXdMYXRlcjIuZHJhd0V4dGVybmFsTGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgIF9kcmF3RXh0ZXJuYWxMYWJlbHMucHVzaChfZHJhd0xhdGVyMi5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZHJhdyBob3ZlcmVkIG5vZGVzIGFib3ZlIGV2ZXJ5dGhpbmcgZWxzZTogZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2pzL3Zpcy1uZXR3b3JrL2lzc3Vlcy8yMjZcblxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaG92ZXJlZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tob3ZlcmVkW2ldXTtcblxuICAgICAgICB2YXIgX2RyYXdMYXRlcjMgPSBub2RlLmRyYXcoY3R4KTtcblxuICAgICAgICBpZiAoX2RyYXdMYXRlcjMuZHJhd0V4dGVybmFsTGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgIF9kcmF3RXh0ZXJuYWxMYWJlbHMucHVzaChfZHJhd0xhdGVyMy5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHJhd0V4dGVybmFsTGFiZWxzOiBmdW5jdGlvbiBkcmF3RXh0ZXJuYWxMYWJlbHMoKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoX2RyYXdFeHRlcm5hbExhYmVscyksXG4gICAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBkcmF3ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0VkZ2VzKGN0eCkge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGVkZ2UuZHJhdyhjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhbGwgYXJyb3dzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdBcnJvd3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdBcnJvd3MoY3R4KSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgZWRnZS5kcmF3QXJyb3dzKGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIHJlcXVpcmVzIGEgc2V0VGltZW91dCBvciBhIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gVGhpcyB3YXMgcmVxdWlyZWQgYmVjYXVzZVxuICAgICAqIHNvbWUgaW1wbGVtZW50YXRpb25zIChzYWZhcmkgYW5kIElFOSkgZGlkIG5vdCBzdXBwb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXRlcm1pbmVCcm93c2VyTWV0aG9kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVCcm93c2VyTWV0aG9kKCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIGJyb3dzZXJUeXBlID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpbmRleE9mJDMoYnJvd3NlclR5cGUpLmNhbGwoYnJvd3NlclR5cGUsIFwibXNpZSA5LjBcIikgIT0gLTEpIHtcbiAgICAgICAgICAvLyBJRSA5XG4gICAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4T2YkMyhicm93c2VyVHlwZSkuY2FsbChicm93c2VyVHlwZSwgXCJzYWZhcmlcIikgIT0gLTEpIHtcbiAgICAgICAgICAvLyBzYWZhcmlcbiAgICAgICAgICBpZiAoaW5kZXhPZiQzKGJyb3dzZXJUeXBlKS5jYWxsKGJyb3dzZXJUeXBlLCBcImNocm9tZVwiKSA8PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgc2VsZWN0aW9uIGJveFxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgMkQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3U2VsZWN0aW9uQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3U2VsZWN0aW9uQm94KGN0eCkge1xuICAgICAgaWYgKHRoaXMuYm9keS5zZWxlY3Rpb25Cb3guc2hvdykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kLnggLSB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0Lng7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZC55IC0gdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC55O1xuICAgICAgICBjdHgucmVjdCh0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LngsIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMTUxLCAxOTQsIDI1MiwgMC4yKVwiO1xuICAgICAgICBjdHguZmlsbFJlY3QodGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC54LCB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LnksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMTUxLCAxOTQsIDI1MiwgMSlcIjtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYW52YXNSZW5kZXJlcjtcbn0oKTtcblxudmFyIHNldEludGVydmFsID0gcGF0aC5zZXRJbnRlcnZhbDtcblxudmFyIHNldEludGVydmFsJDEgPSBzZXRJbnRlcnZhbDtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICpcbiAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAqL1xuZnVuY3Rpb24gb25Ub3VjaChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrLmlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbW1lci5vbihcImhhbW1lci5pbnB1dFwiLCBjYWxsYmFjay5pbnB1dEhhbmRsZXIpO1xufVxuLyoqXG4gKiBSZWdpc3RlciBhIHJlbGVhc2UgZXZlbnQsIHRha2luZyBwbGFjZSBhZnRlciBhIGdlc3R1cmVcbiAqXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBvblJlbGVhc2UoaGFtbWVyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjay5pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNGaW5hbCkge1xuICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gaGFtbWVyLm9uKFwiaGFtbWVyLmlucHV0XCIsIGNhbGxiYWNrLmlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtYWluIGZyYW1lIGZvciB0aGUgTmV0d29yay5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgb25jZSB3aGVuIGEgTmV0d29yayBvYmplY3QgaXMgY3JlYXRlZC4gVGhlIGZyYW1lXG4gKiBjb250YWlucyBhIGNhbnZhcywgYW5kIHRoaXMgY2FudmFzIGNvbnRhaW5zIGFsbCBvYmplY3RzIGxpa2UgdGhlIGF4aXMgYW5kXG4gKiBub2Rlcy5cbiAqL1xuXG52YXIgQ2FudmFzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBDYW52YXMoYm9keSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhcyk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IDE7XG4gICAgdGhpcy5jYW1lcmFTdGF0ZSA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhc1ZpZXdDZW50ZXIgPSB7fTtcbiAgICB0aGlzLl9jbGVhbnVwQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgd2lkdGg6IFwiMTAwJVwiXG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhDYW52YXMsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIF9jb250ZXh0O1xuXG4gICAgICAvLyBiaW5kIHRoZSBldmVudHNcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uY2UoXCJyZXNpemVcIiwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgX3RoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnggPSBvYmoud2lkdGggKiAwLjU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLmhlaWdodCAhPT0gMCkge1xuICAgICAgICAgIF90aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ID0gb2JqLmhlaWdodCAqIDAuNTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInNldFNpemVcIiwgYmluZCQyKF9jb250ZXh0ID0gdGhpcy5zZXRTaXplKS5jYWxsKF9jb250ZXh0LCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5oYW1tZXJGcmFtZS5kZXN0cm95KCk7XG5cbiAgICAgICAgX3RoaXMuaGFtbWVyLmRlc3Ryb3koKTtcblxuICAgICAgICBfdGhpcy5fY2xlYW5VcCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiYXV0b1Jlc2l6ZVwiXTtcbiAgICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9IC8vIEF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gY2hhbmdpbmcgc2l6ZSBvZiB0aGUgY29udGFpbmVyIGVsZW1lbnQuXG5cblxuICAgICAgdGhpcy5fY2xlYW5VcCgpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9SZXNpemUgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MjtcblxuICAgICAgICBpZiAod2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgLy8gZGVjZW50IGJyb3dzZXJzLCBpbW1lZGlhdGUgcmVhY3Rpb25zXG4gICAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gX3RoaXMyLnNldFNpemUoKTtcblxuICAgICAgICAgICAgaWYgKGNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZTtcbiAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGZyYW1lKTtcblxuICAgICAgICAgIHRoaXMuX2NsZWFudXBDYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZnJhbWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElFMTEsIGNvbnRpbm91cyBwb2xsaW5nXG4gICAgICAgICAgdmFyIHJlc2l6ZVRpbWVyID0gc2V0SW50ZXJ2YWwkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IF90aGlzMi5zZXRTaXplKCk7XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDEwMDApO1xuXG4gICAgICAgICAgdGhpcy5fY2xlYW51cENhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVzaXplVGltZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIEF1dG9tYXRpY2FsbHkgYWRhcHQgdG8gY2hhbmdpbmcgc2l6ZSBvZiB0aGUgYnJvd3Nlci5cblxuXG4gICAgICAgIHZhciByZXNpemVGdW5jdGlvbiA9IGJpbmQkMihfY29udGV4dDIgPSB0aGlzLl9vblJlc2l6ZSkuY2FsbChfY29udGV4dDIsIHRoaXMpO1xuXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBcInJlc2l6ZVwiLCByZXNpemVGdW5jdGlvbik7XG5cbiAgICAgICAgdGhpcy5fY2xlYW51cENhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgXCJyZXNpemVcIiwgcmVzaXplRnVuY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhblVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhblVwKCkge1xuICAgICAgdmFyIF9jb250ZXh0MywgX2NvbnRleHQ0LCBfY29udGV4dDU7XG5cbiAgICAgIGZvckVhY2gkMihfY29udGV4dDMgPSByZXZlcnNlJDIoX2NvbnRleHQ0ID0gc3BsaWNlJDIoX2NvbnRleHQ1ID0gdGhpcy5fY2xlYW51cENhbGxiYWNrcykuY2FsbChfY29udGV4dDUsIDApKS5jYWxsKF9jb250ZXh0NCkpLmNhbGwoX2NvbnRleHQzLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9vblJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZXNpemUoKSB7XG4gICAgICB0aGlzLnNldFNpemUoKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYW5kIHN0b3JlIHRoZSBjYW1lcmFTdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwaXhlbFJhdGlvPXRoaXMucGl4ZWxSYXRpb11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENhbWVyYVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDYW1lcmFTdGF0ZSgpIHtcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnBpeGVsUmF0aW87XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aCA9IHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodCA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbiA9IHRoaXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbyxcbiAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhbWVyYVN0YXRlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldENhbWVyYVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDYW1lcmFTdGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggIT09IDAgJiYgdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICE9PSAwICYmIHRoaXMucGl4ZWxSYXRpbyAhPT0gMCAmJiB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGggPiAwICYmIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQgPiAwKSB7XG4gICAgICAgIHZhciB3aWR0aFJhdGlvID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyB0aGlzLnBpeGVsUmF0aW8gLyB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzV2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHRSYXRpbyA9IHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHRoaXMucGl4ZWxSYXRpbyAvIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNIZWlnaHQ7XG4gICAgICAgIHZhciBuZXdTY2FsZSA9IHRoaXMuY2FtZXJhU3RhdGUuc2NhbGU7XG5cbiAgICAgICAgaWYgKHdpZHRoUmF0aW8gIT0gMSAmJiBoZWlnaHRSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogMC41ICogKHdpZHRoUmF0aW8gKyBoZWlnaHRSYXRpbyk7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGhSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogd2lkdGhSYXRpbztcbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHRSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogaGVpZ2h0UmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IG5ld1NjYWxlOyAvLyB0aGlzIGNvbWVzIGZyb20gdGhlIHZpZXcgbW9kdWxlLlxuXG4gICAgICAgIHZhciBjdXJyZW50Vmlld0NlbnRlciA9IHRoaXMuRE9NdG9DYW52YXMoe1xuICAgICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlciA9IHtcbiAgICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgICB4OiBjdXJyZW50Vmlld0NlbnRlci54IC0gdGhpcy5jYW1lcmFTdGF0ZS5wb3NpdGlvbi54LFxuICAgICAgICAgIHk6IGN1cnJlbnRWaWV3Q2VudGVyLnkgLSB0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uLnlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCArPSBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ICs9IGRpc3RhbmNlRnJvbUNlbnRlci55ICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wcmVwYXJlVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgKyBcInB4XCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoaW5kZXhPZiQzKHZhbHVlKS5jYWxsKHZhbHVlLCBcIiVcIikgIT09IC0xIHx8IGluZGV4T2YkMyh2YWx1ZSkuY2FsbCh2YWx1ZSwgXCJweFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXhPZiQzKHZhbHVlKS5jYWxsKHZhbHVlLCBcIiVcIikgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCB1c2UgdGhlIHZhbHVlIHN1cHBsaWVkIGZvciB3aWR0aCBvciBoZWlnaHQ6XCIgKyB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgSFRNTFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBjb250YWluZXIgZWxlbWVudC5cbiAgICAgIHdoaWxlICh0aGlzLmJvZHkuY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICB0aGlzLmJvZHkuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuYm9keS5jb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSBcInZpcy1uZXR3b3JrXCI7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICB0aGlzLmZyYW1lLnRhYkluZGV4ID0gOTAwOyAvLyB0YWIgaW5kZXggaXMgcmVxdWlyZWQgZm9yIGtleWNoYXJtIHRvIGJpbmQga2V5c3Ryb2tlcyB0byB0aGUgZGl2IGluc3RlYWQgb2YgdGhlIHdpbmRvd1xuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lLmNhbnZhcyk7XG5cbiAgICAgIGlmICghdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICB2YXIgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9IFwicmVkXCI7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9IFwiMTBweFwiO1xuICAgICAgICBub0NhbnZhcy5pbm5lckhUTUwgPSBcIkVycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhc1wiO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRQaXhlbFJhdGlvKCk7XG5cbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgIH0gLy8gYWRkIHRoZSBmcmFtZSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRcblxuXG4gICAgICB0aGlzLmJvZHkuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSAxO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2JpbmRIYW1tZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBiaW5kcyBoYW1tZXIsIGl0IGNhbiBiZSByZXBlYXRlZCBvdmVyIGFuZCBvdmVyIGR1ZSB0byB0aGUgdW5pcXVlbmVzcyBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYmluZEhhbW1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEhhbW1lcigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5oYW1tZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgICAgdGhpcy5waW5jaCA9IHt9OyAvLyBpbml0IGhhbW1lclxuXG4gICAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIkMSh0aGlzLmZyYW1lLmNhbnZhcyk7XG4gICAgICB0aGlzLmhhbW1lci5nZXQoXCJwaW5jaFwiKS5zZXQoe1xuICAgICAgICBlbmFibGU6IHRydWVcbiAgICAgIH0pOyAvLyBlbmFibGUgdG8gZ2V0IGJldHRlciByZXNwb25zZSwgdG9kbzogdGVzdCBvbiBtb2JpbGUuXG5cbiAgICAgIHRoaXMuaGFtbWVyLmdldChcInBhblwiKS5zZXQoe1xuICAgICAgICB0aHJlc2hvbGQ6IDUsXG4gICAgICAgIGRpcmVjdGlvbjogSGFtbWVyJDEuRElSRUNUSU9OX0FMTFxuICAgICAgfSk7XG4gICAgICBvblRvdWNoKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ub3VjaChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwidGFwXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vblRhcChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwiZG91YmxldGFwXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRvdWJsZVRhcChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicHJlc3NcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uSG9sZChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFuc3RhcnRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwYW5tb3ZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWcoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbmVuZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnRW5kKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwaW5jaFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25QaW5jaChldmVudCk7XG4gICAgICB9KTsgLy8gVE9ETzogbmVhdGx5IGNsZWFudXAgdGhlc2UgaGFuZGxlcnMgd2hlbiByZS1jcmVhdGluZyB0aGUgQ2FudmFzLCBJRiB0aGVzZSBhcmUgZG9uZSB3aXRoIGhhbW1lciwgZXZlbnQuc3RvcFByb3BhZ2F0aW9uIHdpbGwgbm90IHdvcms/XG5cbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyRnJhbWUgPSBuZXcgSGFtbWVyJDEodGhpcy5mcmFtZSk7XG4gICAgICBvblJlbGVhc2UodGhpcy5oYW1tZXJGcmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUmVsZWFzZShldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgbmV3IHNpemUgZm9yIHRoZSBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2lkdGggICBXaWR0aCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAoZm9yIGV4YW1wbGUgJzgwMHB4J1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yICc1MCUnKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHQgIEhlaWdodCBpbiBwaXhlbHMgb3IgcGVyY2VudGFnZSAgKGZvciBleGFtcGxlICc0MDBweCdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBvciAnMzAlJylcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2l6ZSgpIHtcbiAgICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5vcHRpb25zLmhlaWdodDtcbiAgICAgIHdpZHRoID0gdGhpcy5fcHJlcGFyZVZhbHVlKHdpZHRoKTtcbiAgICAgIGhlaWdodCA9IHRoaXMuX3ByZXBhcmVWYWx1ZShoZWlnaHQpO1xuICAgICAgdmFyIGVtaXRFdmVudCA9IGZhbHNlO1xuICAgICAgdmFyIG9sZFdpZHRoID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGg7XG4gICAgICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0OyAvLyB1cGRhdGUgdGhlIHBpeGVsIHJhdGlvXG4gICAgICAvL1xuICAgICAgLy8gTk9URTogQ29tbWVudCBpbiBmb2xsb3dpbmcgaXMgcmF0aGVyIGluY29uc2lzdGVudDsgdGhpcyBpcyB0aGUgT05MWSBwbGFjZSBpbiB0aGUgY29kZVxuICAgICAgLy8gICAgICAgd2hlcmUgaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwaXhlbCByYXRpbyBjb3VsZCBjaGFuZ2UgYXQgcnVudGltZS5cbiAgICAgIC8vICAgICAgIFRoZSBvbmx5IHdheSBJIGNhbiB0aGluayBvZiB0aGlzIGhhcHBlbmluZyBpcyBhIHJvdGF0aW5nIHNjcmVlbiBvciB0YWJsZXQ7IGJ1dCB0aGVuXG4gICAgICAvLyAgICAgICB0aGVyZSBzaG91bGQgYmUgYSBtZWNoYW5pc20gZm9yIHJlbG9hZGluZyB0aGUgZGF0YSAoVE9ETzogY2hlY2sgaWYgdGhpcyBpcyBwcmVzZW50KS5cbiAgICAgIC8vXG4gICAgICAvLyAgICAgICBJZiB0aGUgYXNzdW1wdGlvbiBpcyB0cnVlIChpLmUuIHBpeGVsIHJhdGlvIGNhbiBjaGFuZ2UgYXQgcnVudGltZSksIHRoZW4gKmFsbCogdXNhZ2VcbiAgICAgIC8vICAgICAgIG9mIHBpeGVsIHJhdGlvIG11c3QgYmUgb3ZlcmhhdWxlZCBmb3IgdGhpcy5cbiAgICAgIC8vXG4gICAgICAvLyAgICAgICBGb3IgdGhlIHRpbWUgYmVpbmcsIEkgd2lsbCBodW1vciB0aGUgYXNzdW1wdGlvbiBoZXJlLCBhbmQgaW4gdGhlIHJlc3Qgb2YgdGhlIGNvZGUgYXNzdW1lIGl0IGlzXG4gICAgICAvLyAgICAgICBjb25zdGFudC5cblxuICAgICAgdmFyIHByZXZpb3VzUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87IC8vIHdlIGNhY2hlIHRoaXMgYmVjYXVzZSB0aGUgY2FtZXJhIHN0YXRlIHN0b3JhZ2UgbmVlZHMgdGhlIG9sZCB2YWx1ZVxuXG4gICAgICB0aGlzLl9zZXRQaXhlbFJhdGlvKCk7XG5cbiAgICAgIGlmICh3aWR0aCAhPSB0aGlzLm9wdGlvbnMud2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMub3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fZ2V0Q2FtZXJhU3RhdGUocHJldmlvdXNSYXRpbyk7XG5cbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMub3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FudmFzVmlld0NlbnRlciA9IHtcbiAgICAgICAgICB4OiAwLjUgKiB0aGlzLmZyYW1lLmNsaWVudFdpZHRoLFxuICAgICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2xpZW50SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIGVtaXRFdmVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIHdvdWxkIGFkYXB0IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHRvIHRoZSB3aWR0aCBmcm9tIDEwMCUgaWYgYW5kIG9ubHkgaWZcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBjaGFuZ2UuXG4gICAgICAgIHZhciBuZXdXaWR0aCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pOyAvLyBzdG9yZSB0aGUgY2FtZXJhIGlmIHRoZXJlIGlzIGEgY2hhbmdlIGluIHNpemUuXG5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoICE9PSBuZXdXaWR0aCB8fCB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgIHRoaXMuX2dldENhbWVyYVN0YXRlKHByZXZpb3VzUmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoICE9PSBuZXdXaWR0aCkge1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgZW1pdEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbWl0RXZlbnQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc2l6ZVwiLCB7XG4gICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyB0aGlzLnBpeGVsUmF0aW8pLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW8pLFxuICAgICAgICAgIG9sZFdpZHRoOiBNYXRoLnJvdW5kKG9sZFdpZHRoIC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBvbGRIZWlnaHQ6IE1hdGgucm91bmQob2xkSGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvKVxuICAgICAgICB9KTsgLy8gcmVzdG9yZSB0aGUgY2FtZXJhIG9uIGNoYW5nZS5cblxuICAgICAgICB0aGlzLl9zZXRDYW1lcmFTdGF0ZSgpO1xuICAgICAgfSAvLyBzZXQgaW5pdGlhbGl6ZWQgc28gdGhlIGdldCBhbmQgc2V0IGNhbWVyYSB3aWxsIHdvcmsgZnJvbSBub3cgb24uXG5cblxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICByZXR1cm4gZW1pdEV2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFtZS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIHBpeGVsIHJhdGlvIGZvciB2YXJpb3VzIGJyb3dzZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZVBpeGVsUmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZVBpeGVsUmF0aW8oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGlmIChjdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGNhbnZheCBjb250ZXh0XCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnVtZXJhdG9yID0gMTtcblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gKHdpbmRvdyAhPT0gdW5kZWZpbmVkKSBkb2Vzbid0IHdvcmsgaGVyZSFcbiAgICAgICAgLy8gUHJvdGVjdGlvbiBkdXJpbmcgdW5pdCB0ZXN0cywgd2hlcmUgJ3dpbmRvdycgY2FuIGJlIG1pc3NpbmdcbiAgICAgICAgbnVtZXJhdG9yID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbm9taW5hdG9yID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIHJldHVybiBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGF6eSBkZXRlcm1pbmF0aW9uIG9mIHBpeGVsIHJhdGlvLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRQaXhlbFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQaXhlbFJhdGlvKCkge1xuICAgICAgdGhpcy5waXhlbFJhdGlvID0gdGhpcy5fZGV0ZXJtaW5lUGl4ZWxSYXRpbygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRyYW5zZm9ybSBpbiB0aGUgY29udGFpbmVkIGNvbnRleHQsIGJhc2VkIG9uIGl0cyBwaXhlbFJhdGlvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJhbnNmb3JtKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICBpZiAoY3R4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCBjYW52YXggY29udGV4dFwiKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIFggY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdikgdG9cbiAgICAgKiB0aGUgWCBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfWGNvbnZlcnRET010b0NhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWGNvbnZlcnRET010b0NhbnZhcyh4KSB7XG4gICAgICByZXR1cm4gKHggLSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54KSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBYIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pIHRvXG4gICAgICogdGhlIFggY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX1hjb252ZXJ0Q2FudmFzVG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1hjb252ZXJ0Q2FudmFzVG9ET00oeCkge1xuICAgICAgcmV0dXJuIHggKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLng7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIFkgY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdikgdG9cbiAgICAgKiB0aGUgWSBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfWWNvbnZlcnRET010b0NhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWWNvbnZlcnRET010b0NhbnZhcyh5KSB7XG4gICAgICByZXR1cm4gKHkgLSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55KSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBZIGNvb3JkaW5hdGUgaW4gY2FudmFzLXNwYWNlICh0aGUgc2ltdWxhdGlvbiBzYW5kYm94LCB3aGljaCB0aGUgY2FtZXJhIGxvb2tzIHVwb24pIHRvXG4gICAgICogdGhlIFkgY29vcmRpbmF0ZSBpbiBET00tc3BhY2UgKGNvb3JkaW5hdGUgcG9pbnQgaW4gYnJvd3NlciByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIGRpdilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX1ljb252ZXJ0Q2FudmFzVG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX1ljb252ZXJ0Q2FudmFzVG9ET00oeSkge1xuICAgICAgcmV0dXJuIHkgKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvc1xuICAgICAqIEByZXR1cm5zIHtwb2ludH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbnZhc1RvRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbnZhc1RvRE9NKHBvcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5fWGNvbnZlcnRDYW52YXNUb0RPTShwb3MueCksXG4gICAgICAgIHk6IHRoaXMuX1ljb252ZXJ0Q2FudmFzVG9ET00ocG9zLnkpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7cG9pbnR9IHBvc1xuICAgICAqIEByZXR1cm5zIHtwb2ludH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRPTXRvQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIERPTXRvQ2FudmFzKHBvcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb3MueCksXG4gICAgICAgIHk6IHRoaXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9zLnkpXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYW52YXM7XG59KCk7XG5cbi8qKlxyXG4gKiBWYWxpZGF0ZSB0aGUgZml0IG9wdGlvbnMsIHJlcGxhY2UgbWlzc2luZyBvcHRpb25hbCB2YWx1ZXMgYnkgZGVmYXVsdHMgZXRjLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmF3T3B0aW9ucyAtIFRoZSByYXcgb3B0aW9ucy5cclxuICogQHBhcmFtIGFsbE5vZGVJZHMgLSBBbGwgbm9kZSBpZHMgdGhhdCB3aWxsIGJlIHVzZWQgaWYgbm9kZXMgYXJlIG9taXR0ZWQgaW5cclxuICogdGhlIHJhdyBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBPcHRpb25zIHdpdGggZXZlcnl0aGluZyBmaWxsZWQgaW4gYW5kIHZhbGlkYXRlZC5cclxuICovXG5mdW5jdGlvbiBub3JtYWxpemVGaXRPcHRpb25zKHJhd09wdGlvbnMsIGFsbE5vZGVJZHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhc3NpZ24kMih7XG4gICAgbm9kZXM6IGFsbE5vZGVJZHMsXG4gICAgbWluWm9vbUxldmVsOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgIG1heFpvb21MZXZlbDogMVxuICB9LCByYXdPcHRpb25zICE9PSBudWxsICYmIHJhd09wdGlvbnMgIT09IHZvaWQgMCA/IHJhd09wdGlvbnMgOiB7fSk7XG5cbiAgaWYgKCFpc0FycmF5JDUob3B0aW9ucy5ub2RlcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm9kZXMgaGFzIHRvIGJlIGFuIGFycmF5IG9mIGlkcy5cIik7XG4gIH1cblxuICBpZiAob3B0aW9ucy5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICBvcHRpb25zLm5vZGVzID0gYWxsTm9kZUlkcztcbiAgfVxuXG4gIGlmICghKHR5cGVvZiBvcHRpb25zLm1pblpvb21MZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLm1pblpvb21MZXZlbCA+IDApKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pbiB6b29tIGxldmVsIGhhcyB0byBiZSBhIG51bWJlciBoaWdoZXIgdGhhbiB6ZXJvLlwiKTtcbiAgfVxuXG4gIGlmICghKHR5cGVvZiBvcHRpb25zLm1heFpvb21MZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLm1pblpvb21MZXZlbCA8PSBvcHRpb25zLm1heFpvb21MZXZlbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWF4IHpvb20gbGV2ZWwgaGFzIHRvIGJlIGEgbnVtYmVyIGhpZ2hlciB0aGFuIG1pbiB6b29tIGxldmVsLlwiKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIFRoZSB2aWV3XG4gKi9cblxudmFyIFZpZXcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gVmlldyhib2R5LCBjYW52YXMpIHtcbiAgICB2YXIgX2NvbnRleHQsXG4gICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgX2NvbnRleHQyO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlldyk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxIC8gdGhpcy5yZW5kZXJSZWZyZXNoUmF0ZTtcbiAgICB0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uID0gXCJlYXNlSW5PdXRRdWludFwiO1xuICAgIHRoaXMuZWFzaW5nVGltZSA9IDA7XG4gICAgdGhpcy5zb3VyY2VTY2FsZSA9IDA7XG4gICAgdGhpcy50YXJnZXRTY2FsZSA9IDA7XG4gICAgdGhpcy5zb3VyY2VUcmFuc2xhdGlvbiA9IDA7XG4gICAgdGhpcy50YXJnZXRUcmFuc2xhdGlvbiA9IDA7XG4gICAgdGhpcy5sb2NrZWRPbk5vZGVJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgdGhpcy52aWV3RnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJmaXRcIiwgYmluZCQyKF9jb250ZXh0ID0gdGhpcy5maXQpLmNhbGwoX2NvbnRleHQsIHRoaXMpKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFuaW1hdGlvbkZpbmlzaGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgfSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJ1bmxvY2tOb2RlXCIsIGJpbmQkMihfY29udGV4dDIgPSB0aGlzLnJlbGVhc2VOb2RlKS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoVmlldywgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB6b29tcyBvdXQgdG8gZml0IGFsbCBkYXRhIG9uIHNjcmVlbiBiYXNlZCBvbiBhbW91bnQgb2Ygbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17e25vZGVzPUFycmF5fX1dXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdGlhbFpvb209ZmFsc2VdICB8IHpvb20gYmFzZWQgb24gZml0dGVkIGZvcm11bGEgb3IgcmFuZ2UsIHRydWUgPSBmaXR0ZWQsIGRlZmF1bHQgPSBmYWxzZTtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXQob3B0aW9ucykge1xuICAgICAgdmFyIGluaXRpYWxab29tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIG9wdGlvbnMgPSBub3JtYWxpemVGaXRPcHRpb25zKG9wdGlvbnMsIHRoaXMuYm9keS5ub2RlSW5kaWNlcyk7XG4gICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgIHZhciByYW5nZTtcbiAgICAgIHZhciB6b29tTGV2ZWw7XG5cbiAgICAgIGlmIChjYW52YXNXaWR0aCA9PT0gMCB8fCBjYW52YXNIZWlnaHQgPT09IDApIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBwb2ludCBpbiB0cnlpbmcgdG8gZml0IGludG8gemVybyBzaXplZCBjYW52YXMuIFRoaXMgY291bGRcbiAgICAgICAgLy8gcG90ZW50aWFsbHkgZXZlbiByZXN1bHQgaW4gaW52YWxpZCB2YWx1ZXMgYmVpbmcgY29tcHV0ZWQuIEZvciBleGFtcGxlXG4gICAgICAgIC8vIGZvciBuZXR3b3JrIHdpdGhvdXQgbm9kZXMgYW5kIHplcm8gc2l6ZWQgY2FudmFzIHRoZSB6b29tIGxldmVsIHdvdWxkXG4gICAgICAgIC8vIGVuZCB1cCBiZWluZyBjb21wdXRlZCBhcyAwLzAgd2hpY2ggcmVzdWx0cyBpbiBOYU4uIEluIGFueSBvdGhlciBjYXNlXG4gICAgICAgIC8vIHRoaXMgd291bGQgYmUgMC9zb21ldGhpbmcgd2hpY2ggaXMgYWdhaW4gcG9pbnRsZXNzIHRvIGNvbXB1dGUuXG4gICAgICAgIHpvb21MZXZlbCA9IDE7XG4gICAgICAgIHJhbmdlID0gTmV0d29ya1V0aWwuZ2V0UmFuZ2UodGhpcy5ib2R5Lm5vZGVzLCBvcHRpb25zLm5vZGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbFpvb20gPT09IHRydWUpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgbW9yZSB0aGFuIGhhbGYgb2YgdGhlIG5vZGVzIGhhdmUgYSBwcmVkZWZpbmVkIHBvc2l0aW9uLiBJZiBzbywgd2UgdXNlIHRoZSByYW5nZSwgbm90IHRoZSBhcHByb3hpbWF0aW9uLlxuICAgICAgICB2YXIgcG9zaXRpb25EZWZpbmVkID0gMDtcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgICAgIGlmIChub2RlLnByZWRlZmluZWRQb3NpdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbkRlZmluZWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb25EZWZpbmVkID4gMC41ICogdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZml0KG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByYW5nZSA9IE5ldHdvcmtVdGlsLmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG4gICAgICAgIHZhciBudW1iZXJPZk5vZGVzID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgem9vbUxldmVsID0gMTIuNjYyIC8gKG51bWJlck9mTm9kZXMgKyA3LjQxNDcpICsgMC4wOTY0ODIyOyAvLyB0aGlzIGlzIG9idGFpbmVkIGZyb20gZml0dGluZyBhIGRhdGFzZXQgZnJvbSA1IHBvaW50cyB3aXRoIHNjYWxlIGxldmVscyB0aGF0IGxvb2tlZCBnb29kLlxuICAgICAgICAvLyBjb3JyZWN0IGZvciBsYXJnZXIgY2FudmFzc2VzLlxuXG4gICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLm1pbihjYW52YXNXaWR0aCAvIDYwMCwgY2FudmFzSGVpZ2h0IC8gNjAwKTtcbiAgICAgICAgem9vbUxldmVsICo9IGZhY3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVzaXplTm9kZXNcIik7XG4gICAgICAgIHJhbmdlID0gTmV0d29ya1V0aWwuZ2V0UmFuZ2UodGhpcy5ib2R5Lm5vZGVzLCBvcHRpb25zLm5vZGVzKTtcbiAgICAgICAgdmFyIHhEaXN0YW5jZSA9IE1hdGguYWJzKHJhbmdlLm1heFggLSByYW5nZS5taW5YKSAqIDEuMTtcbiAgICAgICAgdmFyIHlEaXN0YW5jZSA9IE1hdGguYWJzKHJhbmdlLm1heFkgLSByYW5nZS5taW5ZKSAqIDEuMTtcbiAgICAgICAgdmFyIHhab29tTGV2ZWwgPSBjYW52YXNXaWR0aCAvIHhEaXN0YW5jZTtcbiAgICAgICAgdmFyIHlab29tTGV2ZWwgPSBjYW52YXNIZWlnaHQgLyB5RGlzdGFuY2U7XG4gICAgICAgIHpvb21MZXZlbCA9IHhab29tTGV2ZWwgPD0geVpvb21MZXZlbCA/IHhab29tTGV2ZWwgOiB5Wm9vbUxldmVsO1xuICAgICAgfVxuXG4gICAgICBpZiAoem9vbUxldmVsID4gb3B0aW9ucy5tYXhab29tTGV2ZWwpIHtcbiAgICAgICAgem9vbUxldmVsID0gb3B0aW9ucy5tYXhab29tTGV2ZWw7XG4gICAgICB9IGVsc2UgaWYgKHpvb21MZXZlbCA8IG9wdGlvbnMubWluWm9vbUxldmVsKSB7XG4gICAgICAgIHpvb21MZXZlbCA9IG9wdGlvbnMubWluWm9vbUxldmVsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VudGVyID0gTmV0d29ya1V0aWwuZmluZENlbnRlcihyYW5nZSk7XG4gICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgcG9zaXRpb246IGNlbnRlcixcbiAgICAgICAgc2NhbGU6IHpvb21MZXZlbCxcbiAgICAgICAgYW5pbWF0aW9uOiBvcHRpb25zLmFuaW1hdGlvblxuICAgICAgfTtcbiAgICAgIHRoaXMubW92ZVRvKGFuaW1hdGlvbk9wdGlvbnMpO1xuICAgIH0gLy8gYW5pbWF0aW9uXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXIgYSBub2RlIGluIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9kZUlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXMobm9kZUlkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueCxcbiAgICAgICAgICB5OiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS55XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMucG9zaXRpb24gPSBub2RlUG9zaXRpb247XG4gICAgICAgIG9wdGlvbnMubG9ja2VkT25Ob2RlID0gbm9kZUlkO1xuICAgICAgICB0aGlzLm1vdmVUbyhvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlOiBcIiArIG5vZGVJZCArIFwiIGNhbm5vdCBiZSBmb3VuZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIHwgIG9wdGlvbnMub2Zmc2V0ICAgPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgaW4gRE9NIHBpeGVsc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnNjYWxlICAgID0gbnVtYmVyICAgICAgICAgICAgICAgICAvLyBzY2FsZSB0byBtb3ZlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMucG9zaXRpb24gPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIHBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5hbmltYXRpb24gPSB7ZHVyYXRpb246bnVtYmVyLCBlYXNpbmdGdW5jdGlvbjpTdHJpbmd9IHx8IEJvb2xlYW4gICAvLyBwb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm9mZnNldC54ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb2VyY2UgYW5kIHZlcmlmeSB0aGF0IHggaXMgdmFsaWQuXG4gICAgICAgICAgb3B0aW9ucy5vZmZzZXQueCA9ICtvcHRpb25zLm9mZnNldC54O1xuXG4gICAgICAgICAgaWYgKCFfaXNGaW5pdGUkMihvcHRpb25zLm9mZnNldC54KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcIm9mZnNldC54XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5vZmZzZXQueCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXQueSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB5IGlzIHZhbGlkLlxuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0LnkgPSArb3B0aW9ucy5vZmZzZXQueTtcblxuICAgICAgICAgIGlmICghX2lzRmluaXRlJDIob3B0aW9ucy5vZmZzZXQueSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJvZmZzZXQueVwiIGhhcyB0byBiZSBhIGZpbml0ZSBudW1iZXIuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0LnggPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLm9mZnNldCA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi54ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb2VyY2UgYW5kIHZlcmlmeSB0aGF0IHggaXMgdmFsaWQuXG4gICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi54ID0gK29wdGlvbnMucG9zaXRpb24ueDtcblxuICAgICAgICAgIGlmICghX2lzRmluaXRlJDIob3B0aW9ucy5wb3NpdGlvbi54KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcInBvc2l0aW9uLnhcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uLnggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24ueSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB5IGlzIHZhbGlkLlxuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24ueSA9ICtvcHRpb25zLnBvc2l0aW9uLnk7XG5cbiAgICAgICAgICBpZiAoIV9pc0Zpbml0ZSQyKG9wdGlvbnMucG9zaXRpb24ueSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJwb3NpdGlvbi55XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHRoaXMuZ2V0Vmlld1Bvc2l0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB0aGUgc2NhbGUgaXMgdmFsaWQuXG4gICAgICAgIG9wdGlvbnMuc2NhbGUgPSArb3B0aW9ucy5zY2FsZTtcblxuICAgICAgICBpZiAoIShvcHRpb25zLnNjYWxlID4gMCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwic2NhbGVcIiBoYXMgdG8gYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8uJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7XG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHtcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPSAxMDAwO1xuICAgICAgfSAvLyBkZWZhdWx0IGR1cmF0aW9uXG5cblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZWFzaW5nRnVuY3Rpb24gPSBcImVhc2VJbk91dFF1YWRcIjtcbiAgICAgIH0gLy8gZGVmYXVsdCBlYXNpbmcgZnVuY3Rpb25cblxuXG4gICAgICB0aGlzLmFuaW1hdGVWaWV3KG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICB8ICBvcHRpb25zLm9mZnNldCAgID0ge3g6bnVtYmVyLCB5Om51bWJlcn0gICAvLyBvZmZzZXQgZnJvbSB0aGUgY2VudGVyIGluIERPTSBwaXhlbHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy50aW1lICAgICA9IG51bWJlciAgICAgICAgICAgICAgICAgLy8gYW5pbWF0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMuc2NhbGUgICAgPSBudW1iZXIgICAgICAgICAgICAgICAgIC8vIHNjYWxlIHRvIGFuaW1hdGUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5wb3NpdGlvbiA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gcG9zaXRpb24gdG8gYW5pbWF0ZSB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLmVhc2luZ0Z1bmN0aW9uID0gU3RyaW5nICAgICAgICAgICAvLyBsaW5lYXIsIGVhc2VJblF1YWQsIGVhc2VPdXRRdWFkLCBlYXNlSW5PdXRRdWFkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5DdWJpYywgZWFzZU91dEN1YmljLCBlYXNlSW5PdXRDdWJpYyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluUXVhcnQsIGVhc2VPdXRRdWFydCwgZWFzZUluT3V0UXVhcnQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhc2VJblF1aW50LCBlYXNlT3V0UXVpbnQsIGVhc2VJbk91dFF1aW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlVmlld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlVmlldyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uOyAvLyByZWxlYXNlIGlmIHNvbWV0aGluZyBmb2N1c3NlZCBvbiB0aGUgbm9kZVxuXG4gICAgICB0aGlzLnJlbGVhc2VOb2RlKCk7XG5cbiAgICAgIGlmIChvcHRpb25zLmxvY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gb3B0aW9ucy5sb2NrZWRPbk5vZGU7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICB9IC8vIGZvcmNlZnVsbHkgY29tcGxldGUgdGhlIG9sZCBhbmltYXRpb24gaWYgaXQgd2FzIHN0aWxsIHJ1bm5pbmdcblxuXG4gICAgICBpZiAodGhpcy5lYXNpbmdUaW1lICE9IDApIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblJlZHJhdyh0cnVlKTsgLy8gYnkgc2V0dGluZyBlYXNpbmd0aW1lIHRvIDEsIHdlIGZpbmlzaCB0aGUgYW5pbWF0aW9uLlxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc291cmNlU2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHRoaXMuc291cmNlVHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSBvcHRpb25zLnNjYWxlOyAvLyBzZXQgdGhlIHNjYWxlIHNvIHRoZSB2aWV3Q2VudGVyIGlzIGJhc2VkIG9uIHRoZSBjb3JyZWN0IHpvb20gbGV2ZWwuIFRoaXMgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgdHJhbnNpdGlvblJlZHJhd1xuICAgICAgLy8gYnV0IGF0IGxlYXN0IHRoZW4gd2UnbGwgaGF2ZSB0aGUgdGFyZ2V0IHRyYW5zaXRpb25cblxuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSB0aGlzLnRhcmdldFNjYWxlO1xuICAgICAgdmFyIHZpZXdDZW50ZXIgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfSk7XG4gICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0ge1xuICAgICAgICAvLyBvZmZzZXQgZnJvbSB2aWV3LCBkaXN0YW5jZSB2aWV3IGhhcyB0byBjaGFuZ2UgYnkgdGhlc2UgeCBhbmQgeSB0byBjZW50ZXIgdGhlIG5vZGVcbiAgICAgICAgeDogdmlld0NlbnRlci54IC0gb3B0aW9ucy5wb3NpdGlvbi54LFxuICAgICAgICB5OiB2aWV3Q2VudGVyLnkgLSBvcHRpb25zLnBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgICB0aGlzLnRhcmdldFRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnggKyBkaXN0YW5jZUZyb21DZW50ZXIueCAqIHRoaXMudGFyZ2V0U2NhbGUgKyBvcHRpb25zLm9mZnNldC54LFxuICAgICAgICB5OiB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkgKyBkaXN0YW5jZUZyb21DZW50ZXIueSAqIHRoaXMudGFyZ2V0U2NhbGUgKyBvcHRpb25zLm9mZnNldC55XG4gICAgICB9OyAvLyBpZiB0aGUgdGltZSBpcyBzZXQgdG8gMCwgZG9uJ3QgZG8gYW4gYW5pbWF0aW9uXG5cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQzO1xuXG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSBiaW5kJDIoX2NvbnRleHQzID0gdGhpcy5fbG9ja2VkUmVkcmF3KS5jYWxsKF9jb250ZXh0MywgdGhpcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHRoaXMudGFyZ2V0U2NhbGU7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB0aGlzLnRhcmdldFRyYW5zbGF0aW9uO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NDtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMSAvICg2MCAqIG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uICogMC4wMDEpIHx8IDEgLyA2MDsgLy8gNjAgZm9yIDYwIHNlY29uZHMsIDAuMDAxIGZvciBtaWxsaSdzXG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uO1xuICAgICAgICB0aGlzLnZpZXdGdW5jdGlvbiA9IGJpbmQkMihfY29udGV4dDQgPSB0aGlzLl90cmFuc2l0aW9uUmVkcmF3KS5jYWxsKF9jb250ZXh0NCwgdGhpcyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVzZWQgdG8gYW5pbWF0ZSBzbW9vdGhseSBieSBoaWphY2tpbmcgdGhlIHJlZHJhdyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbG9ja2VkUmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2NrZWRSZWRyYXcoKSB7XG4gICAgICB2YXIgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB0aGlzLmJvZHkubm9kZXNbdGhpcy5sb2NrZWRPbk5vZGVJZF0ueCxcbiAgICAgICAgeTogdGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLnlcbiAgICAgIH07XG4gICAgICB2YXIgdmlld0NlbnRlciA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgeDogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICB5OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSB7XG4gICAgICAgIC8vIG9mZnNldCBmcm9tIHZpZXcsIGRpc3RhbmNlIHZpZXcgaGFzIHRvIGNoYW5nZSBieSB0aGVzZSB4IGFuZCB5IHRvIGNlbnRlciB0aGUgbm9kZVxuICAgICAgICB4OiB2aWV3Q2VudGVyLnggLSBub2RlUG9zaXRpb24ueCxcbiAgICAgICAgeTogdmlld0NlbnRlci55IC0gbm9kZVBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgICB2YXIgc291cmNlVHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHZhciB0YXJnZXRUcmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogc291cmNlVHJhbnNsYXRpb24ueCArIGRpc3RhbmNlRnJvbUNlbnRlci54ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC54LFxuICAgICAgICB5OiBzb3VyY2VUcmFuc2xhdGlvbi55ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnkgKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0LnlcbiAgICAgIH07XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHRhcmdldFRyYW5zbGF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgc3RhdGUgb2YgYSBsb2NrZWQgb24gTm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZU5vZGUoKSB7XG4gICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmlld0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmaW5pc2hlZD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyYW5zaXRpb25SZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zaXRpb25SZWRyYXcoKSB7XG4gICAgICB2YXIgZmluaXNoZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgdGhpcy5lYXNpbmdUaW1lICs9IHRoaXMuYW5pbWF0aW9uU3BlZWQ7XG4gICAgICB0aGlzLmVhc2luZ1RpbWUgPSBmaW5pc2hlZCA9PT0gdHJ1ZSA/IDEuMCA6IHRoaXMuZWFzaW5nVGltZTtcbiAgICAgIHZhciBwcm9ncmVzcyA9IGVhc2luZ0Z1bmN0aW9uc1t0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uXSh0aGlzLmVhc2luZ1RpbWUpO1xuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSB0aGlzLnNvdXJjZVNjYWxlICsgKHRoaXMudGFyZ2V0U2NhbGUgLSB0aGlzLnNvdXJjZVNjYWxlKSAqIHByb2dyZXNzO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnggLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLngpICogcHJvZ3Jlc3MsXG4gICAgICAgIHk6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueSArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnkgLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkpICogcHJvZ3Jlc3NcbiAgICAgIH07IC8vIGNsZWFudXBcblxuICAgICAgaWYgKHRoaXMuZWFzaW5nVGltZSA+PSAxLjApIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMuZWFzaW5nVGltZSA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMubG9ja2VkT25Ob2RlSWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0NTtcblxuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gYmluZCQyKF9jb250ZXh0NSA9IHRoaXMuX2xvY2tlZFJlZHJhdykuY2FsbChfY29udGV4dDUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYW5pbWF0aW9uRmluaXNoZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjYWxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vmlld1Bvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZXc7XG59KCk7XG5cbi8qKlxuICogTmF2aWdhdGlvbiBIYW5kbGVyXG4gKi9cblxudmFyIE5hdmlnYXRpb25IYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIE5hdmlnYXRpb25IYW5kbGVyKGJvZHksIGNhbnZhcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOYXZpZ2F0aW9uSGFuZGxlcik7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycyA9IFtdO1xuICAgIHRoaXMuYm91bmRGdW5jdGlvbnMgPSB7fTtcbiAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgdGhpcy5hY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFjdGl2YXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmFjdGl2YXRlZCA9IHRydWU7XG5cbiAgICAgIF90aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlYWN0aXZhdGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG5cbiAgICAgIF90aGlzLmNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmtleWNoYXJtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3RoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKE5hdmlnYXRpb25IYW5kbGVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNyZWF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9yIHJlZnJlc2hlcyBuYXZpZ2F0aW9uIGFuZCBzZXRzIGtleSBiaW5kaW5nc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubmF2aWdhdGlvbkJ1dHRvbnMgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaWNvbnNDcmVhdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMubG9hZE5hdmlnYXRpb25FbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaWNvbnNDcmVhdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2xlYW5OYXZpZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgcHJldmlvdXMgbmF2aWdhdGlvbiBpdGVtc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW5OYXZpZ2F0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFuTmF2aWdhdGlvbigpIHtcbiAgICAgIC8vIGNsZWFuIGhhbW1lciBiaW5kaW5nc1xuICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkhhbW1lcnMubGVuZ3RoICE9IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzID0gW107XG4gICAgICB9IC8vIGNsZWFuIHVwIHByZXZpb3VzIG5hdmlnYXRpb24gaXRlbXNcblxuXG4gICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uRE9NICYmIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gb2YgdGhlIG5hdmlnYXRpb24gY29udHJvbHMgbm9kZXMuIFRoZXkgYXJlIGRyYXduIG92ZXIgdGhlIHJlc3Qgb2YgdGhlIG5vZGVzIGFuZCBhcmUgbm90IGFmZmVjdGVkIGJ5IHNjYWxlIGFuZCB0cmFuc2xhdGlvblxuICAgICAqIHRoZXkgaGF2ZSBhIHRyaWdnZXJGdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgb24gY2xpY2suIElmIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmF2aWdhdGlvbiBjb250cm9scyBpcyBkZXBlbmRlbnRcbiAgICAgKiBvbiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCBvciB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQsIHdlIGZsYWcgaG9yaXpvbnRhbEFsaWduTGVmdCBhbmQgdmVydGljYWxBbGlnblRvcCBmYWxzZS5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIGxvY2F0aW9uIHdpbGwgYmUgY29ycmVjdGVkIGJ5IHRoZSBfcmVsb2NhdGVOYXZpZ2F0aW9uIGZ1bmN0aW9uIG9uIGEgc2l6ZSBjaGFuZ2Ugb2YgdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkTmF2aWdhdGlvbkVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWROYXZpZ2F0aW9uRWxlbWVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5jbGVhbk5hdmlnYXRpb24oKTtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkRPTSA9IHt9O1xuICAgICAgdmFyIG5hdmlnYXRpb25EaXZzID0gW1widXBcIiwgXCJkb3duXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiem9vbUluXCIsIFwiem9vbU91dFwiLCBcInpvb21FeHRlbmRzXCJdO1xuICAgICAgdmFyIG5hdmlnYXRpb25EaXZBY3Rpb25zID0gW1wiX21vdmVVcFwiLCBcIl9tb3ZlRG93blwiLCBcIl9tb3ZlTGVmdFwiLCBcIl9tb3ZlUmlnaHRcIiwgXCJfem9vbUluXCIsIFwiX3pvb21PdXRcIiwgXCJfZml0XCJdO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdLmNsYXNzTmFtZSA9IFwidmlzLW5hdmlnYXRpb25cIjtcbiAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hdmlnYXRpb25EaXZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtXCIgKyBuYXZpZ2F0aW9uRGl2c1tpXTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXS5hcHBlbmRDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dKTtcbiAgICAgICAgdmFyIGhhbW1lciA9IG5ldyBIYW1tZXIkMSh0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dKTtcblxuICAgICAgICBpZiAobmF2aWdhdGlvbkRpdkFjdGlvbnNbaV0gPT09IFwiX2ZpdFwiKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICAgICAgb25Ub3VjaChoYW1tZXIsIGJpbmQkMihfY29udGV4dCA9IHRoaXMuX2ZpdCkuY2FsbChfY29udGV4dCwgdGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgICAgICBvblRvdWNoKGhhbW1lciwgYmluZCQyKF9jb250ZXh0MiA9IHRoaXMuYmluZFRvUmVkcmF3KS5jYWxsKF9jb250ZXh0MiwgdGhpcywgbmF2aWdhdGlvbkRpdkFjdGlvbnNbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkhhbW1lcnMucHVzaChoYW1tZXIpO1xuICAgICAgfSAvLyB1c2UgYSBoYW1tZXIgZm9yIHRoZSByZWxlYXNlIHNvIHdlIGRvIG5vdCByZXF1aXJlIHRoZSBvbmUgdXNlZCBpbiB0aGUgcmVzdCBvZiB0aGUgbmV0d29ya1xuICAgICAgLy8gdGhlIG9uZSB0aGUgcmVzdCB1c2VzIGNhbiBiZSBvdmVybG9hZGVkIGJ5IHRoZSBtYW5pcHVsYXRpb24gc3lzdGVtLlxuXG5cbiAgICAgIHZhciBoYW1tZXJGcmFtZSA9IG5ldyBIYW1tZXIkMSh0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICBvblJlbGVhc2UoaGFtbWVyRnJhbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLl9zdG9wTW92ZW1lbnQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5wdXNoKGhhbW1lckZyYW1lKTtcbiAgICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJiaW5kVG9SZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZFRvUmVkcmF3KGFjdGlvbikge1xuICAgICAgaWYgKHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID0gYmluZCQyKF9jb250ZXh0MyA9IHRoaXNbYWN0aW9uXSkuY2FsbChfY29udGV4dDMsIHRoaXMpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdGFydFJlbmRlcmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRGcm9tUmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZEZyb21SZWRyYXcoYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgc3RvcHMgYWxsIG1vdmVtZW50IGluZHVjZWQgYnkgdGhlIG5hdmlnYXRpb24gYnV0dG9uc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9maXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpdCgpIHtcbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gNzAwKSB7XG4gICAgICAgIC8vIFRPRE86IGZpeCB1Z2x5IGhhY2sgdG8gYXZvaWQgaGFtbWVyJ3MgZG91YmxlIGZpcmVpbmcgb2YgZXZlbnQgKGJlY2F1c2Ugd2UgdXNlIHJlbGVhc2U/KVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIsIHtcbiAgICAgICAgICBkdXJhdGlvbjogNzAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIHN0b3BzIGFsbCBtb3ZlbWVudCBpbmR1Y2VkIGJ5IHRoZSBuYXZpZ2F0aW9uIGJ1dHRvbnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RvcE1vdmVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wTW92ZW1lbnQoKSB7XG4gICAgICBmb3IgKHZhciBib3VuZEFjdGlvbiBpbiB0aGlzLmJvdW5kRnVuY3Rpb25zKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib3VuZEZ1bmN0aW9ucywgYm91bmRBY3Rpb24pKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2JvdW5kQWN0aW9uXSk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm91bmRGdW5jdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVVcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVVwKCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSArPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlRG93bigpIHtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgLT0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlTGVmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZUxlZnQoKSB7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54ICs9IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC54O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZVJpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlUmlnaHQoKSB7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54IC09IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC54O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfem9vbUluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF96b29tSW4oKSB7XG4gICAgICB2YXIgc2NhbGVPbGQgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlICogKDEgKyB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQuem9vbSk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHZhciBzY2FsZUZyYWMgPSBzY2FsZSAvIHNjYWxlT2xkO1xuICAgICAgdmFyIHR4ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci54ICsgdHJhbnNsYXRpb24ueCAqIHNjYWxlRnJhYztcbiAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHNjYWxlO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHR4LFxuICAgICAgICB5OiB0eVxuICAgICAgfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIsIHtcbiAgICAgICAgZGlyZWN0aW9uOiBcIitcIixcbiAgICAgICAgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlLFxuICAgICAgICBwb2ludGVyOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3pvb21PdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3pvb21PdXQoKSB7XG4gICAgICB2YXIgc2NhbGVPbGQgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlIC8gKDEgKyB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQuem9vbSk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHZhciBzY2FsZUZyYWMgPSBzY2FsZSAvIHNjYWxlT2xkO1xuICAgICAgdmFyIHR4ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci54ICsgdHJhbnNsYXRpb24ueCAqIHNjYWxlRnJhYztcbiAgICAgIHZhciB0eSA9ICgxIC0gc2NhbGVGcmFjKSAqIHRoaXMuY2FudmFzLmNhbnZhc1ZpZXdDZW50ZXIueSArIHRyYW5zbGF0aW9uLnkgKiBzY2FsZUZyYWM7XG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHNjYWxlO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHR4LFxuICAgICAgICB5OiB0eVxuICAgICAgfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIsIHtcbiAgICAgICAgZGlyZWN0aW9uOiBcIi1cIixcbiAgICAgICAgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlLFxuICAgICAgICBwb2ludGVyOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYmluZCBhbGwga2V5cyB1c2luZyBrZXljaGFybS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbmZpZ3VyZUtleWJvYXJkQmluZGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmtleWJvYXJkLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXlib2FyZC5iaW5kVG9XaW5kb3cgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oe1xuICAgICAgICAgICAgY29udGFpbmVyOiB3aW5kb3csXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMua2V5Y2hhcm0gPSBrZXljaGFybSh7XG4gICAgICAgICAgICBjb250YWluZXI6IHRoaXMuY2FudmFzLmZyYW1lLFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMua2V5Y2hhcm0ucmVzZXQoKTtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ0LCBfY29udGV4dDUsIF9jb250ZXh0NiwgX2NvbnRleHQ3LCBfY29udGV4dDgsIF9jb250ZXh0OSwgX2NvbnRleHQxMCwgX2NvbnRleHQxMSwgX2NvbnRleHQxMiwgX2NvbnRleHQxMywgX2NvbnRleHQxNCwgX2NvbnRleHQxNSwgX2NvbnRleHQxNiwgX2NvbnRleHQxNywgX2NvbnRleHQxOCwgX2NvbnRleHQxOSwgX2NvbnRleHQyMCwgX2NvbnRleHQyMSwgX2NvbnRleHQyMiwgX2NvbnRleHQyMywgX2NvbnRleHQyNCwgX2NvbnRleHQyNSwgX2NvbnRleHQyNiwgX2NvbnRleHQyNztcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDQgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0NCwgXCJ1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVVcFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDIoX2NvbnRleHQ1ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDUsIFwiZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVEb3duXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDYgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0NiwgXCJsZWZ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZUxlZnRcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQyKF9jb250ZXh0NyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQ3LCBcInJpZ2h0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZVJpZ2h0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDggPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0OCwgXCI9XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDkgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0OSwgXCJudW0rXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDEwID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDEwLCBcIm51bS1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDExID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDExLCBcIi1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDEyID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDEyLCBcIltcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDEzID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDEzLCBcIl1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuXG4gICAgICAgICAgYmluZCQyKF9jb250ZXh0MTQgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTQsIFwicGFnZXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDE1ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE1LCBcInBhZ2Vkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG5cbiAgICAgICAgICBiaW5kJDIoX2NvbnRleHQxNiA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxNiwgXCJ1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlVXBcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDE3ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE3LCBcImRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZURvd25cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDE4ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE4LCBcImxlZnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZUxlZnRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDE5ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE5LCBcInJpZ2h0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVSaWdodFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQyKF9jb250ZXh0MjAgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjAsIFwiPVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDIxID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDIxLCBcIm51bStcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDIoX2NvbnRleHQyMiA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyMiwgXCJudW0tXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcblxuICAgICAgICAgIGJpbmQkMihfY29udGV4dDIzID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDIzLCBcIi1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQyKF9jb250ZXh0MjQgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjQsIFwiW1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG5cbiAgICAgICAgICBiaW5kJDIoX2NvbnRleHQyNSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyNSwgXCJdXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQyKF9jb250ZXh0MjYgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjYsIFwicGFnZXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuXG4gICAgICAgICAgYmluZCQyKF9jb250ZXh0MjcgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjcsIFwicGFnZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5hdmlnYXRpb25IYW5kbGVyO1xufSgpO1xuXG4vKipcbiAqIFBvcHVwIGlzIGEgY2xhc3MgdG8gY3JlYXRlIGEgcG9wdXAgd2luZG93IHdpdGggc29tZSB0ZXh0XG4gKi9cblxudmFyIFBvcHVwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgICAgIFRoZSBjb250YWluZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gIG92ZXJmbG93TWV0aG9kICBIb3cgdGhlIHBvcHVwIHNob3VsZCBhY3QgdG8gb3ZlcmZsb3dpbmcgKCdmbGlwJyBvciAnY2FwJylcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHVwKGNvbnRhaW5lciwgb3ZlcmZsb3dNZXRob2QpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3B1cCk7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLm92ZXJmbG93TWV0aG9kID0gb3ZlcmZsb3dNZXRob2QgfHwgXCJjYXBcIjtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5wYWRkaW5nID0gNTtcbiAgICB0aGlzLmhpZGRlbiA9IGZhbHNlOyAvLyBjcmVhdGUgdGhlIGZyYW1lXG5cbiAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9IFwidmlzLXRvb2x0aXBcIjtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggICBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBwb3B1cCB3aW5kb3dcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgICBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgcG9wdXAgd2luZG93XG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wdXAsIFt7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IF9wYXJzZUludCQyKHgpO1xuICAgICAgdGhpcy55ID0gX3BhcnNlSW50JDIoeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udGVudCBmb3IgdGhlIHBvcHVwIHdpbmRvdy4gVGhpcyBjYW4gYmUgSFRNTCBjb2RlIG9yIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IEVsZW1lbnR9IGNvbnRlbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dChjb250ZW50KSB7XG4gICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5mcmFtZS5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcmFtZS5pbm5lckhUTUwgPSBjb250ZW50OyAvLyBzdHJpbmcgY29udGFpbmluZyB0ZXh0IG9yIEhUTUxcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgcG9wdXAgd2luZG93XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb1Nob3ddICAgIFNob3cgb3IgaGlkZSB0aGUgd2luZG93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coZG9TaG93KSB7XG4gICAgICBpZiAoZG9TaG93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZG9TaG93ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5mcmFtZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZnJhbWUuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSB0aGlzLmZyYW1lLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLmZyYW1lLnBhcmVudE5vZGUuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBsZWZ0ID0gMCxcbiAgICAgICAgICAgIHRvcCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMub3ZlcmZsb3dNZXRob2QgPT0gXCJmbGlwXCIpIHtcbiAgICAgICAgICB2YXIgaXNMZWZ0ID0gZmFsc2UsXG4gICAgICAgICAgICAgIGlzVG9wID0gdHJ1ZTsgLy8gV2hlcmUgYXJvdW5kIHRoZSBwb3NpdGlvbiBpdCdzIGxvY2F0ZWRcblxuICAgICAgICAgIGlmICh0aGlzLnkgLSBoZWlnaHQgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIGlzVG9wID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMueCArIHdpZHRoID4gbWF4V2lkdGggLSB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIGlzTGVmdCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMueCAtIHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1RvcCkge1xuICAgICAgICAgICAgdG9wID0gdGhpcy55IC0gaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcCA9IHRoaXMueSAtIGhlaWdodDtcblxuICAgICAgICAgIGlmICh0b3AgKyBoZWlnaHQgKyB0aGlzLnBhZGRpbmcgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIHRvcCA9IG1heEhlaWdodCAtIGhlaWdodCAtIHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9wIDwgdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVmdCA9IHRoaXMueDtcblxuICAgICAgICAgIGlmIChsZWZ0ICsgd2lkdGggKyB0aGlzLnBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgbGVmdCA9IG1heFdpZHRoIC0gd2lkdGggLSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlZnQgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZyYW1lKTsgLy8gUmVtb3ZlIGVsZW1lbnQgZnJvbSBET01cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9wdXA7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIHN5bWJvbCQ0ID09PSBcInVuZGVmaW5lZFwiIHx8IGdldEl0ZXJhdG9yTWV0aG9kJDEobykgPT0gbnVsbCkgeyBpZiAoaXNBcnJheSQ1KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gZ2V0SXRlcmF0b3IkMShvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDQobywgbWluTGVuKSB7IHZhciBfY29udGV4dDE1OyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNChvLCBtaW5MZW4pOyB2YXIgbiA9IHNsaWNlJDUoX2NvbnRleHQxNSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDE1LCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tXzEkMihvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNChhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbi8qKlxuICogSGFuZGxlciBmb3IgaW50ZXJhY3Rpb25zXG4gKi9cblxudmFyIEludGVyYWN0aW9uSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9uSGFuZGxlcn0gc2VsZWN0aW9uSGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gSW50ZXJhY3Rpb25IYW5kbGVyKGJvZHksIGNhbnZhcywgc2VsZWN0aW9uSGFuZGxlcikge1xuICAgIHZhciBfY29udGV4dCwgX2NvbnRleHQyLCBfY29udGV4dDMsIF9jb250ZXh0NCwgX2NvbnRleHQ1LCBfY29udGV4dDYsIF9jb250ZXh0NywgX2NvbnRleHQ4LCBfY29udGV4dDksIF9jb250ZXh0MTAsIF9jb250ZXh0MTEsIF9jb250ZXh0MTIsIF9jb250ZXh0MTM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmFjdGlvbkhhbmRsZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBzZWxlY3Rpb25IYW5kbGVyO1xuICAgIHRoaXMubmF2aWdhdGlvbkhhbmRsZXIgPSBuZXcgTmF2aWdhdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzKTsgLy8gYmluZCB0aGUgZXZlbnRzIGZyb20gaGFtbWVyIHRvIGZ1bmN0aW9ucyBpbiB0aGlzIG9iamVjdFxuXG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVGFwID0gYmluZCQyKF9jb250ZXh0ID0gdGhpcy5vblRhcCkuY2FsbChfY29udGV4dCwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVG91Y2ggPSBiaW5kJDIoX2NvbnRleHQyID0gdGhpcy5vblRvdWNoKS5jYWxsKF9jb250ZXh0MiwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwID0gYmluZCQyKF9jb250ZXh0MyA9IHRoaXMub25Eb3VibGVUYXApLmNhbGwoX2NvbnRleHQzLCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Ib2xkID0gYmluZCQyKF9jb250ZXh0NCA9IHRoaXMub25Ib2xkKS5jYWxsKF9jb250ZXh0NCwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ1N0YXJ0ID0gYmluZCQyKF9jb250ZXh0NSA9IHRoaXMub25EcmFnU3RhcnQpLmNhbGwoX2NvbnRleHQ1LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnID0gYmluZCQyKF9jb250ZXh0NiA9IHRoaXMub25EcmFnKS5jYWxsKF9jb250ZXh0NiwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ0VuZCA9IGJpbmQkMihfY29udGV4dDcgPSB0aGlzLm9uRHJhZ0VuZCkuY2FsbChfY29udGV4dDcsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwgPSBiaW5kJDIoX2NvbnRleHQ4ID0gdGhpcy5vbk1vdXNlV2hlZWwpLmNhbGwoX2NvbnRleHQ4LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25QaW5jaCA9IGJpbmQkMihfY29udGV4dDkgPSB0aGlzLm9uUGluY2gpLmNhbGwoX2NvbnRleHQ5LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZU1vdmUgPSBiaW5kJDIoX2NvbnRleHQxMCA9IHRoaXMub25Nb3VzZU1vdmUpLmNhbGwoX2NvbnRleHQxMCwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUmVsZWFzZSA9IGJpbmQkMihfY29udGV4dDExID0gdGhpcy5vblJlbGVhc2UpLmNhbGwoX2NvbnRleHQxMSwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dCA9IGJpbmQkMihfY29udGV4dDEyID0gdGhpcy5vbkNvbnRleHQpLmNhbGwoX2NvbnRleHQxMiwgdGhpcyk7XG4gICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgIHRoaXMucGluY2ggPSB7fTtcbiAgICB0aGlzLnBvcHVwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9wdXBPYmogPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3B1cFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlciA9IGJpbmQkMihfY29udGV4dDEzID0gdGhpcy5nZXRQb2ludGVyKS5jYWxsKF9jb250ZXh0MTMsIHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBkcmFnTm9kZXM6IHRydWUsXG4gICAgICBkcmFnVmlldzogdHJ1ZSxcbiAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgIGtleWJvYXJkOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzcGVlZDoge1xuICAgICAgICAgIHg6IDEwLFxuICAgICAgICAgIHk6IDEwLFxuICAgICAgICAgIHpvb206IDAuMDJcbiAgICAgICAgfSxcbiAgICAgICAgYmluZFRvV2luZG93OiB0cnVlXG4gICAgICB9LFxuICAgICAgbmF2aWdhdGlvbkJ1dHRvbnM6IGZhbHNlLFxuICAgICAgdG9vbHRpcERlbGF5OiAzMDAsXG4gICAgICB6b29tVmlldzogdHJ1ZSxcbiAgICAgIHpvb21TcGVlZDogMVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoSW50ZXJhY3Rpb25IYW5kbGVyLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnBvcHVwVGltZXIpO1xuICAgICAgICBkZWxldGUgX3RoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBleHRlbmQgYWxsIGJ1dCB0aGUgdmFsdWVzIGluIGZpZWxkc1xuICAgICAgICB2YXIgZmllbGRzID0gW1wiaGlkZUVkZ2VzT25EcmFnXCIsIFwiaGlkZUVkZ2VzT25ab29tXCIsIFwiaGlkZU5vZGVzT25EcmFnXCIsIFwia2V5Ym9hcmRcIiwgXCJtdWx0aXNlbGVjdFwiLCBcInNlbGVjdGFibGVcIiwgXCJzZWxlY3RDb25uZWN0ZWRFZGdlc1wiXTtcbiAgICAgICAgc2VsZWN0aXZlTm90RGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7IC8vIG1lcmdlIHRoZSBrZXlib2FyZCBvcHRpb25zIGluLlxuXG4gICAgICAgIG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIFwia2V5Ym9hcmRcIik7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcCkge1xuICAgICAgICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucy50b29sdGlwLCBvcHRpb25zLnRvb2x0aXApO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcC5jb2xvcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRvb2x0aXAuY29sb3IgPSBwYXJzZUNvbG9yKG9wdGlvbnMudG9vbHRpcC5jb2xvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmF2aWdhdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvaW50ZXIgbG9jYXRpb24gZnJvbSBhIHRvdWNoIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHRvdWNoXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludGVyKHRvdWNoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0b3VjaC54IC0gZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcyksXG4gICAgICAgIHk6IHRvdWNoLnkgLSBnZXRBYnNvbHV0ZVRvcCh0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiBzdGFydCBvZiBhIHRvdWNoIGdlc3R1cmUsIHN0b3JlIHRoZSBwb2ludGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25Ub3VjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblRvdWNoKGV2ZW50KSB7XG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDUwKSB7XG4gICAgICAgIHRoaXMuZHJhZy5wb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuZHJhZy5waW5jaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGluY2guc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTsgLy8gdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBldmVudCBiZWNhdXNlIHdlIGhhdmUgdHdvIGhhbW1lciBpbnN0YW5jZXMuIChvbiBjYW52YXMgYW5kIG9uIGZyYW1lKVxuXG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSB0YXAvY2xpY2sgZXZlbnQ6IHNlbGVjdC91bnNlbGVjdCBhIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uVGFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVGFwKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIG11bHRpc2VsZWN0ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMubXVsdGlzZWxlY3QgJiYgKGV2ZW50LmNoYW5nZWRQb2ludGVyc1swXS5jdHJsS2V5IHx8IGV2ZW50LmNoYW5nZWRQb2ludGVyc1swXS5tZXRhS2V5KTtcbiAgICAgIHRoaXMuY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIsIG11bHRpc2VsZWN0KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KHBvaW50ZXIsIGV2ZW50KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjbGlja1wiLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBkb3VibGV0YXAgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uRG91YmxlVGFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRG91YmxlVGFwKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRvdWJsZUNsaWNrXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlIGxvbmcgdGFwIGV2ZW50OiBtdWx0aSBzZWxlY3Qgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uSG9sZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkhvbGQoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgbXVsdGlzZWxlY3QgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucy5tdWx0aXNlbGVjdDtcbiAgICAgIHRoaXMuY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIsIG11bHRpc2VsZWN0KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KHBvaW50ZXIsIGV2ZW50KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjbGlja1wiLCBldmVudCwgcG9pbnRlcik7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiaG9sZFwiLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSB0aGUgcmVsZWFzZSBvZiB0aGUgc2NyZWVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblJlbGVhc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25SZWxlYXNlKGV2ZW50KSB7XG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDEwKSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJyZWxlYXNlXCIsIGV2ZW50LCBwb2ludGVyKTsgLy8gdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBldmVudCBiZWNhdXNlIHdlIGhhdmUgdHdvIGhhbW1lciBpbnN0YW5jZXMuIChvbiBjYW52YXMgYW5kIG9uIGZyYW1lKVxuXG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNvbnRleHQoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwib25jb250ZXh0XCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGFuZCBkZXNlbGVjdCBub2RlcyBkZXBlbmRpbmcgY3VycmVudCBzZWxlY3Rpb24gY2hhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWRkPWZhbHNlXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tTZWxlY3Rpb25DaGFuZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrU2VsZWN0aW9uQ2hhbmdlcyhwb2ludGVyKSB7XG4gICAgICB2YXIgYWRkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgaWYgKGFkZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQocG9pbnRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T25Qb2ludChwb2ludGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBub2RlIGFuZCBlZGdlIGlkJ3MgZnJvbSB0aGUgZmlyc3Qgc2V0IHRoYXQgYXJlIHByZXNlbnQgaW4gdGhlIHNlY29uZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3tub2RlczogQXJyYXkuPE5vZGU+LCBlZGdlczogQXJyYXkuPHZpcy5FZGdlPn19IGZpcnN0U2V0XG4gICAgICogQHBhcmFtIHt7bm9kZXM6IEFycmF5LjxOb2RlPiwgZWRnZXM6IEFycmF5Ljx2aXMuRWRnZT59fSBzZWNvbmRTZXRcbiAgICAgKiBAcmV0dXJucyB7e25vZGVzOiBBcnJheS48Tm9kZT4sIGVkZ2VzOiBBcnJheS48dmlzLkVkZ2U+fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZURpZmZlcmVuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZURpZmZlcmVuY2UoZmlyc3RTZXQsIHNlY29uZFNldCkge1xuICAgICAgdmFyIGFycmF5RGlmZiA9IGZ1bmN0aW9uIGFycmF5RGlmZihmaXJzdEFyciwgc2Vjb25kQXJyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmlyc3RBcnJbaV07XG5cbiAgICAgICAgICBpZiAoaW5kZXhPZiQzKHNlY29uZEFycikuY2FsbChzZWNvbmRBcnIsIHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IGFycmF5RGlmZihmaXJzdFNldC5ub2Rlcywgc2Vjb25kU2V0Lm5vZGVzKSxcbiAgICAgICAgZWRnZXM6IGFycmF5RGlmZihmaXJzdFNldC5lZGdlcywgc2Vjb25kU2V0LmVkZ2VzKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgb25EcmFnU3RhcnQuXG4gICAgICogSXQgaXMgc2VwYXJhdGVkIG91dCBiZWNhdXNlIHdlIGNhbiB0aGVuIG92ZXJsb2FkIGl0IGZvciB0aGUgZGF0YW1hbmlwdWxhdGlvbiBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkRyYWdTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCkge1xuICAgICAgLy8gaWYgYWxyZWFkeSBkcmFnZ2luZywgZG8gbm90IHN0YXJ0XG4gICAgICAvLyB0aGlzIGNhbiBoYXBwZW4gb24gdG91Y2ggc2NyZWVucyB3aXRoIG11bHRpcGxlIGZpbmdlcnNcbiAgICAgIGlmICh0aGlzLmRyYWcuZHJhZ2dpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvL2luIGNhc2UgdGhlIHRvdWNoIGV2ZW50IHdhcyB0cmlnZ2VyZWQgb24gYW4gZXh0ZXJuYWwgZGl2LCBkbyB0aGUgaW5pdGlhbCB0b3VjaCBub3cuXG5cblxuICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5vblRvdWNoKGV2ZW50KTtcbiAgICAgIH0gLy8gbm90ZTogZHJhZy5wb2ludGVyIGlzIHNldCBpbiBvblRvdWNoIHRvIGdldCB0aGUgaW5pdGlhbCB0b3VjaCBsb2NhdGlvblxuXG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdCh0aGlzLmRyYWcucG9pbnRlcik7XG4gICAgICB0aGlzLmRyYWcuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5kcmFnLnNlbGVjdGlvbiA9IFtdO1xuICAgICAgdGhpcy5kcmFnLnRyYW5zbGF0aW9uID0gYXNzaWduJDIoe30sIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKTsgLy8gY29weSB0aGUgb2JqZWN0XG5cbiAgICAgIHRoaXMuZHJhZy5ub2RlSWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChldmVudC5zcmNFdmVudC5zaGlmdEtleSkge1xuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3cgPSB0cnVlO1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0ID0ge1xuICAgICAgICAgIHg6IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCksXG4gICAgICAgICAgeTogdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZCA9IHtcbiAgICAgICAgICB4OiB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpLFxuICAgICAgICAgIHk6IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZHJhZy5ub2RlSWQgPSBub2RlLmlkOyAvLyBzZWxlY3QgdGhlIGNsaWNrZWQgbm9kZSBpZiBub3QgeWV0IHNlbGVjdGVkXG5cbiAgICAgICAgaWYgKG5vZGUuaXNTZWxlY3RlZCgpID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3Qobm9kZSk7XG4gICAgICAgIH0gLy8gYWZ0ZXIgc2VsZWN0IHRvIGNvbnRhaW4gdGhlIG5vZGVcblxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnU3RhcnRcIiwgZXZlbnQsIHRoaXMuZHJhZy5wb2ludGVyKTsgLy8gY3JlYXRlIGFuIGFycmF5IHdpdGggdGhlIHNlbGVjdGVkIG5vZGVzIGFuZCB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbiBhbmQgc3RhdHVzXG5cbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDModGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZXMoKSksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX25vZGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBzID0ge1xuICAgICAgICAgICAgICBpZDogX25vZGUuaWQsXG4gICAgICAgICAgICAgIG5vZGU6IF9ub2RlLFxuICAgICAgICAgICAgICAvLyBzdG9yZSBvcmlnaW5hbCB4LCB5LCB4Rml4ZWQgYW5kIHlGaXhlZCwgbWFrZSB0aGUgbm9kZSB0ZW1wb3JhcmlseSBGaXhlZFxuICAgICAgICAgICAgICB4OiBfbm9kZS54LFxuICAgICAgICAgICAgICB5OiBfbm9kZS55LFxuICAgICAgICAgICAgICB4Rml4ZWQ6IF9ub2RlLm9wdGlvbnMuZml4ZWQueCxcbiAgICAgICAgICAgICAgeUZpeGVkOiBfbm9kZS5vcHRpb25zLmZpeGVkLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfbm9kZS5vcHRpb25zLmZpeGVkLnggPSB0cnVlO1xuICAgICAgICAgICAgX25vZGUub3B0aW9ucy5maXhlZC55ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZy5zZWxlY3Rpb24ucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgaWYgbm8gbm9kZSBpcyBzZWxlY3RlZCBhbmQgdGh1cyB0aGUgdmlldyBpcyBkcmFnZ2VkLlxuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ1N0YXJ0XCIsIGV2ZW50LCB0aGlzLmRyYWcucG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlIGRyYWcgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uRHJhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWcoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5kcmFnLnBpbmNoZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyByZW1vdmUgdGhlIGZvY3VzIG9uIG5vZGUgaWYgaXQgaXMgZm9jdXNzZWQgb24gYnkgdGhlIGZvY3VzT25Ob2RlXG5cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInVubG9ja05vZGVcIik7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZHJhZy5zZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuZHJhZ05vZGVzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnZ2luZ1wiLCBldmVudCwgcG9pbnRlcik7IC8vIGNhbGN1bGF0ZSBkZWx0YSdzIGFuZCBuZXcgbG9jYXRpb25cblxuICAgICAgICB2YXIgZGVsdGFYID0gcG9pbnRlci54IC0gdGhpcy5kcmFnLnBvaW50ZXIueDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IHBvaW50ZXIueSAtIHRoaXMuZHJhZy5wb2ludGVyLnk7IC8vIHVwZGF0ZSBwb3NpdGlvbiBvZiBhbGwgc2VsZWN0ZWQgbm9kZXNcblxuICAgICAgICBmb3JFYWNoJDIoc2VsZWN0aW9uKS5jYWxsKHNlbGVjdGlvbiwgZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBub2RlID0gc2VsZWN0aW9uLm5vZGU7IC8vIG9ubHkgbW92ZSB0aGUgbm9kZSBpZiBpdCB3YXMgbm90IGZpeGVkIGluaXRpYWxseVxuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbi54Rml4ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnggPSBfdGhpczIuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKF90aGlzMi5jYW52YXMuX1hjb252ZXJ0Q2FudmFzVG9ET00oc2VsZWN0aW9uLngpICsgZGVsdGFYKTtcbiAgICAgICAgICB9IC8vIG9ubHkgbW92ZSB0aGUgbm9kZSBpZiBpdCB3YXMgbm90IGZpeGVkIGluaXRpYWxseVxuXG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uLnlGaXhlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IF90aGlzMi5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMoX3RoaXMyLmNhbnZhcy5fWWNvbnZlcnRDYW52YXNUb0RPTShzZWxlY3Rpb24ueSkgKyBkZWx0YVkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIHN0YXJ0IHRoZSBzaW11bGF0aW9uIG9mIHRoZSBwaHlzaWNzXG5cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdGlvbiBib3hcbiAgICAgICAgaWYgKGV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdnaW5nXCIsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpOyAvLyBpZiB0aGUgZHJhZyB3YXMgbm90IHN0YXJ0ZWQgcHJvcGVybHkgYmVjYXVzZSB0aGUgY2xpY2sgc3RhcnRlZCBvdXRzaWRlIHRoZSBuZXR3b3JrIGRpdiwgc3RhcnQgaXQgbm93LlxuXG4gICAgICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25EcmFnU3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kID0ge1xuICAgICAgICAgICAgeDogdGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci54KSxcbiAgICAgICAgICAgIHk6IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfSAvLyBtb3ZlIHRoZSBuZXR3b3JrXG5cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyYWdWaWV3ID09PSB0cnVlICYmICFldmVudC5zcmNFdmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnZ2luZ1wiLCBldmVudCwgcG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTsgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cblxuICAgICAgICAgIGlmICh0aGlzLmRyYWcucG9pbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGlmZlggPSBwb2ludGVyLnggLSB0aGlzLmRyYWcucG9pbnRlci54O1xuICAgICAgICAgIHZhciBkaWZmWSA9IHBvaW50ZXIueSAtIHRoaXMuZHJhZy5wb2ludGVyLnk7XG4gICAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgICB4OiB0aGlzLmRyYWcudHJhbnNsYXRpb24ueCArIGRpZmZYLFxuICAgICAgICAgICAgeTogdGhpcy5kcmFnLnRyYW5zbGF0aW9uLnkgKyBkaWZmWVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBkcmFnIHN0YXJ0IGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkRyYWdFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5kcmFnLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3cpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MTQ7XG5cbiAgICAgICAgdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5zaG93ID0gZmFsc2U7XG4gICAgICAgIHZhciBzZWxlY3Rpb25Cb3hQb3NpdGlvbiA9IHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb247XG4gICAgICAgIHZhciBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heCA9IHtcbiAgICAgICAgICBtaW5YOiBNYXRoLm1pbihzZWxlY3Rpb25Cb3hQb3NpdGlvbi5zdGFydC54LCBzZWxlY3Rpb25Cb3hQb3NpdGlvbi5lbmQueCksXG4gICAgICAgICAgbWluWTogTWF0aC5taW4oc2VsZWN0aW9uQm94UG9zaXRpb24uc3RhcnQueSwgc2VsZWN0aW9uQm94UG9zaXRpb24uZW5kLnkpLFxuICAgICAgICAgIG1heFg6IE1hdGgubWF4KHNlbGVjdGlvbkJveFBvc2l0aW9uLnN0YXJ0LngsIHNlbGVjdGlvbkJveFBvc2l0aW9uLmVuZC54KSxcbiAgICAgICAgICBtYXhZOiBNYXRoLm1heChzZWxlY3Rpb25Cb3hQb3NpdGlvbi5zdGFydC55LCBzZWxlY3Rpb25Cb3hQb3NpdGlvbi5lbmQueSlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9CZVNlbGVjdGVkTm9kZXMgPSBmaWx0ZXIkMihfY29udGV4dDE0ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKF9jb250ZXh0MTQsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgcmV0dXJuIG5vZGUueCA+PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5taW5YICYmIG5vZGUueCA8PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5tYXhYICYmIG5vZGUueSA+PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5taW5ZICYmIG5vZGUueSA8PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5tYXhZO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3JFYWNoJDIodG9CZVNlbGVjdGVkTm9kZXMpLmNhbGwodG9CZVNlbGVjdGVkTm9kZXMsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0T2JqZWN0KF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuY29tbWl0QW5kRW1pdChwb2ludGVyLCBldmVudCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnRW5kXCIsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZHJhZy5zZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yRWFjaCQyKHNlbGVjdGlvbikuY2FsbChzZWxlY3Rpb24sIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHhGaXhlZCBhbmQgeUZpeGVkXG4gICAgICAgICAgICBzLm5vZGUub3B0aW9ucy5maXhlZC54ID0gcy54Rml4ZWQ7XG4gICAgICAgICAgICBzLm5vZGUub3B0aW9ucy5maXhlZC55ID0gcy55Rml4ZWQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZHJhZ0VuZFwiLCBldmVudCwgdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcikpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdFbmRcIiwgZXZlbnQsIHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGluY2ggZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblBpbmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGluY2goZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB0aGlzLmRyYWcucGluY2hlZCA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLnBpbmNoW1wic2NhbGVcIl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBpbmNoLnNjYWxlID0gMTtcbiAgICAgIH0gLy8gVE9ETzogZW5hYmxlZCBtb3Zpbmcgd2hpbGUgcGluY2hpbmc/XG5cblxuICAgICAgdmFyIHNjYWxlID0gdGhpcy5waW5jaC5zY2FsZSAqIGV2ZW50LnNjYWxlO1xuICAgICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogWm9vbSB0aGUgbmV0d29yayBpbiBvciBvdXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBhIG51bWJlciBhcm91bmQgMSwgYW5kIGJldHdlZW4gMC4wMSBhbmQgMTBcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgICAgUG9zaXRpb24gb24gc2NyZWVuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbShzY2FsZSwgcG9pbnRlcikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy56b29tVmlldyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgc2NhbGVPbGQgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcblxuICAgICAgICBpZiAoc2NhbGUgPCAwLjAwMDAxKSB7XG4gICAgICAgICAgc2NhbGUgPSAwLjAwMDAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYWxlID4gMTApIHtcbiAgICAgICAgICBzY2FsZSA9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZVNjYWxlRHJhZ1BvaW50ZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuZHJhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZy5kcmFnZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcHJlU2NhbGVEcmFnUG9pbnRlciA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHRoaXMuZHJhZy5wb2ludGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gKyB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0IC8gMlxuXG5cbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb247XG4gICAgICAgIHZhciBzY2FsZUZyYWMgPSBzY2FsZSAvIHNjYWxlT2xkO1xuICAgICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiBwb2ludGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgICB2YXIgdHkgPSAoMSAtIHNjYWxlRnJhYykgKiBwb2ludGVyLnkgKyB0cmFuc2xhdGlvbi55ICogc2NhbGVGcmFjO1xuICAgICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IHNjYWxlO1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICB4OiB0eCxcbiAgICAgICAgICB5OiB0eVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwcmVTY2FsZURyYWdQb2ludGVyICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwb3N0U2NhbGVEcmFnUG9pbnRlciA9IHRoaXMuY2FudmFzLmNhbnZhc1RvRE9NKHByZVNjYWxlRHJhZ1BvaW50ZXIpO1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnggPSBwb3N0U2NhbGVEcmFnUG9pbnRlci54O1xuICAgICAgICAgIHRoaXMuZHJhZy5wb2ludGVyLnkgPSBwb3N0U2NhbGVEcmFnUG9pbnRlci55O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuXG4gICAgICAgIGlmIChzY2FsZU9sZCA8IHNjYWxlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInpvb21cIiwge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBcIitcIixcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSxcbiAgICAgICAgICAgIHBvaW50ZXI6IHBvaW50ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiem9vbVwiLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IFwiLVwiLFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuYm9keS52aWV3LnNjYWxlLFxuICAgICAgICAgICAgcG9pbnRlcjogcG9pbnRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlIHdoZWVsIGV2ZW50LCB1c2VkIHRvIHpvb20gdGhlIHRpbWVsaW5lXG4gICAgICogU2VlIGh0dHA6Ly9hZG9tYXMub3JnL2phdmFzY3JpcHQtbW91c2Utd2hlZWwvXG4gICAgICogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9FaWdodE1lZGlhL2hhbW1lci5qcy9pc3N1ZXMvMjU2XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9ICBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbk1vdXNlV2hlZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnpvb21WaWV3ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIElmIGRlbHRhIGlzIG5vbnplcm8sIGhhbmRsZSBpdC5cbiAgICAgICAgLy8gQmFzaWNhbGx5LCBkZWx0YSBpcyBub3cgcG9zaXRpdmUgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIHVwLFxuICAgICAgICAvLyBhbmQgbmVnYXRpdmUsIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCBkb3duLlxuICAgICAgICBpZiAoZXZlbnQuZGVsdGFZICE9PSAwKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBuZXcgc2NhbGVcbiAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgICBzY2FsZSAqPSAxICsgKGV2ZW50LmRlbHRhWSA8IDAgPyAxIDogLTEpICogKHRoaXMub3B0aW9ucy56b29tU3BlZWQgKiAwLjEpOyAvLyBjYWxjdWxhdGUgdGhlIHBvaW50ZXIgbG9jYXRpb25cblxuICAgICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHtcbiAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICAgICAgfSk7IC8vIGFwcGx5IHRoZSBuZXcgc2NhbGVcblxuICAgICAgICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlcik7XG4gICAgICAgIH0gLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvbnMgY2F1c2VkIGJ5IG1vdXNlIHdoZWVsLlxuXG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW91c2UgbW92ZSBoYW5kbGVyIGZvciBjaGVja2luZyB3aGV0aGVyIHRoZSB0aXRsZSBtb3ZlcyBvdmVyIGEgbm9kZSB3aXRoIGEgdGl0bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZU1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcih7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvcHVwVmlzaWJsZSA9IGZhbHNlOyAvLyBjaGVjayBpZiB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCBub2RlIGlzIHN0aWxsIHNlbGVjdGVkXG5cbiAgICAgIGlmICh0aGlzLnBvcHVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2NoZWNrSGlkZVBvcHVwKHBvaW50ZXIpO1xuICAgICAgICB9IC8vIGlmIHRoZSBwb3B1cCB3YXMgbm90IGhpZGRlbiBhYm92ZVxuXG5cbiAgICAgICAgaWYgKHRoaXMucG9wdXAuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHBvcHVwVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRQb3NpdGlvbihwb2ludGVyLnggKyAzLCBwb2ludGVyLnkgLSA1KTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiB3ZSBiaW5kIHRoZSBrZXlib2FyZCB0byB0aGUgZGl2LCB3ZSBoYXZlIHRvIGhpZ2hsaWdodCBpdCB0byB1c2UgaXQuIFRoaXMgaGlnaGxpZ2h0cyBpdCBvbiBtb3VzZSBvdmVyLlxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuYmluZFRvV2luZG93ID09PSBmYWxzZSAmJiB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5mb2N1cygpO1xuICAgICAgfSAvLyBzdGFydCBhIHRpbWVvdXQgdGhhdCB3aWxsIGNoZWNrIGlmIHRoZSBtb3VzZSBpcyBwb3NpdGlvbmVkIGFib3ZlIGFuIGVsZW1lbnRcblxuXG4gICAgICBpZiAocG9wdXBWaXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cFRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucG9wdXBUaW1lcik7IC8vIHN0b3AgYW55IHJ1bm5pbmcgY2FsY3VsYXRpb25UaW1lclxuXG4gICAgICAgICAgdGhpcy5wb3B1cFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmRyYWcuZHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLnBvcHVwVGltZXIgPSBzZXRUaW1lb3V0JDIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5fY2hlY2tTaG93UG9wdXAocG9pbnRlcik7XG4gICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnRvb2x0aXBEZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gYWRkaW5nIGhvdmVyIGhpZ2hsaWdodHNcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5ob3Zlck9iamVjdChldmVudCwgcG9pbnRlcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGFuIGVsZW1lbnQgb24gdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBuZXR3b3JrXG4gICAgICogKGEgbm9kZSBvciBlZGdlKS4gSWYgc28sIGFuZCBpZiB0aGlzIGVsZW1lbnQgaGFzIGEgdGl0bGUsXG4gICAgICogc2hvdyBhIHBvcHVwIHdpbmRvdyB3aXRoIGl0cyB0aXRsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLCB5Om51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrU2hvd1BvcHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1Nob3dQb3B1cChwb2ludGVyKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG5cbiAgICAgIHZhciB5ID0gdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KTtcblxuICAgICAgdmFyIHBvaW50ZXJPYmogPSB7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgcmlnaHQ6IHgsXG4gICAgICAgIGJvdHRvbTogeVxuICAgICAgfTtcbiAgICAgIHZhciBwcmV2aW91c1BvcHVwT2JqSWQgPSB0aGlzLnBvcHVwT2JqID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLnBvcHVwT2JqLmlkO1xuICAgICAgdmFyIG5vZGVVbmRlckN1cnNvciA9IGZhbHNlO1xuICAgICAgdmFyIHBvcHVwVHlwZSA9IFwibm9kZVwiOyAvLyBjaGVjayBpZiBhIG5vZGUgaXMgdW5kZXIgdGhlIGN1cnNvci5cblxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZWFyY2ggdGhlIG5vZGVzIGZvciBvdmVybGFwLCBzZWxlY3QgdGhlIHRvcCBvbmUgaW4gY2FzZSBvZiBtdWx0aXBsZSBub2Rlc1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG5cbiAgICAgICAgICBpZiAobm9kZS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZVVuZGVyQ3Vyc29yID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKG5vZGUuZ2V0VGl0bGUoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG92ZXJsYXBwaW5nTm9kZXMucHVzaChub2RlSW5kaWNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdmVybGFwcGluZyBub2Rlcywgc2VsZWN0IHRoZSBsYXN0IG9uZSwgdGhpcyBpcyB0aGUgb25lIHdoaWNoIGlzIGRyYXduIG9uIHRvcCBvZiB0aGUgb3RoZXJzXG4gICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IG5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07IC8vIGlmIHlvdSBob3ZlciBvdmVyIGEgbm9kZSwgdGhlIHRpdGxlIG9mIHRoZSBlZGdlIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBzaG93bi5cblxuICAgICAgICAgIG5vZGVVbmRlckN1cnNvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCAmJiBub2RlVW5kZXJDdXJzb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHNlYXJjaCB0aGUgZWRnZXMgZm9yIG92ZXJsYXBcbiAgICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICAgIHZhciBlZGdlO1xuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcblxuICAgICAgICAgIGlmIChlZGdlLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUgJiYgZWRnZS5nZXRUaXRsZSgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdFZGdlcy5wdXNoKGVkZ2VJbmRpY2VzW19pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJsYXBwaW5nRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucG9wdXBPYmogPSBlZGdlc1tvdmVybGFwcGluZ0VkZ2VzW292ZXJsYXBwaW5nRWRnZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICAgIHBvcHVwVHlwZSA9IFwiZWRnZVwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBvcHVwT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2hvdyBwb3B1cCBtZXNzYWdlIHdpbmRvd1xuICAgICAgICBpZiAodGhpcy5wb3B1cE9iai5pZCAhPT0gcHJldmlvdXNQb3B1cE9iaklkKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9wdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cCA9IG5ldyBQb3B1cCh0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPSBwb3B1cFR5cGU7XG4gICAgICAgICAgdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkID0gdGhpcy5wb3B1cE9iai5pZDsgLy8gYWRqdXN0IGEgc21hbGwgb2Zmc2V0IHN1Y2ggdGhhdCB0aGUgbW91c2UgY3Vyc29yIGlzIGxvY2F0ZWQgaW4gdGhlXG4gICAgICAgICAgLy8gYm90dG9tIGxlZnQgbG9jYXRpb24gb2YgdGhlIHBvcHVwLCBhbmQgeW91IGNhbiBlYXNpbHkgbW92ZSBvdmVyIHRoZVxuICAgICAgICAgIC8vIHBvcHVwIGFyZWFcblxuICAgICAgICAgIHRoaXMucG9wdXAuc2V0UG9zaXRpb24ocG9pbnRlci54ICsgMywgcG9pbnRlci55IC0gNSk7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRUZXh0KHRoaXMucG9wdXBPYmouZ2V0VGl0bGUoKSk7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zaG93KCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInNob3dQb3B1cFwiLCB0aGlzLnBvcHVwT2JqLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJoaWRlUG9wdXBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHBvcHVwIG11c3QgYmUgaGlkZGVuLCB3aGljaCBpcyB0aGUgY2FzZSB3aGVuIHRoZSBtb3VzZSBpcyBub1xuICAgICAqIGxvbmdlciBob3ZlcmluZyBvbiB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4Om51bWJlciwgeTpudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja0hpZGVQb3B1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tIaWRlUG9wdXAocG9pbnRlcikge1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuXG4gICAgICB2YXIgc3RpbGxPbk9iaiA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5wb3B1cC5wb3B1cFRhcmdldFR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RpbGxPbk9iaiA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopOyAvLyBpZiB0aGUgbW91c2UgaXMgc3RpbGwgb25lIHRoZSBub2RlLCB3ZSBoYXZlIHRvIGNoZWNrIGlmIGl0IGlzIG5vdCBhbHNvIG9uIG9uZSB0aGF0IGlzIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAvLyB3ZSBpbml0aWFsbHkgb25seSBjaGVjayBzdGlsbE9uT2JqIGJlY2F1c2UgdGhpcyBpcyBtdWNoIGZhc3Rlci5cblxuICAgICAgICAgIGlmIChzdGlsbE9uT2JqID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgb3Zlck5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuICAgICAgICAgICAgc3RpbGxPbk9iaiA9IG92ZXJOb2RlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG92ZXJOb2RlLmlkID09PSB0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0aWxsT25PYmogPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0aWxsT25PYmogPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucG9wdXBPYmogPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaGlkZVBvcHVwXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnRlcmFjdGlvbkhhbmRsZXI7XG59KCk7XG5cbnZhciBnZXRXZWFrRGF0YSA9IGludGVybmFsTWV0YWRhdGEuZ2V0V2Vha0RhdGE7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQ1ID0gaW50ZXJuYWxTdGF0ZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciQyID0gaW50ZXJuYWxTdGF0ZS5nZXR0ZXJGb3I7XG52YXIgZmluZCA9IGFycmF5SXRlcmF0aW9uLmZpbmQ7XG52YXIgZmluZEluZGV4ID0gYXJyYXlJdGVyYXRpb24uZmluZEluZGV4O1xudmFyIGlkJDEgPSAwOyAvLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcblxudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgcmV0dXJuIHN0b3JlLmZyb3plbiB8fCAoc3RvcmUuZnJvemVuID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xuXG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbnRyaWVzID0gW107XG59O1xuXG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGZpbmQoc3RvcmUuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblxuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtlbHNlIHRoaXMuZW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4KHRoaXMuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSB0aGlzLmVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG52YXIgY29sbGVjdGlvbldlYWsgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlJDUodGhhdCwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBpZDogaWQkMSsrLFxuICAgICAgICBmcm96ZW46IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwge1xuICAgICAgICB0aGF0OiB0aGF0LFxuICAgICAgICBBU19FTlRSSUVTOiBJU19NQVBcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvciQyKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5zZXQoa2V5LCB2YWx1ZSk7ZWxzZSBkYXRhW3N0YXRlLmlkXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgaGFzKGRhdGEsIHN0YXRlLmlkKSAmJiBkZWxldGUgZGF0YVtzdGF0ZS5pZF07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzJDEoa2V5KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmIGhhcyhkYXRhLCBzdGF0ZS5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIElTX01BUCA/IHtcbiAgICAgIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcblxuICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmdldChrZXkpO1xuICAgICAgICAgIHJldHVybiBkYXRhID8gZGF0YVtzdGF0ZS5pZF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH1cbn07XG5cbnZhciBlc193ZWFrTWFwID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gIHZhciBlbmZvcmNlSXRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZS5lbmZvcmNlO1xuICB2YXIgSVNfSUUxMSA9ICFnbG9iYWxfMS5BY3RpdmVYT2JqZWN0ICYmICdBY3RpdmVYT2JqZWN0JyBpbiBnbG9iYWxfMTtcbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG4gIHZhciBJbnRlcm5hbFdlYWtNYXA7XG5cbiAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoaW5pdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgICAgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgfTsgLy8gYFdlYWtNYXBgIGNvbnN0cnVjdG9yXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdlYWttYXAtY29uc3RydWN0b3JcblxuXG4gIHZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gY29sbGVjdGlvbignV2Vha01hcCcsIHdyYXBwZXIsIGNvbGxlY3Rpb25XZWFrKTsgLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuICAvLyBXZSBjYW4ndCB1c2UgZmVhdHVyZSBkZXRlY3Rpb24gYmVjYXVzZSBpdCBjcmFzaCBzb21lIG9sZCBJRSBidWlsZHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ4NVxuXG4gIGlmIChuYXRpdmVXZWFrTWFwICYmIElTX0lFMTEpIHtcbiAgICBJbnRlcm5hbFdlYWtNYXAgPSBjb2xsZWN0aW9uV2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCAnV2Vha01hcCcsIHRydWUpO1xuICAgIGludGVybmFsTWV0YWRhdGEuUkVRVUlSRUQgPSB0cnVlO1xuICAgIHZhciBXZWFrTWFwUHJvdG90eXBlID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBuYXRpdmVEZWxldGUgPSBXZWFrTWFwUHJvdG90eXBlWydkZWxldGUnXTtcbiAgICB2YXIgbmF0aXZlSGFzID0gV2Vha01hcFByb3RvdHlwZS5oYXM7XG4gICAgdmFyIG5hdGl2ZUdldCA9IFdlYWtNYXBQcm90b3R5cGUuZ2V0O1xuICAgIHZhciBuYXRpdmVTZXQgPSBXZWFrTWFwUHJvdG90eXBlLnNldDtcbiAgICByZWRlZmluZUFsbChXZWFrTWFwUHJvdG90eXBlLCB7XG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSXRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZURlbGV0ZS5jYWxsKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuWydkZWxldGUnXShrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZURlbGV0ZS5jYWxsKHRoaXMsIGtleSk7XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJdGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlSGFzLmNhbGwodGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW4uaGFzKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmF0aXZlSGFzLmNhbGwodGhpcywga2V5KTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUl0ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICAgIHJldHVybiBuYXRpdmVIYXMuY2FsbCh0aGlzLCBrZXkpID8gbmF0aXZlR2V0LmNhbGwodGhpcywga2V5KSA6IHN0YXRlLmZyb3plbi5nZXQoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYXRpdmVHZXQuY2FsbCh0aGlzLCBrZXkpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUl0ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICAgIG5hdGl2ZUhhcy5jYWxsKHRoaXMsIGtleSkgPyBuYXRpdmVTZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKSA6IHN0YXRlLmZyb3plbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBuYXRpdmVTZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSk7XG5cbnZhciB3ZWFrTWFwID0gcGF0aC5XZWFrTWFwO1xuXG52YXIgd2Vha01hcCQxID0gd2Vha01hcDtcblxudmFyIHdlYWtNYXAkMiA9IHdlYWtNYXAkMTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2V0LW9iamVjdHNcblxuXG52YXIgZXNfc2V0ID0gY29sbGVjdGlvbignU2V0JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn0sIGNvbGxlY3Rpb25TdHJvbmcpO1xuXG52YXIgc2V0JDEgPSBwYXRoLlNldDtcblxudmFyIHNldCQyID0gc2V0JDE7XG5cbnZhciBzZXQkMyA9IHNldCQyO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xuICB9XG5cbiAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcbn1cbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG4gIH1cblxuICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIHN5bWJvbCQ0ID09PSBcInVuZGVmaW5lZFwiIHx8IGdldEl0ZXJhdG9yTWV0aG9kJDEobykgPT0gbnVsbCkgeyBpZiAoaXNBcnJheSQ1KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gZ2V0SXRlcmF0b3IkMShvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUobywgbWluTGVuKSB7IHZhciBfY29udGV4dDI7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UkNShfY29udGV4dDIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQyLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tXzEkMihvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIF9wcmV2aW91c1NlbGVjdGlvbiwgX3NlbGVjdGlvbiwgX25vZGVzLCBfZWRnZXMsIF9jb21taXRIYW5kbGVyO1xuLyoqXHJcbiAqIEBwYXJhbSBwcmV2XHJcbiAqIEBwYXJhbSBuZXh0XHJcbiAqL1xuXG5mdW5jdGlvbiBkaWZmU2V0cyhwcmV2LCBuZXh0KSB7XG4gIHZhciBkaWZmID0gbmV3IHNldCQzKCk7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQobmV4dCksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIXByZXYuaGFzKGl0ZW0pKSB7XG4gICAgICAgIGRpZmYuYWRkKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIGRpZmY7XG59XG5cbnZhciBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yKTtcblxuICAgIF9wcmV2aW91c1NlbGVjdGlvbi5zZXQodGhpcywgbmV3IHNldCQzKCkpO1xuXG4gICAgX3NlbGVjdGlvbi5zZXQodGhpcywgbmV3IHNldCQzKCkpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yLCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBpdGVtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfaXRlbXMgPSBpdGVtczsgX2kgPCBfaXRlbXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gX2l0ZW1zW19pXTtcblxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9zZWxlY3Rpb24pLmFkZChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGl0ZW1zW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9pdGVtczIgPSBpdGVtczsgX2kyIDwgX2l0ZW1zMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBpdGVtID0gX2l0ZW1zMltfaTJdO1xuXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3NlbGVjdGlvbikuZGVsZXRlKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3NlbGVjdGlvbikuY2xlYXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiB0b0NvbnN1bWFibGVBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9zZWxlY3Rpb24pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2hhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGFuZ2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkZWQ6IHRvQ29uc3VtYWJsZUFycmF5KGRpZmZTZXRzKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3ByZXZpb3VzU2VsZWN0aW9uKSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfc2VsZWN0aW9uKSkpLFxuICAgICAgICBkZWxldGVkOiB0b0NvbnN1bWFibGVBcnJheShkaWZmU2V0cyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9zZWxlY3Rpb24pLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9wcmV2aW91c1NlbGVjdGlvbikpKSxcbiAgICAgICAgcHJldmlvdXM6IHRvQ29uc3VtYWJsZUFycmF5KG5ldyBzZXQkMyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9wcmV2aW91c1NlbGVjdGlvbikpKSxcbiAgICAgICAgY3VycmVudDogdG9Db25zdW1hYmxlQXJyYXkobmV3IHNldCQzKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3NlbGVjdGlvbikpKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdCgpIHtcbiAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5nZXRDaGFuZ2VzKCk7XG5cbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX3ByZXZpb3VzU2VsZWN0aW9uLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9zZWxlY3Rpb24pKTtcblxuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfc2VsZWN0aW9uLCBuZXcgc2V0JDMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfcHJldmlvdXNTZWxlY3Rpb24pKSk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChjaGFuZ2VzLmFkZGVkKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgaXRlbS5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChjaGFuZ2VzLmRlbGV0ZWQpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX2l0ZW0gPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICBfaXRlbS51bnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9zZWxlY3Rpb24pLnNpemU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcjtcbn0oKTtcblxuX3ByZXZpb3VzU2VsZWN0aW9uID0gbmV3IHdlYWtNYXAkMigpLCBfc2VsZWN0aW9uID0gbmV3IHdlYWtNYXAkMigpO1xudmFyIFNlbGVjdGlvbkFjY3VtdWxhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VsZWN0aW9uQWNjdW11bGF0b3IoKSB7XG4gICAgdmFyIGNvbW1pdEhhbmRsZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uQWNjdW11bGF0b3IpO1xuXG4gICAgX25vZGVzLnNldCh0aGlzLCBuZXcgU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yKCkpO1xuXG4gICAgX2VkZ2VzLnNldCh0aGlzLCBuZXcgU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yKCkpO1xuXG4gICAgX2NvbW1pdEhhbmRsZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG5cbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9jb21taXRIYW5kbGVyLCBjb21taXRIYW5kbGVyKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFNlbGVjdGlvbkFjY3VtdWxhdG9yLCBbe1xuICAgIGtleTogXCJnZXROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlcygpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ub2RlcykuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VzKCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2VkZ2VzKS5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZXMoKSB7XG4gICAgICB2YXIgX2NsYXNzUHJpdmF0ZUZpZWxkR2U7XG5cbiAgICAgIChfY2xhc3NQcml2YXRlRmllbGRHZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX25vZGVzKSkuYWRkLmFwcGx5KF9jbGFzc1ByaXZhdGVGaWVsZEdlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFZGdlcygpIHtcbiAgICAgIHZhciBfY2xhc3NQcml2YXRlRmllbGRHZTI7XG5cbiAgICAgIChfY2xhc3NQcml2YXRlRmllbGRHZTIgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9lZGdlcykpLmFkZC5hcHBseShfY2xhc3NQcml2YXRlRmllbGRHZTIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZU5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZU5vZGVzKG5vZGUpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX25vZGVzKS5kZWxldGUobm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUVkZ2VzKGVkZ2UpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2VkZ2VzKS5kZWxldGUoZWRnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfbm9kZXMpLmNsZWFyKCk7XG5cbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2VkZ2VzKS5jbGVhcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21taXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWl0KCkge1xuICAgICAgdmFyIF9jbGFzc1ByaXZhdGVGaWVsZEdlMywgX2NvbnRleHQ7XG5cbiAgICAgIHZhciBzdW1tYXJ5ID0ge1xuICAgICAgICBub2RlczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfbm9kZXMpLmNvbW1pdCgpLFxuICAgICAgICBlZGdlczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZWRnZXMpLmNvbW1pdCgpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgcmVzdFtfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICAoX2NsYXNzUHJpdmF0ZUZpZWxkR2UzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfY29tbWl0SGFuZGxlcikpLmNhbGwuYXBwbHkoX2NsYXNzUHJpdmF0ZUZpZWxkR2UzLCBjb25jYXQkMihfY29udGV4dCA9IFt0aGlzLCBzdW1tYXJ5XSkuY2FsbChfY29udGV4dCwgcmVzdCkpO1xuXG4gICAgICByZXR1cm4gc3VtbWFyeTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2l6ZU5vZGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfbm9kZXMpLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVFZGdlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2VkZ2VzKS5zaXplO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTZWxlY3Rpb25BY2N1bXVsYXRvcjtcbn0oKTtcbl9ub2RlcyA9IG5ldyB3ZWFrTWFwJDIoKSwgX2VkZ2VzID0gbmV3IHdlYWtNYXAkMigpLCBfY29tbWl0SGFuZGxlciA9IG5ldyB3ZWFrTWFwJDIoKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2Ygc3ltYm9sJDQgPT09IFwidW5kZWZpbmVkXCIgfHwgZ2V0SXRlcmF0b3JNZXRob2QkMShvKSA9PSBudWxsKSB7IGlmIChpc0FycmF5JDUobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBnZXRJdGVyYXRvciQxKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNihvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MzsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDYobywgbWluTGVuKTsgdmFyIG4gPSBzbGljZSQ1KF9jb250ZXh0MyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDMsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIGZyb21fMSQyKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDYobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ2KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXG4gKiBUaGUgaGFuZGxlciBmb3Igc2VsZWN0aW9uc1xuICovXG5cbnZhciBTZWxlY3Rpb25IYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIFNlbGVjdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdGlvbkhhbmRsZXIpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvciA9IG5ldyBTZWxlY3Rpb25BY2N1bXVsYXRvcigpO1xuICAgIHRoaXMuaG92ZXJPYmogPSB7XG4gICAgICBub2Rlczoge30sXG4gICAgICBlZGdlczoge31cbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHRydWUsXG4gICAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB0cnVlXG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKFNlbGVjdGlvbkhhbmRsZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXCJtdWx0aXNlbGVjdFwiLCBcImhvdmVyQ29ubmVjdGVkRWRnZXNcIiwgXCJzZWxlY3RhYmxlXCIsIFwic2VsZWN0Q29ubmVjdGVkRWRnZXNcIl07XG4gICAgICAgIHNlbGVjdGl2ZURlZXBFeHRlbmQoZmllbGRzLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYW5kbGVzIHRoZSBzZWxlY3Rpb24gcGFydCBvZiB0aGUgdGFwO1xuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RPblBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE9uUG9pbnQocG9pbnRlcikge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcikgfHwgdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7IC8vIHVuc2VsZWN0IGFmdGVyIGdldHRpbmcgdGhlIG9iamVjdHMgaW4gb3JkZXIgdG8gcmVzdG9yZSB3aWR0aCBhbmQgaGVpZ2h0LlxuXG4gICAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcblxuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdEFkZGl0aW9uYWxPblBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEFkZGl0aW9uYWxPblBvaW50KHBvaW50ZXIpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcikgfHwgdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAob2JqLmlzU2VsZWN0ZWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChvYmopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0aW9uQ2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzdGFuZGFyZCBmaWVsZHMgZm9yIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgT2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRCYXNlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRCYXNlRXZlbnQoZXZlbnQsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICBwcm9wZXJ0aWVzW1wicG9pbnRlclwiXSA9IHtcbiAgICAgICAgRE9NOiB7XG4gICAgICAgICAgeDogcG9pbnRlci54LFxuICAgICAgICAgIHk6IHBvaW50ZXIueVxuICAgICAgICB9LFxuICAgICAgICBjYW52YXM6IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpXG4gICAgICB9O1xuICAgICAgcHJvcGVydGllc1tcImV2ZW50XCJdID0gZXZlbnQ7XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gZXZlbnQgd2hpY2ggdGhlIHVzZXIgY2FuIGNhdGNoLlxuICAgICAqXG4gICAgICogVGhpcyBhZGRzIHNvbWUgZXh0cmEgZGF0YSB0byB0aGUgZXZlbnQgd2l0aCByZXNwZWN0IHRvIGN1cnNvciBwb3NpdGlvbiBhbmRcbiAgICAgKiBzZWxlY3RlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lIG9mIGV2ZW50IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgICAgICAgICAgICBPYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCB1bmRlZmluZWR9IG9sZFNlbGVjdGlvbiAgICAgICAgICAgICBJZiBwcmVzZW50LCBzZWxlY3Rpb24gc3RhdGUgYmVmb3JlIGV2ZW50IG9jY3VyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBbZW1wdHlTZWxlY3Rpb249ZmFsc2VdICBJbmRpY2F0ZSBpZiBzZWxlY3Rpb24gZGF0YSBzaG91bGQgYmUgcGFzc2VkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZUNsaWNrRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVDbGlja0V2ZW50KGV2ZW50VHlwZSwgZXZlbnQsIHBvaW50ZXIsIG9sZFNlbGVjdGlvbikge1xuICAgICAgdmFyIGVtcHR5U2VsZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgaWYgKGVtcHR5U2VsZWN0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHByb3BlcnRpZXMubm9kZXMgPSBbXTtcbiAgICAgICAgcHJvcGVydGllcy5lZGdlcyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHByb3BlcnRpZXMubm9kZXMgPSB0bXAubm9kZXM7XG4gICAgICAgIHByb3BlcnRpZXMuZWRnZXMgPSB0bXAuZWRnZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvbGRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wZXJ0aWVzW1wicHJldmlvdXNTZWxlY3Rpb25cIl0gPSBvbGRTZWxlY3Rpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudFR5cGUgPT0gXCJjbGlja1wiKSB7XG4gICAgICAgIC8vIEZvciB0aGUgdGltZSBiZWluZywgcmVzdHJpY3QgdGhpcyBmdW5jdGlvbmFsaXR5IHRvXG4gICAgICAgIC8vIGp1c3QgdGhlIGNsaWNrIGV2ZW50LlxuICAgICAgICBwcm9wZXJ0aWVzLml0ZW1zID0gdGhpcy5nZXRDbGlja2VkSXRlbXMocG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5jb250cm9sRWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXMuY29udHJvbEVkZ2UgPSBldmVudC5jb250cm9sRWRnZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChldmVudFR5cGUsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWdobGlnaHRFZGdlcz10aGlzLm9wdGlvbnMuc2VsZWN0Q29ubmVjdGVkRWRnZXNdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0T2JqZWN0KG9iaikge1xuICAgICAgdmFyIGhpZ2hsaWdodEVkZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm9wdGlvbnMuc2VsZWN0Q29ubmVjdGVkRWRnZXM7XG5cbiAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIGlmIChoaWdobGlnaHRFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzJF9zZWxlY3Rpb25BY2N1bTtcblxuICAgICAgICAgICAgKF90aGlzJF9zZWxlY3Rpb25BY2N1bSA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yKS5hZGRFZGdlcy5hcHBseShfdGhpcyRfc2VsZWN0aW9uQWNjdW0sIHRvQ29uc3VtYWJsZUFycmF5KG9iai5lZGdlcykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmFkZE5vZGVzKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuYWRkRWRnZXMob2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzZWxlY3RPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzZWxlY3RPYmplY3Qob2JqKSB7XG4gICAgICBpZiAob2JqLmlzU2VsZWN0ZWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvYmouc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlIGFsbCBub2RlcyBvdmVybGFwcGluZyB3aXRoIGdpdmVuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119ICAgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkge1xuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSBbXTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlc1tpXTtcblxuICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5pc092ZXJsYXBwaW5nV2l0aChvYmplY3QpKSB7XG4gICAgICAgICAgb3ZlcmxhcHBpbmdOb2Rlcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHBvc2l0aW9uIG9iamVjdCBpbiBjYW52YXNzcGFjZSBmcm9tIGEgc2luZ2xlIHBvaW50IGluIHNjcmVlbnNwYWNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKSB7XG4gICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBjYW52YXNQb3MueCAtIDEsXG4gICAgICAgIHRvcDogY2FudmFzUG9zLnkgKyAxLFxuICAgICAgICByaWdodDogY2FudmFzUG9zLnggKyAxLFxuICAgICAgICBib3R0b206IGNhbnZhc1Bvcy55IC0gMVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b3Agbm9kZSBhdCB0aGUgcGFzc2VkIHBvaW50IChsaWtlIGEgY2xpY2spXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5Ob2RlPXRydWVdXG4gICAgICogQHJldHVybnMge05vZGUgfCB1bmRlZmluZWR9IG5vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlQXQocG9pbnRlcikge1xuICAgICAgdmFyIHJldHVybk5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIC8vIHdlIGZpcnN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gbmF2aWdhdGlvbiBjb250cm9scyBlbGVtZW50XG4gICAgICB2YXIgcG9zaXRpb25PYmplY3QgPSB0aGlzLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcblxuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZXMgPSB0aGlzLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb3NpdGlvbk9iamVjdCk7IC8vIGlmIHRoZXJlIGFyZSBvdmVybGFwcGluZyBub2Rlcywgc2VsZWN0IHRoZSBsYXN0IG9uZSwgdGhpcyBpcyB0aGVcbiAgICAgIC8vIG9uZSB3aGljaCBpcyBkcmF3biBvbiB0b3Agb2YgdGhlIG90aGVyc1xuXG5cbiAgICAgIGlmIChvdmVybGFwcGluZ05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHJldHVybk5vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nTm9kZXNbb3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0cmlldmUgYWxsIGVkZ2VzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0LCBzZWxlY3RvciBpcyBhcm91bmQgY2VudGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG92ZXJsYXBwaW5nRWRnZXMgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RWRnZXNPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEVkZ2VzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCwgb3ZlcmxhcHBpbmdFZGdlcykge1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5lZGdlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZUlkID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzW2ldO1xuXG4gICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLmlzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkpIHtcbiAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXRyaWV2ZSBhbGwgbm9kZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybnMge251bWJlcltdfSAgIEFuIGFycmF5IHdpdGggaWQncyBvZiB0aGUgb3ZlcmxhcHBpbmcgbm9kZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFsbEVkZ2VzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QpIHtcbiAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2VzID0gW107XG5cbiAgICAgIHRoaXMuX2dldEVkZ2VzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCwgb3ZlcmxhcHBpbmdFZGdlcyk7XG5cbiAgICAgIHJldHVybiBvdmVybGFwcGluZ0VkZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGVkZ2VzIG5lYXJlc3QgdG8gdGhlIHBhc3NlZCBwb2ludCAobGlrZSBhIGNsaWNrKVxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0dXJuRWRnZT10cnVlXVxuICAgICAqIEByZXR1cm5zIHtFZGdlIHwgdW5kZWZpbmVkfSBub2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZUF0KHBvaW50ZXIpIHtcbiAgICAgIHZhciByZXR1cm5FZGdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGVkZ2VzLCBwaWNrIGNsb3Nlc3Qgd2l0aGluIDEwXG4gICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG4gICAgICB2YXIgbWluZGlzdCA9IDEwO1xuICAgICAgdmFyIG92ZXJsYXBwaW5nRWRnZSA9IG51bGw7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZUluZGljZXNbaV07XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUlkXTtcblxuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgeEZyb20gPSBlZGdlLmZyb20ueDtcbiAgICAgICAgICB2YXIgeUZyb20gPSBlZGdlLmZyb20ueTtcbiAgICAgICAgICB2YXIgeFRvID0gZWRnZS50by54O1xuICAgICAgICAgIHZhciB5VG8gPSBlZGdlLnRvLnk7XG4gICAgICAgICAgdmFyIGRpc3QgPSBlZGdlLmVkZ2VUeXBlLmdldERpc3RhbmNlVG9FZGdlKHhGcm9tLCB5RnJvbSwgeFRvLCB5VG8sIGNhbnZhc1Bvcy54LCBjYW52YXNQb3MueSk7XG5cbiAgICAgICAgICBpZiAoZGlzdCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nRWRnZSA9IGVkZ2VJZDtcbiAgICAgICAgICAgIG1pbmRpc3QgPSBkaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcmxhcHBpbmdFZGdlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChyZXR1cm5FZGdlID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5lZGdlc1tvdmVybGFwcGluZ0VkZ2VdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvdmVybGFwcGluZ0VkZ2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBvYmplY3QgdG8gdGhlIHNlbGVjdGlvbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZFRvSG92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZFRvSG92ZXIob2JqKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICB0aGlzLmhvdmVyT2JqLm5vZGVzW29iai5pZF0gPSBvYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhvdmVyT2JqLmVkZ2VzW29iai5pZF0gPSBvYmo7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNpbmdsZSBvcHRpb24gZnJvbSBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVGcm9tU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzJF9zZWxlY3Rpb25BY2N1bTI7XG5cbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZGVsZXRlTm9kZXMob2JqKTtcblxuICAgICAgICAoX3RoaXMkX3NlbGVjdGlvbkFjY3VtMiA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yKS5kZWxldGVFZGdlcy5hcHBseShfdGhpcyRfc2VsZWN0aW9uQWNjdW0yLCB0b0NvbnN1bWFibGVBcnJheShvYmouZWRnZXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZUVkZ2VzKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc2VsZWN0IGFsbCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnNlbGVjdEFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdEFsbCgpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNsZWFyKCk7XG5cbiAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIG51bWJlciBvZiBzZWxlY3RlZCBub2Rlc1xuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkTm9kZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkTm9kZUNvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLnNpemVOb2RlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgZWRnZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZEVkZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZEVkZ2VDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5zaXplRWRnZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNlbGVjdCB0aGUgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaG92ZXJDb25uZWN0ZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaG92ZXJDb25uZWN0ZWRFZGdlcyhub2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBub2RlLmVkZ2VzW2ldO1xuICAgICAgICBlZGdlLmhvdmVyID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGhpZ2hsaWdodCBmcm9tIGEgbm9kZSBvciBlZGdlLCBpbiByZXNwb25zZSB0byBtb3VzZSBtb3ZlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBAcGFyYW0ge05vZGV8dmlzLkVkZ2V9IG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWl0Qmx1ckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRCbHVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIG9iamVjdCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgaWYgKG9iamVjdC5ob3ZlciA9PT0gdHJ1ZSkge1xuICAgICAgICBvYmplY3QuaG92ZXIgPSBmYWxzZTtcblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIHByb3BlcnRpZXMubm9kZSA9IG9iamVjdC5pZDtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmx1ck5vZGVcIiwgcHJvcGVydGllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcGVydGllcy5lZGdlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJibHVyRWRnZVwiLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGhpZ2hsaWdodCBmb3IgYSBub2RlIG9yIGVkZ2UsIGluIHJlc3BvbnNlIHRvIG1vdXNlIG1vdmVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEBwYXJhbSB7Tm9kZXx2aXMuRWRnZX0gb2JqZWN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGhvdmVyQ2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWl0SG92ZXJFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0SG92ZXJFdmVudChldmVudCwgcG9pbnRlciwgb2JqZWN0KSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX2luaXRCYXNlRXZlbnQoZXZlbnQsIHBvaW50ZXIpO1xuXG4gICAgICB2YXIgaG92ZXJDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChvYmplY3QuaG92ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgIG9iamVjdC5ob3ZlciA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fYWRkVG9Ib3ZlcihvYmplY3QpO1xuXG4gICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm5vZGUgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImhvdmVyTm9kZVwiLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmVkZ2UgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImhvdmVyRWRnZVwiLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaG92ZXJDaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFjdGlvbnMgaW4gcmVzcG9uc2UgdG8gYSBtb3VzZSBtb3ZlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudFxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciB8IG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhvdmVyT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhvdmVyT2JqZWN0KGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcik7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmplY3QgPSB0aGlzLmdldEVkZ2VBdChwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvdmVyQ2hhbmdlZCA9IGZhbHNlOyAvLyByZW1vdmUgYWxsIG5vZGUgaG92ZXIgaGlnaGxpZ2h0c1xuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ob3Zlck9iai5ub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaG92ZXJPYmoubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiBvYmplY3QuaWQgIT0gbm9kZUlkIHx8IG9iamVjdCBpbnN0YW5jZW9mIEVkZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEJsdXJFdmVudChldmVudCwgcG9pbnRlciwgdGhpcy5ob3Zlck9iai5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvdmVyT2JqLm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyByZW1vdmluZyBhbGwgZWRnZSBob3ZlciBoaWdobGlnaHRzXG5cblxuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuaG92ZXJPYmouZWRnZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmhvdmVyT2JqLmVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGhvdmVyIGhhcyBiZWVuIGNoYW5nZWQgaGVyZSBpdCBtZWFucyB0aGF0IHRoZSBub2RlIGhhcyBiZWVuIGhvdmVyZWQgb3ZlciBvciBvZmZcbiAgICAgICAgICAvLyB3ZSB0aGVuIGRvIG5vdCB1c2UgdGhlIGVtaXRCbHVyRXZlbnQgbWV0aG9kIGhlcmUuXG4gICAgICAgICAgaWYgKGhvdmVyQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdLmhvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgIH0gLy8gaWYgdGhlIGJsdXIgcmVtYWlucyB0aGUgc2FtZSBhbmQgdGhlIG9iamVjdCBpcyB1bmRlZmluZWQgKG1vdXNlIG9mZikgb3IgYW5vdGhlclxuICAgICAgICAgIC8vIGVkZ2UgaGFzIGJlZW4gaG92ZXJlZCwgb3IgYW5vdGhlciBub2RlIGhhcyBiZWVuIGhvdmVyZWQgd2UgYmx1ciB0aGUgZWRnZS5cbiAgICAgICAgICBlbHNlIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBFZGdlICYmIG9iamVjdC5pZCAhPSBlZGdlSWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiAhb2JqZWN0LmhvdmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdEJsdXJFdmVudChldmVudCwgcG9pbnRlciwgdGhpcy5ob3Zlck9iai5lZGdlc1tlZGdlSWRdKTtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgICAgaG92ZXJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGhvdmVyZWRFZGdlc0NvdW50ID0ga2V5cyQzKHRoaXMuaG92ZXJPYmouZWRnZXMpLmxlbmd0aDtcblxuICAgICAgICB2YXIgaG92ZXJlZE5vZGVzQ291bnQgPSBrZXlzJDModGhpcy5ob3Zlck9iai5ub2RlcykubGVuZ3RoO1xuXG4gICAgICAgIHZhciBuZXdPbmx5SG92ZXJlZEVkZ2UgPSBvYmplY3QgaW5zdGFuY2VvZiBFZGdlICYmIGhvdmVyZWRFZGdlc0NvdW50ID09PSAwICYmIGhvdmVyZWROb2Rlc0NvdW50ID09PSAwO1xuICAgICAgICB2YXIgbmV3T25seUhvdmVyZWROb2RlID0gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiBob3ZlcmVkRWRnZXNDb3VudCA9PT0gMCAmJiBob3ZlcmVkTm9kZXNDb3VudCA9PT0gMDtcblxuICAgICAgICBpZiAoaG92ZXJDaGFuZ2VkIHx8IG5ld09ubHlIb3ZlcmVkRWRnZSB8fCBuZXdPbmx5SG92ZXJlZE5vZGUpIHtcbiAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0aGlzLmVtaXRIb3ZlckV2ZW50KGV2ZW50LCBwb2ludGVyLCBvYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgJiYgdGhpcy5vcHRpb25zLmhvdmVyQ29ubmVjdGVkRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9ob3ZlckNvbm5lY3RlZEVkZ2VzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhvdmVyQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhbmQgZGVzZWxlY3Qgbm9kZXMgZGVwZW5kaW5nIGN1cnJlbnQgc2VsZWN0aW9uIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEZvciBjaGFuZ2luZyBub2Rlcywgc2VsZWN0L2Rlc2VsZWN0IGV2ZW50cyBhcmUgZmlyZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBGb3IgYSBnaXZlbiBlZGdlLCBpZiBvbmUgY29ubmVjdGluZyBub2RlIGlzIGRlc2VsZWN0ZWQgYW5kIHdpdGggdGhlXG4gICAgICogc2FtZSBjbGljayB0aGUgb3RoZXIgbm9kZSBpcyBzZWxlY3RlZCwgbm8gZXZlbnRzIGZvciB0aGUgZWRnZSB3aWxsIGZpcmUuIEl0XG4gICAgICogd2FzIHNlbGVjdGVkIGFuZCBpdCB3aWxsIHJlbWFpbiBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciAtIFRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZVxuICAgICAqIGNsaWNrLCB0YXAsIGRyYWdlbmTigKYgdGhhdCB0cmlnZ2VyZWQgdGhpcy5cbiAgICAgKiBAcGFyYW0ge1VJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb21taXRBbmRFbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdEFuZEVtaXQocG9pbnRlciwgZXZlbnQpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgc2VsZWN0aW9uQ2hhbmdlcyA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNvbW1pdCgpO1xuXG4gICAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSB7XG4gICAgICAgIG5vZGVzOiBzZWxlY3Rpb25DaGFuZ2VzLm5vZGVzLnByZXZpb3VzLFxuICAgICAgICBlZGdlczogc2VsZWN0aW9uQ2hhbmdlcy5lZGdlcy5wcmV2aW91c1xuICAgICAgfTtcblxuICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZXMuZWRnZXMuZGVsZXRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZGVzZWxlY3RFZGdlXCIsIGV2ZW50LCBwb2ludGVyLCBwcmV2aW91c1NlbGVjdGlvbik7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZXMubm9kZXMuZGVsZXRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwiZGVzZWxlY3ROb2RlXCIsIGV2ZW50LCBwb2ludGVyLCBwcmV2aW91c1NlbGVjdGlvbik7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZXMubm9kZXMuYWRkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcInNlbGVjdE5vZGVcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rpb25DaGFuZ2VzLmVkZ2VzLmFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJzZWxlY3RFZGdlXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfSAvLyBmaXJlIHRoZSBzZWxlY3QgZXZlbnQgaWYgYW55dGhpbmcgaGFzIGJlZW4gc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZFxuXG5cbiAgICAgIGlmIChzZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBzZWxlY3Qgb3IgdW5zZWxlY3RcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJzZWxlY3RcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgYW5kIGVkZ2UgaWRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3tub2RlczogQXJyYXkuPHN0cmluZz4sIGVkZ2VzOiBBcnJheS48c3RyaW5nPn19IEFycmF5cyB3aXRoIHRoZVxuICAgICAqIGlkcyBvZiB0aGUgc2VsZWN0ZWQgbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiB0aGlzLmdldFNlbGVjdGVkTm9kZUlkcygpLFxuICAgICAgICBlZGdlczogdGhpcy5nZXRTZWxlY3RlZEVkZ2VJZHMoKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgd2l0aCBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXROb2RlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVkZ2VzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3aXRoIHNlbGVjdGVkIGVkZ2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZEVkZ2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldEVkZ2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBpZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IHdpdGggdGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgbm9kZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZE5vZGVJZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlSWRzKCkge1xuICAgICAgdmFyIF9jb250ZXh0O1xuXG4gICAgICByZXR1cm4gbWFwJDIoX2NvbnRleHQgPSB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXROb2RlcygpKS5jYWxsKF9jb250ZXh0LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5pZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVkZ2UgaWRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlIHNlbGVjdGVkIGVkZ2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWRFZGdlSWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkRWRnZUlkcygpIHtcbiAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgIHJldHVybiBtYXAkMihfY29udGV4dDIgPSB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXRFZGdlcygpKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuaWQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e25vZGVzOiBBcnJheS48c3RyaW5nPiwgZWRnZXM6IEFycmF5LjxzdHJpbmc+fX0gc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhc2VsZWN0aW9uLm5vZGVzICYmICFzZWxlY3Rpb24uZWRnZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlNlbGVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIG5vZGVzIGFuZC9vciBlZGdlcyBwcm9wZXJ0aWVzXCIpO1xuICAgICAgfSAvLyBmaXJzdCB1bnNlbGVjdCBhbnkgc2VsZWN0ZWQgbm9kZSwgaWYgb3B0aW9uIGlzIHRydWUgb3IgdW5kZWZpbmVkXG5cblxuICAgICAgaWYgKG9wdGlvbnMudW5zZWxlY3RBbGwgfHwgb3B0aW9ucy51bnNlbGVjdEFsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbi5ub2Rlcykge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShzZWxlY3Rpb24ubm9kZXMpLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGlkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZF07XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTm9kZSB3aXRoIGlkIFwiJyArIGlkICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfSAvLyBkb24ndCBzZWxlY3QgZWRnZXMgd2l0aCBpdFxuXG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KG5vZGUsIG9wdGlvbnMuaGlnaGxpZ2h0RWRnZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rpb24uZWRnZXMpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KHNlbGVjdGlvbi5lZGdlcyksXG4gICAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9pZCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW19pZF07XG5cbiAgICAgICAgICAgIGlmICghZWRnZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRWRnZSB3aXRoIGlkIFwiJyArIF9pZCArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RPYmplY3QoZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG5cbiAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgemVybyBvciBtb3JlIG5vZGVzIHdpdGggdGhlIG9wdGlvbiB0byBoaWdobGlnaHQgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gc2VsZWN0aW9uICAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hsaWdodEVkZ2VzXVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0Tm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0Tm9kZXMoc2VsZWN0aW9uKSB7XG4gICAgICB2YXIgaGlnaGxpZ2h0RWRnZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ubGVuZ3RoID09PSB1bmRlZmluZWQpIHRocm93IFwiU2VsZWN0aW9uIG11c3QgYmUgYW4gYXJyYXkgd2l0aCBpZHNcIjtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgbm9kZXM6IHNlbGVjdGlvblxuICAgICAgfSwge1xuICAgICAgICBoaWdobGlnaHRFZGdlczogaGlnaGxpZ2h0RWRnZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgemVybyBvciBtb3JlIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IHNlbGVjdGlvbiAgICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEVkZ2VzKHNlbGVjdGlvbikge1xuICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBcIlNlbGVjdGlvbiBtdXN0IGJlIGFuIGFycmF5IHdpdGggaWRzXCI7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbih7XG4gICAgICAgIGVkZ2VzOiBzZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgc2VsZWN0aW9uOiByZW1vdmUgaWRzIG9mIG5vZGVzIHdoaWNoIG5vIGxvbmdlciBleGlzdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBub2RlIGluIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldE5vZGVzKCkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlLmlkKSkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZU5vZGVzKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGVkZ2UgaW4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0RWRnZXMoKSkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsIGVkZ2UuaWQpKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZGVsZXRlRWRnZXMoZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB0aGUgdmlzdWFsIGVsZW1lbnRzIGNsaWNrZWQgd2hpY2ggYXJlIG9uIHRoZSBnaXZlbiBwb2ludC5cbiAgICAgKlxuICAgICAqIEFsbCBlbGVtZW50cyBhcmUgcmV0dXJuZWQ7IHRoaXMgaW5jbHVkZXMgbm9kZXMsIGVkZ2VzIGFuZCB0aGVpciBsYWJlbHMuXG4gICAgICogVGhlIG9yZGVyIHJldHVybmVkIGlzIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIGkuZS4gZWxlbWVudCAwIG9mIHRoZSByZXR1cm5cbiAgICAgKiB2YWx1ZSBpcyB0aGUgdG9wbW9zdCBpdGVtIGNsaWNrZWQgb24uXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGNvbnNpc3RzIG9mIGFuIGFycmF5IG9mIHRoZSBmb2xsb3dpbmcgcG9zc2libGUgZWxlbWVudHM6XG4gICAgICpcbiAgICAgKiAtIGB7bm9kZUlkOm51bWJlcn1gICAgICAgICAgICAgIC0gbm9kZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7bm9kZUlkOm51bWJlciwgbGFiZWxJZDowfWAgIC0gbGFiZWwgb2Ygbm9kZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7ZWRnZUlkOm51bWJlcn1gICAgICAgICAgICAgIC0gZWRnZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKiAtIGB7ZWRnZTpudW1iZXIsIGxhYmVsSWQ6MH1gICAgIC0gbGFiZWwgb2YgZWRnZSB3aXRoIGdpdmVuIGlkIGNsaWNrZWQgb25cbiAgICAgKlxuICAgICAqICMjIE5PVEVTXG4gICAgICpcbiAgICAgKiAtIEN1cnJlbnRseSwgdGhlcmUgaXMgb25seSBvbmUgbGFiZWwgYXNzb2NpYXRlZCB3aXRoIGEgbm9kZSBvciBhbiBlZGdlLFxuICAgICAqICAgYnV0IHRoaXMgaXMgZXhwZWN0ZWQgdG8gY2hhbmdlIHNvbWV3aGVyZSBpbiB0aGUgZnV0dXJlLlxuICAgICAqIC0gU2luY2UgdGhlcmUgaXMgbm8gei1pbmRleGluZyB5ZXQsIGl0IGlzIG5vdCByZWFsbHkgcG9zc2libGUgdG8gc2V0IHRoZSBub2RlcyBhbmRcbiAgICAgKiAgIGVkZ2VzIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBGb3IgdGhlIHRpbWUgYmVpbmcsIG5vZGVzIGNvbWUgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb2ludGVyICBtb3VzZSBwb3NpdGlvbiBpbiBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG5vZGVDbGlja0l0ZW18bm9kZUxhYmVsQ2xpY2tJdGVtfGVkZ2VDbGlja0l0ZW18ZWRnZUxhYmVsQ2xpY2tJdGVtPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2xpY2tlZEl0ZW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsaWNrZWRJdGVtcyhwb2ludGVyKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgIHZhciBpdGVtcyA9IFtdOyAvLyBOb3RlIHJldmVyc2Ugb3JkZXI7IHdlIHdhbnQgdGhlIHRvcG1vc3QgY2xpY2tlZCBpdGVtcyB0byBiZSBmaXJzdCBpbiB0aGUgYXJyYXlcbiAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHNlbGVjdGVkIG5vZGVzIGFyZSBkaXNyZWdhcmRlZCBoZXJlOyB0aGVzZSBub3JtYWxseSBkaXNwbGF5IG9uIHRvcFxuXG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSBub2RlSW5kaWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgdmFyIHJldCA9IG5vZGUuZ2V0SXRlbXNPblBvaW50KHBvaW50KTtcbiAgICAgICAgaXRlbXMucHVzaC5hcHBseShpdGVtcywgcmV0KTsgLy8gQXBwZW5kIHRoZSByZXR1cm4gdmFsdWUgdG8gdGhlIHJ1bm5pbmcgbGlzdC5cbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IGVkZ2VJbmRpY2VzLmxlbmd0aCAtIDE7IF9pID49IDA7IF9pLS0pIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tfaV1dO1xuXG4gICAgICAgIHZhciBfcmV0ID0gZWRnZS5nZXRJdGVtc09uUG9pbnQocG9pbnQpO1xuXG4gICAgICAgIGl0ZW1zLnB1c2guYXBwbHkoaXRlbXMsIF9yZXQpOyAvLyBBcHBlbmQgdGhlIHJldHVybiB2YWx1ZSB0byB0aGUgcnVubmluZyBsaXN0LlxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlbGVjdGlvbkhhbmRsZXI7XG59KCk7XG5cbnZhciBjcmVhdGVNZXRob2QkNSA9IGZ1bmN0aW9uIChJU19SSUdIVCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c0xlbmd0aCwgbWVtbykge1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICAgIHZhciBzZWxmID0gaW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoIDwgMikgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgICAgaW5kZXggKz0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IGk7XG5cbiAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgSVNfUklHSFQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufTtcblxudmFyIGFycmF5UmVkdWNlID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiAgbGVmdDogY3JlYXRlTWV0aG9kJDUoZmFsc2UpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QkNSh0cnVlKVxufTtcblxudmFyIGVuZ2luZUlzTm9kZSA9IGNsYXNzb2ZSYXcoZ2xvYmFsXzEucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgJHJlZHVjZSA9IGFycmF5UmVkdWNlLmxlZnQ7XG52YXIgU1RSSUNUX01FVEhPRCQzID0gYXJyYXlNZXRob2RJc1N0cmljdCgncmVkdWNlJyk7XG52YXIgVVNFU19UT19MRU5HVEgkOCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdyZWR1Y2UnLCB7XG4gIDE6IDBcbn0pOyAvLyBDaHJvbWUgODAtODIgaGFzIGEgY3JpdGljYWwgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ5OTgyXG5cbnZhciBDSFJPTUVfQlVHID0gIWVuZ2luZUlzTm9kZSAmJiBlbmdpbmVWOFZlcnNpb24gPiA3OSAmJiBlbmdpbmVWOFZlcnNpb24gPCA4MzsgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuXG5fZXhwb3J0KHtcbiAgdGFyZ2V0OiAnQXJyYXknLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCQzIHx8ICFVU0VTX1RPX0xFTkdUSCQ4IHx8IENIUk9NRV9CVUdcbn0sIHtcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmblxuICAvKiAsIGluaXRpYWxWYWx1ZSAqL1xuICApIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgcmVkdWNlID0gZW50cnlWaXJ0dWFsKCdBcnJheScpLnJlZHVjZTtcblxudmFyIEFycmF5UHJvdG90eXBlJGQgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciByZWR1Y2VfMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQucmVkdWNlO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGQgfHwgaXQgaW5zdGFuY2VvZiBBcnJheSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGQucmVkdWNlID8gcmVkdWNlIDogb3duO1xufTtcblxudmFyIHJlZHVjZSQxID0gcmVkdWNlXzE7XG5cbnZhciByZWR1Y2UkMiA9IHJlZHVjZSQxO1xuXG52YXIgdGVzdCQyID0gW107XG52YXIgbmF0aXZlU29ydCA9IHRlc3QkMi5zb3J0OyAvLyBJRTgtXG5cbnZhciBGQUlMU19PTl9VTkRFRklORUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHRlc3QkMi5zb3J0KHVuZGVmaW5lZCk7XG59KTsgLy8gVjggYnVnXG5cbnZhciBGQUlMU19PTl9OVUxMID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0JDIuc29ydChudWxsKTtcbn0pOyAvLyBPbGQgV2ViS2l0XG5cbnZhciBTVFJJQ1RfTUVUSE9EJDQgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdzb3J0Jyk7XG52YXIgRk9SQ0VEJDYgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgIVNUUklDVF9NRVRIT0QkNDsgLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb3J0XG5cbl9leHBvcnQoe1xuICB0YXJnZXQ6ICdBcnJheScsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IEZPUkNFRCQ2XG59LCB7XG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkID8gbmF0aXZlU29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKSA6IG5hdGl2ZVNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcblxudmFyIHNvcnQgPSBlbnRyeVZpcnR1YWwoJ0FycmF5Jykuc29ydDtcblxudmFyIEFycmF5UHJvdG90eXBlJGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBzb3J0XzEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNvcnQ7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkZSB8fCBpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkZS5zb3J0ID8gc29ydCA6IG93bjtcbn07XG5cbnZhciBzb3J0JDEgPSBzb3J0XzE7XG5cbnZhciBzb3J0JDIgPSBzb3J0JDE7XG5cbnZhciB0aW1zb3J0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAvKioqKlxuICAgKiBUaGUgTUlUIExpY2Vuc2VcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSAyMDE1IE1hcmNvIFppY2NhcmRpXG4gICAqXG4gICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAqXG4gICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gICAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgKlxuICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gICAqIFRIRSBTT0ZUV0FSRS5cbiAgICpcbiAgICoqKiovXG4gIChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAge1xuICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9XG4gIH0pKGNvbW1vbmpzR2xvYmFsLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgICBleHBvcnRzLnNvcnQgPSBzb3J0O1xuXG4gICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIERFRkFVTFRfTUlOX01FUkdFID0gMzI7XG4gICAgdmFyIERFRkFVTFRfTUlOX0dBTExPUElORyA9IDc7XG4gICAgdmFyIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIID0gMjU2O1xuICAgIHZhciBQT1dFUlNfT0ZfVEVOID0gWzFlMCwgMWUxLCAxZTIsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOV07XG5cbiAgICBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgICBpZiAoeCA8IDFlNSkge1xuICAgICAgICBpZiAoeCA8IDFlMikge1xuICAgICAgICAgIHJldHVybiB4IDwgMWUxID8gMCA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA8IDFlNCkge1xuICAgICAgICAgIHJldHVybiB4IDwgMWUzID8gMiA6IDM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gNDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPCAxZTcpIHtcbiAgICAgICAgcmV0dXJuIHggPCAxZTYgPyA1IDogNjtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPCAxZTkpIHtcbiAgICAgICAgcmV0dXJuIHggPCAxZTggPyA3IDogODtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxwaGFiZXRpY2FsQ29tcGFyZShhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKH5+YSA9PT0gYSAmJiB+fmIgPT09IGIpIHtcbiAgICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhIDwgMCB8fCBiIDwgMCkge1xuICAgICAgICAgIGlmIChiID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhID0gLWE7XG4gICAgICAgICAgYiA9IC1iO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFsID0gbG9nMTAoYSk7XG4gICAgICAgIHZhciBibCA9IGxvZzEwKGIpO1xuICAgICAgICB2YXIgdCA9IDA7XG5cbiAgICAgICAgaWYgKGFsIDwgYmwpIHtcbiAgICAgICAgICBhICo9IFBPV0VSU19PRl9URU5bYmwgLSBhbCAtIDFdO1xuICAgICAgICAgIGIgLz0gMTA7XG4gICAgICAgICAgdCA9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGFsID4gYmwpIHtcbiAgICAgICAgICBiICo9IFBPV0VSU19PRl9URU5bYWwgLSBibCAtIDFdO1xuICAgICAgICAgIGEgLz0gMTA7XG4gICAgICAgICAgdCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgYVN0ciA9IFN0cmluZyhhKTtcbiAgICAgIHZhciBiU3RyID0gU3RyaW5nKGIpO1xuXG4gICAgICBpZiAoYVN0ciA9PT0gYlN0cikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFTdHIgPCBiU3RyID8gLTEgOiAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1pblJ1bkxlbmd0aChuKSB7XG4gICAgICB2YXIgciA9IDA7XG5cbiAgICAgIHdoaWxlIChuID49IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICAgIHIgfD0gbiAmIDE7XG4gICAgICAgIG4gPj49IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuICsgcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpIHtcbiAgICAgIHZhciBydW5IaSA9IGxvICsgMTtcblxuICAgICAgaWYgKHJ1bkhpID09PSBoaSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbcnVuSGkrK10sIGFycmF5W2xvXSkgPCAwKSB7XG4gICAgICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA8IDApIHtcbiAgICAgICAgICBydW5IaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV2ZXJzZVJ1bihhcnJheSwgbG8sIHJ1bkhpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA+PSAwKSB7XG4gICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnVuSGkgLSBsbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgICAgIGhpLS07XG5cbiAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIHZhciB0ID0gYXJyYXlbbG9dO1xuICAgICAgICBhcnJheVtsbysrXSA9IGFycmF5W2hpXTtcbiAgICAgICAgYXJyYXlbaGktLV0gPSB0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgc3RhcnQsIGNvbXBhcmUpIHtcbiAgICAgIGlmIChzdGFydCA9PT0gbG8pIHtcbiAgICAgICAgc3RhcnQrKztcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHN0YXJ0IDwgaGk7IHN0YXJ0KyspIHtcbiAgICAgICAgdmFyIHBpdm90ID0gYXJyYXlbc3RhcnRdO1xuICAgICAgICB2YXIgbGVmdCA9IGxvO1xuICAgICAgICB2YXIgcmlnaHQgPSBzdGFydDtcblxuICAgICAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgdmFyIG1pZCA9IGxlZnQgKyByaWdodCA+Pj4gMTtcblxuICAgICAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbiA9IHN0YXJ0IC0gbGVmdDtcblxuICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBhcnJheVtsZWZ0ICsgM10gPSBhcnJheVtsZWZ0ICsgMl07XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBhcnJheVtsZWZ0ICsgMl0gPSBhcnJheVtsZWZ0ICsgMV07XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBhcnJheVtsZWZ0ICsgMV0gPSBhcnJheVtsZWZ0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2xlZnRdID0gcGl2b3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2FsbG9wTGVmdCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID4gMCkge1xuICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICBvZmZzZXQgKz0gaGludDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPD0gMCkge1xuICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgICAgfVxuXG4gICAgICBsYXN0T2Zmc2V0Kys7XG5cbiAgICAgIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IG07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BSaWdodCh2YWx1ZSwgYXJyYXksIHN0YXJ0LCBsZW5ndGgsIGhpbnQsIGNvbXBhcmUpIHtcbiAgICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgICAgdmFyIG9mZnNldCA9IDE7XG5cbiAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA8IDApIHtcbiAgICAgICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gaGludCAtIHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+PSAwKSB7XG4gICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIG9mZnNldCArPSBoaW50O1xuICAgICAgfVxuXG4gICAgICBsYXN0T2Zmc2V0Kys7XG5cbiAgICAgIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBtID0gbGFzdE9mZnNldCArIChvZmZzZXQgLSBsYXN0T2Zmc2V0ID4+PiAxKTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgVGltU29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbVNvcnQpO1xuXG4gICAgICAgIHRoaXMuYXJyYXkgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBudWxsO1xuICAgICAgICB0aGlzLm1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnRtcFN0b3JhZ2VMZW5ndGggPSBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5zdGFja0xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucnVuU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJ1bkxlbmd0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2tTaXplID0gMDtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICAgICAgICB0aGlzLnRtcFN0b3JhZ2VMZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG1wID0gbmV3IEFycmF5KHRoaXMudG1wU3RvcmFnZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhY2tMZW5ndGggPSB0aGlzLmxlbmd0aCA8IDEyMCA/IDUgOiB0aGlzLmxlbmd0aCA8IDE1NDIgPyAxMCA6IHRoaXMubGVuZ3RoIDwgMTE5MTUxID8gMTkgOiA0MDtcbiAgICAgICAgdGhpcy5ydW5TdGFydCA9IG5ldyBBcnJheSh0aGlzLnN0YWNrTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5ydW5MZW5ndGggPSBuZXcgQXJyYXkodGhpcy5zdGFja0xlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIFRpbVNvcnQucHJvdG90eXBlLnB1c2hSdW4gPSBmdW5jdGlvbiBwdXNoUnVuKHJ1blN0YXJ0LCBydW5MZW5ndGgpIHtcbiAgICAgICAgdGhpcy5ydW5TdGFydFt0aGlzLnN0YWNrU2l6ZV0gPSBydW5TdGFydDtcbiAgICAgICAgdGhpcy5ydW5MZW5ndGhbdGhpcy5zdGFja1NpemVdID0gcnVuTGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YWNrU2l6ZSArPSAxO1xuICAgICAgfTtcblxuICAgICAgVGltU29ydC5wcm90b3R5cGUubWVyZ2VSdW5zID0gZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5zdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLnN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICBpZiAobiA+PSAxICYmIHRoaXMucnVuTGVuZ3RoW24gLSAxXSA8PSB0aGlzLnJ1bkxlbmd0aFtuXSArIHRoaXMucnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgdGhpcy5ydW5MZW5ndGhbbiAtIDJdIDw9IHRoaXMucnVuTGVuZ3RoW25dICsgdGhpcy5ydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ydW5MZW5ndGhbbiAtIDFdIDwgdGhpcy5ydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucnVuTGVuZ3RoW25dID4gdGhpcy5ydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1lcmdlQXQobik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFRpbVNvcnQucHJvdG90eXBlLmZvcmNlTWVyZ2VSdW5zID0gZnVuY3Rpb24gZm9yY2VNZXJnZVJ1bnMoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMuc3RhY2tTaXplIC0gMjtcblxuICAgICAgICAgIGlmIChuID4gMCAmJiB0aGlzLnJ1bkxlbmd0aFtuIC0gMV0gPCB0aGlzLnJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1lcmdlQXQobik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFRpbVNvcnQucHJvdG90eXBlLm1lcmdlQXQgPSBmdW5jdGlvbiBtZXJnZUF0KGkpIHtcbiAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIHZhciBzdGFydDEgPSB0aGlzLnJ1blN0YXJ0W2ldO1xuICAgICAgICB2YXIgbGVuZ3RoMSA9IHRoaXMucnVuTGVuZ3RoW2ldO1xuICAgICAgICB2YXIgc3RhcnQyID0gdGhpcy5ydW5TdGFydFtpICsgMV07XG4gICAgICAgIHZhciBsZW5ndGgyID0gdGhpcy5ydW5MZW5ndGhbaSArIDFdO1xuICAgICAgICB0aGlzLnJ1bkxlbmd0aFtpXSA9IGxlbmd0aDEgKyBsZW5ndGgyO1xuXG4gICAgICAgIGlmIChpID09PSB0aGlzLnN0YWNrU2l6ZSAtIDMpIHtcbiAgICAgICAgICB0aGlzLnJ1blN0YXJ0W2kgKyAxXSA9IHRoaXMucnVuU3RhcnRbaSArIDJdO1xuICAgICAgICAgIHRoaXMucnVuTGVuZ3RoW2kgKyAxXSA9IHRoaXMucnVuTGVuZ3RoW2kgKyAyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhY2tTaXplLS07XG4gICAgICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgICAgIHN0YXJ0MSArPSBrO1xuICAgICAgICBsZW5ndGgxIC09IGs7XG5cbiAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgyID0gZ2FsbG9wTGVmdChhcnJheVtzdGFydDEgKyBsZW5ndGgxIC0gMV0sIGFycmF5LCBzdGFydDIsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgxIDw9IGxlbmd0aDIpIHtcbiAgICAgICAgICB0aGlzLm1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFRpbVNvcnQucHJvdG90eXBlLm1lcmdlTG93ID0gZnVuY3Rpb24gbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLnRtcDtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJzb3IxID0gMDtcbiAgICAgICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgICAgIHZhciBkZXN0ID0gc3RhcnQxO1xuICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pbkdhbGxvcCA9IHRoaXMubWluR2FsbG9wO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICAgICAgdmFyIGNvdW50MiA9IDA7XG4gICAgICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlKGFycmF5W2N1cnNvcjJdLCB0bXBbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcbiAgICAgICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG4gICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgbWluR2FsbG9wKTtcblxuICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb3VudDEgPSBnYWxsb3BSaWdodChhcnJheVtjdXJzb3IyXSwgdG1wLCBjdXJzb3IxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgICAgIGN1cnNvcjEgKz0gY291bnQxO1xuICAgICAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcblxuICAgICAgICAgICAgICBpZiAobGVuZ3RoMSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb3VudDIgPSBnYWxsb3BMZWZ0KHRtcFtjdXJzb3IxXSwgYXJyYXksIGN1cnNvcjIsIGxlbmd0aDIsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlc3QgKz0gY291bnQyO1xuICAgICAgICAgICAgICBjdXJzb3IyICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG5cbiAgICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaW5HYWxsb3AtLTtcbiAgICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtaW5HYWxsb3AgPCAwKSB7XG4gICAgICAgICAgICBtaW5HYWxsb3AgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1pbkdhbGxvcCArPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICAgICAgaWYgKG1pbkdhbGxvcCA8IDEpIHtcbiAgICAgICAgICB0aGlzLm1pbkdhbGxvcCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgVGltU29ydC5wcm90b3R5cGUubWVyZ2VIaWdoID0gZnVuY3Rpb24gbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgIHZhciBjb21wYXJlID0gdGhpcy5jb21wYXJlO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICB2YXIgdG1wID0gdGhpcy50bXA7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQyICsgaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgICAgICB2YXIgY3Vyc29yMiA9IGxlbmd0aDIgLSAxO1xuICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgICAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICAgICAgdmFyIGN1c3RvbURlc3QgPSAwO1xuICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluR2FsbG9wID0gdGhpcy5taW5HYWxsb3A7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgY291bnQxID0gMDtcbiAgICAgICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBtaW5HYWxsb3ApO1xuXG4gICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50MSA9IGxlbmd0aDEgLSBnYWxsb3BSaWdodCh0bXBbY3Vyc29yMl0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIGxlbmd0aDEgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MTtcbiAgICAgICAgICAgICAgY3Vyc29yMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvdW50MiA9IGxlbmd0aDIgLSBnYWxsb3BMZWZ0KGFycmF5W2N1cnNvcjFdLCB0bXAsIDAsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICAgICAgY3Vyc29yMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjIgKyAxO1xuXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IHRtcFtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChsZW5ndGgyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcC0tO1xuICAgICAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgICAgIG1pbkdhbGxvcCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWluR2FsbG9wICs9IDI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1pbkdhbGxvcCA9IG1pbkdhbGxvcDtcblxuICAgICAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgICAgIHRoaXMubWluR2FsbG9wID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gVGltU29ydDtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBzb3J0KGFycmF5LCBjb21wYXJlLCBsbywgaGkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuIG9ubHkgc29ydCBhcnJheXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb21wYXJlKSB7XG4gICAgICAgIGNvbXBhcmUgPSBhbHBoYWJldGljYWxDb21wYXJlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoaSA9IGxvO1xuICAgICAgICBsbyA9IGNvbXBhcmU7XG4gICAgICAgIGNvbXBhcmUgPSBhbHBoYWJldGljYWxDb21wYXJlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxvKSB7XG4gICAgICAgIGxvID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoaSkge1xuICAgICAgICBoaSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgICAgIGlmIChyZW1haW5pbmcgPCAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJ1bkxlbmd0aCA9IDA7XG5cbiAgICAgIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHMgPSBuZXcgVGltU29ydChhcnJheSwgY29tcGFyZSk7XG4gICAgICB2YXIgbWluUnVuID0gbWluUnVuTGVuZ3RoKHJlbWFpbmluZyk7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICAgICAgdmFyIGZvcmNlID0gcmVtYWluaW5nO1xuXG4gICAgICAgICAgaWYgKGZvcmNlID4gbWluUnVuKSB7XG4gICAgICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgbG8gKyBmb3JjZSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHMucHVzaFJ1bihsbywgcnVuTGVuZ3RoKTtcbiAgICAgICAgdHMubWVyZ2VSdW5zKCk7XG4gICAgICAgIHJlbWFpbmluZyAtPSBydW5MZW5ndGg7XG4gICAgICAgIGxvICs9IHJ1bkxlbmd0aDtcbiAgICAgIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgICAgIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgdGltc29ydCQxID0gdGltc29ydDtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHMoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mJDUoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mJDUodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IGNvbnN0cnVjdCQzKFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHMoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY29uc3RydWN0JDMpIHJldHVybiBmYWxzZTsgaWYgKGNvbnN0cnVjdCQzLnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25zdHJ1Y3QkMyhEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbi8qKlxuICogSW50ZXJmYWNlIGRlZmluaXRpb24gZm9yIGRpcmVjdGlvbiBzdHJhdGVneSBjbGFzc2VzLlxuICpcbiAqIFRoaXMgY2xhc3MgZGVzY3JpYmVzIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBTdHJhdGVneVxuICogcGF0dGVybiBjbGFzc2VzIHVzZWQgdG8gZGlmZmVyZW50aWF0ZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbFxuICogZGlyZWN0aW9uIG9mIGhpZXJhcmNoaWNhbCByZXN1bHRzLlxuICpcbiAqIEZvciBhIGdpdmVuIGRpcmVjdGlvbiwgb25lIGNvb3JkaW5hdGUgd2lsbCBiZSAnZml4ZWQnLCBtZWFuaW5nIHRoYXQgaXQgaXNcbiAqIGRldGVybWluZWQgYnkgbGV2ZWwuXG4gKiBUaGUgb3RoZXIgY29vcmRpbmF0ZSBpcyAndW5maXhlZCcsIG1lYW5pbmcgdGhhdCB0aGUgbm9kZXMgb24gYSBnaXZlbiBsZXZlbFxuICogY2FuIHN0aWxsIG1vdmUgYWxvbmcgdGhhdCBjb29yZGluYXRlLiBTbzpcbiAqXG4gKiAtIGB2ZXJ0aWNhbGAgbGF5b3V0OiBgeGAgdW5maXhlZCwgYHlgIGZpeGVkIHBlciBsZXZlbFxuICogLSBgaG9yaXpvbnRhbGAgbGF5b3V0OiBgeGAgZml4ZWQgcGVyIGxldmVsLCBgeWAgdW5maXhlZFxuICpcbiAqIFRoZSBsb2NhbCBtZXRob2RzIGFyZSBzdHVicyBhbmQgc2hvdWxkIGJlIHJlZ2FyZGVkIGFzIGFic3RyYWN0LlxuICogRGVyaXZlZCBjbGFzc2VzICoqbXVzdCoqIGltcGxlbWVudCBhbGwgdGhlIG1ldGhvZHMgdGhlbXNlbHZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBEaXJlY3Rpb25JbnRlcmZhY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaXJlY3Rpb25JbnRlcmZhY2UoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlyZWN0aW9uSW50ZXJmYWNlKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKERpcmVjdGlvbkludGVyZmFjZSwgW3tcbiAgICBrZXk6IFwiYWJzdHJhY3RcIixcblxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyFcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBkdW1teSBjYWxsIHdoaWNoIGlzIHVzZWQgdG8gc3VwcHJlc3MgdGhlIGpzZG9jIGVycm9ycyBvZiB0eXBlOlxuICAgICAqXG4gICAgICogICBcIidwYXJhbScgaXMgYXNzaWduZWQgYSB2YWx1ZSBidXQgbmV2ZXIgdXNlZFwiXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFrZV91c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFrZV91c2UoKSB7Ly8gRG8gbm90aGluZyBzcGVjaWFsXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR5cGUgdG8gdXNlIHRvIHRyYW5zbGF0ZSBkeW5hbWljIGN1cnZlcyB0bywgaW4gdGhlIGNhc2Ugb2YgaGllcmFyY2hpY2FsIGxheW91dC5cbiAgICAgKiBEeW5hbWljIGN1cnZlcyBkbyBub3Qgd29yayBmb3IgdGhlc2UuXG4gICAgICpcbiAgICAgKiBUaGUgdmFsdWUgc2hvdWxkIGJlIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGFjdHVhbCBkaXJlY3Rpb24gb2YgdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IERpcmVjdGlvbiwgZWl0aGVyICd2ZXJ0aWNhbCcgb3IgJ2hvcml6b250YWwnXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjdXJ2ZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VydmVUeXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0aGF0IGlzIG5vdCBmaXhlZCBmb3IgdGhpcyBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVhZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIG9mIHRoZSB1bmZpeGVkIGNvb3JkaW5hdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZSk7XG4gICAgICByZXR1cm4gdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRoYXQgaXMgbm90IGZpeGVkIGZvciB0aGlzIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBhZGp1c3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xldmVsXSBpZiBzcGVjaWZpZWQsIHRoZSBoaWVyYXJjaHkgbGV2ZWwgdGhhdCB0aGlzIG5vZGUgc2hvdWxkIGJlIGZpeGVkIHRvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihub2RlLCBwb3NpdGlvbikge1xuICAgICAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGUsIHBvc2l0aW9uLCBsZXZlbCk7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgd2lkdGggb2YgYSB0cmVlLlxuICAgICAqXG4gICAgICogQSBgdHJlZWAgaGVyZSBpcyBhIHN1YnNldCBvZiBub2RlcyB3aXRoaW4gdGhlIG5ldHdvcmsgd2hpY2ggYXJlIG5vdCBjb25uZWN0ZWQgdG8gb3RoZXIgbm9kZXMsXG4gICAgICogb25seSBhbW9uZyB0aGVtc2VsdmVzLiBJbiBlc3NlbmNlLCBpdCBpcyBhIHN1Yi1uZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBudW1iZXIgb2YgYSB0cmVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gdGhlIHdpZHRoIG9mIGEgdHJlZSBpbiB0aGUgdmlldyBjb29yZGluYXRlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJlZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJlZVNpemUoaW5kZXgpIHtcbiAgICAgIHRoaXMuZmFrZV91c2UoaW5kZXgpO1xuICAgICAgcmV0dXJuIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydCBhcnJheSBvZiBub2RlcyBvbiB0aGUgdW5maXhlZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBjaHJvbWUgaGFzIG5vbi1zdGFibGUgc29ydGluZyBpbXBsZW1lbnRhdGlvbiwgd2hpY2hcbiAgICAgKiBoYXMgYSB0ZW5kZW5jeSB0byBjaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBhcnJheSBpdGVtcyxcbiAgICAgKiBldmVuIGlmIHRoZSBjdXN0b20gc29ydCBmdW5jdGlvbiByZXR1cm5zIDAuXG4gICAgICpcbiAgICAgKiBGb3IgdGhpcyByZWFzb24sIGFuIGV4dGVybmFsIHNvcnQgaW1wbGVtZW50YXRpb24gaXMgdXNlZCxcbiAgICAgKiB3aGljaCBoYXMgdGhlIGFkZGVkIGJlbmVmaXQgb2YgYmVpbmcgZmFzdGVyIHRoYW4gdGhlIHN0YW5kYXJkXG4gICAgICogcGxhdGZvcm1zIGltcGxlbWVudGF0aW9uLiBUaGlzIGhhcyBiZWVuIHZlcmlmaWVkIG9uIGBub2RlLmpzYCxcbiAgICAgKiBgZmlyZWZveGAgYW5kIGBjaHJvbWVgIChhbGwgbGludXgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVBcnJheSBhcnJheSBvZiBub2RlcyB0byBzb3J0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGVBcnJheSk7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbiB0aGUgZml4ZWQgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSB0byB0aGUgZ2l2ZW4gbGV2ZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBhZGp1c3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgVGhlIGxldmVsIHRvIGZpeCB0b1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlLCBsZXZlbCk7XG4gICAgICB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBvZmZzZXQgdG8gdGhlIHVuZml4ZWQgY29vcmRpbmF0ZSBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZUlkfSBub2RlSWQgSWQgb2YgdGhlIG5vZGUgdG8gYWRqdXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpZmYgT2Zmc2V0IHRvIGFkZCB0byB0aGUgdW5maXhlZCBjb29yZGluYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdChub2RlSWQsIGRpZmYpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZUlkLCBkaWZmKTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGlyZWN0aW9uSW50ZXJmYWNlO1xufSgpO1xuLyoqXG4gKiBWZXJ0aWNhbCBTdHJhdGVneVxuICpcbiAqIENvb3JkaW5hdGUgYHlgIGlzIGZpeGVkIG9uIGxldmVscywgY29vcmRpbmF0ZSBgeGAgaXMgdW5maXhlZC5cbiAqXG4gKiBAYXVnbWVudHMgRGlyZWN0aW9uSW50ZXJmYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIFZlcnRpY2FsU3RyYXRlZ3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXJlY3Rpb25JbnRlcmZhY2UpIHtcbiAgaW5oZXJpdHMoVmVydGljYWxTdHJhdGVneSwgX0RpcmVjdGlvbkludGVyZmFjZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRzKFZlcnRpY2FsU3RyYXRlZ3kpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0IHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IExheW91dEVuZ2luZSBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIFZlcnRpY2FsU3RyYXRlZ3kobGF5b3V0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVmVydGljYWxTdHJhdGVneSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLmxheW91dCA9IGxheW91dDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG5cblxuICBjcmVhdGVDbGFzcyhWZXJ0aWNhbFN0cmF0ZWd5LCBbe1xuICAgIGtleTogXCJjdXJ2ZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VydmVUeXBlKCkge1xuICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLng7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUueCA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRyZWVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyZWVTaXplKGluZGV4KSB7XG4gICAgICB2YXIgcmVzID0gdGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmdldFRyZWVTaXplKHRoaXMubGF5b3V0LmJvZHkubm9kZXMsIGluZGV4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogcmVzLm1pbl94LFxuICAgICAgICBtYXg6IHJlcy5tYXhfeFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICB0aW1zb3J0JDEuc29ydChub2RlQXJyYXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnggLSBiLng7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4KG5vZGUsIGxldmVsKSB7XG4gICAgICBub2RlLnkgPSB0aGlzLmxheW91dC5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBsZXZlbDtcbiAgICAgIG5vZGUub3B0aW9ucy5maXhlZC55ID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdChub2RlSWQsIGRpZmYpIHtcbiAgICAgIHRoaXMubGF5b3V0LmJvZHkubm9kZXNbbm9kZUlkXS54ICs9IGRpZmY7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZlcnRpY2FsU3RyYXRlZ3k7XG59KERpcmVjdGlvbkludGVyZmFjZSk7XG4vKipcbiAqIEhvcml6b250YWwgU3RyYXRlZ3lcbiAqXG4gKiBDb29yZGluYXRlIGB4YCBpcyBmaXhlZCBvbiBsZXZlbHMsIGNvb3JkaW5hdGUgYHlgIGlzIHVuZml4ZWQuXG4gKlxuICogQGF1Z21lbnRzIERpcmVjdGlvbkludGVyZmFjZVxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBIb3Jpem9udGFsU3RyYXRlZ3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXJlY3Rpb25JbnRlcmZhY2UyKSB7XG4gIGluaGVyaXRzKEhvcml6b250YWxTdHJhdGVneSwgX0RpcmVjdGlvbkludGVyZmFjZTIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyJHMoSG9yaXpvbnRhbFN0cmF0ZWd5KTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxheW91dCByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBMYXlvdXRFbmdpbmUgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBIb3Jpem9udGFsU3RyYXRlZ3kobGF5b3V0KSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEhvcml6b250YWxTdHJhdGVneSk7XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMyLmxheW91dCA9IGxheW91dDtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoSG9yaXpvbnRhbFN0cmF0ZWd5LCBbe1xuICAgIGtleTogXCJjdXJ2ZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VydmVUeXBlKCkge1xuICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS55O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmFkZFRvT3JkZXJpbmcobm9kZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnkgPSBwb3NpdGlvbjtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmVlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5nZXRUcmVlU2l6ZSh0aGlzLmxheW91dC5ib2R5Lm5vZGVzLCBpbmRleCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHJlcy5taW5feSxcbiAgICAgICAgbWF4OiByZXMubWF4X3lcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic29ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KG5vZGVBcnJheSkge1xuICAgICAgdGltc29ydCQxLnNvcnQobm9kZUFycmF5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS55IC0gYi55O1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeChub2RlLCBsZXZlbCkge1xuICAgICAgbm9kZS54ID0gdGhpcy5sYXlvdXQub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogbGV2ZWw7XG4gICAgICBub2RlLm9wdGlvbnMuZml4ZWQueCA9IHRydWU7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQobm9kZUlkLCBkaWZmKSB7XG4gICAgICB0aGlzLmxheW91dC5ib2R5Lm5vZGVzW25vZGVJZF0ueSArPSBkaWZmO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIb3Jpem9udGFsU3RyYXRlZ3k7XG59KERpcmVjdGlvbkludGVyZmFjZSk7XG5cbnZhciAkZXZlcnkgPSBhcnJheUl0ZXJhdGlvbi5ldmVyeTtcbnZhciBTVFJJQ1RfTUVUSE9EJDUgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdldmVyeScpO1xudmFyIFVTRVNfVE9fTEVOR1RIJDkgPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCgnZXZlcnknKTsgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcblxuX2V4cG9ydCh7XG4gIHRhcmdldDogJ0FycmF5JyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogIVNUUklDVF9NRVRIT0QkNSB8fCAhVVNFU19UT19MRU5HVEgkOVxufSwge1xuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZXZlcnkgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykuZXZlcnk7XG5cbnZhciBBcnJheVByb3RvdHlwZSRmID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgZXZlcnlfMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZXZlcnk7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkZiB8fCBpdCBpbnN0YW5jZW9mIEFycmF5ICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkZi5ldmVyeSA/IGV2ZXJ5IDogb3duO1xufTtcblxudmFyIGV2ZXJ5JDEgPSBldmVyeV8xO1xuXG52YXIgZXZlcnkkMiA9IGV2ZXJ5JDE7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIHN5bWJvbCQ0ID09PSBcInVuZGVmaW5lZFwiIHx8IGdldEl0ZXJhdG9yTWV0aG9kJDEobykgPT0gbnVsbCkgeyBpZiAoaXNBcnJheSQ1KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gZ2V0SXRlcmF0b3IkMShvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDcobywgbWluTGVuKSB7IHZhciBfY29udGV4dDk7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ3KG8sIG1pbkxlbik7IHZhciBuID0gc2xpY2UkNShfY29udGV4dDkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQ5LCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBmcm9tXzEkMihvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ3KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyoqXHJcbiAqIFRyeSB0byBhc3NpZ24gbGV2ZWxzIHRvIG5vZGVzIGFjY29yZGluZyB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGN5Y2xpYyDigJxoaWVyYXJjaHnigJ0uXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlcyAtIFZpc2libGUgbm9kZXMgb2YgdGhlIGdyYXBoLlxyXG4gKiBAcGFyYW0gbGV2ZWxzIC0gSWYgcHJlc2VudCBsZXZlbHMgd2lsbCBiZSBhZGRlZCB0byBpdCwgaWYgbm90IGEgbmV3IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFBvcHVsYXRlZCBub2RlIGxldmVscy5cclxuICovXG5mdW5jdGlvbiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25DeWNsaWMobm9kZXMsIGxldmVscykge1xuICB2YXIgZWRnZXMgPSBuZXcgc2V0JDMoKTtcblxuICBmb3JFYWNoJDIobm9kZXMpLmNhbGwobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIF9jb250ZXh0O1xuXG4gICAgZm9yRWFjaCQyKF9jb250ZXh0ID0gbm9kZS5lZGdlcykuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCkge1xuICAgICAgICBlZGdlcy5hZGQoZWRnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZvckVhY2gkMihlZGdlcykuY2FsbChlZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgZnJvbUlkID0gZWRnZS5mcm9tLmlkO1xuICAgIHZhciB0b0lkID0gZWRnZS50by5pZDtcblxuICAgIGlmIChsZXZlbHNbZnJvbUlkXSA9PSBudWxsKSB7XG4gICAgICBsZXZlbHNbZnJvbUlkXSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGxldmVsc1t0b0lkXSA9PSBudWxsIHx8IGxldmVsc1tmcm9tSWRdID49IGxldmVsc1t0b0lkXSkge1xuICAgICAgbGV2ZWxzW3RvSWRdID0gbGV2ZWxzW2Zyb21JZF0gKyAxO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxldmVscztcbn1cbi8qKlxyXG4gKiBBc3NpZ24gbGV2ZWxzIHRvIG5vZGVzIGFjY29yZGluZyB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGhpZXJhcmNoeS4gTGVhdmVzIHdpbGwgYmUgbGluZWQgdXAgYXQgdGhlIGJvdHRvbSBhbmQgYWxsIG90aGVyIG5vZGVzIGFzIGNsb3NlIHRvIHRoZWlyIGNoaWxkcmVuIGFzIHBvc3NpYmxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZXMgLSBWaXNpYmxlIG5vZGVzIG9mIHRoZSBncmFwaC5cclxuICpcclxuICogQHJldHVybnMgUG9wdWxhdGVkIG5vZGUgbGV2ZWxzLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25MZWF2ZXMobm9kZXMpIHtcbiAgcmV0dXJuIGZpbGxMZXZlbHNCeURpcmVjdGlvbiggLy8gUGljayBvbmx5IGxlYXZlcyAobm9kZXMgd2l0aG91dCBjaGlsZHJlbikuXG4gIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIF9jb250ZXh0MiwgX2NvbnRleHQzO1xuXG4gICAgcmV0dXJuIGV2ZXJ5JDIoX2NvbnRleHQyID0gZmlsdGVyJDIoX2NvbnRleHQzID0gbm9kZS5lZGdlcyAvLyBUYWtlIG9ubHkgdmlzaWJsZSBub2RlcyBpbnRvIGFjY291bnQuXG4gICAgKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBub2Rlcy5oYXMoZWRnZS50b0lkKTtcbiAgICB9KSAvLyBDaGVjayB0aGF0IGFsbCBlZGdlcyBsZWFkIHRvIHRoaXMgbm9kZSAobGVhZikuXG4gICAgKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLnRvID09PSBub2RlO1xuICAgIH0pO1xuICB9LCAvLyBVc2UgdGhlIGxvd2VzdCBsZXZlbC5cbiAgZnVuY3Rpb24gKG5ld0xldmVsLCBvbGRMZXZlbCkge1xuICAgIHJldHVybiBvbGRMZXZlbCA+IG5ld0xldmVsO1xuICB9LCAvLyBHbyBhZ2FpbnN0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzLlxuICBcImZyb21cIiwgbm9kZXMpO1xufVxuLyoqXHJcbiAqIEFzc2lnbiBsZXZlbHMgdG8gbm9kZXMgYWNjb3JkaW5nIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgaGllcmFyY2h5LiBSb290cyB3aWxsIGJlIGxpbmVkIHVwIGF0IHRoZSB0b3AgYW5kIGFsbCBub2RlcyBhcyBjbG9zZSB0byB0aGVpciBwYXJlbnRzIGFzIHBvc3NpYmxlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZXMgLSBWaXNpYmxlIG5vZGVzIG9mIHRoZSBncmFwaC5cclxuICpcclxuICogQHJldHVybnMgUG9wdWxhdGVkIG5vZGUgbGV2ZWxzLlxyXG4gKi9cblxuZnVuY3Rpb24gZmlsbExldmVsc0J5RGlyZWN0aW9uUm9vdHMobm9kZXMpIHtcbiAgcmV0dXJuIGZpbGxMZXZlbHNCeURpcmVjdGlvbiggLy8gUGljayBvbmx5IHJvb3RzIChub2RlcyB3aXRob3V0IHBhcmVudHMpLlxuICBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfY29udGV4dDQsIF9jb250ZXh0NTtcblxuICAgIHJldHVybiBldmVyeSQyKF9jb250ZXh0NCA9IGZpbHRlciQyKF9jb250ZXh0NSA9IG5vZGUuZWRnZXMgLy8gVGFrZSBvbmx5IHZpc2libGUgbm9kZXMgaW50byBhY2NvdW50LlxuICAgICkuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gbm9kZXMuaGFzKGVkZ2UudG9JZCk7XG4gICAgfSkgLy8gQ2hlY2sgdGhhdCBhbGwgZWRnZXMgbGVhZCBmcm9tIHRoaXMgbm9kZSAocm9vdCkuXG4gICAgKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLmZyb20gPT09IG5vZGU7XG4gICAgfSk7XG4gIH0sIC8vIFVzZSB0aGUgaGlnaGVzdCBsZXZlbC5cbiAgZnVuY3Rpb24gKG5ld0xldmVsLCBvbGRMZXZlbCkge1xuICAgIHJldHVybiBvbGRMZXZlbCA8IG5ld0xldmVsO1xuICB9LCAvLyBHbyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlcy5cbiAgXCJ0b1wiLCBub2Rlcyk7XG59XG4vKipcclxuICogQXNzaWduIGxldmVscyB0byBub2RlcyBhY2NvcmRpbmcgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBoaWVyYXJjaHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBpc0VudHJ5Tm9kZSAtIENoZWNrcyBhbmQgcmV0dXJuIHRydWUgaWYgdGhlIGdyYXBoIHNob3VsZCBiZSB0cmF2ZXJzZWQgZnJvbSB0aGlzIG5vZGUuXHJcbiAqIEBwYXJhbSBzaG91bGRMZXZlbEJlUmVwbGFjZWQgLSBDaGVja3MgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGV2ZWwgb2YgZ2l2ZW4gbm9kZSBzaG91bGQgYmUgdXBkYXRlZCB0byB0aGUgbmV3IHZhbHVlLlxyXG4gKiBAcGFyYW0gZGlyZWN0aW9uIC0gV2hldGVyIHRoZSBncmFwaCBzaG91bGQgYmUgdHJhdmVyc2VkIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzIGBcInRvXCJgIG9yIGluIHRoZSBvdGhlciB3YXkgYFwiZnJvbVwiYC5cclxuICogQHBhcmFtIG5vZGVzIC0gVmlzaWJsZSBub2RlcyBvZiB0aGUgZ3JhcGguXHJcbiAqXHJcbiAqIEByZXR1cm5zIFBvcHVsYXRlZCBub2RlIGxldmVscy5cclxuICovXG5cbmZ1bmN0aW9uIGZpbGxMZXZlbHNCeURpcmVjdGlvbihpc0VudHJ5Tm9kZSwgc2hvdWxkTGV2ZWxCZVJlcGxhY2VkLCBkaXJlY3Rpb24sIG5vZGVzKSB7XG4gIHZhciBfY29udGV4dDY7XG5cbiAgdmFyIGxldmVscyA9IGNyZWF0ZSQyKG51bGwpOyAvLyBJZiBhY3ljbGljLCB0aGUgZ3JhcGggY2FuIGJlIHdhbGtlZCB0aHJvdWdoIHdpdGggKG1vc3QgbGlrZWx5IHdheSkgZmV3ZXJcbiAgLy8gc3RlcHMgdGhhbiB0aGUgbnVtYmVyIGJlbGxvdy4gVGhlIGV4YWN0IHZhbHVlIGlzbid0IHRvbyBpbXBvcnRhbnQgYXMgbG9uZ1xuICAvLyBhcyBpdCdzIHF1aWNrIHRvIGNvbXB1dGUgKGRvZXNuJ3QgaW1wYWN0IGFjeWNsaWMgZ3JhcGhzIHRvbyBtdWNoKSwgaXNcbiAgLy8gaGlnaGVyIHRoYW4gdGhlIG51bWJlciBvZiBzdGVwcyBhY3R1YWxseSBuZWVkZWQgKGRvZXNuJ3QgY3V0IG9mZiBiZWZvcmVcbiAgLy8gYWN5Y2xpYyBncmFwaCBpcyB3YWxrZWQgdGhyb3VnaCkgYW5kIHByZXZlbnRzIGluZmluaXRlIGxvb3BzIChjdXRzIG9mZiBmb3JcbiAgLy8gY3ljbGljIGdyYXBocykuXG5cblxuICB2YXIgbGltaXQgPSByZWR1Y2UkMihfY29udGV4dDYgPSB0b0NvbnN1bWFibGVBcnJheSh2YWx1ZXMkMyhub2RlcykuY2FsbChub2RlcykpKS5jYWxsKF9jb250ZXh0NiwgZnVuY3Rpb24gKGFjYywgbm9kZSkge1xuICAgIHJldHVybiBhY2MgKyAxICsgbm9kZS5lZGdlcy5sZW5ndGg7XG4gIH0sIDApO1xuXG4gIHZhciBlZGdlSWRQcm9wID0gZGlyZWN0aW9uICsgXCJJZFwiO1xuICB2YXIgbmV3TGV2ZWxEaWZmID0gZGlyZWN0aW9uID09PSBcInRvXCIgPyAxIDogLTE7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYobm9kZXMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IHNsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgIGVudHJ5Tm9kZUlkID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgZW50cnlOb2RlID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgIGlmICggLy8gU2tpcCBpZiB0aGUgbm9kZSBpcyBub3QgdmlzaWJsZS5cbiAgICAgICFub2Rlcy5oYXMoZW50cnlOb2RlSWQpIHx8IC8vIFNraXAgaWYgdGhlIG5vZGUgaXMgbm90IGFuIGVudHJ5IG5vZGUuXG4gICAgICAhaXNFbnRyeU5vZGUoZW50cnlOb2RlKSkge1xuICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgfSAvLyBMaW5lIHVwIGFsbCB0aGUgZW50cnkgbm9kZXMgb24gbGV2ZWwgMC5cblxuXG4gICAgICBsZXZlbHNbZW50cnlOb2RlSWRdID0gMDtcbiAgICAgIHZhciBzdGFjayA9IFtlbnRyeU5vZGVdO1xuICAgICAgdmFyIGRvbmUgPSAwO1xuICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICAgIHZhciBfY29udGV4dDcsIF9jb250ZXh0ODtcblxuICAgICAgICBpZiAoIW5vZGVzLmhhcyhlbnRyeU5vZGVJZCkpIHtcbiAgICAgICAgICAvLyBTa2lwIGlmIHRoZSBub2RlIGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3TGV2ZWwgPSBsZXZlbHNbbm9kZS5pZF0gKyBuZXdMZXZlbERpZmY7XG5cbiAgICAgICAgZm9yRWFjaCQyKF9jb250ZXh0NyA9IGZpbHRlciQyKF9jb250ZXh0OCA9IG5vZGUuZWRnZXMpLmNhbGwoX2NvbnRleHQ4LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHJldHVybiAoLy8gSWdub3JlIGRpc2Nvbm5lY3RlZCBlZGdlcy5cbiAgICAgICAgICAgIGVkZ2UuY29ubmVjdGVkICYmIC8vIElnbm9yZSBjaXJjdWxhciBlZGdlcy5cbiAgICAgICAgICAgIGVkZ2UudG8gIT09IGVkZ2UuZnJvbSAmJiAvLyBJZ25vcmUgZWRnZXMgbGVhZGluZyB0byB0aGUgbm9kZSB0aGF0J3MgY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICAgIGVkZ2VbZGlyZWN0aW9uXSAhPT0gbm9kZSAmJiAvLyBJZ25vcmUgZWRnZXMgY29ubmVjdGluZyB0byBhbiBpbnZpc2libGUgbm9kZS5cbiAgICAgICAgICAgIG5vZGVzLmhhcyhlZGdlLnRvSWQpICYmIC8vIElnbm9yZSBlZGdlcyBjb25uZWN0aW5nIGZyb20gYW4gaW52aXNpYmxlIG5vZGUuXG4gICAgICAgICAgICBub2Rlcy5oYXMoZWRnZS5mcm9tSWQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSkpLmNhbGwoX2NvbnRleHQ3LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHZhciB0YXJnZXROb2RlSWQgPSBlZGdlW2VkZ2VJZFByb3BdO1xuICAgICAgICAgIHZhciBvbGRMZXZlbCA9IGxldmVsc1t0YXJnZXROb2RlSWRdO1xuXG4gICAgICAgICAgaWYgKG9sZExldmVsID09IG51bGwgfHwgc2hvdWxkTGV2ZWxCZVJlcGxhY2VkKG5ld0xldmVsLCBvbGRMZXZlbCkpIHtcbiAgICAgICAgICAgIGxldmVsc1t0YXJnZXROb2RlSWRdID0gbmV3TGV2ZWw7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGVkZ2VbZGlyZWN0aW9uXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZG9uZSA+IGxpbWl0KSB7XG4gICAgICAgICAgLy8gVGhpcyB3b3VsZCBydW4gZm9yZXZlciBvbiBhIGN5Y2xpYyBncmFwaC5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjoge1xuICAgICAgICAgICAgICB2OiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25DeWNsaWMobm9kZXMsIGxldmVscylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrZG9uZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgd2hpbGUgKG5vZGUgPSBzdGFjay5wb3AoKSkge1xuICAgICAgICB2YXIgX3JldDIgPSBfbG9vcDIoKTtcblxuICAgICAgICBpZiAoX3JldDIgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICAgIGlmIChfdHlwZW9mXzEoX3JldDIpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldDIudjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICBpZiAoX3R5cGVvZl8xKF9yZXQpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIGxldmVscztcbn1cblxuLyoqXG4gKiBUaGVyZSdzIGEgbWl4LXVwIHdpdGggdGVybXMgaW4gdGhlIGNvZGUuIEZvbGxvd2luZyBhcmUgdGhlIGZvcm1hbCBkZWZpbml0aW9uczpcbiAqXG4gKiAgIHRyZWUgICAtIGEgc3RyaWN0IGhpZXJhcmNoaWNhbCBuZXR3b3JrLCBpLmUuIGV2ZXJ5IG5vZGUgaGFzIGF0IG1vc3Qgb25lIHBhcmVudFxuICogICBmb3Jlc3QgLSBhIGNvbGxlY3Rpb24gb2YgdHJlZXMuIFRoZXNlIGRpc3RpbmN0IHRyZWVzIGFyZSB0aHVzIG5vdCBjb25uZWN0ZWQuXG4gKlxuICogU286XG4gKiAtIGluIGEgbmV0d29yayB0aGF0IGlzIG5vdCBhIHRyZWUsIHRoZXJlIGV4aXN0IG5vZGVzIHdpdGggbXVsdGlwbGUgcGFyZW50cy5cbiAqIC0gYSBuZXR3b3JrIGNvbnNpc3Rpbmcgb2YgdW5jb25uZWN0ZWQgc3ViLW5ldHdvcmtzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmVcbiAqICAgaXMgbm90IGEgdHJlZSwgaXMgbm90IGEgZm9yZXN0LlxuICpcbiAqIEluIHRoZSBjb2RlLCB0aGUgZGVmaW5pdGlvbnMgYXJlOlxuICpcbiAqICAgdHJlZSAgIC0gYW55IGRpc2Nvbm5lY3RlZCBzdWItbmV0d29yaywgc3RyaWN0IGhpZXJhcmNoaWNhbCBvciBub3QuXG4gKiAgIGZvcmVzdCAtIGEgYnVuY2ggb2YgdGhlc2Ugc3ViLW5ldHdvcmtzXG4gKlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0cmVlIGFuZCBub3QtdHJlZSBpcyBpbXBvcnRhbnQgaW4gdGhlIGNvZGUsIG5vdGFibHkgd2l0aGluXG4gKiB0byB0aGUgYmxvY2stc2hpZnRpbmcgYWxnb3JpdGhtLiBUaGUgYWxnb3JpdGhtIGFzc3VtZXMgZm9ybWFsIHRyZWVzIGFuZCBmYWlsc1xuICogZm9yIG5vdC10cmVlcywgb2Z0ZW4gaW4gYSBzcGVjdGFjdWxhciBtYW5uZXIgKHNlYXJjaCBmb3IgJ2V4cGxvZGluZyBuZXR3b3JrJyBpbiB0aGUgaXNzdWVzKS5cbiAqXG4gKiBJbiBvcmRlciB0byBkaXN0aW5ndWlzaCB0aGUgZGVmaW5pdGlvbnMgaW4gdGhlIGZvbGxvd2luZyBjb2RlLCB0aGUgYWRqZWN0aXZlICdmb3JtYWwnIGlzXG4gKiB1c2VkLiBJZiAnZm9ybWFsJyBpcyBhYnNlbnQsIHlvdSBtdXN0IGFzc3VtZSB0aGUgbm9uLWZvcm1hbCBkZWZpbml0aW9uLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIE5PVEVTXG4gKiA9PT09PVxuICpcbiAqIEEgaGllcmFyY2hpY2FsIGxheW91dCBpcyBhIGRpZmZlcmVudCB0aGluZyBmcm9tIGEgaGllcmFyY2hpY2FsIG5ldHdvcmsuXG4gKiBUaGUgbGF5b3V0IGlzIGEgd2F5IHRvIGFycmFuZ2UgdGhlIG5vZGVzIGluIHRoZSB2aWV3OyB0aGlzIGNhbiBiZSBkb25lXG4gKiBvbiBub24taGllcmFyY2hpY2FsIG5ldHdvcmtzIGFzIHdlbGwuIFRoZSBjb252ZXJzZSBpcyBhbHNvIHBvc3NpYmxlLlxuICovXG4vKipcbiAqIENvbnRhaW5lciBmb3IgZGVyaXZlZCBkYXRhIG9uIGN1cnJlbnQgbmV0d29yaywgcmVsYXRpbmcgdG8gaGllcmFyY2h5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEhpZXJhcmNoaWNhbFN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBIaWVyYXJjaGljYWxTdGF0dXMoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSGllcmFyY2hpY2FsU3RhdHVzKTtcblxuICAgIHRoaXMuY2hpbGRyZW5SZWZlcmVuY2UgPSB7fTsgLy8gY2hpbGQgaWQncyBwZXIgbm9kZSBpZFxuXG4gICAgdGhpcy5wYXJlbnRSZWZlcmVuY2UgPSB7fTsgLy8gcGFyZW50IGlkJ3MgcGVyIG5vZGUgaWRcblxuICAgIHRoaXMudHJlZXMgPSB7fTsgLy8gdHJlZSBpZCBwZXIgbm9kZSBpZDsgaS5lLiB0byB3aGljaCB0cmVlIGRvZXMgZ2l2ZW4gbm9kZSBpZCBiZWxvbmdcblxuICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmcgPSB7fTsgLy8gVGhlIG5vZGVzIHBlciBsZXZlbCwgaW4gdGhlIGRpc3BsYXkgb3JkZXJcblxuICAgIHRoaXMubGV2ZWxzID0ge307IC8vIGhpZXJhcmNoeSBsZXZlbCBwZXIgbm9kZSBpZFxuXG4gICAgdGhpcy5kaXN0cmlidXRpb25JbmRleCA9IHt9OyAvLyBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgaW4gdGhlIGxldmVsIHNvcnRpbmcgb3JkZXIsIHBlciBub2RlIGlkLlxuXG4gICAgdGhpcy5pc1RyZWUgPSBmYWxzZTsgLy8gVHJ1ZSBpZiBjdXJyZW50IG5ldHdvcmsgaXMgYSBmb3JtYWwgdHJlZVxuXG4gICAgdGhpcy50cmVlSW5kZXggPSAtMTsgLy8gSGlnaGVzdCB0cmVlIGlkIGluIGN1cnJlbnQgbmV0d29yay5cbiAgfVxuICAvKipcbiAgICogQWRkIHRoZSByZWxhdGlvbiBiZXR3ZWVuIGdpdmVuIG5vZGVzIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGUuaWR9IHBhcmVudE5vZGVJZFxuICAgKiBAcGFyYW0ge05vZGUuaWR9IGNoaWxkTm9kZUlkXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoSGllcmFyY2hpY2FsU3RhdHVzLCBbe1xuICAgIGtleTogXCJhZGRSZWxhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSZWxhdGlvbihwYXJlbnROb2RlSWQsIGNoaWxkTm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hpbGRyZW5SZWZlcmVuY2VbcGFyZW50Tm9kZUlkXS5wdXNoKGNoaWxkTm9kZUlkKTtcblxuICAgICAgaWYgKHRoaXMucGFyZW50UmVmZXJlbmNlW2NoaWxkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGFyZW50UmVmZXJlbmNlW2NoaWxkTm9kZUlkXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0ucHVzaChwYXJlbnROb2RlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgY3VycmVudCBzdGF0ZSBpcyBmb3IgYSBmb3JtYWwgdHJlZSBvciBmb3JtYWwgZm9yZXN0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgY2FzZSBpZiBldmVyeSBub2RlIGhhcyBhdCBtb3N0IG9uZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBQcmU6IHBhcmVudFJlZmVyZW5jZSBpbml0J2VkIHByb3Blcmx5IGZvciBjdXJyZW50IG5ldHdvcmtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrSWZUcmVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrSWZUcmVlKCkge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnBhcmVudFJlZmVyZW5jZSkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRSZWZlcmVuY2VbaV0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuaXNUcmVlID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNUcmVlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VwYXJhdGUgdHJlZXMgaW4gdGhlIGN1cnJlbnQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJudW1UcmVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBudW1UcmVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyZWVJbmRleCArIDE7IC8vIFRoaXMgYXNzdW1lcyB0aGUgaW5kZXhlcyBhcmUgYXNzaWduZWQgY29uc2VjaXRpdmVseVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gYSB0cmVlIGlkIHRvIGEgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB0cmVlSWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFRyZWVJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUcmVlSW5kZXgobm9kZSwgdHJlZUlkKSB7XG4gICAgICBpZiAodHJlZUlkID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gRG9uJ3QgYm90aGVyXG5cbiAgICAgIGlmICh0aGlzLnRyZWVzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy50cmVlc1tub2RlLmlkXSA9IHRyZWVJZDtcbiAgICAgICAgdGhpcy50cmVlSW5kZXggPSBNYXRoLm1heCh0cmVlSWQsIHRoaXMudHJlZUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIGxldmVsIGZvciBnaXZlbiBpZCBpcyBkZWZpbmVkLlxuICAgICAqXG4gICAgICogU2V0cyBsZXZlbCB0byB6ZXJvIGZvciBnaXZlbiBub2RlIGlkIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbnN1cmVMZXZlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVMZXZlbChub2RlSWQpIHtcbiAgICAgIGlmICh0aGlzLmxldmVsc1tub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUlkXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbWF4aW11bSBsZXZlbCBvZiBhIGJyYW5jaC5cbiAgICAgKlxuICAgICAqIFRPRE86IE5ldmVyIGVudGVyZWQ7IGZpbmQgYSB0ZXN0IGNhc2UgdG8gdGVzdCB0aGlzIVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4TGV2ZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4TGV2ZWwobm9kZUlkKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYWNjdW11bGF0b3IgPSB7fTtcblxuICAgICAgdmFyIF9nZXRNYXhMZXZlbCA9IGZ1bmN0aW9uIF9nZXRNYXhMZXZlbChub2RlSWQpIHtcbiAgICAgICAgaWYgKGFjY3VtdWxhdG9yW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcltub2RlSWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxldmVsID0gX3RoaXMubGV2ZWxzW25vZGVJZF07XG5cbiAgICAgICAgaWYgKF90aGlzLmNoaWxkcmVuUmVmZXJlbmNlW25vZGVJZF0pIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBfdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtub2RlSWRdO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBNYXRoLm1heChsZXZlbCwgX2dldE1heExldmVsKGNoaWxkcmVuW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjdW11bGF0b3Jbbm9kZUlkXSA9IGxldmVsO1xuICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX2dldE1heExldmVsKG5vZGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlQVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZUJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxldmVsRG93bnN0cmVhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXZlbERvd25zdHJlYW0obm9kZUEsIG5vZGVCKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUIuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbGV2ZWxcbiAgICAgICAgaWYgKHRoaXMubGV2ZWxzW25vZGVBLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5sZXZlbHNbbm9kZUEuaWRdID0gMDtcbiAgICAgICAgfSAvLyBzZXQgbGV2ZWxcblxuXG4gICAgICAgIHRoaXMubGV2ZWxzW25vZGVCLmlkXSA9IHRoaXMubGV2ZWxzW25vZGVBLmlkXSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNtYWxsIHV0aWwgbWV0aG9kIHRvIHNldCB0aGUgbWluaW11bSBsZXZlbHMgb2YgdGhlIG5vZGVzIHRvIHplcm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE1pbkxldmVsVG9aZXJvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1pbkxldmVsVG9aZXJvKG5vZGVzKSB7XG4gICAgICB2YXIgbWluTGV2ZWwgPSAxZTk7IC8vIGdldCB0aGUgbWluaW11bSBsZXZlbFxuXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmxldmVsc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1pbkxldmVsID0gTWF0aC5taW4odGhpcy5sZXZlbHNbbm9kZUlkXSwgbWluTGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBzdWJ0cmFjdCB0aGUgbWluaW11bSBmcm9tIHRoZSBzZXQgc28gd2UgaGF2ZSBhIHJhbmdlIHN0YXJ0aW5nIGZyb20gMFxuXG5cbiAgICAgIGZvciAodmFyIF9ub2RlSWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlcywgX25vZGVJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5sZXZlbHNbX25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5sZXZlbHNbX25vZGVJZF0gLT0gbWluTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWluIGFuZCBtYXggeHktY29vcmRpbmF0ZXMgb2YgYSBnaXZlbiB0cmVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e21pbl94OiBudW1iZXIsIG1heF94OiBudW1iZXIsIG1pbl95OiBudW1iZXIsIG1heF95OiBudW1iZXJ9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHJlZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJlZVNpemUobm9kZXMsIGluZGV4KSB7XG4gICAgICB2YXIgbWluX3ggPSAxZTk7XG4gICAgICB2YXIgbWF4X3ggPSAtMWU5O1xuICAgICAgdmFyIG1pbl95ID0gMWU5O1xuICAgICAgdmFyIG1heF95ID0gLTFlOTtcblxuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMudHJlZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnRyZWVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJlZXNbbm9kZUlkXSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIG1pbl94ID0gTWF0aC5taW4obm9kZS54LCBtaW5feCk7XG4gICAgICAgICAgICBtYXhfeCA9IE1hdGgubWF4KG5vZGUueCwgbWF4X3gpO1xuICAgICAgICAgICAgbWluX3kgPSBNYXRoLm1pbihub2RlLnksIG1pbl95KTtcbiAgICAgICAgICAgIG1heF95ID0gTWF0aC5tYXgobm9kZS55LCBtYXhfeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbl94OiBtaW5feCxcbiAgICAgICAgbWF4X3g6IG1heF94LFxuICAgICAgICBtaW5feTogbWluX3ksXG4gICAgICAgIG1heF95OiBtYXhfeVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdHdvIG5vZGVzIGhhdmUgdGhlIHNhbWUgcGFyZW50KHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUxXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0d28gbm9kZXMgaGF2ZSBhIHNhbWUgYW5jZXN0b3Igbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYXNTYW1lUGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1NhbWVQYXJlbnQobm9kZTEsIG5vZGUyKSB7XG4gICAgICB2YXIgcGFyZW50czEgPSB0aGlzLnBhcmVudFJlZmVyZW5jZVtub2RlMS5pZF07XG4gICAgICB2YXIgcGFyZW50czIgPSB0aGlzLnBhcmVudFJlZmVyZW5jZVtub2RlMi5pZF07XG5cbiAgICAgIGlmIChwYXJlbnRzMSA9PT0gdW5kZWZpbmVkIHx8IHBhcmVudHMyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyZW50czIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAocGFyZW50czFbaV0gPT0gcGFyZW50czJbal0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byBub2RlcyBhcmUgaW4gdGhlIHNhbWUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyBpcyBzbywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpblNhbWVTdWJOZXR3b3JrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluU2FtZVN1Yk5ldHdvcmsobm9kZTEsIG5vZGUyKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmVlc1tub2RlMS5pZF0gPT09IHRoaXMudHJlZXNbbm9kZTIuaWRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIHRoZSBkaXN0aW5jdCBsZXZlbHMgaW4gdGhlIGN1cnJlbnQgbmV0d29ya1xuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGV2ZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExldmVscygpIHtcbiAgICAgIHJldHVybiBrZXlzJDModGhpcy5kaXN0cmlidXRpb25PcmRlcmluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5vZGUgdG8gdGhlIG9yZGVyaW5nIHBlciBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb09yZGVyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRvT3JkZXJpbmcobm9kZSwgbGV2ZWwpIHtcbiAgICAgIGlmICh0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1ByZXNlbnQgPSBmYWxzZTtcbiAgICAgIHZhciBjdXJMZXZlbCA9IHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuXG4gICAgICBmb3IgKHZhciBuIGluIGN1ckxldmVsKSB7XG4gICAgICAgIC8vaWYgKGN1ckxldmVsW25dLmlkID09PSBub2RlLmlkKSB7XG4gICAgICAgIGlmIChjdXJMZXZlbFtuXSA9PT0gbm9kZSkge1xuICAgICAgICAgIGlzUHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1ByZXNlbnQpIHtcbiAgICAgICAgdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0ucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5kaXN0cmlidXRpb25JbmRleFtub2RlLmlkXSA9IHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhpZXJhcmNoaWNhbFN0YXR1cztcbn0oKTtcbi8qKlxuICogVGhlIExheW91dCBFbmdpbmVcbiAqL1xuXG5cbnZhciBMYXlvdXRFbmdpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIExheW91dEVuZ2luZShib2R5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5b3V0RW5naW5lKTtcblxuICAgIHRoaXMuYm9keSA9IGJvZHk7IC8vIE1ha2Ugc3VyZSB0aGVyZSBhbHdheXMgaXMgc29tZSBSTkcgYmVjYXVzZSB0aGUgc2V0T3B0aW9ucyBtZXRob2Qgd29uJ3RcbiAgICAvLyBzZXQgaXQgdW5sZXNzIHRoZXJlJ3MgYSBzZWVkIGZvciBpdC5cblxuICAgIHRoaXMuX3Jlc2V0Uk5HKE1hdGgucmFuZG9tKCkgKyBcIjpcIiArIG5vdyQyKCkpO1xuXG4gICAgdGhpcy5zZXRQaHlzaWNzID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5vcHRpb25zQmFja3VwID0ge1xuICAgICAgcGh5c2ljczoge31cbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICByYW5kb21TZWVkOiB1bmRlZmluZWQsXG4gICAgICBpbXByb3ZlZExheW91dDogdHJ1ZSxcbiAgICAgIGNsdXN0ZXJUaHJlc2hvbGQ6IDE1MCxcbiAgICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgbGV2ZWxTZXBhcmF0aW9uOiAxNTAsXG4gICAgICAgIG5vZGVTcGFjaW5nOiAxMDAsXG4gICAgICAgIHRyZWVTcGFjaW5nOiAyMDAsXG4gICAgICAgIGJsb2NrU2hpZnRpbmc6IHRydWUsXG4gICAgICAgIGVkZ2VNaW5pbWl6YXRpb246IHRydWUsXG4gICAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB0cnVlLFxuICAgICAgICBkaXJlY3Rpb246IFwiVURcIixcbiAgICAgICAgLy8gVUQsIERVLCBMUiwgUkxcbiAgICAgICAgc29ydE1ldGhvZDogXCJodWJzaXplXCIgLy8gaHVic2l6ZSwgZGlyZWN0ZWRcblxuICAgICAgfVxuICAgIH07XG5cbiAgICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoTGF5b3V0RW5naW5lLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFMb2FkZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIubGF5b3V0TmV0d29yaygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNldEhpZXJhcmNoaWNhbExheW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zZXR1cEhpZXJhcmNoaWNhbExheW91dCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBnZXQgdGhlIHR5cGUgb2Ygc3RhdGljIHNtb290aCBjdXJ2ZSBpbiBjYXNlIGl0IGlzIHJlcXVpcmVkXG5cblxuICAgICAgICB2YXIgdHlwZSA9IF90aGlzMi5kaXJlY3Rpb24uY3VydmVUeXBlKCk7IC8vIGZvcmNlIGFsbCBlZGdlcyBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLlxuXG5cbiAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIiwgdHlwZSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWxsT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgYWxsT3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaGllcmFyY2hpY2FsID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbDtcbiAgICAgICAgdmFyIHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9IGhpZXJhcmNoaWNhbC5lbmFibGVkO1xuICAgICAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKFtcInJhbmRvbVNlZWRcIiwgXCJpbXByb3ZlZExheW91dFwiLCBcImNsdXN0ZXJUaHJlc2hvbGRcIl0sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIFwiaGllcmFyY2hpY2FsXCIpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJhbmRvbVNlZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0Uk5HKG9wdGlvbnMucmFuZG9tU2VlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAocHJldkhpZXJhcmNoaWNhbFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBvdmVycmlkZGVuIG9wdGlvbnMgZm9yIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoXCIsIHRydWUpO1xuICAgICAgICAgIH0gLy8gbWFrZSBzdXJlIHRoZSBsZXZlbCBzZXBhcmF0aW9uIGlzIHRoZSByaWdodCB3YXkgdXBcblxuXG4gICAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09IFwiUkxcIiB8fCBoaWVyYXJjaGljYWwuZGlyZWN0aW9uID09PSBcIkRVXCIpIHtcbiAgICAgICAgICAgIGlmIChoaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICBoaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNldERpcmVjdGlvblN0cmF0ZWd5KCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNldEhpZXJhcmNoaWNhbExheW91dFwiKTsgLy8gYmVjYXVzZSB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBuZWVkcyBpdCdzIG93biBwaHlzaWNzIGFuZCBzbW9vdGggY3VydmUgc2V0dGluZ3MsXG4gICAgICAgICAgLy8gd2UgYWRhcHQgdGhlIG90aGVyIG9wdGlvbnMgaWYgbmVlZGVkLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0KGFsbE9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2SGllcmFyY2hpY2FsU3RhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIG92ZXJyaWRkZW4gb3B0aW9ucyBmb3Igbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlZnJlc2hcIik7XG4gICAgICAgICAgICByZXR1cm4gZGVlcEV4dGVuZChhbGxPcHRpb25zLCB0aGlzLm9wdGlvbnNCYWNrdXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsT3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHdpdGggZ2l2ZW4gc2VlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBzZWVkIC0gVGhlIHNlZWQgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0aGUgdGhlIFJORy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNldFJOR1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXRSTkcoc2VlZCkge1xuICAgICAgdGhpcy5pbml0aWFsUmFuZG9tU2VlZCA9IHNlZWQ7XG4gICAgICB0aGlzLl9ybmcgPSBBbGVhKHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhbGxPcHRpb25zXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkYXB0QWxsT3B0aW9uc0ZvckhpZXJhcmNoaWNhbExheW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXQoYWxsT3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgYmFja3VwUGh5c2ljcyA9IHRoaXMub3B0aW9uc0JhY2t1cC5waHlzaWNzOyAvLyBzZXQgdGhlIHBoeXNpY3NcblxuICAgICAgICBpZiAoYWxsT3B0aW9ucy5waHlzaWNzID09PSB1bmRlZmluZWQgfHwgYWxsT3B0aW9ucy5waHlzaWNzID09PSB0cnVlKSB7XG4gICAgICAgICAgYWxsT3B0aW9ucy5waHlzaWNzID0ge1xuICAgICAgICAgICAgZW5hYmxlZDogYmFja3VwUGh5c2ljcy5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYmFja3VwUGh5c2ljcy5lbmFibGVkLFxuICAgICAgICAgICAgc29sdmVyOiBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLmVuYWJsZWQgPSBiYWNrdXBQaHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBiYWNrdXBQaHlzaWNzLmVuYWJsZWQ7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5zb2x2ZXIgPSBiYWNrdXBQaHlzaWNzLnNvbHZlciB8fCBcImJhcm5lc0h1dFwiO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2ZfMShhbGxPcHRpb25zLnBoeXNpY3MpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5lbmFibGVkID0gYWxsT3B0aW9ucy5waHlzaWNzLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbGxPcHRpb25zLnBoeXNpY3MuZW5hYmxlZDtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9IGFsbE9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgfHwgXCJiYXJuZXNIdXRcIjtcbiAgICAgICAgICBhbGxPcHRpb25zLnBoeXNpY3Muc29sdmVyID0gXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIjtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxPcHRpb25zLnBoeXNpY3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5zb2x2ZXIgPSBcImJhcm5lc0h1dFwiO1xuICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHtcbiAgICAgICAgICAgIHNvbHZlcjogXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIlxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gZ2V0IHRoZSB0eXBlIG9mIHN0YXRpYyBzbW9vdGggY3VydmUgaW4gY2FzZSBpdCBpcyByZXF1aXJlZFxuXG5cbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmRpcmVjdGlvbi5jdXJ2ZVR5cGUoKTsgLy8gZGlzYWJsZSBzbW9vdGggY3VydmVzIGlmIG5vdGhpbmcgaXMgZGVmaW5lZC4gSWYgc21vb3RoIGN1cnZlcyBoYXZlIGJlZW4gdHVybmVkIG9uLFxuICAgICAgICAvLyB0dXJuIHRoZW0gaW50byBzdGF0aWMgc21vb3RoIGN1cnZlcy5cblxuICAgICAgICBpZiAoYWxsT3B0aW9ucy5lZGdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IFwiZHluYW1pY1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzID0ge1xuICAgICAgICAgICAgc21vb3RoOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHtcbiAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBcImR5bmFtaWNcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgICBzbW9vdGg6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPSB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc21vb3RoID0gYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGg7IC8vIGFsbG93IGN1c3RvbSB0eXBlcyBleGNlcHQgZm9yIGR5bmFtaWNcblxuICAgICAgICAgICAgaWYgKHNtb290aC50eXBlICE9PSB1bmRlZmluZWQgJiYgc21vb3RoLnR5cGUgIT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBzbW9vdGgudHlwZTtcbiAgICAgICAgICAgIH0gLy8gVE9ETzogdGhpcyBpcyBvcHRpb25zIG1lcmdpbmc7IHNlZSBpZiB0aGUgc3RhbmRhcmQgcm91dGluZXMgY2FuIGJlIHVzZWQgaGVyZS5cblxuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHNtb290aC5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogc21vb3RoLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogc21vb3RoLnR5cGUgPT09IHVuZGVmaW5lZCA/IFwiZHluYW1pY1wiIDogc21vb3RoLnR5cGUsXG4gICAgICAgICAgICAgICAgcm91bmRuZXNzOiBzbW9vdGgucm91bmRuZXNzID09PSB1bmRlZmluZWQgPyAwLjUgOiBzbW9vdGgucm91bmRuZXNzLFxuICAgICAgICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiBzbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogc21vb3RoLmZvcmNlRGlyZWN0aW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07IC8vIE5PVEU6IENvcHlpbmcgYW4gb2JqZWN0IHRvIHNlbGY7IHRoaXMgaXMgYmFzaWNhbGx5IHNldHRpbmcgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCB2YXJpYWJsZXNcblxuICAgICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPSB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHNtb290aC5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogc21vb3RoLmVuYWJsZWQsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIHJvdW5kbmVzczogc21vb3RoLnJvdW5kbmVzcyA9PT0gdW5kZWZpbmVkID8gMC41IDogc21vb3RoLnJvdW5kbmVzcyxcbiAgICAgICAgICAgICAgZm9yY2VEaXJlY3Rpb246IHNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBzbW9vdGguZm9yY2VEaXJlY3Rpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEZvcmNlIGFsbCBlZGdlcyBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLlxuICAgICAgICAvLyBPbmx5IGFwcGxpZXMgdG8gZWRnZXMgdGhhdCBkbyBub3QgdXNlIHRoZSBnbG9iYWwgb3B0aW9ucyBmb3Igc21vb3RoLlxuXG5cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9mb3JjZURpc2FibGVEeW5hbWljQ3VydmVzXCIsIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsT3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25Jbml0aWFsbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb25Jbml0aWFsbHkobm9kZXNBcnJheSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9yZXNldFJORyh0aGlzLmluaXRpYWxSYW5kb21TZWVkKTtcblxuICAgICAgICB2YXIgcmFkaXVzID0gbm9kZXNBcnJheS5sZW5ndGggKyA1MDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzQXJyYXlbaV07XG5cbiAgICAgICAgICB2YXIgYW5nbGUgPSAyICogTWF0aC5QSSAqIHRoaXMuX3JuZygpO1xuXG4gICAgICAgICAgaWYgKG5vZGUueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLnggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGUueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBLYW1hZGEgS2F3YWkgdG8gcG9zaXRpb24gbm9kZXMuIFRoaXMgaXMgcXVpdGUgYSBoZWF2eSBhbGdvcml0aG0gc28gaWYgdGhlcmUgYXJlIGEgbG90IG9mIG5vZGVzIHdlXG4gICAgICogY2x1c3RlciB0aGVtIGZpcnN0IHRvIHJlZHVjZSB0aGUgYW1vdW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGF5b3V0TmV0d29ya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXlvdXROZXR3b3JrKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaW1wcm92ZWRMYXlvdXQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7IC8vIGZpcnN0IGNoZWNrIGlmIHdlIHNob3VsZCBLYW1hZGEgS2F3YWkgdG8gbGF5b3V0LiBUaGUgdGhyZXNob2xkIGlzIGlmIGxlc3MgdGhhbiBoYWxmIG9mIHRoZSB2aXNpYmxlXG4gICAgICAgIC8vIG5vZGVzIGhhdmUgcHJlZGVmaW5lZCBwb3NpdGlvbnMgd2UgdXNlIHRoaXMuXG5cbiAgICAgICAgdmFyIHBvc2l0aW9uRGVmaW5lZCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaW5kaWNlc1tpXV07XG5cbiAgICAgICAgICBpZiAobm9kZS5wcmVkZWZpbmVkUG9zaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uRGVmaW5lZCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgbm9kZXMgaGF2ZSBhIHByZWRlZmluZWQgcG9zaXRpb24gd2UgY29udGludWVcblxuXG4gICAgICAgIGlmIChwb3NpdGlvbkRlZmluZWQgPCAwLjUgKiBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBNQVhfTEVWRUxTID0gMTA7XG4gICAgICAgICAgdmFyIGxldmVsID0gMDtcbiAgICAgICAgICB2YXIgY2x1c3RlclRocmVzaG9sZCA9IHRoaXMub3B0aW9ucy5jbHVzdGVyVGhyZXNob2xkOyAvL1xuICAgICAgICAgIC8vIERlZmluZSB0aGUgb3B0aW9ucyBmb3IgdGhlIGhpZGRlbiBjbHVzdGVyIG5vZGVzXG4gICAgICAgICAgLy8gVGhlc2Ugb3B0aW9ucyBkb24ndCBwcm9wYWdhdGUgb3V0c2lkZSB0aGUgY2x1c3RlcmluZyBwaGFzZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFNvbWUgb3B0aW9ucyBhcmUgZXhwbGljaXRseSBkaXNhYmxlZCwgYmVjYXVzZSB0aGV5IG1heSBiZSBzZXQgaW4gZ3JvdXAgb3IgZGVmYXVsdCBub2RlIG9wdGlvbnMuXG4gICAgICAgICAgLy8gVGhlIGNsdXN0ZXJzIGFyZSBuZXZlciBkaXNwbGF5ZWQsIHNvIG1vc3QgZXhwbGljaXQgc2V0dGluZ3MgaGVyZSBzZXJ2ZSBhcyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhlIGV4cGxpY2l0IHNldHRpbmcgb2YgJ3NoYXBlJyBpcyB0byBhdm9pZCBgc2hhcGU6ICdpbWFnZSdgOyBpbWFnZXMgYXJlIG5vdCBwYXNzZWQgdG8gdGhlIGhpZGRlblxuICAgICAgICAgIC8vIGNsdXN0ZXIgbm9kZXMsIGxlYWRpbmcgdG8gYW4gZXhjZXB0aW9uIG9uIGNyZWF0aW9uLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gQWxsIHNldHRpbmdzIGhlcmUgYXJlIHBlcmZvcm1hbmNlIHJlbGF0ZWQsIGV4Y2VwdCB3aGVuIG5vdGVkIG90aGVyd2lzZS5cbiAgICAgICAgICAvL1xuXG4gICAgICAgICAgdmFyIGNsdXN0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHNoYXBlOiBcImVsbGlwc2VcIixcbiAgICAgICAgICAgICAgLy8gQnVnZml4OiBhdm9pZCB0eXBlICdpbWFnZScsIG5vIGltYWdlcyBzdXBwbGllZFxuICAgICAgICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgICAgICAgLy8gYXZvaWQgbGFiZWwgaGFuZGxpbmdcbiAgICAgICAgICAgICAgZ3JvdXA6IFwiXCIsXG4gICAgICAgICAgICAgIC8vIGF2b2lkIGdyb3VwIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICBtdWx0aTogZmFsc2VcbiAgICAgICAgICAgICAgfSAvLyBhdm9pZCBmb250IHByb3BhZ2F0aW9uXG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbHVzdGVyRWRnZVByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgICAgICAgIC8vIGF2b2lkIGxhYmVsIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICBtdWx0aTogZmFsc2VcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gYXZvaWQgZm9udCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSAvLyBhdm9pZCBkcmF3aW5nIHBlbmFsdHkgZm9yIGNvbXBsZXggZWRnZXNcblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTsgLy8gaWYgdGhlcmUgYXJlIGEgbG90IG9mIG5vZGVzLCB3ZSBjbHVzdGVyIGJlZm9yZSB3ZSBydW4gdGhlIGFsZ29yaXRobS5cbiAgICAgICAgICAvLyBOT1RFOiB0aGlzIHBhcnQgZmFpbHMgdG8gZmluZCBjbHVzdGVycyBmb3IgbGFyZ2Ugc2NhbGUtZnJlZSBuZXR3b3Jrcywgd2hpY2ggc2hvdWxkXG4gICAgICAgICAgLy8gICAgICAgYmUgZWFzaWx5IGNsdXN0ZXJhYmxlLlxuICAgICAgICAgIC8vIFRPRE86IGV4YW1pbmUgd2h5IHRoaXMgaXMgc29cblxuICAgICAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCA+IGNsdXN0ZXJUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydExlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5kaWNlcy5sZW5ndGggPiBjbHVzdGVyVGhyZXNob2xkICYmIGxldmVsIDw9IE1BWF9MRVZFTFMpIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLnRpbWUoXCJjbHVzdGVyaW5nXCIpXG4gICAgICAgICAgICAgIGxldmVsICs9IDE7XG4gICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBpbmRpY2VzLmxlbmd0aDsgLy8gaWYgdGhlcmUgYXJlIG1hbnkgbm9kZXMgd2UgZG8gYSBodWJzaXplIGNsdXN0ZXJcblxuICAgICAgICAgICAgICBpZiAobGV2ZWwgJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5jbHVzdGVyQnJpZGdlcyhjbHVzdGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5jbHVzdGVyT3V0bGllcnMoY2x1c3Rlck9wdGlvbnMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGFmdGVyID0gaW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgaWYgKGJlZm9yZSA9PSBhZnRlciAmJiBsZXZlbCAlIDMgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWNsdXN0ZXJBbGwoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfbGF5b3V0RmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlRoaXMgbmV0d29yayBjb3VsZCBub3QgYmUgcG9zaXRpb25lZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIGltcHJvdmVkIGxheW91dCBhbGdvcml0aG0uXCIgKyBcIiBQbGVhc2UgZGlzYWJsZSBpbXByb3ZlZExheW91dCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gLy9jb25zb2xlLnRpbWVFbmQoXCJjbHVzdGVyaW5nXCIpXG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coYmVmb3JlLGxldmVsLGFmdGVyKTtcblxuICAgICAgICAgICAgfSAvLyBpbmNyZWFzZSB0aGUgc2l6ZSBvZiB0aGUgZWRnZXNcblxuXG4gICAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5rYW1hZGFLYXdhaS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgc3ByaW5nTGVuZ3RoOiBNYXRoLm1heCgxNTAsIDIgKiBzdGFydExlbmd0aClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZXZlbCA+IE1BWF9MRVZFTFMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlRoZSBjbHVzdGVyaW5nIGRpZG4ndCBzdWNjZWVkIHdpdGhpbiB0aGUgYW1vdW50IG9mIGludGVyYXRpb25zIGFsbG93ZWQsXCIgKyBcIiBwcm9ncmVzc2luZyB3aXRoIHBhcnRpYWwgcmVzdWx0LlwiKTtcbiAgICAgICAgICB9IC8vIHBvc2l0aW9uIHRoZSBzeXN0ZW0gZm9yIHRoZXNlIG5vZGVzIGFuZCBlZGdlc1xuXG5cbiAgICAgICAgICB0aGlzLmJvZHkubW9kdWxlcy5rYW1hZGFLYXdhaS5zb2x2ZShpbmRpY2VzLCB0aGlzLmJvZHkuZWRnZUluZGljZXMsIHRydWUpOyAvLyBzaGlmdCB0byBjZW50ZXIgcG9pbnRcblxuICAgICAgICAgIHRoaXMuX3NoaWZ0VG9DZW50ZXIoKTsgLy8gcGVydHVyYiB0aGUgbm9kZXMgYSBsaXR0bGUgYml0IHRvIGZvcmNlIHRoZSBwaHlzaWNzIHRvIGtpY2sgaW5cblxuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IDcwO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGluZGljZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHBlcnR1cmIgdGhlIG5vZGVzIHRoYXQgYXJlbid0IGZpeGVkXG4gICAgICAgICAgICB2YXIgX25vZGUgPSB0aGlzLmJvZHkubm9kZXNbaW5kaWNlc1tfaV1dO1xuXG4gICAgICAgICAgICBpZiAoX25vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBfbm9kZS54ICs9ICgwLjUgLSB0aGlzLl9ybmcoKSkgKiBvZmZzZXQ7XG4gICAgICAgICAgICAgIF9ub2RlLnkgKz0gKDAuNSAtIHRoaXMuX3JuZygpKSAqIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHVuY2x1c3RlciBhbGwgY2x1c3RlcnNcblxuXG4gICAgICAgICAgdGhpcy5fZGVjbHVzdGVyQWxsKCk7IC8vIHJlcG9zaXRpb24gYWxsIGJlemllciBub2Rlcy5cblxuXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZSBhbGwgdGhlIG5vZGVzIHRvd2FyZHMgdG8gdGhlIGNlbnRlciBzbyBncmF2aXRhdGlvbmFsIHB1bGwgd2lsIG5vdCBtb3ZlIHRoZSBub2RlcyBhd2F5IGZyb20gdmlld1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zaGlmdFRvQ2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaGlmdFRvQ2VudGVyKCkge1xuICAgICAgdmFyIHJhbmdlID0gTmV0d29ya1V0aWwuZ2V0UmFuZ2VDb3JlKHRoaXMuYm9keS5ub2RlcywgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKTtcbiAgICAgIHZhciBjZW50ZXIgPSBOZXR3b3JrVXRpbC5maW5kQ2VudGVyKHJhbmdlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgbm9kZS54IC09IGNlbnRlci54O1xuICAgICAgICBub2RlLnkgLT0gY2VudGVyLnk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIGNsdXN0ZXJzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlY2x1c3RlckFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjbHVzdGVyQWxsKCkge1xuICAgICAgdmFyIGNsdXN0ZXJzUHJlc2VudCA9IHRydWU7XG5cbiAgICAgIHdoaWxlIChjbHVzdGVyc1ByZXNlbnQgPT09IHRydWUpIHtcbiAgICAgICAgY2x1c3RlcnNQcmVzZW50ID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV0uaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlcih0aGlzLmJvZHkubm9kZUluZGljZXNbaV0sIHt9LCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsdXN0ZXJzUHJlc2VudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfCp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsUmFuZG9tU2VlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgbWFpbiBmdW5jdGlvbiB0byBsYXlvdXQgdGhlIG5vZGVzIGluIGEgaGllcmFyY2hpY2FsIHdheS5cbiAgICAgKiBJdCBjaGVja3MgaWYgdGhlIG5vZGUgZGV0YWlscyBhcmUgc3VwcGxpZWQgY29ycmVjdGx5XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBIaWVyYXJjaGljYWxMYXlvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBIaWVyYXJjaGljYWxMYXlvdXQoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkID09PSB0cnVlICYmIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGdldCB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VzdCBodWJzIGFuZCBjaGVjayBpZiB0aGUgdXNlciBoYXMgZGVmaW5lZCBhIGxldmVsIGZvciBhIG5vZGUuXG4gICAgICAgIHZhciBub2RlLCBub2RlSWQ7XG4gICAgICAgIHZhciBkZWZpbmVkTGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVuZGVmaW5lZExldmVsID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdE5vZGVPbkxldmVsID0ge307XG4gICAgICAgIHRoaXMuaGllcmFyY2hpY2FsID0gbmV3IEhpZXJhcmNoaWNhbFN0YXR1cygpO1xuXG4gICAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgICAgIGlmIChub2RlLm9wdGlvbnMubGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBkZWZpbmVkTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUlkXSA9IG5vZGUub3B0aW9ucy5sZXZlbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuZGVmaW5lZExldmVsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgdGhlIHVzZXIgZGVmaW5lZCBzb21lIGxldmVscyBidXQgbm90IGFsbCwgYWxlcnQgYW5kIHJ1biB3aXRob3V0IGhpZXJhcmNoaWNhbCBsYXlvdXRcblxuXG4gICAgICAgIGlmICh1bmRlZmluZWRMZXZlbCA9PT0gdHJ1ZSAmJiBkZWZpbmVkTGV2ZWwgPT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUbyB1c2UgdGhlIGhpZXJhcmNoaWNhbCBsYXlvdXQsIG5vZGVzIHJlcXVpcmUgZWl0aGVyIG5vIHByZWRlZmluZWQgbGV2ZWxzXCIgKyBcIiBvciBsZXZlbHMgaGF2ZSB0byBiZSBkZWZpbmVkIGZvciBhbGwgbm9kZXMuXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlZmluZSBsZXZlbHMgaWYgdW5kZWZpbmVkIGJ5IHRoZSB1c2Vycy4gQmFzZWQgb24gaHVic2l6ZS5cbiAgICAgICAgICBpZiAodW5kZWZpbmVkTGV2ZWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBzb3J0TWV0aG9kID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5zb3J0TWV0aG9kO1xuXG4gICAgICAgICAgICBpZiAoc29ydE1ldGhvZCA9PT0gXCJodWJzaXplXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvcnRNZXRob2QgPT09IFwiZGlyZWN0ZWRcIikge1xuICAgICAgICAgICAgICB0aGlzLl9kZXRlcm1pbmVMZXZlbHNEaXJlY3RlZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3J0TWV0aG9kID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBmYWxsYmFjayBmb3IgY2FzZXMgd2hlcmUgdGhlcmUgYXJlIG5vZGVzIGJ1dCBubyBlZGdlc1xuXG5cbiAgICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBfbm9kZUlkMikpIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwuZW5zdXJlTGV2ZWwoX25vZGVJZDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gY2hlY2sgdGhlIGRpc3RyaWJ1dGlvbiBvZiB0aGUgbm9kZXMgcGVyIGxldmVsLlxuXG5cbiAgICAgICAgICB2YXIgZGlzdHJpYnV0aW9uID0gdGhpcy5fZ2V0RGlzdHJpYnV0aW9uKCk7IC8vIGdldCB0aGUgcGFyZW50IGNoaWxkcmVuIHJlbGF0aW9ucy5cblxuXG4gICAgICAgICAgdGhpcy5fZ2VuZXJhdGVNYXAoKTsgLy8gcGxhY2UgdGhlIG5vZGVzIG9uIHRoZSBjYW52YXMuXG5cblxuICAgICAgICAgIHRoaXMuX3BsYWNlTm9kZXNCeUhpZXJhcmNoeShkaXN0cmlidXRpb24pOyAvLyBjb25kZW5zZSB0aGUgd2hpdGVzcGFjZS5cblxuXG4gICAgICAgICAgdGhpcy5fY29uZGVuc2VIaWVyYXJjaHkoKTsgLy8gc2hpZnQgdG8gY2VudGVyIHNvIGdyYXZpdHkgZG9lcyBub3QgaGF2ZSB0byBkbyBtdWNoXG5cblxuICAgICAgICAgIHRoaXMuX3NoaWZ0VG9DZW50ZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbmRlbnNlSGllcmFyY2h5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25kZW5zZUhpZXJhcmNoeSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyBHbG9iYWwgdmFyIGluIHRoaXMgc2NvcGUgdG8gZGVmaW5lIHdoZW4gdGhlIG1vdmVtZW50IGhhcyBzdG9wcGVkLlxuICAgICAgdmFyIHN0aWxsU2hpZnRpbmcgPSBmYWxzZTtcbiAgICAgIHZhciBicmFuY2hlcyA9IHt9OyAvLyBmaXJzdCB3ZSBoYXZlIHNvbWUgbWV0aG9kcyB0byBoZWxwIHNoaWZ0aW5nIHRyZWVzIGFyb3VuZC5cbiAgICAgIC8vIHRoZSBtYWluIG1ldGhvZCB0byBzaGlmdCB0aGUgdHJlZXNcblxuICAgICAgdmFyIHNoaWZ0VHJlZXMgPSBmdW5jdGlvbiBzaGlmdFRyZWVzKCkge1xuICAgICAgICB2YXIgdHJlZVNpemVzID0gZ2V0VHJlZVNpemVzKCk7XG4gICAgICAgIHZhciBzaGlmdEJ5ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWVTaXplcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGlmZiA9IHRyZWVTaXplc1tpXS5tYXggLSB0cmVlU2l6ZXNbaSArIDFdLm1pbjtcbiAgICAgICAgICBzaGlmdEJ5ICs9IGRpZmYgKyBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwudHJlZVNwYWNpbmc7XG4gICAgICAgICAgc2hpZnRUcmVlKGkgKyAxLCBzaGlmdEJ5KTtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gc2hpZnQgYSBzaW5nbGUgdHJlZSBieSBhbiBvZmZzZXRcblxuXG4gICAgICB2YXIgc2hpZnRUcmVlID0gZnVuY3Rpb24gc2hpZnRUcmVlKGluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHRyZWVzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC50cmVlcztcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdHJlZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRyZWVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICBpZiAodHJlZXNbbm9kZUlkXSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmRpcmVjdGlvbi5zaGlmdChub2RlSWQsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBnZXQgdGhlIHdpZHRoIG9mIGFsbCB0cmVlc1xuXG5cbiAgICAgIHZhciBnZXRUcmVlU2l6ZXMgPSBmdW5jdGlvbiBnZXRUcmVlU2l6ZXMoKSB7XG4gICAgICAgIHZhciB0cmVlV2lkdGhzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpczMuaGllcmFyY2hpY2FsLm51bVRyZWVzKCk7IGkrKykge1xuICAgICAgICAgIHRyZWVXaWR0aHMucHVzaChfdGhpczMuZGlyZWN0aW9uLmdldFRyZWVTaXplKGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmVlV2lkdGhzO1xuICAgICAgfTsgLy8gZ2V0IGEgbWFwIG9mIGFsbCBub2RlcyBpbiB0aGlzIGJyYW5jaFxuXG5cbiAgICAgIHZhciBnZXRCcmFuY2hOb2RlcyA9IGZ1bmN0aW9uIGdldEJyYW5jaE5vZGVzKHNvdXJjZSwgbWFwKSB7XG4gICAgICAgIGlmIChtYXBbc291cmNlLmlkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcFtzb3VyY2UuaWRdID0gdHJ1ZTtcblxuICAgICAgICBpZiAoX3RoaXMzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtzb3VyY2UuaWRdKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtzb3VyY2UuaWRdO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZ2V0QnJhbmNoTm9kZXMoX3RoaXMzLmJvZHkubm9kZXNbY2hpbGRyZW5baV1dLCBtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gZ2V0IGEgbWluIG1heCB3aWR0aCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIG1vdmVtZW50IHNwYWNlIGl0IGhhcyBvbiBlaXRoZXIgc2lkZXNcbiAgICAgIC8vIHdlIHVzZSBtaW4gbWF4IHRlcm1pbm9sb2d5IGJlY2F1c2Ugd2lkdGggYW5kIGhlaWdodCBjYW4gaW50ZXJjaGFuZ2UgZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxheW91dFxuXG5cbiAgICAgIHZhciBnZXRCcmFuY2hCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE1hcCkge1xuICAgICAgICB2YXIgbWF4TGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDFlOTtcbiAgICAgICAgdmFyIG1pblNwYWNlID0gMWU5O1xuICAgICAgICB2YXIgbWF4U3BhY2UgPSAxZTk7XG4gICAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICAgIHZhciBtYXggPSAtMWU5O1xuXG4gICAgICAgIGZvciAodmFyIGJyYW5jaE5vZGUgaW4gYnJhbmNoTWFwKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChicmFuY2hNYXAsIGJyYW5jaE5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ib2R5Lm5vZGVzW2JyYW5jaE5vZGVdO1xuICAgICAgICAgICAgdmFyIGxldmVsID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZS5pZF07XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7IC8vIGdldCB0aGUgc3BhY2UgYXJvdW5kIHRoZSBub2RlLlxuXG5cbiAgICAgICAgICAgIHZhciBfdGhpczMkX2dldFNwYWNlQXJvdW4gPSBfdGhpczMuX2dldFNwYWNlQXJvdW5kTm9kZShub2RlLCBicmFuY2hNYXApLFxuICAgICAgICAgICAgICAgIF90aGlzMyRfZ2V0U3BhY2VBcm91bjIgPSBzbGljZWRUb0FycmF5KF90aGlzMyRfZ2V0U3BhY2VBcm91biwgMiksXG4gICAgICAgICAgICAgICAgbWluU3BhY2VOb2RlID0gX3RoaXMzJF9nZXRTcGFjZUFyb3VuMlswXSxcbiAgICAgICAgICAgICAgICBtYXhTcGFjZU5vZGUgPSBfdGhpczMkX2dldFNwYWNlQXJvdW4yWzFdO1xuXG4gICAgICAgICAgICBtaW5TcGFjZSA9IE1hdGgubWluKG1pblNwYWNlTm9kZSwgbWluU3BhY2UpO1xuICAgICAgICAgICAgbWF4U3BhY2UgPSBNYXRoLm1pbihtYXhTcGFjZU5vZGUsIG1heFNwYWNlKTsgLy8gdGhlIHdpZHRoIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHRoZSBsZXZlbHMgdHdvIG5vZGVzIGhhdmUgaW4gY29tbW9uLiBUaGlzIGlzIHdoeSB3ZSBmaWx0ZXIgb24gdGhpcy5cblxuICAgICAgICAgICAgaWYgKGxldmVsIDw9IG1heExldmVsKSB7XG4gICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHBvc2l0aW9uLCBtaW4pO1xuICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChwb3NpdGlvbiwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21pbiwgbWF4LCBtaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgfTsgLy8gY2hlY2sgd2hhdCB0aGUgbWF4aW11bSBsZXZlbCBpcyB0aGVzZSBub2RlcyBoYXZlIGluIGNvbW1vbi5cblxuXG4gICAgICB2YXIgZ2V0Q29sbGlzaW9uTGV2ZWwgPSBmdW5jdGlvbiBnZXRDb2xsaXNpb25MZXZlbChub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgdmFyIG1heExldmVsMSA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TWF4TGV2ZWwobm9kZTEuaWQpO1xuXG4gICAgICAgIHZhciBtYXhMZXZlbDIgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldE1heExldmVsKG5vZGUyLmlkKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5taW4obWF4TGV2ZWwxLCBtYXhMZXZlbDIpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQ29uZGVuc2UgZWxlbWVudHMuIFRoZXNlIGNhbiBiZSBub2RlcyBvciBicmFuY2hlcyBkZXBlbmRpbmcgb24gdGhlIGNhbGxiYWNrLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBsZXZlbHNcbiAgICAgICAqIEBwYXJhbSB7Kn0gY2VudGVyUGFyZW50c1xuICAgICAgICovXG5cblxuICAgICAgdmFyIHNoaWZ0RWxlbWVudHNDbG9zZXIgPSBmdW5jdGlvbiBzaGlmdEVsZW1lbnRzQ2xvc2VyKGNhbGxiYWNrLCBsZXZlbHMsIGNlbnRlclBhcmVudHMpIHtcbiAgICAgICAgdmFyIGhpZXIgPSBfdGhpczMuaGllcmFyY2hpY2FsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gaGllci5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG5cbiAgICAgICAgICBpZiAobGV2ZWxOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlMSA9IGxldmVsTm9kZXNbal07XG4gICAgICAgICAgICAgIHZhciBub2RlMiA9IGxldmVsTm9kZXNbaiArIDFdOyAvLyBOT1RFOiBsb2dpYyBtYWludGFpbmVkIGFzIGl0IHdhczsgaWYgbm9kZXMgaGF2ZSBzYW1lIGFuY2VzdG9yLFxuICAgICAgICAgICAgICAvLyAgICAgICB0aGVuIG9mIGNvdXJzZSB0aGV5IGFyZSBpbiB0aGUgc2FtZSBzdWItbmV0d29yay5cblxuICAgICAgICAgICAgICBpZiAoaGllci5oYXNTYW1lUGFyZW50KG5vZGUxLCBub2RlMikgJiYgaGllci5pblNhbWVTdWJOZXR3b3JrKG5vZGUxLCBub2RlMikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlMSwgbm9kZTIsIGNlbnRlclBhcmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBjYWxsYmFjayBmb3Igc2hpZnRpbmcgYnJhbmNoZXNcblxuXG4gICAgICB2YXIgYnJhbmNoU2hpZnRDYWxsYmFjayA9IGZ1bmN0aW9uIGJyYW5jaFNoaWZ0Q2FsbGJhY2sobm9kZTEsIG5vZGUyKSB7XG4gICAgICAgIHZhciBjZW50ZXJQYXJlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICAgIC8vd2luZG93LkNBTExCQUNLUy5wdXNoKCgpID0+IHtcbiAgICAgICAgdmFyIHBvczEgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUxKTtcblxuICAgICAgICB2YXIgcG9zMiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZTIpO1xuXG4gICAgICAgIHZhciBkaWZmQWJzID0gTWF0aC5hYnMocG9zMiAtIHBvczEpO1xuICAgICAgICB2YXIgbm9kZVNwYWNpbmcgPSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7IC8vY29uc29sZS5sb2coXCJOT1cgQ0hFQ0tJTkc6XCIsIG5vZGUxLmlkLCBub2RlMi5pZCwgZGlmZkFicyk7XG5cbiAgICAgICAgaWYgKGRpZmZBYnMgPiBub2RlU3BhY2luZykge1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlczEgPSB7fTtcbiAgICAgICAgICB2YXIgYnJhbmNoTm9kZXMyID0ge307XG4gICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZTEsIGJyYW5jaE5vZGVzMSk7XG4gICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZTIsIGJyYW5jaE5vZGVzMik7IC8vIGNoZWNrIHRoZSBsYXJnZXN0IGRpc3RhbmNlIGJldHdlZW4gdGhlIGJyYW5jaGVzXG5cbiAgICAgICAgICB2YXIgbWF4TGV2ZWwgPSBnZXRDb2xsaXNpb25MZXZlbChub2RlMSwgbm9kZTIpO1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlQm91bmRhcnkxID0gZ2V0QnJhbmNoQm91bmRhcnkoYnJhbmNoTm9kZXMxLCBtYXhMZXZlbCk7XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVCb3VuZGFyeTIgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczIsIG1heExldmVsKTtcbiAgICAgICAgICB2YXIgbWF4MSA9IGJyYW5jaE5vZGVCb3VuZGFyeTFbMV07XG4gICAgICAgICAgdmFyIG1pbjIgPSBicmFuY2hOb2RlQm91bmRhcnkyWzBdO1xuICAgICAgICAgIHZhciBtaW5TcGFjZTIgPSBicmFuY2hOb2RlQm91bmRhcnkyWzJdOyAvL2NvbnNvbGUubG9nKG5vZGUxLmlkLCBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczEsIG1heExldmVsKSwgbm9kZTIuaWQsXG4gICAgICAgICAgLy8gICAgICAgICAgICBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczIsIG1heExldmVsKSwgbWF4TGV2ZWwpO1xuXG4gICAgICAgICAgdmFyIGRpZmZCcmFuY2ggPSBNYXRoLmFicyhtYXgxIC0gbWluMik7XG5cbiAgICAgICAgICBpZiAoZGlmZkJyYW5jaCA+IG5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWF4MSAtIG1pbjIgKyBub2RlU3BhY2luZztcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IC1taW5TcGFjZTIgKyBub2RlU3BhY2luZykge1xuICAgICAgICAgICAgICBvZmZzZXQgPSAtbWluU3BhY2UyICsgbm9kZVNwYWNpbmc7IC8vY29uc29sZS5sb2coXCJSRVNFVFRJTkcgT0ZGU0VUXCIsIG1heDEgLSBtaW4yICsgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZywgLW1pblNwYWNlMiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNISUZUSU5HXCIsIG5vZGUyLmlkLCBvZmZzZXQpO1xuICAgICAgICAgICAgICBfdGhpczMuX3NoaWZ0QmxvY2sobm9kZTIuaWQsIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChjZW50ZXJQYXJlbnQgPT09IHRydWUpIF90aGlzMy5fY2VudGVyUGFyZW50KG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTt9KVxuXG4gICAgICB9O1xuXG4gICAgICB2YXIgbWluaW1pemVFZGdlTGVuZ3RoID0gZnVuY3Rpb24gbWluaW1pemVFZGdlTGVuZ3RoKGl0ZXJhdGlvbnMsIG5vZGUpIHtcbiAgICAgICAgLy93aW5kb3cuQ0FMTEJBQ0tTLnB1c2goKCkgPT4ge1xuICAgICAgICAvLyAgY29uc29sZS5sb2coXCJ0c1wiLG5vZGUuaWQpO1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZDtcbiAgICAgICAgdmFyIGFsbEVkZ2VzID0gbm9kZS5lZGdlcztcbiAgICAgICAgdmFyIG5vZGVMZXZlbCA9IF90aGlzMy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGUuaWRdOyAvLyBnYXRoZXIgY29uc3RhbnRzXG5cbiAgICAgICAgdmFyIEMyID0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb247XG4gICAgICAgIHZhciByZWZlcmVuY2VOb2RlcyA9IHt9O1xuICAgICAgICB2YXIgYWJvdmVFZGdlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuXG4gICAgICAgICAgaWYgKGVkZ2UudG9JZCAhPSBlZGdlLmZyb21JZCkge1xuICAgICAgICAgICAgdmFyIG90aGVyTm9kZSA9IGVkZ2UudG9JZCA9PSBub2RlSWQgPyBlZGdlLmZyb20gOiBlZGdlLnRvO1xuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZXNbYWxsRWRnZXNbaV0uaWRdID0gb3RoZXJOb2RlO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMzLmhpZXJhcmNoaWNhbC5sZXZlbHNbb3RoZXJOb2RlLmlkXSA8IG5vZGVMZXZlbCkge1xuICAgICAgICAgICAgICBhYm92ZUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGRpZmZlcmVudGlhdGVkIHN1bSBvZiBsZW5ndGhzIGJhc2VkIG9uIG9ubHkgbW92aW5nIG9uZSBub2RlIG92ZXIgb25lIGF4aXNcblxuXG4gICAgICAgIHZhciBnZXRGeCA9IGZ1bmN0aW9uIGdldEZ4KHBvaW50LCBlZGdlcykge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWRnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pMl0uaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHJlZmVyZW5jZU5vZGVzW2VkZ2VzW19pMl0uaWRdKSAtIHBvaW50O1xuICAgICAgICAgICAgICBzdW0gKz0gYSAvIE1hdGguc3FydChhICogYSArIEMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9OyAvLyBkb3VibHkgZGlmZmVyZW50aWF0ZWQgc3VtIG9mIGxlbmd0aHMgYmFzZWQgb24gb25seSBtb3Zpbmcgb25lIG5vZGUgb3ZlciBvbmUgYXhpc1xuXG5cbiAgICAgICAgdmFyIGdldERGeCA9IGZ1bmN0aW9uIGdldERGeChwb2ludCwgZWRnZXMpIHtcbiAgICAgICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVkZ2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgIGlmIChyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTNdLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBhID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTNdLmlkXSkgLSBwb2ludDtcbiAgICAgICAgICAgICAgc3VtIC09IEMyICogTWF0aC5wb3coYSAqIGEgKyBDMiwgLTEuNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0R3Vlc3MgPSBmdW5jdGlvbiBnZXRHdWVzcyhpdGVyYXRpb25zLCBlZGdlcykge1xuICAgICAgICAgIHZhciBndWVzcyA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7IC8vIE5ld3RvbidzIG1ldGhvZCBmb3Igb3B0aW1pemF0aW9uXG5cblxuICAgICAgICAgIHZhciBndWVzc01hcCA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgaXRlcmF0aW9uczsgX2k0KyspIHtcbiAgICAgICAgICAgIHZhciBmeCA9IGdldEZ4KGd1ZXNzLCBlZGdlcyk7XG4gICAgICAgICAgICB2YXIgZGZ4ID0gZ2V0REZ4KGd1ZXNzLCBlZGdlcyk7IC8vIHdlIGxpbWl0IHRoZSBtb3ZlbWVudCB0byBhdm9pZCBpbnN0YWJpbGl0eS5cblxuICAgICAgICAgICAgdmFyIGxpbWl0ID0gNDA7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBNYXRoLm1heCgtbGltaXQsIE1hdGgubWluKGxpbWl0LCBNYXRoLnJvdW5kKGZ4IC8gZGZ4KSkpO1xuICAgICAgICAgICAgZ3Vlc3MgPSBndWVzcyAtIHJhdGlvOyAvLyByZWR1Y2UgZHVwbGljYXRlc1xuXG4gICAgICAgICAgICBpZiAoZ3Vlc3NNYXBbZ3Vlc3NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGd1ZXNzTWFwW2d1ZXNzXSA9IF9pNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ3Vlc3M7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1vdmVCcmFuY2ggPSBmdW5jdGlvbiBtb3ZlQnJhbmNoKGd1ZXNzKSB7XG4gICAgICAgICAgLy8gcG9zaXRpb24gbm9kZSBpZiB0aGVyZSBpcyBzcGFjZVxuICAgICAgICAgIHZhciBub2RlUG9zaXRpb24gPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpOyAvLyBjaGVjayBtb3ZhYmxlIGFyZWEgb2YgdGhlIGJyYW5jaFxuXG5cbiAgICAgICAgICBpZiAoYnJhbmNoZXNbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGJyYW5jaE5vZGVzID0ge307XG4gICAgICAgICAgICBnZXRCcmFuY2hOb2Rlcyhub2RlLCBicmFuY2hOb2Rlcyk7XG4gICAgICAgICAgICBicmFuY2hlc1tub2RlLmlkXSA9IGJyYW5jaE5vZGVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBicmFuY2hCb3VuZGFyeSA9IGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaGVzW25vZGUuaWRdKTtcbiAgICAgICAgICB2YXIgbWluU3BhY2VCcmFuY2ggPSBicmFuY2hCb3VuZGFyeVsyXTtcbiAgICAgICAgICB2YXIgbWF4U3BhY2VCcmFuY2ggPSBicmFuY2hCb3VuZGFyeVszXTtcbiAgICAgICAgICB2YXIgZGlmZiA9IGd1ZXNzIC0gbm9kZVBvc2l0aW9uOyAvLyBjaGVjayBpZiB3ZSBhcmUgYWxsb3dlZCB0byBtb3ZlIHRoZSBub2RlOlxuXG4gICAgICAgICAgdmFyIGJyYW5jaE9mZnNldCA9IDA7XG5cbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGJyYW5jaE9mZnNldCA9IE1hdGgubWluKGRpZmYsIG1heFNwYWNlQnJhbmNoIC0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICBicmFuY2hPZmZzZXQgPSAtTWF0aC5taW4oLWRpZmYsIG1pblNwYWNlQnJhbmNoIC0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYnJhbmNoT2Zmc2V0ICE9IDApIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJtb3ZpbmcgYnJhbmNoOlwiLGJyYW5jaE9mZnNldCwgbWF4U3BhY2VCcmFuY2gsIG1pblNwYWNlQnJhbmNoKVxuICAgICAgICAgICAgX3RoaXMzLl9zaGlmdEJsb2NrKG5vZGUuaWQsIGJyYW5jaE9mZnNldCk7IC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG5cblxuICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtb3ZlTm9kZSA9IGZ1bmN0aW9uIG1vdmVOb2RlKGd1ZXNzKSB7XG4gICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7IC8vIHBvc2l0aW9uIG5vZGUgaWYgdGhlcmUgaXMgc3BhY2VcblxuXG4gICAgICAgICAgdmFyIF90aGlzMyRfZ2V0U3BhY2VBcm91bjMgPSBfdGhpczMuX2dldFNwYWNlQXJvdW5kTm9kZShub2RlKSxcbiAgICAgICAgICAgICAgX3RoaXMzJF9nZXRTcGFjZUFyb3VuNCA9IHNsaWNlZFRvQXJyYXkoX3RoaXMzJF9nZXRTcGFjZUFyb3VuMywgMiksXG4gICAgICAgICAgICAgIG1pblNwYWNlID0gX3RoaXMzJF9nZXRTcGFjZUFyb3VuNFswXSxcbiAgICAgICAgICAgICAgbWF4U3BhY2UgPSBfdGhpczMkX2dldFNwYWNlQXJvdW40WzFdO1xuXG4gICAgICAgICAgdmFyIGRpZmYgPSBndWVzcyAtIG5vZGVQb3NpdGlvbjsgLy8gY2hlY2sgaWYgd2UgYXJlIGFsbG93ZWQgdG8gbW92ZSB0aGUgbm9kZTpcblxuICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IG5vZGVQb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1pbihub2RlUG9zaXRpb24gKyAobWF4U3BhY2UgLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICAgbmV3UG9zaXRpb24gPSBNYXRoLm1heChub2RlUG9zaXRpb24gLSAobWluU3BhY2UgLSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpLCBndWVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uICE9PSBub2RlUG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJtb3ZpbmcgTm9kZTpcIixkaWZmLCBtaW5TcGFjZSwgbWF4U3BhY2UpO1xuICAgICAgICAgICAgX3RoaXMzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihub2RlLCBuZXdQb3NpdGlvbik7IC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG5cblxuICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBndWVzcyA9IGdldEd1ZXNzKGl0ZXJhdGlvbnMsIGFib3ZlRWRnZXMpO1xuICAgICAgICBtb3ZlQnJhbmNoKGd1ZXNzKTtcbiAgICAgICAgZ3Vlc3MgPSBnZXRHdWVzcyhpdGVyYXRpb25zLCBhbGxFZGdlcyk7XG4gICAgICAgIG1vdmVOb2RlKGd1ZXNzKTsgLy99KVxuICAgICAgfTsgLy8gbWV0aG9kIHRvIHJlbW92ZSB3aGl0ZXNwYWNlIGJldHdlZW4gYnJhbmNoZXMuIEJlY2F1c2Ugd2UgZG8gYm90dG9tIHVwLCB3ZSBjYW4gY2VudGVyIHRoZSBwYXJlbnRzLlxuXG5cbiAgICAgIHZhciBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcCA9IGZ1bmN0aW9uIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwKGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7XG5cbiAgICAgICAgbGV2ZWxzID0gcmV2ZXJzZSQyKGxldmVscykuY2FsbChsZXZlbHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgc3RpbGxTaGlmdGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tqXTtcbiAgICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGV2ZWxOb2Rlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBtaW5pbWl6ZUVkZ2VMZW5ndGgoMTAwMCwgbGV2ZWxOb2Rlc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0aWxsU2hpZnRpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGSU5JU0hFRCBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcCBJTiBcIiArIGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBtZXRob2QgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgYmV0d2VlbiBicmFuY2hlcy4gQmVjYXVzZSB3ZSBkbyBib3R0b20gdXAsIHdlIGNhbiBjZW50ZXIgdGhlIHBhcmVudHMuXG5cblxuICAgICAgdmFyIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcCA9IGZ1bmN0aW9uIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcChpdGVyYXRpb25zKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldExldmVscygpO1xuXG4gICAgICAgIGxldmVscyA9IHJldmVyc2UkMihsZXZlbHMpLmNhbGwobGV2ZWxzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzaGlmdEVsZW1lbnRzQ2xvc2VyKGJyYW5jaFNoaWZ0Q2FsbGJhY2ssIGxldmVscywgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoc3RpbGxTaGlmdGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZJTklTSEVEIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcCBJTiBcIiArIChpKzEpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gY2VudGVyIGFsbCBwYXJlbnRzXG5cblxuICAgICAgdmFyIGNlbnRlckFsbFBhcmVudHMgPSBmdW5jdGlvbiBjZW50ZXJBbGxQYXJlbnRzKCkge1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gX3RoaXMzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF90aGlzMy5ib2R5Lm5vZGVzLCBub2RlSWQpKSBfdGhpczMuX2NlbnRlclBhcmVudChfdGhpczMuYm9keS5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gY2VudGVyIGFsbCBwYXJlbnRzXG5cblxuICAgICAgdmFyIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCA9IGZ1bmN0aW9uIGNlbnRlckFsbFBhcmVudHNCb3R0b21VcCgpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7XG5cbiAgICAgICAgbGV2ZWxzID0gcmV2ZXJzZSQyKGxldmVscykuY2FsbChsZXZlbHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIF90aGlzMy5fY2VudGVyUGFyZW50KGxldmVsTm9kZXNbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gdGhlIGFjdHVhbCB3b3JrIGlzIGRvbmUgaGVyZS5cblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ibG9ja1NoaWZ0aW5nID09PSB0cnVlKSB7XG4gICAgICAgIHNoaWZ0QnJhbmNoZXNDbG9zZXJCb3R0b21VcCg1KTtcbiAgICAgICAgY2VudGVyQWxsUGFyZW50cygpO1xuICAgICAgfSAvLyBtaW5pbWl6ZSBlZGdlIGxlbmd0aFxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVkZ2VNaW5pbWl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAoMjApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5wYXJlbnRDZW50cmFsaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBjZW50ZXJBbGxQYXJlbnRzQm90dG9tVXAoKTtcbiAgICAgIH1cblxuICAgICAgc2hpZnRUcmVlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGdpdmVzIHRoZSBzcGFjZSBhcm91bmQgdGhlIG5vZGUuIElGIGEgbWFwIGlzIHN1cHBsaWVkLCBpdCB3aWxsIG9ubHkgY2hlY2sgYWdhaW5zdCBub2RlcyBOT1QgaW4gdGhlIG1hcC5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gb25seSBnZXQgdGhlIGRpc3RhbmNlcyB0byBub2RlcyBvdXRzaWRlIG9mIGEgYnJhbmNoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHt7Tm9kZS5pZDogdmlzLk5vZGV9fSBtYXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTcGFjZUFyb3VuZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNwYWNlQXJvdW5kTm9kZShub2RlLCBtYXApIHtcbiAgICAgIHZhciB1c2VNYXAgPSB0cnVlO1xuXG4gICAgICBpZiAobWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXNlTWFwID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlLmlkXTtcblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uSW5kZXhbbm9kZS5pZF07XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUpO1xuICAgICAgICB2YXIgb3JkZXJpbmcgPSB0aGlzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICAgIHZhciBtaW5TcGFjZSA9IDFlOTtcbiAgICAgICAgdmFyIG1heFNwYWNlID0gMWU5O1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IG9yZGVyaW5nW2luZGV4IC0gMV07XG5cbiAgICAgICAgICBpZiAodXNlTWFwID09PSB0cnVlICYmIG1hcFtwcmV2Tm9kZS5pZF0gPT09IHVuZGVmaW5lZCB8fCB1c2VNYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgcHJldlBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHByZXZOb2RlKTtcbiAgICAgICAgICAgIG1pblNwYWNlID0gcG9zaXRpb24gLSBwcmV2UG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCAhPSBvcmRlcmluZy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIG5leHROb2RlID0gb3JkZXJpbmdbaW5kZXggKyAxXTtcblxuICAgICAgICAgIGlmICh1c2VNYXAgPT09IHRydWUgJiYgbWFwW25leHROb2RlLmlkXSA9PT0gdW5kZWZpbmVkIHx8IHVzZU1hcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obmV4dE5vZGUpO1xuICAgICAgICAgICAgbWF4U3BhY2UgPSBNYXRoLm1pbihtYXhTcGFjZSwgbmV4dFBvcyAtIHBvc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21pblNwYWNlLCBtYXhTcGFjZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXZSB1c2UgdGhpcyBtZXRob2QgdG8gY2VudGVyIGEgcGFyZW50IG5vZGUgYW5kIGNoZWNrIGlmIGl0IGRvZXMgbm90IGNyb3NzIG90aGVyIG5vZGVzIHdoZW4gaXQgZG9lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2VudGVyUGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jZW50ZXJQYXJlbnQobm9kZSkge1xuICAgICAgaWYgKHRoaXMuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtub2RlLmlkXSkge1xuICAgICAgICB2YXIgcGFyZW50cyA9IHRoaXMuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtub2RlLmlkXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyZW50SWQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnRJZF07XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHRoaXMuX2dldENlbnRlclBvc2l0aW9uKGNoaWxkcmVuKTtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBfdGhpcyRfZ2V0U3BhY2VBcm91bmQgPSB0aGlzLl9nZXRTcGFjZUFyb3VuZE5vZGUocGFyZW50Tm9kZSksXG4gICAgICAgICAgICAgICAgX3RoaXMkX2dldFNwYWNlQXJvdW5kMiA9IHNsaWNlZFRvQXJyYXkoX3RoaXMkX2dldFNwYWNlQXJvdW5kLCAyKSxcbiAgICAgICAgICAgICAgICBtaW5TcGFjZSA9IF90aGlzJF9nZXRTcGFjZUFyb3VuZDJbMF0sXG4gICAgICAgICAgICAgICAgbWF4U3BhY2UgPSBfdGhpcyRfZ2V0U3BhY2VBcm91bmQyWzFdO1xuXG4gICAgICAgICAgICB2YXIgZGlmZiA9IHBvc2l0aW9uIC0gbmV3UG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmIChkaWZmIDwgMCAmJiBNYXRoLmFicyhkaWZmKSA8IG1heFNwYWNlIC0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyB8fCBkaWZmID4gMCAmJiBNYXRoLmFicyhkaWZmKSA8IG1pblNwYWNlIC0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZykge1xuICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihwYXJlbnROb2RlLCBuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcGxhY2VzIHRoZSBub2RlcyBvbiB0aGUgY2FudmFzIGJhc2VkIG9uIHRoZSBoaWVyYXJjaGlhbCBkaXN0cmlidXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGlzdHJpYnV0aW9uIHwgb2J0YWluZWQgYnkgdGhlIGZ1bmN0aW9uIHRoaXMuX2dldERpc3RyaWJ1dGlvbigpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZU5vZGVzQnlIaWVyYXJjaHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlTm9kZXNCeUhpZXJhcmNoeShkaXN0cmlidXRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb25lZE5vZGVzID0ge307IC8vIHN0YXJ0IHBsYWNpbmcgYWxsIHRoZSBsZXZlbCAwIG5vZGVzIGZpcnN0LiBUaGVuIHJlY3Vyc2l2ZWx5IHBvc2l0aW9uIHRoZWlyIGJyYW5jaGVzLlxuXG4gICAgICBmb3IgKHZhciBsZXZlbCBpbiBkaXN0cmlidXRpb24pIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkaXN0cmlidXRpb24sIGxldmVsKSkge1xuICAgICAgICAgIHZhciBfY29udGV4dDtcblxuICAgICAgICAgIC8vIHNvcnQgbm9kZXMgaW4gbGV2ZWwgYnkgcG9zaXRpb246XG4gICAgICAgICAgdmFyIG5vZGVBcnJheSA9IGtleXMkMyhkaXN0cmlidXRpb25bbGV2ZWxdKTtcblxuICAgICAgICAgIG5vZGVBcnJheSA9IHRoaXMuX2luZGV4QXJyYXlUb05vZGVzKG5vZGVBcnJheSk7XG5cbiAgICAgICAgICBzb3J0JDIoX2NvbnRleHQgPSB0aGlzLmRpcmVjdGlvbikuY2FsbChfY29udGV4dCwgbm9kZUFycmF5KTtcblxuICAgICAgICAgIHZhciBoYW5kbGVkTm9kZUNvdW50ID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVBcnJheVtpXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25lZE5vZGVzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nO1xuICAgICAgICAgICAgICB2YXIgcG9zID0gc3BhY2luZyAqIGhhbmRsZWROb2RlQ291bnQ7IC8vIFdlIGdldCB0aGUgWCBvciBZIHZhbHVlcyB3ZSBuZWVkIGFuZCBzdG9yZSB0aGVtIGluIHBvcyBhbmQgcHJldmlvdXNQb3MuXG4gICAgICAgICAgICAgIC8vIFRoZSBnZXQgYW5kIHNldCBtYWtlIHN1cmUgd2UgZ2V0IFggb3IgWVxuXG4gICAgICAgICAgICAgIGlmIChoYW5kbGVkTm9kZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGVBcnJheVtpIC0gMV0pICsgc3BhY2luZztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKG5vZGUsIHBvcywgbGV2ZWwpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZShub2RlLCBsZXZlbCwgcG9zKTtcblxuICAgICAgICAgICAgICBoYW5kbGVkTm9kZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSByZWN1cnNpdmVseSBjYWxsZWQgZnVuY3Rpb24gdG8gZW51bWVyYXRlIHRoZSBicmFuY2hlcyBmcm9tIHRoZSBsYXJnZXN0IGh1YnMgYW5kIHBsYWNlIHRoZSBub2Rlc1xuICAgICAqIG9uIGEgWCBwb3NpdGlvbiB0aGF0IGVuc3VyZXMgdGhlcmUgd2lsbCBiZSBubyBvdmVybGFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBwYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJlbnRMZXZlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGxhY2VCcmFuY2hOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VCcmFuY2hOb2RlcyhwYXJlbnRJZCwgcGFyZW50TGV2ZWwpIHtcbiAgICAgIHZhciBfY29udGV4dDI7XG5cbiAgICAgIHZhciBjaGlsZFJlZiA9IHRoaXMuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXTsgLy8gaWYgdGhpcyBpcyBub3QgYSBwYXJlbnQsIGNhbmNlbCB0aGUgcGxhY2luZy4gVGhpcyBjYW4gaGFwcGVuIHdpdGggbXVsdGlwbGUgcGFyZW50cyB0byBvbmUgY2hpbGQuXG5cbiAgICAgIGlmIChjaGlsZFJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZ2V0IGEgbGlzdCBvZiBjaGlsZE5vZGVzXG5cblxuICAgICAgdmFyIGNoaWxkTm9kZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2godGhpcy5ib2R5Lm5vZGVzW2NoaWxkUmVmW2ldXSk7XG4gICAgICB9IC8vIHVzZSB0aGUgcG9zaXRpb25zIHRvIG9yZGVyIHRoZSBub2Rlcy5cblxuXG4gICAgICBzb3J0JDIoX2NvbnRleHQyID0gdGhpcy5kaXJlY3Rpb24pLmNhbGwoX2NvbnRleHQyLCBjaGlsZE5vZGVzKTsgLy8gcG9zaXRpb24gdGhlIGNoaWxkTm9kZXNcblxuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBjaGlsZE5vZGVzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbX2k1XTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZUxldmVsID0gdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW2NoaWxkTm9kZS5pZF07IC8vIGNoZWNrIGlmIHRoZSBjaGlsZCBub2RlIGlzIGJlbG93IHRoZSBwYXJlbnQgbm9kZSBhbmQgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBwb3NpdGlvbmVkLlxuXG4gICAgICAgIGlmIChjaGlsZE5vZGVMZXZlbCA+IHBhcmVudExldmVsICYmIHRoaXMucG9zaXRpb25lZE5vZGVzW2NoaWxkTm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldCB0aGUgYW1vdW50IG9mIHNwYWNlIHJlcXVpcmVkIGZvciB0aGlzIG5vZGUuIElmIHBhcmVudCB0aGUgd2lkdGggaXMgYmFzZWQgb24gdGhlIGFtb3VudCBvZiBjaGlsZHJlbi5cbiAgICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgdmFyIHBvcyA9IHZvaWQgMDsgLy8gd2UgZ2V0IHRoZSBYIG9yIFkgdmFsdWVzIHdlIG5lZWQgYW5kIHN0b3JlIHRoZW0gaW4gcG9zIGFuZCBwcmV2aW91c1Bvcy5cbiAgICAgICAgICAvLyBUaGUgZ2V0IGFuZCBzZXQgbWFrZSBzdXJlIHdlIGdldCBYIG9yIFlcblxuICAgICAgICAgIGlmIChfaTUgPT09IDApIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihjaGlsZE5vZGVzW19pNSAtIDFdKSArIHNwYWNpbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24oY2hpbGROb2RlLCBwb3MsIGNoaWxkTm9kZUxldmVsKTtcblxuICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZShjaGlsZE5vZGUsIGNoaWxkTm9kZUxldmVsLCBwb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjZW50ZXIgdGhlIHBhcmVudCBub2Rlcy5cblxuXG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5fZ2V0Q2VudGVyUG9zaXRpb24oY2hpbGROb2Rlcyk7XG5cbiAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKHRoaXMuYm9keS5ub2Rlc1twYXJlbnRJZF0sIGNlbnRlciwgcGFyZW50TGV2ZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjaGVja3MgZm9yIG92ZXJsYXAgYW5kIGlmIHJlcXVpcmVkIHNoaWZ0cyB0aGUgYnJhbmNoLiBJdCBhbHNvIGtlZXBzIHJlY29yZHMgb2YgcG9zaXRpb25lZCBub2Rlcy5cbiAgICAgKiBGaW5hbGx5IGl0IHdpbGwgY2FsbCBfcGxhY2VCcmFuY2hOb2RlcyB0byBwbGFjZSB0aGUgYnJhbmNoIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWUobm9kZSwgbGV2ZWwsIHBvcykge1xuICAgICAgLy8gVGhpcyBtZXRob2Qgb25seSB3b3JrcyBmb3IgZm9ybWFsIHRyZWVzIGFuZCBmb3JtYWwgZm9yZXN0c1xuICAgICAgLy8gRWFybHkgZXhpdCBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZVxuICAgICAgaWYgKCF0aGlzLmhpZXJhcmNoaWNhbC5pc1RyZWUpIHJldHVybjsgLy8gaWYgb3ZlcmxhcCBoYXMgYmVlbiBkZXRlY3RlZCwgd2Ugc2hpZnQgdGhlIGJyYW5jaFxuXG4gICAgICBpZiAodGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzUG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3RoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXV0pO1xuXG4gICAgICAgIGlmIChwb3MgLSBwcmV2aW91c1BvcyA8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICB2YXIgZGlmZiA9IHByZXZpb3VzUG9zICsgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyAtIHBvcztcblxuICAgICAgICAgIHZhciBzaGFyZWRQYXJlbnQgPSB0aGlzLl9maW5kQ29tbW9uUGFyZW50KHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSwgbm9kZS5pZCk7XG5cbiAgICAgICAgICB0aGlzLl9zaGlmdEJsb2NrKHNoYXJlZFBhcmVudC53aXRoQ2hpbGQsIGRpZmYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSA9IG5vZGUuaWQ7IC8vIHN0b3JlIGNoYW5nZSBpbiBwb3NpdGlvbi5cblxuICAgICAgdGhpcy5wb3NpdGlvbmVkTm9kZXNbbm9kZS5pZF0gPSB0cnVlO1xuXG4gICAgICB0aGlzLl9wbGFjZUJyYW5jaE5vZGVzKG5vZGUuaWQsIGxldmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZXMgYW4gYXJyYXkgd2l0aCBub2RlIGluZGljZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAgICAgKiBVc2VkIGZvciBzb3J0aW5nIGJhc2VkIG9uIG5vZGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGUuaWQ+fSBpZEFycmF5XG4gICAgICogQHJldHVybnMge0FycmF5LjxOb2RlPn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbmRleEFycmF5VG9Ob2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5kZXhBcnJheVRvTm9kZXMoaWRBcnJheSkge1xuICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheS5wdXNoKHRoaXMuYm9keS5ub2Rlc1tpZEFycmF5W2ldXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBnZXQgdGhlIGRpc3RyaWJ1dGlvbiBvZiBsZXZlbHMgYmFzZWQgb24gaHVic2l6ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RyaWJ1dGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdHJpYnV0aW9uKCkge1xuICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHt9O1xuICAgICAgdmFyIG5vZGVJZCwgbm9kZTsgLy8gd2UgZml4IFkgYmVjYXVzZSB0aGUgaGllcmFyY2h5IGlzIHZlcnRpY2FsLFxuICAgICAgLy8gd2UgZml4IFggc28gd2UgZG8gbm90IGdpdmUgYSBub2RlIGFuIHggcG9zaXRpb24gZm9yIGEgc2Vjb25kIHRpbWUuXG4gICAgICAvLyB0aGUgZml4IG9mIFggaXMgcmVtb3ZlZCBhZnRlciB0aGUgeCB2YWx1ZSBoYXMgYmVlbiBzZXQuXG5cbiAgICAgIGZvciAobm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkID8gMCA6IHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlSWRdO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLmZpeChub2RlLCBsZXZlbCk7XG5cbiAgICAgICAgICBpZiAoZGlzdHJpYnV0aW9uW2xldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXN0cmlidXRpb25bbGV2ZWxdID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlzdHJpYnV0aW9uW2xldmVsXVtub2RlSWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlzdHJpYnV0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGFjdGl2ZSAoaS5lLiB2aXNpYmxlKSBlZGdlcyBmb3IgdGhpcyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHZpcy5FZGdlPn0gQXJyYXkgb2YgZWRnZSBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFjdGl2ZUVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBY3RpdmVFZGdlcyhub2RlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yRWFjaCQzKG5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDM7XG5cbiAgICAgICAgaWYgKGluZGV4T2YkMyhfY29udGV4dDMgPSBfdGhpczQuYm9keS5lZGdlSW5kaWNlcykuY2FsbChfY29udGV4dDMsIGVkZ2UuaWQpICE9PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaHVic2l6ZXMgZm9yIGFsbCBhY3RpdmUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0SHViU2l6ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEh1YlNpemVzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBodWJTaXplcyA9IHt9O1xuICAgICAgdmFyIG5vZGVJZHMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICBmb3JFYWNoJDMobm9kZUlkcywgZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICB2YXIgbm9kZSA9IF90aGlzNS5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgdmFyIGh1YlNpemUgPSBfdGhpczUuX2dldEFjdGl2ZUVkZ2VzKG5vZGUpLmxlbmd0aDtcblxuICAgICAgICBodWJTaXplc1todWJTaXplXSA9IHRydWU7XG4gICAgICB9KTsgLy8gTWFrZSBhbiBhcnJheSBvZiB0aGUgc2l6ZSBzb3J0ZWQgZGVzY2VuZGluZ1xuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3JFYWNoJDMoaHViU2l6ZXMsIGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKE51bWJlcihzaXplKSk7XG4gICAgICB9KTtcblxuICAgICAgc29ydCQyKHRpbXNvcnQkMSkuY2FsbCh0aW1zb3J0JDEsIHJlc3VsdCwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIgLSBhO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gYWxsb2NhdGVzIG5vZGVzIGluIGxldmVscyBiYXNlZCBvbiB0aGUgcmVjdXJzaXZlIGJyYW5jaGluZyBmcm9tIHRoZSBsYXJnZXN0IGh1YnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZUxldmVsc0J5SHVic2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBsZXZlbERvd25zdHJlYW0gPSBmdW5jdGlvbiBsZXZlbERvd25zdHJlYW0obm9kZUEsIG5vZGVCKSB7XG4gICAgICAgIF90aGlzNi5oaWVyYXJjaGljYWwubGV2ZWxEb3duc3RyZWFtKG5vZGVBLCBub2RlQik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgaHViU2l6ZXMgPSB0aGlzLl9nZXRIdWJTaXplcygpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgIHZhciBodWJTaXplID0gaHViU2l6ZXNbaV07XG4gICAgICAgIGlmIChodWJTaXplID09PSAwKSByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICBmb3JFYWNoJDMoX3RoaXM2LmJvZHkubm9kZUluZGljZXMsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzNi5ib2R5Lm5vZGVzW25vZGVJZF07XG5cbiAgICAgICAgICBpZiAoaHViU2l6ZSA9PT0gX3RoaXM2Ll9nZXRBY3RpdmVFZGdlcyhub2RlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIF90aGlzNi5fY3Jhd2xOZXR3b3JrKGxldmVsRG93bnN0cmVhbSwgbm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBodWJTaXplcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgX3JldCA9IF9sb29wKGkpO1xuXG4gICAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUT0RPOiByZWxlYXNlIGZlYXR1cmVcbiAgICAgKiBUT0RPOiBEZXRlcm1pbmUgaWYgdGhpcyBmZWF0dXJlIGlzIG5lZWRlZCBhdCBhbGxcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBtaW5MZXZlbCA9IDEwMDAwMDsgLy8gVE9ETzogdGhpcyBzaG91bGQgY29tZSBmcm9tIG9wdGlvbnMuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gVGhpcyBzaG91bGQgZXZlbnR1YWxseSBiZSBpbXBsZW1lbnRlZCB3aXRoIHRoZXNlIHBhcmFtZXRlcnMgdXNlZC5cblxuICAgICAgdmFyIGN1c3RvbUNhbGxiYWNrID0gZnVuY3Rpb24gY3VzdG9tQ2FsbGJhY2sobm9kZUEsIG5vZGVCLCBlZGdlKSB7fTsgLy8gVE9ETzogcGVyaGFwcyBtb3ZlIHRvIEhpZXJhcmNoaWNhbFN0YXR1cy5cbiAgICAgIC8vICAgICAgIEJ1dCBJIGN1cnJlbnRseSBkb24ndCBzZWUgdGhlIHBvaW50LCB0aGlzIG1ldGhvZCBpcyBub3QgdXNlZC5cblxuXG4gICAgICB2YXIgbGV2ZWxCeURpcmVjdGlvbiA9IGZ1bmN0aW9uIGxldmVsQnlEaXJlY3Rpb24obm9kZUEsIG5vZGVCLCBlZGdlKSB7XG4gICAgICAgIHZhciBsZXZlbEEgPSBfdGhpczcuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQS5pZF07IC8vIHNldCBpbml0aWFsIGxldmVsXG5cbiAgICAgICAgaWYgKGxldmVsQSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV2ZWxBID0gX3RoaXM3LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUEuaWRdID0gbWluTGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZiA9IGN1c3RvbUNhbGxiYWNrKE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlQSwgXCJub2RlXCIpLCBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMobm9kZUIsIFwibm9kZVwiKSwgTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGVkZ2UsIFwiZWRnZVwiKSk7XG4gICAgICAgIF90aGlzNy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVCLmlkXSA9IGxldmVsQSArIGRpZmY7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9jcmF3bE5ldHdvcmsobGV2ZWxCeURpcmVjdGlvbik7XG5cbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsLnNldE1pbkxldmVsVG9aZXJvKHRoaXMuYm9keS5ub2Rlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlIG5vZGVzIGluIGxldmVscyBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCkge1xuICAgICAgdmFyIF9jb250ZXh0NCxcbiAgICAgICAgICBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgbm9kZXMgPSByZWR1Y2UkMihfY29udGV4dDQgPSB0aGlzLmJvZHkubm9kZUluZGljZXMpLmNhbGwoX2NvbnRleHQ0LCBmdW5jdGlvbiAoYWNjLCBpZCkge1xuICAgICAgICBhY2Muc2V0KGlkLCBfdGhpczguYm9keS5ub2Rlc1tpZF0pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwgbmV3IG1hcCQ1KCkpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5zaGFrZVRvd2FyZHMgPT09IFwicm9vdHNcIikge1xuICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHMgPSBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25Sb290cyhub2Rlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHMgPSBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25MZWF2ZXMobm9kZXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhpZXJhcmNoaWNhbC5zZXRNaW5MZXZlbFRvWmVybyh0aGlzLmJvZHkubm9kZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGJvb2trZWVwaW5nIG9mIHBhcmVudCBhbmQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbmVyYXRlTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZU1hcCgpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB2YXIgZmlsbEluUmVsYXRpb25zID0gZnVuY3Rpb24gZmlsbEluUmVsYXRpb25zKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICAgICAgICBpZiAoX3RoaXM5LmhpZXJhcmNoaWNhbC5sZXZlbHNbY2hpbGROb2RlLmlkXSA+IF90aGlzOS5oaWVyYXJjaGljYWwubGV2ZWxzW3BhcmVudE5vZGUuaWRdKSB7XG4gICAgICAgICAgX3RoaXM5LmhpZXJhcmNoaWNhbC5hZGRSZWxhdGlvbihwYXJlbnROb2RlLmlkLCBjaGlsZE5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9jcmF3bE5ldHdvcmsoZmlsbEluUmVsYXRpb25zKTtcblxuICAgICAgdGhpcy5oaWVyYXJjaGljYWwuY2hlY2tJZlRyZWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3Jhd2wgb3ZlciB0aGUgZW50aXJlIG5ldHdvcmsgYW5kIHVzZSBhIGNhbGxiYWNrIG9uIGVhY2ggbm9kZSBjb3VwbGUgdGhhdCBpcyBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1mdW5jdGlvbigpe31dICAgICAgICAgIHwgd2lsbCByZWNlaXZlIG5vZGVBLCBub2RlQiBhbmQgdGhlIGNvbm5lY3RpbmcgZWRnZS4gQSBhbmQgQiBhcmUgZGlzdGluY3QuXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBzdGFydGluZ05vZGVJZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3Jhd2xOZXR3b3JrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmF3bE5ldHdvcmsoKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24gKCkge307XG4gICAgICB2YXIgc3RhcnRpbmdOb2RlSWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwcm9ncmVzcyA9IHt9O1xuXG4gICAgICB2YXIgY3Jhd2xlciA9IGZ1bmN0aW9uIGNyYXdsZXIobm9kZSwgdHJlZSkge1xuICAgICAgICBpZiAocHJvZ3Jlc3Nbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzMTAuaGllcmFyY2hpY2FsLnNldFRyZWVJbmRleChub2RlLCB0cmVlKTtcblxuICAgICAgICAgIHByb2dyZXNzW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlO1xuXG4gICAgICAgICAgdmFyIGVkZ2VzID0gX3RoaXMxMC5fZ2V0QWN0aXZlRWRnZXMobm9kZSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ICc9PT0nIGJlY2F1c2UgaWQncyBjYW4gYmUgc3RyaW5nIGFuZCBudW1lcmljXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gZWRnZS5mcm9tO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGVkZ2UudG87XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPSBjaGlsZE5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgJyE9PScgYmVjYXVzZSBpZCdzIGNhbiBiZSBzdHJpbmcgYW5kIG51bWVyaWNcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlLCBjaGlsZE5vZGUsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIGNyYXdsZXIoY2hpbGROb2RlLCB0cmVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHN0YXJ0aW5nTm9kZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ3Jhd2wgb3ZlciBhbGwgbm9kZXNcbiAgICAgICAgdmFyIHRyZWVJbmRleCA9IDA7IC8vIFNlcnZlcyB0byBwYXNzIGEgdW5pcXVlIGlkIGZvciB0aGUgY3VycmVudCBkaXN0aW5jdCB0cmVlXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldO1xuXG4gICAgICAgICAgaWYgKHByb2dyZXNzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIGNyYXdsZXIobm9kZSwgdHJlZUluZGV4KTtcbiAgICAgICAgICAgIHRyZWVJbmRleCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3Jhd2wgZnJvbSB0aGUgZ2l2ZW4gc3RhcnRpbmcgbm9kZVxuICAgICAgICB2YXIgX25vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW3N0YXJ0aW5nTm9kZUlkXTtcblxuICAgICAgICBpZiAoX25vZGUyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZSBub3QgZm91bmQ6XCIsIHN0YXJ0aW5nTm9kZUlkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjcmF3bGVyKF9ub2RlMik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNoaWZ0IGEgYnJhbmNoIGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBwYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zaGlmdEJsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaGlmdEJsb2NrKHBhcmVudElkLCBkaWZmKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgIHZhciBwcm9ncmVzcyA9IHt9O1xuXG4gICAgICB2YXIgc2hpZnRlciA9IGZ1bmN0aW9uIHNoaWZ0ZXIocGFyZW50SWQpIHtcbiAgICAgICAgaWYgKHByb2dyZXNzW3BhcmVudElkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyZXNzW3BhcmVudElkXSA9IHRydWU7XG5cbiAgICAgICAgX3RoaXMxMS5kaXJlY3Rpb24uc2hpZnQocGFyZW50SWQsIGRpZmYpO1xuXG4gICAgICAgIHZhciBjaGlsZFJlZiA9IF90aGlzMTEuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXTtcblxuICAgICAgICBpZiAoY2hpbGRSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNoaWZ0ZXIoY2hpbGRSZWZbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2hpZnRlcihwYXJlbnRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBjb21tb24gcGFyZW50IGJldHdlZW4gYnJhbmNoZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGNoaWxkQVxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gY2hpbGRCXG4gICAgICogQHJldHVybnMge3tmb3VuZFBhcmVudCwgd2l0aENoaWxkfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRDb21tb25QYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRDb21tb25QYXJlbnQoY2hpbGRBLCBjaGlsZEIpIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgdmFyIHBhcmVudHMgPSB7fTtcblxuICAgICAgdmFyIGl0ZXJhdGVQYXJlbnRzID0gZnVuY3Rpb24gaXRlcmF0ZVBhcmVudHMocGFyZW50cywgY2hpbGQpIHtcbiAgICAgICAgdmFyIHBhcmVudFJlZiA9IF90aGlzMTIuaGllcmFyY2hpY2FsLnBhcmVudFJlZmVyZW5jZVtjaGlsZF07XG5cbiAgICAgICAgaWYgKHBhcmVudFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRSZWZbaV07XG4gICAgICAgICAgICBwYXJlbnRzW3BhcmVudF0gPSB0cnVlO1xuICAgICAgICAgICAgaXRlcmF0ZVBhcmVudHMocGFyZW50cywgcGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBmaW5kUGFyZW50ID0gZnVuY3Rpb24gZmluZFBhcmVudChwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICB2YXIgcGFyZW50UmVmID0gX3RoaXMxMi5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW2NoaWxkXTtcblxuICAgICAgICBpZiAocGFyZW50UmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudFJlZltpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudHNbcGFyZW50XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm91bmRQYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgICAgICB3aXRoQ2hpbGQ6IGNoaWxkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBicmFuY2ggPSBmaW5kUGFyZW50KHBhcmVudHMsIHBhcmVudCk7XG5cbiAgICAgICAgICAgIGlmIChicmFuY2guZm91bmRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvdW5kUGFyZW50OiBudWxsLFxuICAgICAgICAgIHdpdGhDaGlsZDogY2hpbGRcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGl0ZXJhdGVQYXJlbnRzKHBhcmVudHMsIGNoaWxkQSk7XG4gICAgICByZXR1cm4gZmluZFBhcmVudChwYXJlbnRzLCBjaGlsZEIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0cmF0ZWd5IHBhdHRlcm4gZm9yIGhhbmRsaW5nIHRoZSBjb29yZGluYXRlcyBnaXZlbiB0aGUgY3VycmVudCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgaW5kaXZpZHVhbCBpbnN0YW5jZXMgY29udGFpbiBhbGwgdGhlIG9wZXJhdGlvbnMgYW5kIGRhdGEgc3BlY2lmaWMgdG8gYSBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90VXBkYXRlPWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXREaXJlY3Rpb25TdHJhdGVneVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXJlY3Rpb25TdHJhdGVneSgpIHtcbiAgICAgIHZhciBpc1ZlcnRpY2FsID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09IFwiVURcIiB8fCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gXCJEVVwiO1xuXG4gICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IG5ldyBWZXJ0aWNhbFN0cmF0ZWd5KHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBuZXcgSG9yaXpvbnRhbFN0cmF0ZWd5KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiBhIGJyYW5jaCBmcm9tIHRoZSBwYXNzZWQgbGlzdCBvZiBjaGlsZCBub2Rlc1xuICAgICAqXG4gICAgICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHBvc2l0aW9ucyBvZiBhbGwgdGhlIGNoaWxkIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZXx2aXMuTm9kZS5pZD59IGNoaWxkTm9kZXMgIEFycmF5IG9mIGVpdGhlciBjaGlsZCBub2RlcyBvciBub2RlIGlkJ3NcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q2VudGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENlbnRlclBvc2l0aW9uKGNoaWxkTm9kZXMpIHtcbiAgICAgIHZhciBtaW5Qb3MgPSAxZTk7XG4gICAgICB2YXIgbWF4UG9zID0gLTFlOTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZXNbaV0uaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICBjaGlsZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24oY2hpbGROb2RlKTtcbiAgICAgICAgbWluUG9zID0gTWF0aC5taW4obWluUG9zLCBwb3NpdGlvbik7XG4gICAgICAgIG1heFBvcyA9IE1hdGgubWF4KG1heFBvcywgcG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMC41ICogKG1pblBvcyArIG1heFBvcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExheW91dEVuZ2luZTtcbn0oKTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIHRvb2xiYXIgZGl2IGVsZW1lbnQgb2YgY2hpbGRyZW5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBNYW5pcHVsYXRpb25TeXN0ZW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKiBAcGFyYW0ge1NlbGVjdGlvbkhhbmRsZXJ9IHNlbGVjdGlvbkhhbmRsZXJcbiAgICogQHBhcmFtIHtJbnRlcmFjdGlvbkhhbmRsZXJ9IGludGVyYWN0aW9uSGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gTWFuaXB1bGF0aW9uU3lzdGVtKGJvZHksIGNhbnZhcywgc2VsZWN0aW9uSGFuZGxlciwgaW50ZXJhY3Rpb25IYW5kbGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgX2NvbnRleHQsXG4gICAgICAgIF9jb250ZXh0MjtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1hbmlwdWxhdGlvblN5c3RlbSk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IHNlbGVjdGlvbkhhbmRsZXI7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIgPSBpbnRlcmFjdGlvbkhhbmRsZXI7XG4gICAgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZWRpdE1vZGVEaXYgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jbG9zZURpdiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMgPSBbXTtcbiAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zID0ge307XG4gICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucyA9IFtdO1xuICAgIHRoaXMudG91Y2hUaW1lID0gMDtcbiAgICB0aGlzLnRlbXBvcmFyeUlkcyA9IHtcbiAgICAgIG5vZGVzOiBbXSxcbiAgICAgIGVkZ2VzOiBbXVxuICAgIH07XG4gICAgdGhpcy5ndWlFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbk1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgaW5pdGlhbGx5QWN0aXZlOiBmYWxzZSxcbiAgICAgIGFkZE5vZGU6IHRydWUsXG4gICAgICBhZGRFZGdlOiB0cnVlLFxuICAgICAgZWRpdE5vZGU6IHVuZGVmaW5lZCxcbiAgICAgIGVkaXRFZGdlOiB0cnVlLFxuICAgICAgZGVsZXRlTm9kZTogdHJ1ZSxcbiAgICAgIGRlbGV0ZUVkZ2U6IHRydWUsXG4gICAgICBjb250cm9sTm9kZVN0eWxlOiB7XG4gICAgICAgIHNoYXBlOiBcImRvdFwiLFxuICAgICAgICBzaXplOiA2LFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IFwiI2ZmMDAwMFwiLFxuICAgICAgICAgIGJvcmRlcjogXCIjM2MzYzNjXCIsXG4gICAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiMwN2Y5NjhcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCIjM2MzYzNjXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJvcmRlcldpZHRoOiAyLFxuICAgICAgICBib3JkZXJXaWR0aFNlbGVjdGVkOiAyXG4gICAgICB9XG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2NsZWFuKCk7XG4gICAgfSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgYmluZCQyKF9jb250ZXh0ID0gdGhpcy5fcmVzdG9yZSkuY2FsbChfY29udGV4dCwgdGhpcykpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3Jlc2V0RGF0YVwiLCBiaW5kJDIoX2NvbnRleHQyID0gdGhpcy5fcmVzdG9yZSkuY2FsbChfY29udGV4dDIsIHRoaXMpKTtcbiAgfVxuICAvKipcbiAgICogSWYgc29tZXRoaW5nIGNoYW5nZXMgaW4gdGhlIGRhdGEgZHVyaW5nIGVkaXRpbmcsIHN3aXRjaCBiYWNrIHRvIHRoZSBpbml0aWFsIGRhdGFtYW5pcHVsYXRpb24gc3RhdGUgYW5kIGNsb3NlIGFsbCBlZGl0IG1vZGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKE1hbmlwdWxhdGlvblN5c3RlbSwgW3tcbiAgICBrZXk6IFwiX3Jlc3RvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmUoKSB7XG4gICAgICBpZiAodGhpcy5pbk1vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdGlhbGx5QWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBPcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhbGxPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBhbGxPcHRpb25zLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICBpZiAoYWxsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhbGxPcHRpb25zLmxvY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZSA9IGFsbE9wdGlvbnMubG9jYWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGUgPSBnbG9iYWxPcHRpb25zLmxvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbGxPcHRpb25zLmxvY2FsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGVzID0gYWxsT3B0aW9ucy5sb2NhbGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGVzID0gZ2xvYmFsT3B0aW9ucy5sb2NhbGVzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgZGVlcEV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbml0aWFsbHlBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldHVwKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGVkaXQtbW9kZS4gRHJhd3MgdGhlIERPTSByZXF1aXJlZCBhbmQgY2xlYW5zIHVwIGFmdGVyIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVFZGl0TW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVFZGl0TW9kZSgpIHtcbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgRWRpdCBNb2RlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVFZGl0TW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBFZGl0IE1vZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVFZGl0TW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRCdXR0b24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgbWFpbiB0b29sYmFyLiBSZW1vdmVzIGZ1bmN0aW9ucyBib3VuZCB0byB0aGUgc2VsZWN0IGV2ZW50LiBCaW5kcyBhbGwgdGhlIGJ1dHRvbnMgb2YgdGhlIHRvb2xiYXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd01hbmlwdWxhdG9yVG9vbGJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93TWFuaXB1bGF0b3JUb29sYmFyKCkge1xuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7IC8vIHJlc2V0IGdsb2JhbCB2YXJpYWJsZXNcblxuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9OyAvLyBpZiB0aGUgZ3VpIGlzIGVuYWJsZWQsIGRyYXcgYWxsIGVsZW1lbnRzLlxuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDMsIF9jb250ZXh0NDtcblxuICAgICAgICAvLyBhIF9yZXN0b3JlIHdpbGwgaGlkZSB0aGVzZSBtZW51c1xuICAgICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB2YXIgc2VsZWN0ZWROb2RlQ291bnQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlQ291bnQoKTtcbiAgICAgICAgdmFyIHNlbGVjdGVkRWRnZUNvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUNvdW50KCk7XG4gICAgICAgIHZhciBzZWxlY3RlZFRvdGFsQ291bnQgPSBzZWxlY3RlZE5vZGVDb3VudCArIHNlbGVjdGVkRWRnZUNvdW50O1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG4gICAgICAgIHZhciBuZWVkU2VwZXJhdG9yID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGROb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUFkZE5vZGVCdXR0b24obG9jYWxlKTtcblxuICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRFZGdlICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3RlZE5vZGVDb3VudCA9PT0gMSAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXROb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVFZGl0Tm9kZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkRWRnZUNvdW50ID09PSAxICYmIHNlbGVjdGVkTm9kZUNvdW50ID09PSAwICYmIHRoaXMub3B0aW9ucy5lZGl0RWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVFZGl0RWRnZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICB9IC8vIHJlbW92ZSBidXR0b25zXG5cblxuICAgICAgICBpZiAoc2VsZWN0ZWRUb3RhbENvdW50ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID4gMCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcig0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRGVsZXRlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZE5vZGVDb3VudCA9PT0gMCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlRWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcig0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlRGVsZXRlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuXG5cbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KHRoaXMuY2xvc2VEaXYsIGJpbmQkMihfY29udGV4dDMgPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0MywgdGhpcykpOyAvLyByZWZyZXNoIHRoaXMgYmFyIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gc2VsZWN0ZWRcblxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRFdmVudChcInNlbGVjdFwiLCBiaW5kJDIoX2NvbnRleHQ0ID0gdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKS5jYWxsKF9jb250ZXh0NCwgdGhpcykpO1xuICAgICAgfSAvLyByZWRyYXcgdG8gc2hvdyBhbnkgcG9zc2libGUgY2hhbmdlc1xuXG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHRvb2xiYXIgZm9yIGFkZGluZyBOb2Rlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTm9kZU1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZU1vZGUoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ2O1xuXG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcblxuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9IFwiYWRkTm9kZVwiO1xuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDU7XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbXCJhZGREZXNjcmlwdGlvblwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiYWRkRGVzY3JpcHRpb25cIl0pOyAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cblxuXG4gICAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0Rpdih0aGlzLmNsb3NlRGl2LCBiaW5kJDIoX2NvbnRleHQ1ID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDUsIHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KFwiY2xpY2tcIiwgYmluZCQyKF9jb250ZXh0NiA9IHRoaXMuX3BlcmZvcm1BZGROb2RlKS5jYWxsKF9jb250ZXh0NiwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjYWxsIHRoZSBib3VuZCBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGVkaXRpbmcgb2YgdGhlIG5vZGUuIFRoZSBub2RlIGhhcyB0byBiZSBzZWxlY3RlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVkaXROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXROb2RlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfSAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuXG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZXMoKVswXTtcblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmluTW9kZSA9IFwiZWRpdE5vZGVcIjtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5lZGl0Tm9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRlZXBFeHRlbmQoe30sIG5vZGUub3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgZGF0YS54ID0gbm9kZS54O1xuICAgICAgICAgICAgZGF0YS55ID0gbm9kZS55O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXROb2RlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdE5vZGUoZGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXMyLmluTW9kZSA9PT0gXCJlZGl0Tm9kZVwiKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfdGhpczIuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bXCJlZGl0Q2x1c3RlckVycm9yXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGl0Q2x1c3RlckVycm9yXCJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZnVuY3Rpb24gaGFzIGJlZW4gY29uZmlndXJlZCB0byBoYW5kbGUgdGhlIGVkaXRpbmcgb2Ygbm9kZXMuXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSB0b29sYmFyIHRvIGNvbm5lY3Qgbm9kZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEVkZ2VNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVkZ2VNb2RlKCkge1xuICAgICAgdmFyIF9jb250ZXh0OCwgX2NvbnRleHQ5LCBfY29udGV4dDEwLCBfY29udGV4dDExLCBfY29udGV4dDEyO1xuXG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcblxuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9IFwiYWRkRWRnZVwiO1xuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDc7XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbXCJlZGdlRGVzY3JpcHRpb25cIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkZ2VEZXNjcmlwdGlvblwiXSk7IC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuXG5cbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KHRoaXMuY2xvc2VEaXYsIGJpbmQkMihfY29udGV4dDcgPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0NywgdGhpcykpO1xuICAgICAgfSAvLyB0ZW1wb3JhcmlseSBvdmVybG9hZCBmdW5jdGlvbnNcblxuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRvdWNoXCIsIGJpbmQkMihfY29udGV4dDggPSB0aGlzLl9oYW5kbGVDb25uZWN0KS5jYWxsKF9jb250ZXh0OCwgdGhpcykpO1xuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdFbmRcIiwgYmluZCQyKF9jb250ZXh0OSA9IHRoaXMuX2ZpbmlzaENvbm5lY3QpLmNhbGwoX2NvbnRleHQ5LCB0aGlzKSk7XG5cbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1wiLCBiaW5kJDIoX2NvbnRleHQxMCA9IHRoaXMuX2RyYWdDb250cm9sTm9kZSkuY2FsbChfY29udGV4dDEwLCB0aGlzKSk7XG5cbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uUmVsZWFzZVwiLCBiaW5kJDIoX2NvbnRleHQxMSA9IHRoaXMuX2ZpbmlzaENvbm5lY3QpLmNhbGwoX2NvbnRleHQxMSwgdGhpcykpO1xuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdTdGFydFwiLCBiaW5kJDIoX2NvbnRleHQxMiA9IHRoaXMuX2RyYWdTdGFydEVkZ2UpLmNhbGwoX2NvbnRleHQxMiwgdGhpcykpO1xuXG4gICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkhvbGRcIiwgZnVuY3Rpb24gKCkge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgdGhlIHRvb2xiYXIgdG8gZWRpdCBlZGdlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZWRpdEVkZ2VNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRFZGdlTW9kZSgpIHtcbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcblxuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9IFwiZWRpdEVkZ2VcIjtcblxuICAgICAgaWYgKF90eXBlb2ZfMSh0aGlzLm9wdGlvbnMuZWRpdEVkZ2UpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZWRpdEVkZ2UuZWRpdFdpdGhvdXREcmFnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VJZHMoKVswXTtcblxuICAgICAgICBpZiAodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG5cbiAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2UoZWRnZS5mcm9tLmlkLCBlZGdlLnRvLmlkKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDEzO1xuXG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKCk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24obG9jYWxlW1wiZWRpdEVkZ2VEZXNjcmlwdGlvblwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdEVkZ2VEZXNjcmlwdGlvblwiXSk7IC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuXG5cbiAgICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KHRoaXMuY2xvc2VEaXYsIGJpbmQkMihfY29udGV4dDEzID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDEzLCB0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzKClbMF07XG5cbiAgICAgIGlmICh0aGlzLmVkZ2VCZWluZ0VkaXRlZElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MTQsIF9jb250ZXh0MTUsIF9jb250ZXh0MTYsIF9jb250ZXh0MTc7XG5cbiAgICAgICAgdmFyIF9lZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdOyAvLyBjcmVhdGUgY29udHJvbCBub2Rlc1xuXG4gICAgICAgIHZhciBjb250cm9sTm9kZUZyb20gPSB0aGlzLl9nZXROZXdUYXJnZXROb2RlKF9lZGdlLmZyb20ueCwgX2VkZ2UuZnJvbS55KTtcblxuICAgICAgICB2YXIgY29udHJvbE5vZGVUbyA9IHRoaXMuX2dldE5ld1RhcmdldE5vZGUoX2VkZ2UudG8ueCwgX2VkZ2UudG8ueSk7XG5cbiAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaChjb250cm9sTm9kZUZyb20uaWQpO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKGNvbnRyb2xOb2RlVG8uaWQpO1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbY29udHJvbE5vZGVGcm9tLmlkXSA9IGNvbnRyb2xOb2RlRnJvbTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2goY29udHJvbE5vZGVGcm9tLmlkKTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NvbnRyb2xOb2RlVG8uaWRdID0gY29udHJvbE5vZGVUbztcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2goY29udHJvbE5vZGVUby5pZCk7IC8vIHRlbXBvcmFyaWx5IG92ZXJsb2FkIFVJIGZ1bmN0aW9ucywgY2xlYW5lZCB1cCBhdXRvbWF0aWNhbGx5IGJlY2F1c2Ugb2YgX3RlbXBvcmFyeUJpbmRVSVxuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uVG91Y2hcIiwgYmluZCQyKF9jb250ZXh0MTQgPSB0aGlzLl9jb250cm9sTm9kZVRvdWNoKS5jYWxsKF9jb250ZXh0MTQsIHRoaXMpKTsgLy8gdXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRhcFwiLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkhvbGRcIiwgZnVuY3Rpb24gKCkge30pOyAvLyBkaXNhYmxlZFxuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnU3RhcnRcIiwgYmluZCQyKF9jb250ZXh0MTUgPSB0aGlzLl9jb250cm9sTm9kZURyYWdTdGFydCkuY2FsbChfY29udGV4dDE1LCB0aGlzKSk7IC8vIHVzZWQgdG8gc2VsZWN0IGNvbnRyb2wgbm9kZVxuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnXCIsIGJpbmQkMihfY29udGV4dDE2ID0gdGhpcy5fY29udHJvbE5vZGVEcmFnKS5jYWxsKF9jb250ZXh0MTYsIHRoaXMpKTsgLy8gdXNlZCB0byBkcmFnIGNvbnRyb2wgbm9kZVxuXG5cbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnRW5kXCIsIGJpbmQkMihfY29udGV4dDE3ID0gdGhpcy5fY29udHJvbE5vZGVEcmFnRW5kKS5jYWxsKF9jb250ZXh0MTcsIHRoaXMpKTsgLy8gdXNlZCB0byBjb25uZWN0IG9yIHJldmVydCBjb250cm9sIG5vZGVzXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbk1vdXNlTW92ZVwiLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG4gICAgICAgIC8vIGNyZWF0ZSBmdW5jdGlvbiB0byBwb3NpdGlvbiBjb250cm9sIG5vZGVzIGNvcnJlY3RseSBvbiBtb3ZlbWVudFxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgYmVjYXVzZSB3ZSB1c2UgdGhlIHRlbXBvcmFyeSBiaW5kXG5cblxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kRXZlbnQoXCJiZWZvcmVEcmF3aW5nXCIsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb25zID0gX2VkZ2UuZWRnZVR5cGUuZmluZEJvcmRlclBvc2l0aW9ucyhjdHgpO1xuXG4gICAgICAgICAgaWYgKGNvbnRyb2xOb2RlRnJvbS5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlRnJvbS54ID0gcG9zaXRpb25zLmZyb20ueDtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlRnJvbS55ID0gcG9zaXRpb25zLmZyb20ueTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udHJvbE5vZGVUby5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlVG8ueCA9IHBvc2l0aW9ucy50by54O1xuICAgICAgICAgICAgY29udHJvbE5vZGVUby55ID0gcG9zaXRpb25zLnRvLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBkZWxldGUgZXZlcnl0aGluZyBpbiB0aGUgc2VsZWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVTZWxlY3RlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVTZWxlY3RlZCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyB3aGVuIHVzaW5nIHRoZSBndWksIGVuYWJsZSBlZGl0IG1vZGUgaWYgaXQgd2FzbnQgYWxyZWFkeS5cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIH0gLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcblxuXG4gICAgICB0aGlzLl9jbGVhbigpO1xuXG4gICAgICB0aGlzLmluTW9kZSA9IFwiZGVsZXRlXCI7XG4gICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVJZHMoKTtcbiAgICAgIHZhciBzZWxlY3RlZEVkZ2VzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkRWRnZUlkcygpO1xuICAgICAgdmFyIGRlbGV0ZUZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoc2VsZWN0ZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbc2VsZWN0ZWROb2Rlc1tpXV0uaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImRlbGV0ZUNsdXN0ZXJFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZGVsZXRlQ2x1c3RlckVycm9yXCJdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5kZWxldGVOb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBkZWxldGVGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5kZWxldGVOb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkRWRnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5kZWxldGVFZGdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBkZWxldGVGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5kZWxldGVFZGdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGVsZXRlRnVuY3Rpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICBub2Rlczogc2VsZWN0ZWROb2RlcyxcbiAgICAgICAgICBlZGdlczogc2VsZWN0ZWRFZGdlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkZWxldGVGdW5jdGlvbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBkZWxldGVGdW5jdGlvbihkYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzMy5pbk1vZGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShmaW5hbGl6ZWREYXRhLmVkZ2VzKTtcblxuICAgICAgICAgICAgICBfdGhpczMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5yZW1vdmUoZmluYWxpemVkRGF0YS5ub2Rlcyk7XG5cbiAgICAgICAgICAgICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuXG4gICAgICAgICAgICAgIF90aGlzMy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG5cbiAgICAgICAgICAgICAgX3RoaXMzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGRlbGV0ZSBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShzZWxlY3RlZEVkZ2VzKTtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShzZWxlY3RlZE5vZGVzKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfSAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogUFJJVkFURSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovL1xuXG4gICAgLyoqXG4gICAgICogZHJhdyBvciByZW1vdmUgdGhlIERPTVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gRW5hYmxlIHRoZSBHVUlcbiAgICAgICAgdGhpcy5ndWlFbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVXcmFwcGVycygpO1xuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRCdXR0b24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTWFuaXB1bGF0aW9uRE9NKCk7IC8vIGRpc2FibGUgdGhlIGd1aVxuXG5cbiAgICAgICAgdGhpcy5ndWlFbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSB0aGUgZGl2IG92ZXJsYXlzIHRoYXQgY29udGFpbiB0aGUgRE9NXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVdyYXBwZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVXcmFwcGVycygpIHtcbiAgICAgIC8vIGxvYWQgdGhlIG1hbmlwdWxhdG9yIEhUTUwgZWxlbWVudHMuIEFsbCBzdHlsaW5nIGRvbmUgaW4gY3NzLlxuICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5jbGFzc05hbWUgPSBcInZpcy1tYW5pcHVsYXRpb25cIjtcblxuICAgICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25EaXYpO1xuICAgICAgfSAvLyBjb250YWluZXIgZm9yIHRoZSBlZGl0IGJ1dHRvbi5cblxuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZURpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZWRpdE1vZGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LmNsYXNzTmFtZSA9IFwidmlzLWVkaXQtbW9kZVwiO1xuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICB9IC8vIGNvbnRhaW5lciBmb3IgdGhlIGNsb3NlIGRpdiBidXR0b25cblxuXG4gICAgICBpZiAodGhpcy5jbG9zZURpdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmNsb3NlRGl2LmNsYXNzTmFtZSA9IFwidmlzLWNsb3NlXCI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY2xvc2VEaXYpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSBhIG5ldyB0YXJnZXQgbm9kZS4gVXNlZCBmb3IgY3JlYXRpbmcgbmV3IGVkZ2VzIGFuZCBlZGl0aW5nIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXROZXdUYXJnZXROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXROZXdUYXJnZXROb2RlKHgsIHkpIHtcbiAgICAgIHZhciBjb250cm9sTm9kZVN0eWxlID0gZGVlcEV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmNvbnRyb2xOb2RlU3R5bGUpO1xuICAgICAgY29udHJvbE5vZGVTdHlsZS5pZCA9IFwidGFyZ2V0Tm9kZVwiICsgdjQoKTtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUuaGlkZGVuID0gZmFsc2U7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLnBoeXNpY3MgPSBmYWxzZTtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUueCA9IHg7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLnkgPSB5OyAvLyB3ZSBoYXZlIHRvIGRlZmluZSB0aGUgYm91bmRpbmcgYm94IGluIG9yZGVyIGZvciB0aGUgbm9kZXMgdG8gYmUgZHJhd24gaW1tZWRpYXRlbHlcblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoY29udHJvbE5vZGVTdHlsZSk7XG4gICAgICBub2RlLnNoYXBlLmJvdW5kaW5nQm94ID0ge1xuICAgICAgICBsZWZ0OiB4LFxuICAgICAgICByaWdodDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICBib3R0b206IHlcbiAgICAgIH07XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBlZGl0IGJ1dHRvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUVkaXRCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRCdXR0b24oKSB7XG4gICAgICB2YXIgX2NvbnRleHQxODtcblxuICAgICAgLy8gcmVzdG9yZSBldmVyeXRoaW5nIHRvIGl0J3Mgb3JpZ2luYWwgc3RhdGUgKGlmIGFwcGxpY2FibGUpXG4gICAgICB0aGlzLl9jbGVhbigpOyAvLyByZXNldCB0aGUgbWFuaXB1bGF0aW9uRE9NXG5cblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTsgLy8gZW1wdHkgdGhlIGVkaXRNb2RlRGl2XG5cbiAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmVkaXRNb2RlRGl2KTsgLy8gY3JlYXRlIHRoZSBjb250ZW50cyBmb3IgdGhlIGVkaXRNb2RlIGJ1dHRvblxuXG4gICAgICB2YXIgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV07XG5cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJlZGl0TW9kZVwiLCBcInZpcy1idXR0b24gdmlzLWVkaXQgdmlzLWVkaXQtbW9kZVwiLCBsb2NhbGVbXCJlZGl0XCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGl0XCJdKTtcblxuICAgICAgdGhpcy5lZGl0TW9kZURpdi5hcHBlbmRDaGlsZChidXR0b24pOyAvLyBiaW5kIGEgaGFtbWVyIGxpc3RlbmVyIHRvIHRoZSBidXR0b24sIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIHRvZ2dsZUVkaXRNb2RlLlxuXG4gICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCBiaW5kJDIoX2NvbnRleHQxOCA9IHRoaXMudG9nZ2xlRWRpdE1vZGUpLmNhbGwoX2NvbnRleHQxOCwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGNsZWFucyB1cCBhZnRlciBldmVyeXRoaW5nIHRoaXMgbW9kdWxlIGRvZXMuIFRlbXBvcmFyeSBlbGVtZW50cywgZnVuY3Rpb25zIGFuZCBldmVudHMgYXJlIHJlbW92ZWQsIHBoeXNpY3MgcmVzdG9yZWQsIGhhbW1lcnMgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuKCkge1xuICAgICAgLy8gbm90IGluIG1vZGVcbiAgICAgIHRoaXMuaW5Nb2RlID0gZmFsc2U7IC8vIF9jbGVhbiB0aGUgZGl2c1xuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMubWFuaXB1bGF0aW9uRGl2KTsgLy8gcmVtb3ZlcyBhbGwgdGhlIGJpbmRpbmdzIGFuZCBvdmVybG9hZHNcblxuICAgICAgICB0aGlzLl9jbGVhbk1hbmlwdWxhdG9ySGFtbWVycygpO1xuICAgICAgfSAvLyByZW1vdmUgdGVtcG9yYXJ5IG5vZGVzIGFuZCBlZGdlc1xuXG5cbiAgICAgIHRoaXMuX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCk7IC8vIHJlc3RvcmUgb3ZlcmxvYWRlZCBVSSBmdW5jdGlvbnNcblxuXG4gICAgICB0aGlzLl91bmJpbmRUZW1wb3JhcnlVSXMoKTsgLy8gcmVtb3ZlIHRoZSB0ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1xuXG5cbiAgICAgIHRoaXMuX3VuYmluZFRlbXBvcmFyeUV2ZW50cygpOyAvLyByZXN0b3JlIHRoZSBwaHlzaWNzIGlmIHJlcXVpcmVkXG5cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc3RvcmVQaHlzaWNzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYWNoIGRvbSBlbGVtZW50IGhhcyBpdCdzIG93biBoYW1tZXIuIFRoZXkgYXJlIHN0b3JlZCBpbiB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMuIFRoaXMgY2xlYW5zIHRoZW0gdXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFuTWFuaXB1bGF0b3JIYW1tZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbk1hbmlwdWxhdG9ySGFtbWVycygpIHtcbiAgICAgIC8vIF9jbGVhbiBoYW1tZXIgYmluZGluZ3NcbiAgICAgIGlmICh0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMubGVuZ3RoICE9IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkhhbW1lcnNbaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgRE9NIGVsZW1lbnRzIGNyZWF0ZWQgYnkgdGhpcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZU1hbmlwdWxhdGlvbkRPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlTWFuaXB1bGF0aW9uRE9NKCkge1xuICAgICAgLy8gcmVtb3ZlcyBhbGwgdGhlIGJpbmRpbmdzIGFuZCBvdmVybG9hZHNcbiAgICAgIHRoaXMuX2NsZWFuKCk7IC8vIGVtcHR5IHRoZSBtYW5pcHVsYXRpb24gZGl2c1xuXG5cbiAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5jbG9zZURpdik7IC8vIHJlbW92ZSB0aGUgbWFuaXB1bGF0aW9uIGRpdnNcblxuICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uRGl2KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGVEaXYpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsb3NlRGl2KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuY2xvc2VEaXYpO1xuICAgICAgfSAvLyBzZXQgdGhlIHJlZmVyZW5jZXMgdG8gdW5kZWZpbmVkXG5cblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmVkaXRNb2RlRGl2ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jbG9zZURpdiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgc2VwZXJhdG9yIGxpbmUuIHRoZSBpbmRleCBpcyB0byBkaWZmZXJlbnRpYXRlIGluIHRoZSBtYW5pcHVsYXRpb24gZG9tXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTFdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVTZXBlcmF0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVNlcGVyYXRvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW1wic2VwZXJhdG9yTGluZURpdlwiICsgaW5kZXhdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW1wic2VwZXJhdG9yTGluZURpdlwiICsgaW5kZXhdLmNsYXNzTmFtZSA9IFwidmlzLXNlcGFyYXRvci1saW5lXCI7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVtcInNlcGVyYXRvckxpbmVEaXZcIiArIGluZGV4XSk7XG4gICAgfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAgIERPTSBmdW5jdGlvbnMgZm9yIGJ1dHRvbnMgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVBZGROb2RlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBZGROb2RlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MTk7XG5cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJhZGROb2RlXCIsIFwidmlzLWJ1dHRvbiB2aXMtYWRkXCIsIGxvY2FsZVtcImFkZE5vZGVcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImFkZE5vZGVcIl0pO1xuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCBiaW5kJDIoX2NvbnRleHQxOSA9IHRoaXMuYWRkTm9kZU1vZGUpLmNhbGwoX2NvbnRleHQxOSwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUFkZEVkZ2VCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUFkZEVkZ2VCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMDtcblxuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImFkZEVkZ2VcIiwgXCJ2aXMtYnV0dG9uIHZpcy1jb25uZWN0XCIsIGxvY2FsZVtcImFkZEVkZ2VcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImFkZEVkZ2VcIl0pO1xuXG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgICB0aGlzLl9iaW5kSGFtbWVyVG9EaXYoYnV0dG9uLCBiaW5kJDIoX2NvbnRleHQyMCA9IHRoaXMuYWRkRWRnZU1vZGUpLmNhbGwoX2NvbnRleHQyMCwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUVkaXROb2RlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFZGl0Tm9kZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDIxO1xuXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiZWRpdE5vZGVcIiwgXCJ2aXMtYnV0dG9uIHZpcy1lZGl0XCIsIGxvY2FsZVtcImVkaXROb2RlXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGl0Tm9kZVwiXSk7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIGJpbmQkMihfY29udGV4dDIxID0gdGhpcy5lZGl0Tm9kZSkuY2FsbChfY29udGV4dDIxLCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRWRpdEVkZ2VCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjI7XG5cbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJlZGl0RWRnZVwiLCBcInZpcy1idXR0b24gdmlzLWVkaXRcIiwgbG9jYWxlW1wiZWRpdEVkZ2VcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImVkaXRFZGdlXCJdKTtcblxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgICAgdGhpcy5fYmluZEhhbW1lclRvRGl2KGJ1dHRvbiwgYmluZCQyKF9jb250ZXh0MjIgPSB0aGlzLmVkaXRFZGdlTW9kZSkuY2FsbChfY29udGV4dDIyLCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRGVsZXRlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMztcblxuICAgICAgdmFyIGRlbGV0ZUJ0bkNsYXNzO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ0bCkge1xuICAgICAgICBkZWxldGVCdG5DbGFzcyA9IFwidmlzLWJ1dHRvbiB2aXMtZGVsZXRlLXJ0bFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQnRuQ2xhc3MgPSBcInZpcy1idXR0b24gdmlzLWRlbGV0ZVwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiZGVsZXRlXCIsIGRlbGV0ZUJ0bkNsYXNzLCBsb2NhbGVbXCJkZWxcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImRlbFwiXSk7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIGJpbmQkMihfY29udGV4dDIzID0gdGhpcy5kZWxldGVTZWxlY3RlZCkuY2FsbChfY29udGV4dDIzLCB0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQmFja0J1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDI0O1xuXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiYmFja1wiLCBcInZpcy1idXR0b24gdmlzLWJhY2tcIiwgbG9jYWxlW1wiYmFja1wiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiYmFja1wiXSk7XG5cbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgIHRoaXMuX2JpbmRIYW1tZXJUb0RpdihidXR0b24sIGJpbmQkMihfY29udGV4dDI0ID0gdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKS5jYWxsKF9jb250ZXh0MjQsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7bGFiZWx9IGxhYmVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsQ2xhc3NOYW1lXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCdXR0b24oaWQsIGNsYXNzTmFtZSwgbGFiZWwpIHtcbiAgICAgIHZhciBsYWJlbENsYXNzTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJ2aXMtbGFiZWxcIjtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJEaXZcIl0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkRpdlwiXS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiTGFiZWxcIl0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkxhYmVsXCJdLmNsYXNzTmFtZSA9IGxhYmVsQ2xhc3NOYW1lO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkxhYmVsXCJdLmlubmVySFRNTCA9IGxhYmVsO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkRpdlwiXS5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiTGFiZWxcIl0pO1xuICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJEaXZcIl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZURlc2NyaXB0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZXNjcmlwdGlvbihsYWJlbCkge1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlQnV0dG9uKFwiZGVzY3JpcHRpb25cIiwgXCJ2aXMtYnV0dG9uIHZpcy1ub25lXCIsIGxhYmVsKSk7XG4gICAgfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFbmQgb2YgRE9NIGZ1bmN0aW9ucyBmb3IgYnV0dG9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBiaW5kcyBhbiBldmVudCB1bnRpbCBjbGVhbnVwIGJ5IHRoZSBjbGVhbiBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdGdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdGVtcG9yYXJ5QmluZEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kRXZlbnQoZXZlbnQsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zLnB1c2goe1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIGJvdW5kRnVuY3Rpb246IG5ld0Z1bmN0aW9uXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKGV2ZW50LCBuZXdGdW5jdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgb3ZlcnJpZGVzIGFuIFVJIGZ1bmN0aW9uIHVudGlsIGNsZWFudXAgYnkgdGhlIGNsZWFuIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gVUlmdW5jdGlvbk5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdGdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdGVtcG9yYXJ5QmluZFVJXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kVUkoVUlmdW5jdGlvbk5hbWUsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbVUlmdW5jdGlvbk5hbWVdID0gdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXSA9IG5ld0Z1bmN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBVSSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdC4gVHlwbz8gWW91IHRyaWVkOiBcIiArIFVJZnVuY3Rpb25OYW1lICsgXCIgcG9zc2libGUgYXJlOiBcIiArIHN0cmluZ2lmeSQyKGtleXMkMyh0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIG92ZXJyaWRkZW4gVUkgZnVuY3Rpb25zIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91bmJpbmRUZW1wb3JhcnlVSXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VuYmluZFRlbXBvcmFyeVVJcygpIHtcbiAgICAgIGZvciAodmFyIGZ1bmN0aW9uTmFtZSBpbiB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucywgZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVyc1tmdW5jdGlvbk5hbWVdID0gdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucyA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgdGhlIGV2ZW50cyBjcmVhdGVkIGJ5IF90ZW1wb3JhcnlCaW5kRXZlbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdW5iaW5kVGVtcG9yYXJ5RXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bmJpbmRUZW1wb3JhcnlFdmVudHMoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNbaV0uZXZlbnQ7XG4gICAgICAgIHZhciBib3VuZEZ1bmN0aW9uID0gdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1tpXS5ib3VuZEZ1bmN0aW9uO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoZXZlbnROYW1lLCBib3VuZEZ1bmN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGFuIGhhbW1lciBpbnN0YW5jZSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYm91bmRGdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRIYW1tZXJUb0RpdlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEhhbW1lclRvRGl2KGRvbUVsZW1lbnQsIGJvdW5kRnVuY3Rpb24pIHtcbiAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyJDEoZG9tRWxlbWVudCwge30pO1xuICAgICAgb25Ub3VjaChoYW1tZXIsIGJvdW5kRnVuY3Rpb24pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzLnB1c2goaGFtbWVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVhdGx5IGNsZWFuIHVwIHRlbXBvcmFyeSBlZGdlcyBhbmQgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCkge1xuICAgICAgLy8gX2NsZWFuIHRlbXBvcmFyeSBlZGdlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRlbXBvcmFyeUlkcy5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2NvbnRleHQyNTtcblxuICAgICAgICB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbaV1dLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1tpXV07XG5cbiAgICAgICAgdmFyIGluZGV4VGVtcEVkZ2UgPSBpbmRleE9mJDMoX2NvbnRleHQyNSA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcykuY2FsbChfY29udGV4dDI1LCB0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1tpXSk7XG5cbiAgICAgICAgaWYgKGluZGV4VGVtcEVkZ2UgIT09IC0xKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0MjY7XG5cbiAgICAgICAgICBzcGxpY2UkMihfY29udGV4dDI2ID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzKS5jYWxsKF9jb250ZXh0MjYsIGluZGV4VGVtcEVkZ2UsIDEpO1xuICAgICAgICB9XG4gICAgICB9IC8vIF9jbGVhbiB0ZW1wb3Jhcnkgbm9kZXNcblxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfY29udGV4dDI3O1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbX2ldXTtcblxuICAgICAgICB2YXIgaW5kZXhUZW1wTm9kZSA9IGluZGV4T2YkMyhfY29udGV4dDI3ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKF9jb250ZXh0MjcsIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzW19pXSk7XG5cbiAgICAgICAgaWYgKGluZGV4VGVtcE5vZGUgIT09IC0xKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0Mjg7XG5cbiAgICAgICAgICBzcGxpY2UkMihfY29udGV4dDI4ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKF9jb250ZXh0MjgsIGluZGV4VGVtcE5vZGUsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGVtcG9yYXJ5SWRzID0ge1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGVkZ2VzOiBbXVxuICAgICAgfTtcbiAgICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIHRoZSB0b3VjaCBpcyB1c2VkIHRvIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGluaXRpYWwgY2xpY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29udHJvbE5vZGVUb3VjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVUb3VjaChldmVudCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICB0aGlzLmxhc3RUb3VjaCA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdGhpcy5sYXN0VG91Y2gudHJhbnNsYXRpb24gPSBhc3NpZ24kMih7fSwgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24pOyAvLyBjb3B5IHRoZSBvYmplY3RcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIGRyYWcgc3RhcnQgaXMgdXNlZCB0byBtYXJrIG9uZSBvZiB0aGUgY29udHJvbCBub2RlcyBhcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29udHJvbE5vZGVEcmFnU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0KCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDtcblxuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuXG4gICAgICB2YXIgZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07XG4gICAgICB2YXIgdG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMV1dO1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG4gICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgZnJvbVNlbGVjdCA9IGZyb20uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICB2YXIgdG9TZWxlY3QgPSB0by5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgaWYgKGZyb21TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gZnJvbTtcbiAgICAgICAgZWRnZS5lZGdlVHlwZS5mcm9tID0gZnJvbTtcbiAgICAgIH0gZWxzZSBpZiAodG9TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdG87XG4gICAgICAgIGVkZ2UuZWRnZVR5cGUudG8gPSB0bztcbiAgICAgIH0gLy8gd2UgdXNlIHRoZSBzZWxlY3Rpb24gdG8gZmluZCB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIFdlIGV4cGxpY2l0bHkgc2VsZWN0IGl0IGhlcmUuXG5cblxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3QodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRyYWdnaW5nIHRoZSBjb250cm9sIG5vZGVzIG9yIHRoZSBjYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29udHJvbE5vZGVEcmFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZURyYWcoZXZlbnQpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJkaXNhYmxlUGh5c2ljc1wiKTtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgcG9zID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMocG9pbnRlcik7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueCA9IHBvcy54O1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUueSA9IHBvcy55O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub25EcmFnKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbm5lY3Rpbmcgb3IgcmVzdG9yaW5nIHRoZSBjb250cm9sIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jb250cm9sTm9kZURyYWdFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlRHJhZ0VuZChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcblxuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuXG4gICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTsgLy8gaWYgdGhlIG5vZGUgdGhhdCB3YXMgZHJhZ2dlZCBpcyBub3QgYSBjb250cm9sIG5vZGUsIHJldHVyblxuXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyB3ZSB1c2UgdGhlIHNlbGVjdGlvbiB0byBmaW5kIHRoZSBub2RlIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZC4gV2UgZXhwbGljaXRseSBERXNlbGVjdCB0aGUgY29udHJvbCBub2RlIGhlcmUuXG5cblxuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG5cbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVJZHMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuXG4gICAgICB2YXIgbm9kZSA9IHVuZGVmaW5lZDtcblxuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAob3ZlcmxhcHBpbmdOb2RlSWRzW2ldICE9PSB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUuaWQpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZUlkc1tpXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcGVyZm9ybSB0aGUgY29ubmVjdGlvblxuXG5cbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bXCJjcmVhdGVFZGdlRXJyb3JcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS5pZCA9PT0gZnJvbS5pZCkge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUVkaXRFZGdlKG5vZGUuaWQsIGVkZ2UudG8uaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2UoZWRnZS5mcm9tLmlkLCBub2RlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2UudXBkYXRlRWRnZVR5cGUoKTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc3RvcmVQaHlzaWNzXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgRURJVCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBBREQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogdGhlIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzZWxlY3Rpb24gZXZlbnQuIEl0IGNoZWNrcyBpZiB5b3Ugd2FudCB0byBjb25uZWN0IGEgY2x1c3RlciBhbmQgY2hhbmdlcyB0aGUgZGVzY3JpcHRpb25cbiAgICAgKiB0byB3YWxrIHRoZSB1c2VyIHRocm91Z2ggdGhlIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlQ29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ29ubmVjdChldmVudCkge1xuICAgICAgLy8gY2hlY2sgdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gMTAwKSB7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uID0gYXNzaWduJDIoe30sIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKTsgLy8gY29weSB0aGUgb2JqZWN0XG5cbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIuZHJhZy5wb2ludGVyID0gdGhpcy5sYXN0VG91Y2g7IC8vIERyYWcgcG9pbnRlciBpcyBub3QgdXBkYXRlZCB3aGVuIGFkZGluZyBlZGdlc1xuXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLmRyYWcudHJhbnNsYXRpb24gPSB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbjtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0KHBvaW50ZXIpO1xuXG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdW1wiY3JlYXRlRWRnZUVycm9yXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJjcmVhdGVFZGdlRXJyb3JcIl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBub2RlIHRoZSB0ZW1wb3JhcnkgbGluZSBjYW4gbG9vayBhdFxuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLl9nZXROZXdUYXJnZXROb2RlKG5vZGUueCwgbm9kZS55KTtcblxuICAgICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW3RhcmdldE5vZGUuaWRdID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKHRhcmdldE5vZGUuaWQpOyAvLyBjcmVhdGUgYSB0ZW1wb3JhcnkgZWRnZVxuXG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkVkZ2UgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2Uoe1xuICAgICAgICAgICAgICBpZDogXCJjb25uZWN0aW9uRWRnZVwiICsgdjQoKSxcbiAgICAgICAgICAgICAgZnJvbTogbm9kZS5pZCxcbiAgICAgICAgICAgICAgdG86IHRhcmdldE5vZGUuaWQsXG4gICAgICAgICAgICAgIHBoeXNpY3M6IGZhbHNlLFxuICAgICAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29udGludW91c1wiLFxuICAgICAgICAgICAgICAgIHJvdW5kbmVzczogMC41XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW2Nvbm5lY3Rpb25FZGdlLmlkXSA9IGNvbm5lY3Rpb25FZGdlO1xuICAgICAgICAgICAgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLnB1c2goY29ubmVjdGlvbkVkZ2UuaWQpO1xuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaCh0YXJnZXROb2RlLmlkKTtcbiAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzLnB1c2goY29ubmVjdGlvbkVkZ2UuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYWdDb250cm9sTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhZ0NvbnRyb2xOb2RlKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuXG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7IC8vIHJlbWVtYmVyIHRoZSBlZGdlIGlkXG5cblxuICAgICAgdmFyIGNvbm5lY3RGcm9tSWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbm5lY3RGcm9tSWQgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF1dLmZyb21JZDtcbiAgICAgIH0gLy8gZ2V0IHRoZSBvdmVybGFwcGluZyBub2RlIGJ1dCBOT1QgdGhlIHRlbXBvcmFyeSBub2RlO1xuXG5cbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVJZHMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX2dldEFsbE5vZGVzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopO1xuXG4gICAgICB2YXIgbm9kZSA9IHVuZGVmaW5lZDtcblxuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgX2NvbnRleHQyOTtcblxuICAgICAgICAvLyBpZiB0aGUgbm9kZSBpZCBpcyBOT1QgYSB0ZW1wb3Jhcnkgbm9kZSwgYWNjZXB0IHRoZSBub2RlLlxuICAgICAgICBpZiAoaW5kZXhPZiQzKF9jb250ZXh0MjkgPSB0aGlzLnRlbXBvcmFyeUlkcy5ub2RlcykuY2FsbChfY29udGV4dDI5LCBvdmVybGFwcGluZ05vZGVJZHNbaV0pID09PSAtMSkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbb3ZlcmxhcHBpbmdOb2RlSWRzW2ldXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudC5jb250cm9sRWRnZSA9IHtcbiAgICAgICAgZnJvbTogY29ubmVjdEZyb21JZCxcbiAgICAgICAgdG86IG5vZGUgPyBub2RlLmlkIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNvbnRyb2xOb2RlRHJhZ2dpbmdcIiwgZXZlbnQsIHBvaW50ZXIpO1xuXG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07IC8vIHRoZXJlIGlzIG9ubHkgb25lIHRlbXAgbm9kZSBpbiB0aGUgYWRkIGVkZ2UgbW9kZS5cblxuICAgICAgICB0YXJnZXROb2RlLnggPSB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpO1xuICAgICAgICB0YXJnZXROb2RlLnkgPSB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLm9uRHJhZyhldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdGhlIG5ldyBlZGdlIHRvIHRoZSB0YXJnZXQgaWYgb25lIGV4aXN0cywgb3RoZXJ3aXNlIHJlbW92ZSB0ZW1wIGxpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluaXNoQ29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluaXNoQ29ubmVjdChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcblxuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpOyAvLyByZW1lbWJlciB0aGUgZWRnZSBpZFxuXG5cbiAgICAgIHZhciBjb25uZWN0RnJvbUlkID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25uZWN0RnJvbUlkID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdXS5mcm9tSWQ7XG4gICAgICB9IC8vIGdldCB0aGUgb3ZlcmxhcHBpbmcgbm9kZSBidXQgTk9UIHRoZSB0ZW1wb3Jhcnkgbm9kZTtcblxuXG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcblxuICAgICAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSBvdmVybGFwcGluZ05vZGVJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MzA7XG5cbiAgICAgICAgLy8gaWYgdGhlIG5vZGUgaWQgaXMgTk9UIGEgdGVtcG9yYXJ5IG5vZGUsIGFjY2VwdCB0aGUgbm9kZS5cbiAgICAgICAgaWYgKGluZGV4T2YkMyhfY29udGV4dDMwID0gdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMpLmNhbGwoX2NvbnRleHQzMCwgb3ZlcmxhcHBpbmdOb2RlSWRzW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZUlkc1tpXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY2xlYW4gdGVtcG9yYXJ5IG5vZGVzIGFuZCBlZGdlcy5cblxuXG4gICAgICB0aGlzLl9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpOyAvLyBwZXJmb3JtIHRoZSBjb25uZWN0aW9uXG5cblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiY3JlYXRlRWRnZUVycm9yXCJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2Nvbm5lY3RGcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW25vZGUuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1BZGRFZGdlKGNvbm5lY3RGcm9tSWQsIG5vZGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudC5jb250cm9sRWRnZSA9IHtcbiAgICAgICAgZnJvbTogY29ubmVjdEZyb21JZCxcbiAgICAgICAgdG86IG5vZGUgPyBub2RlLmlkIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNvbnRyb2xOb2RlRHJhZ0VuZFwiLCBldmVudCwgcG9pbnRlcik7IC8vIE5vIG5lZWQgdG8gZG8gX2dlbmVyYXRlY2xpY2tldmVudCgnZHJhZ0VuZCcpIGhlcmUsIHRoZSByZWd1bGFyIGRyYWdFbmQgZXZlbnQgZmlyZXMuXG5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kcmFnU3RhcnRFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmFnU3RhcnRFZGdlKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdTdGFydFwiLCBldmVudCwgcG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgQUREIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQZXJmb3JtaW5nIGFsbCB0aGUgYWN0dWFsIGRhdGEgbWFuaXB1bGF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbm9kZSBvbiB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2xpY2tEYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtQWRkTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUFkZE5vZGUoY2xpY2tEYXRhKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICBpZDogdjQoKSxcbiAgICAgICAgeDogY2xpY2tEYXRhLnBvaW50ZXIuY2FudmFzLngsXG4gICAgICAgIHk6IGNsaWNrRGF0YS5wb2ludGVyLmNhbnZhcy55LFxuICAgICAgICBsYWJlbDogXCJuZXdcIlxuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYWRkTm9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkTm9kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYWRkTm9kZShkZWZhdWx0RGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhICE9PSBudWxsICYmIGZpbmFsaXplZERhdGEgIT09IHVuZGVmaW5lZCAmJiBfdGhpczQuaW5Nb2RlID09PSBcImFkZE5vZGVcIikge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgX3RoaXM0LmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkuYWRkKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpczQuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgYWRkIGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5hZGQoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogY29ubmVjdCB0d28gbm9kZXMgd2l0aCBhIG5ldyBlZGdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBzb3VyY2VOb2RlSWRcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHRhcmdldE5vZGVJZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGVyZm9ybUFkZEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1BZGRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICBmcm9tOiBzb3VyY2VOb2RlSWQsXG4gICAgICAgIHRvOiB0YXJnZXROb2RlSWRcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkZEVkZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZEVkZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFkZEVkZ2UoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXM1LmluTW9kZSA9PT0gXCJhZGRFZGdlXCIpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgIF90aGlzNS5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLmFkZChmaW5hbGl6ZWREYXRhKTtcblxuICAgICAgICAgICAgICBfdGhpczUuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuXG4gICAgICAgICAgICAgIF90aGlzNS5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBjb25uZWN0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5hZGQoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbm5lY3QgdHdvIG5vZGVzIHdpdGggYSBuZXcgZWRnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gc291cmNlTm9kZUlkXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSB0YXJnZXROb2RlSWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcmZvcm1FZGl0RWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUVkaXRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICBpZDogdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCxcbiAgICAgICAgZnJvbTogc291cmNlTm9kZUlkLFxuICAgICAgICB0bzogdGFyZ2V0Tm9kZUlkLFxuICAgICAgICBsYWJlbDogdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0KHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQpLmxhYmVsXG4gICAgICB9O1xuICAgICAgdmFyIGVlRnVuY3QgPSB0aGlzLm9wdGlvbnMuZWRpdEVkZ2U7XG5cbiAgICAgIGlmIChfdHlwZW9mXzEoZWVGdW5jdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZWVGdW5jdCA9IGVlRnVuY3QuZWRpdFdpdGhvdXREcmFnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGVlRnVuY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoZWVGdW5jdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBlZUZ1bmN0KGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgPT09IG51bGwgfHwgZmluYWxpemVkRGF0YSA9PT0gdW5kZWZpbmVkIHx8IF90aGlzNi5pbk1vZGUgIT09IFwiZWRpdEVkZ2VcIikge1xuICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX3RoaXM2LmJvZHkuZWRnZXNbZGVmYXVsdERhdGEuaWRdLnVwZGF0ZUVkZ2VUeXBlKCk7XG5cbiAgICAgICAgICAgICAgX3RoaXM2LmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcblxuICAgICAgICAgICAgICBfdGhpczYuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXM2LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkudXBkYXRlKGZpbmFsaXplZERhdGEpO1xuXG4gICAgICAgICAgICAgIF90aGlzNi5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgICAgICAgX3RoaXM2LnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGVkaXQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS51cGRhdGUoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hbmlwdWxhdGlvblN5c3RlbTtcbn0oKTtcblxudmFyIGh0bWxDb2xvcnMgPSB7XG4gIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgbmF2eTogXCIjMDAwMDgwXCIsXG4gIGRhcmtibHVlOiBcIiMwMDAwOEJcIixcbiAgbWVkaXVtYmx1ZTogXCIjMDAwMENEXCIsXG4gIGJsdWU6IFwiIzAwMDBGRlwiLFxuICBkYXJrZ3JlZW46IFwiIzAwNjQwMFwiLFxuICBncmVlbjogXCIjMDA4MDAwXCIsXG4gIHRlYWw6IFwiIzAwODA4MFwiLFxuICBkYXJrY3lhbjogXCIjMDA4QjhCXCIsXG4gIGRlZXBza3libHVlOiBcIiMwMEJGRkZcIixcbiAgZGFya3R1cnF1b2lzZTogXCIjMDBDRUQxXCIsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBcIiMwMEZBOUFcIixcbiAgbGltZTogXCIjMDBGRjAwXCIsXG4gIHNwcmluZ2dyZWVuOiBcIiMwMEZGN0ZcIixcbiAgYXF1YTogXCIjMDBGRkZGXCIsXG4gIGN5YW46IFwiIzAwRkZGRlwiLFxuICBtaWRuaWdodGJsdWU6IFwiIzE5MTk3MFwiLFxuICBkb2RnZXJibHVlOiBcIiMxRTkwRkZcIixcbiAgbGlnaHRzZWFncmVlbjogXCIjMjBCMkFBXCIsXG4gIGZvcmVzdGdyZWVuOiBcIiMyMjhCMjJcIixcbiAgc2VhZ3JlZW46IFwiIzJFOEI1N1wiLFxuICBkYXJrc2xhdGVncmF5OiBcIiMyRjRGNEZcIixcbiAgbGltZWdyZWVuOiBcIiMzMkNEMzJcIixcbiAgbWVkaXVtc2VhZ3JlZW46IFwiIzNDQjM3MVwiLFxuICB0dXJxdW9pc2U6IFwiIzQwRTBEMFwiLFxuICByb3lhbGJsdWU6IFwiIzQxNjlFMVwiLFxuICBzdGVlbGJsdWU6IFwiIzQ2ODJCNFwiLFxuICBkYXJrc2xhdGVibHVlOiBcIiM0ODNEOEJcIixcbiAgbWVkaXVtdHVycXVvaXNlOiBcIiM0OEQxQ0NcIixcbiAgaW5kaWdvOiBcIiM0QjAwODJcIixcbiAgZGFya29saXZlZ3JlZW46IFwiIzU1NkIyRlwiLFxuICBjYWRldGJsdWU6IFwiIzVGOUVBMFwiLFxuICBjb3JuZmxvd2VyYmx1ZTogXCIjNjQ5NUVEXCIsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFwiIzY2Q0RBQVwiLFxuICBkaW1ncmF5OiBcIiM2OTY5NjlcIixcbiAgc2xhdGVibHVlOiBcIiM2QTVBQ0RcIixcbiAgb2xpdmVkcmFiOiBcIiM2QjhFMjNcIixcbiAgc2xhdGVncmF5OiBcIiM3MDgwOTBcIixcbiAgbGlnaHRzbGF0ZWdyYXk6IFwiIzc3ODg5OVwiLFxuICBtZWRpdW1zbGF0ZWJsdWU6IFwiIzdCNjhFRVwiLFxuICBsYXduZ3JlZW46IFwiIzdDRkMwMFwiLFxuICBjaGFydHJldXNlOiBcIiM3RkZGMDBcIixcbiAgYXF1YW1hcmluZTogXCIjN0ZGRkQ0XCIsXG4gIG1hcm9vbjogXCIjODAwMDAwXCIsXG4gIHB1cnBsZTogXCIjODAwMDgwXCIsXG4gIG9saXZlOiBcIiM4MDgwMDBcIixcbiAgZ3JheTogXCIjODA4MDgwXCIsXG4gIHNreWJsdWU6IFwiIzg3Q0VFQlwiLFxuICBsaWdodHNreWJsdWU6IFwiIzg3Q0VGQVwiLFxuICBibHVldmlvbGV0OiBcIiM4QTJCRTJcIixcbiAgZGFya3JlZDogXCIjOEIwMDAwXCIsXG4gIGRhcmttYWdlbnRhOiBcIiM4QjAwOEJcIixcbiAgc2FkZGxlYnJvd246IFwiIzhCNDUxM1wiLFxuICBkYXJrc2VhZ3JlZW46IFwiIzhGQkM4RlwiLFxuICBsaWdodGdyZWVuOiBcIiM5MEVFOTBcIixcbiAgbWVkaXVtcHVycGxlOiBcIiM5MzcwRDhcIixcbiAgZGFya3Zpb2xldDogXCIjOTQwMEQzXCIsXG4gIHBhbGVncmVlbjogXCIjOThGQjk4XCIsXG4gIGRhcmtvcmNoaWQ6IFwiIzk5MzJDQ1wiLFxuICB5ZWxsb3dncmVlbjogXCIjOUFDRDMyXCIsXG4gIHNpZW5uYTogXCIjQTA1MjJEXCIsXG4gIGJyb3duOiBcIiNBNTJBMkFcIixcbiAgZGFya2dyYXk6IFwiI0E5QTlBOVwiLFxuICBsaWdodGJsdWU6IFwiI0FERDhFNlwiLFxuICBncmVlbnllbGxvdzogXCIjQURGRjJGXCIsXG4gIHBhbGV0dXJxdW9pc2U6IFwiI0FGRUVFRVwiLFxuICBsaWdodHN0ZWVsYmx1ZTogXCIjQjBDNERFXCIsXG4gIHBvd2RlcmJsdWU6IFwiI0IwRTBFNlwiLFxuICBmaXJlYnJpY2s6IFwiI0IyMjIyMlwiLFxuICBkYXJrZ29sZGVucm9kOiBcIiNCODg2MEJcIixcbiAgbWVkaXVtb3JjaGlkOiBcIiNCQTU1RDNcIixcbiAgcm9zeWJyb3duOiBcIiNCQzhGOEZcIixcbiAgZGFya2toYWtpOiBcIiNCREI3NkJcIixcbiAgc2lsdmVyOiBcIiNDMEMwQzBcIixcbiAgbWVkaXVtdmlvbGV0cmVkOiBcIiNDNzE1ODVcIixcbiAgaW5kaWFucmVkOiBcIiNDRDVDNUNcIixcbiAgcGVydTogXCIjQ0Q4NTNGXCIsXG4gIGNob2NvbGF0ZTogXCIjRDI2OTFFXCIsXG4gIHRhbjogXCIjRDJCNDhDXCIsXG4gIGxpZ2h0Z3JleTogXCIjRDNEM0QzXCIsXG4gIHBhbGV2aW9sZXRyZWQ6IFwiI0Q4NzA5M1wiLFxuICB0aGlzdGxlOiBcIiNEOEJGRDhcIixcbiAgb3JjaGlkOiBcIiNEQTcwRDZcIixcbiAgZ29sZGVucm9kOiBcIiNEQUE1MjBcIixcbiAgY3JpbXNvbjogXCIjREMxNDNDXCIsXG4gIGdhaW5zYm9ybzogXCIjRENEQ0RDXCIsXG4gIHBsdW06IFwiI0REQTBERFwiLFxuICBidXJseXdvb2Q6IFwiI0RFQjg4N1wiLFxuICBsaWdodGN5YW46IFwiI0UwRkZGRlwiLFxuICBsYXZlbmRlcjogXCIjRTZFNkZBXCIsXG4gIGRhcmtzYWxtb246IFwiI0U5OTY3QVwiLFxuICB2aW9sZXQ6IFwiI0VFODJFRVwiLFxuICBwYWxlZ29sZGVucm9kOiBcIiNFRUU4QUFcIixcbiAgbGlnaHRjb3JhbDogXCIjRjA4MDgwXCIsXG4gIGtoYWtpOiBcIiNGMEU2OENcIixcbiAgYWxpY2VibHVlOiBcIiNGMEY4RkZcIixcbiAgaG9uZXlkZXc6IFwiI0YwRkZGMFwiLFxuICBhenVyZTogXCIjRjBGRkZGXCIsXG4gIHNhbmR5YnJvd246IFwiI0Y0QTQ2MFwiLFxuICB3aGVhdDogXCIjRjVERUIzXCIsXG4gIGJlaWdlOiBcIiNGNUY1RENcIixcbiAgd2hpdGVzbW9rZTogXCIjRjVGNUY1XCIsXG4gIG1pbnRjcmVhbTogXCIjRjVGRkZBXCIsXG4gIGdob3N0d2hpdGU6IFwiI0Y4RjhGRlwiLFxuICBzYWxtb246IFwiI0ZBODA3MlwiLFxuICBhbnRpcXVld2hpdGU6IFwiI0ZBRUJEN1wiLFxuICBsaW5lbjogXCIjRkFGMEU2XCIsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcIiNGQUZBRDJcIixcbiAgb2xkbGFjZTogXCIjRkRGNUU2XCIsXG4gIHJlZDogXCIjRkYwMDAwXCIsXG4gIGZ1Y2hzaWE6IFwiI0ZGMDBGRlwiLFxuICBtYWdlbnRhOiBcIiNGRjAwRkZcIixcbiAgZGVlcHBpbms6IFwiI0ZGMTQ5M1wiLFxuICBvcmFuZ2VyZWQ6IFwiI0ZGNDUwMFwiLFxuICB0b21hdG86IFwiI0ZGNjM0N1wiLFxuICBob3RwaW5rOiBcIiNGRjY5QjRcIixcbiAgY29yYWw6IFwiI0ZGN0Y1MFwiLFxuICBkYXJrb3JhbmdlOiBcIiNGRjhDMDBcIixcbiAgbGlnaHRzYWxtb246IFwiI0ZGQTA3QVwiLFxuICBvcmFuZ2U6IFwiI0ZGQTUwMFwiLFxuICBsaWdodHBpbms6IFwiI0ZGQjZDMVwiLFxuICBwaW5rOiBcIiNGRkMwQ0JcIixcbiAgZ29sZDogXCIjRkZENzAwXCIsXG4gIHBlYWNocHVmZjogXCIjRkZEQUI5XCIsXG4gIG5hdmFqb3doaXRlOiBcIiNGRkRFQURcIixcbiAgbW9jY2FzaW46IFwiI0ZGRTRCNVwiLFxuICBiaXNxdWU6IFwiI0ZGRTRDNFwiLFxuICBtaXN0eXJvc2U6IFwiI0ZGRTRFMVwiLFxuICBibGFuY2hlZGFsbW9uZDogXCIjRkZFQkNEXCIsXG4gIHBhcGF5YXdoaXA6IFwiI0ZGRUZENVwiLFxuICBsYXZlbmRlcmJsdXNoOiBcIiNGRkYwRjVcIixcbiAgc2Vhc2hlbGw6IFwiI0ZGRjVFRVwiLFxuICBjb3Juc2lsazogXCIjRkZGOERDXCIsXG4gIGxlbW9uY2hpZmZvbjogXCIjRkZGQUNEXCIsXG4gIGZsb3JhbHdoaXRlOiBcIiNGRkZBRjBcIixcbiAgc25vdzogXCIjRkZGQUZBXCIsXG4gIHllbGxvdzogXCIjRkZGRjAwXCIsXG4gIGxpZ2h0eWVsbG93OiBcIiNGRkZGRTBcIixcbiAgaXZvcnk6IFwiI0ZGRkZGMFwiLFxuICB3aGl0ZTogXCIjRkZGRkZGXCJcbn07XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz0xXVxuICovXG5cbnZhciBDb2xvclBpY2tlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BpeGVsUmF0aW89MV1cbiAgICovXG4gIGZ1bmN0aW9uIENvbG9yUGlja2VyKCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JQaWNrZXIpO1xuXG4gICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICB0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMgPSB7XG4gICAgICB4OiAyODkgLyAyLFxuICAgICAgeTogMjg5IC8gMlxuICAgIH07XG4gICAgdGhpcy5yID0gMjg5ICogMC40OTtcbiAgICB0aGlzLmNvbG9yID0ge1xuICAgICAgcjogMjU1LFxuICAgICAgZzogMjU1LFxuICAgICAgYjogMjU1LFxuICAgICAgYTogMS4wXG4gICAgfTtcbiAgICB0aGlzLmh1ZUNpcmNsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluaXRpYWxDb2xvciA9IHtcbiAgICAgIHI6IDI1NSxcbiAgICAgIGc6IDI1NSxcbiAgICAgIGI6IDI1NSxcbiAgICAgIGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5wcmV2aW91c0NvbG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlOyAvLyBib3VuZCBieVxuXG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307IC8vIGNyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG5cblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiB0aGlzIGluc2VydHMgdGhlIGNvbG9yUGlja2VyIGludG8gYSBkaXYgZnJvbSB0aGUgRE9NXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoQ29sb3JQaWNrZXIsIFt7XG4gICAga2V5OiBcImluc2VydFRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRvKGNvbnRhaW5lcikge1xuICAgICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmhhbW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcblxuICAgICAgdGhpcy5fYmluZEhhbW1lcigpO1xuXG4gICAgICB0aGlzLl9zZXRTaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRVcGRhdGVDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVcGRhdGVDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgdXBkYXRlIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIG9uIGFwcGx5IGFuZCBzYXZlLiBCaW5kIGl0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldENsb3NlQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2xvc2VDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gYXR0ZW1wdGVkIHRvIHNldCBhcyBjb2xvclBpY2tlciBjbG9zaW5nIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaXNDb2xvclN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDb2xvclN0cmluZyhjb2xvcikge1xuICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gaHRtbENvbG9yc1tjb2xvcl07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29sb3Igb2YgdGhlIGNvbG9yUGlja2VyXG4gICAgICogU3VwcG9ydGVkIGZvcm1hdHM6XG4gICAgICogJ3JlZCcgICAgICAgICAgICAgICAgICAgLS0+IEhUTUwgY29sb3Igc3RyaW5nXG4gICAgICogJyNmZmZmZmYnICAgICAgICAgICAgICAgLS0+IGhleCBzdHJpbmdcbiAgICAgKiAncmdiKDI1NSwyNTUsMjU1KScgICAgICAtLT4gcmdiIHN0cmluZ1xuICAgICAqICdyZ2JhKDI1NSwyNTUsMjU1LDEuMCknIC0tPiByZ2JhIHN0cmluZ1xuICAgICAqIHtyOjI1NSxnOjI1NSxiOjI1NX0gICAgIC0tPiByZ2Igb2JqZWN0XG4gICAgICoge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfSAtLT4gcmdiYSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgb2JqZWN0fSBjb2xvclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldEluaXRpYWw9dHJ1ZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbG9yKGNvbG9yKSB7XG4gICAgICB2YXIgc2V0SW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgaWYgKGNvbG9yID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZ2JhOyAvLyBpZiBhIGh0bWwgY29sb3Igc2hvcnRoYW5kIGlzIHVzZWQsIGNvbnZlcnQgdG8gaGV4XG5cbiAgICAgIHZhciBodG1sQ29sb3IgPSB0aGlzLl9pc0NvbG9yU3RyaW5nKGNvbG9yKTtcblxuICAgICAgaWYgKGh0bWxDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbG9yID0gaHRtbENvbG9yO1xuICAgICAgfSAvLyBjaGVjayBmb3JtYXRcblxuXG4gICAgICBpZiAoaXNTdHJpbmcoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkUkdCKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciByZ2JhQXJyYXkgPSBjb2xvci5zdWJzdHIoNCkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDUpLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICByZ2JhID0ge1xuICAgICAgICAgICAgcjogcmdiYUFycmF5WzBdLFxuICAgICAgICAgICAgZzogcmdiYUFycmF5WzFdLFxuICAgICAgICAgICAgYjogcmdiYUFycmF5WzJdLFxuICAgICAgICAgICAgYTogMS4wXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkUkdCQShjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgX3JnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig1KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNikuc3BsaXQoXCIsXCIpO1xuXG4gICAgICAgICAgcmdiYSA9IHtcbiAgICAgICAgICAgIHI6IF9yZ2JhQXJyYXlbMF0sXG4gICAgICAgICAgICBnOiBfcmdiYUFycmF5WzFdLFxuICAgICAgICAgICAgYjogX3JnYmFBcnJheVsyXSxcbiAgICAgICAgICAgIGE6IF9yZ2JhQXJyYXlbM11cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRIZXgoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHJnYk9iaiA9IGhleFRvUkdCKGNvbG9yKTtcbiAgICAgICAgICByZ2JhID0ge1xuICAgICAgICAgICAgcjogcmdiT2JqLnIsXG4gICAgICAgICAgICBnOiByZ2JPYmouZyxcbiAgICAgICAgICAgIGI6IHJnYk9iai5iLFxuICAgICAgICAgICAgYTogMS4wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGNvbG9yLnIgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5nICE9PSB1bmRlZmluZWQgJiYgY29sb3IuYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjb2xvci5hICE9PSB1bmRlZmluZWQgPyBjb2xvci5hIDogXCIxLjBcIjtcbiAgICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgICAgIGE6IGFscGhhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBzZXQgY29sb3JcblxuXG4gICAgICBpZiAocmdiYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29sb3IgcGFzc2VkIHRvIHRoZSBjb2xvclBpY2tlci4gU3VwcG9ydGVkIGFyZSBzdHJpbmdzOiByZ2IsIGhleCwgcmdiYS4gT2JqZWN0OiByZ2IgKHtyOnIsZzpnLGI6YixbYTphXX0pLiBTdXBwbGllZDogXCIgKyBzdHJpbmdpZnkkMihjb2xvcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0Q29sb3IocmdiYSwgc2V0SW5pdGlhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgc2hvd3MgdGhlIGNvbG9yIHBpY2tlci5cbiAgICAgKiBUaGUgaHVlIGNpcmNsZSBpcyBjb25zdHJ1Y3RlZCBvbmNlIGFuZCBzdG9yZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICBpZiAodGhpcy5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuY2xvc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICAgIHRoaXMuX2dlbmVyYXRlSHVlQ2lyY2xlKCk7XG4gICAgfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUFJJVkFURSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgcGlja2VyLiBJcyBjYWxsZWQgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAgICogT3B0aW9uYWwgYm9vbGVhbiB0byBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIGVhc3kgYWNjZXNzIGxhdGVyIG9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RvcmVQcmV2aW91cz10cnVlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzdG9yZVByZXZpb3VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIG5leHQgdGltZTtcbiAgICAgIGlmIChzdG9yZVByZXZpb3VzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNDb2xvciA9IGFzc2lnbiQyKHt9LCB0aGlzLmNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYXBwbGllZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuaW5pdGlhbENvbG9yKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7IC8vIGNhbGwgdGhlIGNsb3NpbmcgY2FsbGJhY2ssIHJlc3RvcmluZyB0aGUgb25jbGljayBtZXRob2QuXG4gICAgICAvLyB0aGlzIGlzIGluIGEgc2V0VGltZW91dCBiZWNhdXNlIGl0IHdpbGwgdHJpZ2dlciB0aGUgc2hvdyBhZ2FpbiBiZWZvcmUgdGhlIGNsaWNrIGlzIGRvbmUuXG5cbiAgICAgIHNldFRpbWVvdXQkMihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG5cbiAgICAgICAgICBfdGhpcy5jbG9zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYm91bmQgdG8gdGhlIHNhdmUgYnV0dG9uLiBTYXZlcyBhbmQgaGlkZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpO1xuICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQm91bmQgdG8gYXBwbHkgYnV0dG9uLiBTYXZlcyBidXQgZG9lcyBub3QgY2xvc2UuIElzIHVuZG9uZSBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5KCkge1xuICAgICAgdGhpcy5hcHBsaWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodGhpcy5jb2xvcik7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcih0aGlzLmNvbG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbG9hZCB0aGUgY29sb3IgZnJvbSB0aGUgcHJldmlvdXMgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbG9hZExhc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRMYXN0KCkge1xuICAgICAgaWYgKHRoaXMucHJldmlvdXNDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0Q29sb3IodGhpcy5wcmV2aW91c0NvbG9yLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGVydChcIlRoZXJlIGlzIG5vIGxhc3QgY29sb3IgdG8gbG9hZC4uLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBjb2xvciwgcGxhY2UgdGhlIHBpY2tlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJnYmFcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXRJbml0aWFsPXRydWVdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q29sb3IocmdiYSkge1xuICAgICAgdmFyIHNldEluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIC8vIHN0b3JlIHRoZSBpbml0aWFsIGNvbG9yXG4gICAgICBpZiAoc2V0SW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmluaXRpYWxDb2xvciA9IGFzc2lnbiQyKHt9LCByZ2JhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb2xvciA9IHJnYmE7XG4gICAgICB2YXIgaHN2ID0gUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG4gICAgICB2YXIgYW5nbGVDb252ZXJ0ID0gMiAqIE1hdGguUEk7XG4gICAgICB2YXIgcmFkaXVzID0gdGhpcy5yICogaHN2LnM7XG4gICAgICB2YXIgeCA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlQ29udmVydCAqIGhzdi5oKTtcbiAgICAgIHZhciB5ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy55ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGVDb252ZXJ0ICogaHN2LmgpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPSB4IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudFdpZHRoICsgXCJweFwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLnRvcCA9IHkgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIocmdiYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJvdW5kIHRvIG9wYWNpdHkgY29udHJvbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRPcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbG9yLmEgPSB2YWx1ZSAvIDEwMDtcblxuICAgICAgdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBib3VuZCB0byBicmlnaHRuZXNzIGNvbnRyb2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0QnJpZ2h0bmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QnJpZ2h0bmVzcyh2YWx1ZSkge1xuICAgICAgdmFyIGhzdiA9IFJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgICAgaHN2LnYgPSB2YWx1ZSAvIDEwMDtcbiAgICAgIHZhciByZ2JhID0gSFNWVG9SR0IoaHN2LmgsIGhzdi5zLCBoc3Yudik7XG4gICAgICByZ2JhW1wiYVwiXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuXG4gICAgICB0aGlzLl91cGRhdGVQaWNrZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBjb2xvciBwaWNrZXIuIEEgYmxhY2sgY2lyY2xlIG92ZXJsYXlzIHRoZSBodWUgY2lyY2xlIHRvIG1pbWljIHRoZSBicmlnaHRuZXNzIGRlY3JlYXNpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmdiYVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlUGlja2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVQaWNrZXIoKSB7XG4gICAgICB2YXIgcmdiYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5jb2xvcjtcbiAgICAgIHZhciBoc3YgPSBSR0JUb0hTVihyZ2JhLnIsIHJnYmEuZywgcmdiYS5iKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApOyAvLyBjbGVhciB0aGUgY2FudmFzXG5cbiAgICAgIHZhciB3ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIHZhciBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YSh0aGlzLmh1ZUNpcmNsZSwgMCwgMCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsMCwwLFwiICsgKDEgLSBoc3YudikgKyBcIilcIjtcbiAgICAgIGN0eC5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LCB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksIHRoaXMucik7XG5cbiAgICAgIGZpbGwkMihjdHgpLmNhbGwoY3R4KTtcblxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAxMDAgKiBoc3YudjtcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gMTAwICogcmdiYS5hO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKFwiICsgdGhpcy5pbml0aWFsQ29sb3IuciArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuZyArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYiArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYSArIFwiKVwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoXCIgKyB0aGlzLmNvbG9yLnIgKyBcIixcIiArIHRoaXMuY29sb3IuZyArIFwiLFwiICsgdGhpcy5jb2xvci5iICsgXCIsXCIgKyB0aGlzLmNvbG9yLmEgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXNlZCBieSBjcmVhdGUgdG8gc2V0IHRoZSBzaXplIG9mIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNpemUoKSB7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy53aWR0aCA9IDI4OSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuaGVpZ2h0ID0gMjg5ICogdGhpcy5waXhlbFJhdGlvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYWxsIGRvbSBlbGVtZW50c1xuICAgICAqIFRPRE86IGNsZWFudXAsIGxvdHMgb2Ygc2ltaWxhciBkb20gZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB2YXIgX2NvbnRleHQsIF9jb250ZXh0MiwgX2NvbnRleHQzLCBfY29udGV4dDQ7XG5cbiAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSBcInZpcy1jb2xvci1waWNrZXJcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGFzc05hbWUgPSBcInZpcy1zZWxlY3RvclwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuXG4gICAgICBpZiAoIXRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgICB2YXIgbm9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9IFwicmVkXCI7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9IFwiMTBweFwiO1xuICAgICAgICBub0NhbnZhcy5pbm5lckhUTUwgPSBcIkVycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhc1wiO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbG9yXCI7XG4gICAgICB0aGlzLm9wYWNpdHlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5vcGFjaXR5RGl2LmNsYXNzTmFtZSA9IFwidmlzLW9wYWNpdHlcIjtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmJyaWdodG5lc3NEaXYuY2xhc3NOYW1lID0gXCJ2aXMtYnJpZ2h0bmVzc1wiO1xuICAgICAgdGhpcy5hcnJvd0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmFycm93RGl2LmNsYXNzTmFtZSA9IFwidmlzLWFycm93XCI7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudHlwZSA9IFwicmFuZ2VcIjsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcblxuICAgICAgICB0aGlzLm9wYWNpdHlSYW5nZS5taW4gPSBcIjBcIjtcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWF4ID0gXCIxMDBcIjtcbiAgICAgIH0gY2F0Y2ggKGVycikgey8vIFRPRE86IEFkZCBzb21lIGVycm9yIGhhbmRsaW5nLlxuICAgICAgfVxuXG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSA9IFwiMTAwXCI7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5jbGFzc05hbWUgPSBcInZpcy1yYW5nZVwiO1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnR5cGUgPSBcInJhbmdlXCI7IC8vIE5vdCBzdXBwb3J0ZWQgb24gSUU5XG5cbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWluID0gXCIwXCI7XG4gICAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm1heCA9IFwiMTAwXCI7XG4gICAgICB9IGNhdGNoIChlcnIpIHsvLyBUT0RPOiBBZGQgc29tZSBlcnJvciBoYW5kbGluZy5cbiAgICAgIH1cblxuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSBcIjEwMFwiO1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UuY2xhc3NOYW1lID0gXCJ2aXMtcmFuZ2VcIjtcbiAgICAgIHRoaXMub3BhY2l0eURpdi5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlSYW5nZSk7XG4gICAgICB0aGlzLmJyaWdodG5lc3NEaXYuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzUmFuZ2UpO1xuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldE9wYWNpdHkodGhpcy52YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmNsYXNzTmFtZSA9IFwidmlzLWxhYmVsIHZpcy1icmlnaHRuZXNzXCI7XG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5pbm5lckhUTUwgPSBcImJyaWdodG5lc3M6XCI7XG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtb3BhY2l0eVwiO1xuICAgICAgdGhpcy5vcGFjaXR5TGFiZWwuaW5uZXJIVE1MID0gXCJvcGFjaXR5OlwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm5ld0NvbG9yRGl2LmNsYXNzTmFtZSA9IFwidmlzLW5ldy1jb2xvclwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5pbm5lckhUTUwgPSBcIm5ld1wiO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuY2xhc3NOYW1lID0gXCJ2aXMtaW5pdGlhbC1jb2xvclwiO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuaW5uZXJIVE1MID0gXCJpbml0aWFsXCI7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWNhbmNlbFwiO1xuICAgICAgdGhpcy5jYW5jZWxCdXR0b24uaW5uZXJIVE1MID0gXCJjYW5jZWxcIjtcbiAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLm9uY2xpY2sgPSBiaW5kJDIoX2NvbnRleHQgPSB0aGlzLl9oaWRlKS5jYWxsKF9jb250ZXh0LCB0aGlzLCBmYWxzZSk7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuYXBwbHlCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1hcHBseVwiO1xuICAgICAgdGhpcy5hcHBseUJ1dHRvbi5pbm5lckhUTUwgPSBcImFwcGx5XCI7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLm9uY2xpY2sgPSBiaW5kJDIoX2NvbnRleHQyID0gdGhpcy5fYXBwbHkpLmNhbGwoX2NvbnRleHQyLCB0aGlzKTtcbiAgICAgIHRoaXMuc2F2ZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLnNhdmVCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1zYXZlXCI7XG4gICAgICB0aGlzLnNhdmVCdXR0b24uaW5uZXJIVE1MID0gXCJzYXZlXCI7XG4gICAgICB0aGlzLnNhdmVCdXR0b24ub25jbGljayA9IGJpbmQkMihfY29udGV4dDMgPSB0aGlzLl9zYXZlKS5jYWxsKF9jb250ZXh0MywgdGhpcyk7XG4gICAgICB0aGlzLmxvYWRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5sb2FkQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtbG9hZFwiO1xuICAgICAgdGhpcy5sb2FkQnV0dG9uLmlubmVySFRNTCA9IFwibG9hZCBsYXN0XCI7XG4gICAgICB0aGlzLmxvYWRCdXR0b24ub25jbGljayA9IGJpbmQkMihfY29udGV4dDQgPSB0aGlzLl9sb2FkTGFzdCkuY2FsbChfY29udGV4dDQsIHRoaXMpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd0Rpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0xhYmVsKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5TGFiZWwpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5ld0NvbG9yRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5pbml0aWFsQ29sb3JEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNhbmNlbEJ1dHRvbik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXBwbHlCdXR0b24pO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnNhdmVCdXR0b24pO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmxvYWRCdXR0b24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBiaW5kIGhhbW1lciB0byB0aGUgY29sb3IgcGlja2VyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRIYW1tZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5kcmFnID0ge307XG4gICAgICB0aGlzLnBpbmNoID0ge307XG4gICAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIkMSh0aGlzLmNvbG9yUGlja2VyQ2FudmFzKTtcbiAgICAgIHRoaXMuaGFtbWVyLmdldChcInBpbmNoXCIpLnNldCh7XG4gICAgICAgIGVuYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBvblRvdWNoKHRoaXMuaGFtbWVyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInRhcFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbnN0YXJ0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFubW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbmVuZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBodWUgY2lyY2xlLiBUaGlzIGlzIHJlbGF0aXZlbHkgaGVhdnkgKDIwMG1zKSBhbmQgaXMgZG9uZSBvbmx5IG9uY2Ugb24gdGhlIGZpcnN0IHRpbWUgaXQgaXMgc2hvd24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbmVyYXRlSHVlQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZUh1ZUNpcmNsZSgpIHtcbiAgICAgIGlmICh0aGlzLmdlbmVyYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTsgLy8gY2xlYXIgdGhlIGNhbnZhc1xuXG4gICAgICAgIHZhciB3ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTsgLy8gZHJhdyBodWUgY2lyY2xlXG5cbiAgICAgICAgdmFyIHgsIHksIGh1ZSwgc2F0O1xuICAgICAgICB0aGlzLmNlbnRlckNvb3JkaW5hdGVzID0ge1xuICAgICAgICAgIHg6IHcgKiAwLjUsXG4gICAgICAgICAgeTogaCAqIDAuNVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnIgPSAwLjQ5ICogdztcbiAgICAgICAgdmFyIGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJIC8gMzYwO1xuICAgICAgICB2YXIgaGZhYyA9IDEgLyAzNjA7XG4gICAgICAgIHZhciBzZmFjID0gMSAvIHRoaXMucjtcbiAgICAgICAgdmFyIHJnYjtcblxuICAgICAgICBmb3IgKGh1ZSA9IDA7IGh1ZSA8IDM2MDsgaHVlKyspIHtcbiAgICAgICAgICBmb3IgKHNhdCA9IDA7IHNhdCA8IHRoaXMucjsgc2F0KyspIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnggKyBzYXQgKiBNYXRoLnNpbihhbmdsZUNvbnZlcnQgKiBodWUpO1xuICAgICAgICAgICAgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHNhdCAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgICByZ2IgPSBIU1ZUb1JHQihodWUgKiBoZmFjLCBzYXQgKiBzZmFjLCAxKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYihcIiArIHJnYi5yICsgXCIsXCIgKyByZ2IuZyArIFwiLFwiICsgcmdiLmIgKyBcIilcIjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4IC0gMC41LCB5IC0gMC41LCAyLCAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsMSlcIjtcbiAgICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmh1ZUNpcmNsZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbW92ZSB0aGUgc2VsZWN0b3IuIFRoaXMgaXMgY2FsbGVkIGJ5IGhhbW1lciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVTZWxlY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVNlbGVjdG9yKGV2ZW50KSB7XG4gICAgICB2YXIgcmVjdCA9IHRoaXMuY29sb3JQaWNrZXJEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbGVmdCA9IGV2ZW50LmNlbnRlci54IC0gcmVjdC5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGV2ZW50LmNlbnRlci55IC0gcmVjdC50b3A7XG4gICAgICB2YXIgY2VudGVyWSA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50SGVpZ2h0O1xuICAgICAgdmFyIGNlbnRlclggPSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudFdpZHRoO1xuICAgICAgdmFyIHggPSBsZWZ0IC0gY2VudGVyWDtcbiAgICAgIHZhciB5ID0gdG9wIC0gY2VudGVyWTtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeCwgeSk7XG4gICAgICB2YXIgcmFkaXVzID0gMC45OCAqIE1hdGgubWluKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSwgY2VudGVyWCk7XG4gICAgICB2YXIgbmV3VG9wID0gTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzICsgY2VudGVyWTtcbiAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzICsgY2VudGVyWDtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS50b3AgPSBuZXdUb3AgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPSBuZXdMZWZ0IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudFdpZHRoICsgXCJweFwiOyAvLyBzZXQgY29sb3JcblxuICAgICAgdmFyIGggPSBhbmdsZSAvICgyICogTWF0aC5QSSk7XG4gICAgICBoID0gaCA8IDAgPyBoICsgMSA6IGg7XG4gICAgICB2YXIgcyA9IHJhZGl1cyAvIHRoaXMucjtcbiAgICAgIHZhciBoc3YgPSBSR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICAgIGhzdi5oID0gaDtcbiAgICAgIGhzdi5zID0gcztcbiAgICAgIHZhciByZ2JhID0gSFNWVG9SR0IoaHN2LmgsIGhzdi5zLCBoc3Yudik7XG4gICAgICByZ2JhW1wiYVwiXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhOyAvLyB1cGRhdGUgcHJldmlld3NcblxuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKFwiICsgdGhpcy5pbml0aWFsQ29sb3IuciArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuZyArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYiArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYSArIFwiKVwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoXCIgKyB0aGlzLmNvbG9yLnIgKyBcIixcIiArIHRoaXMuY29sb3IuZyArIFwiLFwiICsgdGhpcy5jb2xvci5iICsgXCIsXCIgKyB0aGlzLmNvbG9yLmEgKyBcIilcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29sb3JQaWNrZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIHdheSB0aGlzIHdvcmtzIGlzIGZvciBhbGwgcHJvcGVydGllcyBvZiB0aGlzLnBvc3NpYmxlIG9wdGlvbnMsIHlvdSBjYW4gc3VwcGx5IHRoZSBwcm9wZXJ0eSBuYW1lIGluIGFueSBmb3JtIHRvIGxpc3QgdGhlIG9wdGlvbnMuXG4gKiBCb29sZWFuIG9wdGlvbnMgYXJlIHJlY29nbmlzZWQgYXMgQm9vbGVhblxuICogTnVtYmVyIG9wdGlvbnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtkZWZhdWx0IHZhbHVlLCBtaW4gdmFsdWUsIG1heCB2YWx1ZSwgc3RlcHNpemVdXG4gKiBDb2xvcnMgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFsnY29sb3InLCAnI2ZmZmZmZiddXG4gKiBTdHJpbmdzIHdpdGggc2hvdWxkIGJlIHdyaXR0ZW4gYXMgYXJyYXk6IFtvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCAuLl1cbiAqXG4gKiBUaGUgb3B0aW9ucyBhcmUgbWF0Y2hlZCB3aXRoIHRoZWlyIGNvdW50ZXJwYXJ0cyBpbiBlYWNoIG9mIHRoZSBtb2R1bGVzIGFuZCB0aGUgdmFsdWVzIHVzZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24gYXJlXG4gKi9cblxudmFyIENvbmZpZ3VyYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50TW9kdWxlICAgICAgICB8IHRoZSBsb2NhdGlvbiB3aGVyZSBwYXJlbnRNb2R1bGUuc2V0T3B0aW9ucygpIGNhbiBiZSBjYWxsZWRcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRDb250YWluZXIgICAgfCB0aGUgZGVmYXVsdCBjb250YWluZXIgb2YgdGhlIG1vZHVsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlndXJlT3B0aW9ucyAgICB8IHRoZSBmdWxseSBjb25maWd1cmVkIGFuZCBwcmVkZWZpbmVkIG9wdGlvbnMgc2V0IGZvdW5kIGluIGFsbE9wdGlvbnMuanNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gICAgICAgICAgfCBjYW52YXMgcGl4ZWwgcmF0aW9cbiAgICovXG4gIGZ1bmN0aW9uIENvbmZpZ3VyYXRvcihwYXJlbnRNb2R1bGUsIGRlZmF1bHRDb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMpIHtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmZpZ3VyYXRvcik7XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudE1vZHVsZTtcbiAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG4gICAgdGhpcy5jb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyO1xuICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBvcHVwQ291bnRlciA9IDA7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgZmlsdGVyOiB0cnVlLFxuICAgICAgY29udGFpbmVyOiB1bmRlZmluZWQsXG4gICAgICBzaG93QnV0dG9uOiB0cnVlXG4gICAgfTtcblxuICAgIGFzc2lnbiQyKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMgPSBjb25maWd1cmVPcHRpb25zO1xuICAgIHRoaXMubW9kdWxlT3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZG9tRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgdGhpcy5wb3B1cExpbWl0ID0gNTtcbiAgICB0aGlzLnBvcHVwSGlzdG9yeSA9IHt9O1xuICAgIHRoaXMuY29sb3JQaWNrZXIgPSBuZXcgQ29sb3JQaWNrZXIocGl4ZWxSYXRpbyk7XG4gICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiByZWZyZXNoIGFsbCBvcHRpb25zLlxuICAgKiBCZWNhdXNlIGFsbCBtb2R1bGVzIHBhcnNlIHRoZWlyIG9wdGlvbnMgYnkgdGhlbXNlbHZlcywgd2UganVzdCB1c2UgdGhlaXIgb3B0aW9ucy4gV2UgY29weSB0aGVtIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoQ29uZmlndXJhdG9yLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZXNldCB0aGUgcG9wdXAgaGlzdG9yeSBiZWNhdXNlIHRoZSBpbmRpY2VzIG1heSBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgICAgdGhpcy5wb3B1cEhpc3RvcnkgPSB7fTtcblxuICAgICAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuXG4gICAgICAgIHZhciBlbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5JDUob3B0aW9ucykpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucy5qb2luKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZl8xKG9wdGlvbnMpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgY2Fubm90IGJlIG51bGxcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmlsdGVyJDIob3B0aW9ucykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IGZpbHRlciQyKG9wdGlvbnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLnNob3dCdXR0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNob3dCdXR0b24gPSBvcHRpb25zLnNob3dCdXR0b247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbmFibGVkID0gb3B0aW9ucy5lbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgICBlbmFibGVkID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IG9wdGlvbnM7XG4gICAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsdGVyJDIodGhpcy5vcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1vZHVsZU9wdGlvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE1vZHVsZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TW9kdWxlT3B0aW9ucyhtb2R1bGVPcHRpb25zKSB7XG4gICAgICB0aGlzLm1vZHVsZU9wdGlvbnMgPSBtb2R1bGVPcHRpb25zO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuXG4gICAgICB2YXIgZmlsdGVyID0gZmlsdGVyJDIodGhpcy5vcHRpb25zKTtcblxuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHNob3cgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgb3B0aW9uIGluIHRoaXMuY29uZmlndXJlT3B0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29uZmlndXJlT3B0aW9ucywgb3B0aW9uKSkge1xuICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIHNob3cgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNob3cgPSBmaWx0ZXIob3B0aW9uLCBbXSk7XG4gICAgICAgICAgICBzaG93ID0gc2hvdyB8fCB0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW29wdGlvbl0sIFtvcHRpb25dLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpbHRlciA9PT0gdHJ1ZSB8fCBpbmRleE9mJDMoZmlsdGVyKS5jYWxsKGZpbHRlciwgb3B0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gdHJ1ZTsgLy8gbGluZWJyZWFrIGJldHdlZW4gY2F0ZWdvcmllc1xuXG4gICAgICAgICAgICBpZiAoY291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWFrZUl0ZW0oW10pO1xuICAgICAgICAgICAgfSAvLyBhIGhlYWRlciBmb3IgdGhlIGNhdGVnb3J5XG5cblxuICAgICAgICAgICAgdGhpcy5fbWFrZUhlYWRlcihvcHRpb24pOyAvLyBnZXQgdGhlIHN1YiBvcHRpb25zXG5cblxuICAgICAgICAgICAgdGhpcy5faGFuZGxlT2JqZWN0KHRoaXMuY29uZmlndXJlT3B0aW9uc1tvcHRpb25dLCBbb3B0aW9uXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21ha2VCdXR0b24oKTtcblxuICAgICAgdGhpcy5fcHVzaCgpOyAvL34gdGhpcy5jb2xvclBpY2tlci5pbnNlcnRUbyh0aGlzLmNvbnRhaW5lcik7XG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogZHJhdyBhbGwgRE9NIGVsZW1lbnRzIG9uIHRoZSBzY3JlZW5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHVzaCgpIHtcbiAgICAgIHRoaXMud3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLndyYXBwZXIuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbi13cmFwcGVyXCI7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudHNbaV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zaG93UG9wdXBJZk5lZWRlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkZWxldGUgYWxsIERPTSBlbGVtZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW4oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNbaV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy53cmFwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRvbUVsZW1lbnRzID0gW107XG5cbiAgICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgYWN0dWFsT3B0aW9ucyBpZiBpdCBleGlzdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZhbHVlKHBhdGgpIHtcbiAgICAgIHZhciBiYXNlID0gdGhpcy5tb2R1bGVPcHRpb25zO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJhc2VbcGF0aFtpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJhc2UgPSBiYXNlW3BhdGhbaV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFsbCBvcHRpb24gZWxlbWVudHMgYXJlIHdyYXBwZWQgaW4gYW4gaXRlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheS48RWxlbWVudD59IGRvbUVsZW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlSXRlbShwYXRoKSB7XG4gICAgICBpZiAodGhpcy5hbGxvd0NyZWF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaXRlbS5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaXRlbSB2aXMtY29uZmlnLXNcIiArIHBhdGgubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkb21FbGVtZW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgZG9tRWxlbWVudHNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yRWFjaCQyKGRvbUVsZW1lbnRzKS5jYWxsKGRvbUVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaGVhZGVyIGZvciBtYWpvciBzdWJqZWN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VIZWFkZXIobmFtZSkge1xuICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWhlYWRlclwiO1xuICAgICAgZGl2LmlubmVySFRNTCA9IG5hbWU7XG5cbiAgICAgIHRoaXMuX21ha2VJdGVtKFtdLCBkaXYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgbGFiZWwsIGlmIGl0IGlzIGFuIG9iamVjdCBsYWJlbCwgaXQgZ2V0cyBkaWZmZXJlbnQgc3R5bGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9iamVjdExhYmVsXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlTGFiZWwobmFtZSwgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdExhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1sYWJlbCB2aXMtY29uZmlnLXNcIiArIHBhdGgubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqZWN0TGFiZWwgPT09IHRydWUpIHtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPGk+PGI+XCIgKyBuYW1lICsgXCI6PC9iPjwvaT5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBuYW1lICsgXCI6XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBkcm9wZG93biBsaXN0IGZvciBtdWx0aXBsZSBwb3NzaWJsZSBzdHJpbmcgb3B0b2luc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlRHJvcGRvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICAgIHNlbGVjdC5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctc2VsZWN0XCI7XG4gICAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IDA7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpbmRleE9mJDMoYXJyKS5jYWxsKGFyciwgdmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWUgPSBpbmRleE9mJDMoYXJyKS5jYWxsKGFyciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24udmFsdWUgPSBhcnJbaV07XG5cbiAgICAgICAgaWYgKGkgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBcInNlbGVjdGVkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb24uaW5uZXJIVE1MID0gYXJyW2ldO1xuICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgc2VsZWN0Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fdXBkYXRlKHRoaXMudmFsdWUsIHBhdGgpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG5cbiAgICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBzZWxlY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgcmFuZ2Ugb2JqZWN0IGZvciBudW1lcmljIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlUmFuZ2UoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyclswXTtcbiAgICAgIHZhciBtaW4gPSBhcnJbMV07XG4gICAgICB2YXIgbWF4ID0gYXJyWzJdO1xuICAgICAgdmFyIHN0ZXAgPSBhcnJbM107XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICByYW5nZS5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2VcIjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmFuZ2UudHlwZSA9IFwicmFuZ2VcIjsgLy8gbm90IHN1cHBvcnRlZCBvbiBJRTlcblxuICAgICAgICByYW5nZS5taW4gPSBtaW47XG4gICAgICAgIHJhbmdlLm1heCA9IG1heDtcbiAgICAgIH0gY2F0Y2ggKGVycikgey8vIFRPRE86IEFkZCBzb21lIGVycm9yIGhhbmRsaW5nLlxuICAgICAgfVxuXG4gICAgICByYW5nZS5zdGVwID0gc3RlcDsgLy8gc2V0IHVwIHRoZSBwb3B1cCBzZXR0aW5ncyBpbiBjYXNlIHRoZXkgYXJlIG5lZWRlZC5cblxuICAgICAgdmFyIHBvcHVwU3RyaW5nID0gXCJcIjtcbiAgICAgIHZhciBwb3B1cFZhbHVlID0gMDtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZhY3RvciA9IDEuMjtcblxuICAgICAgICBpZiAodmFsdWUgPCAwICYmIHZhbHVlICogZmFjdG9yIDwgbWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gXCJyYW5nZSBpbmNyZWFzZWRcIjtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAvIGZhY3RvciA8IG1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IE1hdGguY2VpbCh2YWx1ZSAvIGZhY3Rvcik7XG4gICAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgICBwb3B1cFN0cmluZyA9IFwicmFuZ2UgaW5jcmVhc2VkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgKiBmYWN0b3IgPiBtYXggJiYgbWF4ICE9PSAxKSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWF4O1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gXCJyYW5nZSBpbmNyZWFzZWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhbmdlLnZhbHVlID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZS52YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgaW5wdXQuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlaW5wdXRcIjtcbiAgICAgIGlucHV0LnZhbHVlID0gcmFuZ2UudmFsdWU7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICByYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgICAgIG1lLl91cGRhdGUoTnVtYmVyKHRoaXMudmFsdWUpLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHJhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuXG4gICAgICB2YXIgaXRlbUluZGV4ID0gdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHJhbmdlLCBpbnB1dCk7IC8vIGlmIGEgcG9wdXAgaXMgbmVlZGVkIEFORCBpdCBoYXMgbm90IGJlZW4gc2hvd24gZm9yIHRoaXMgdmFsdWUsIHNob3cgaXQuXG5cblxuICAgICAgaWYgKHBvcHVwU3RyaW5nICE9PSBcIlwiICYmIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gIT09IHBvcHVwVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wb3B1cEhpc3RvcnlbaXRlbUluZGV4XSA9IHBvcHVwVmFsdWU7XG5cbiAgICAgICAgdGhpcy5fc2V0dXBQb3B1cChwb3B1cFN0cmluZywgaXRlbUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFrZSBhIGJ1dHRvbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUJ1dHRvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZ2VuZXJhdGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uXCI7XG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLmlubmVySFRNTCA9IFwiZ2VuZXJhdGUgb3B0aW9uc1wiO1xuXG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuX3ByaW50T3B0aW9ucygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24gaG92ZXJcIjtcbiAgICAgICAgfTtcblxuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbm1vdXNlb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b25cIjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLW9wdGlvbi1jb250YWluZXJcIjtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKHRoaXMub3B0aW9uc0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMucHVzaChnZW5lcmF0ZUJ1dHRvbik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHByZXBhcmUgdGhlIHBvcHVwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXR1cFBvcHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFBvcHVwKHN0cmluZywgaW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gdHJ1ZSAmJiB0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUgJiYgdGhpcy5wb3B1cENvdW50ZXIgPCB0aGlzLnBvcHVwTGltaXQpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5pZCA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IHN0cmluZztcblxuICAgICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuX3JlbW92ZVBvcHVwKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wb3B1cENvdW50ZXIgKz0gMTtcbiAgICAgICAgdGhpcy5wb3B1cERpdiA9IHtcbiAgICAgICAgICBodG1sOiBkaXYsXG4gICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgcG9wdXAgZnJvbSB0aGUgZG9tXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZVBvcHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVQb3B1cCgpIHtcbiAgICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmRlbGV0ZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnBvcHVwRGl2ID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIHBvcHVwIGlmIGl0IGlzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2hvd1BvcHVwSWZOZWVkZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dQb3B1cElmTmVlZGVkKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY29ycmVzcG9uZGluZ0VsZW1lbnQgPSB0aGlzLmRvbUVsZW1lbnRzW3RoaXMucG9wdXBEaXYuaW5kZXhdO1xuICAgICAgICB2YXIgcmVjdCA9IGNvcnJlc3BvbmRpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUubGVmdCA9IHJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLnRvcCA9IHJlY3QudG9wIC0gMzAgKyBcInB4XCI7IC8vIDMwIGlzIHRoZSBoZWlnaHQ7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwRGl2Lmh0bWwpO1xuICAgICAgICB0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0ID0gc2V0VGltZW91dCQyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMucG9wdXBEaXYuaHRtbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfSwgMTUwMCk7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dCA9IHNldFRpbWVvdXQkMihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLl9yZW1vdmVQb3B1cCgpO1xuICAgICAgICB9LCAxODAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFrZSBhIGNoZWNrYm94IGZvciBib29sZWFuIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlQ2hlY2tib3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDaGVja2JveChkZWZhdWx0VmFsdWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgICAgY2hlY2tib3guY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNoZWNrYm94XCI7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gZGVmYXVsdFZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBpZiAoX3R5cGVvZl8xKGRlZmF1bHRWYWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl91cGRhdGUodGhpcy5jaGVja2VkLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuXG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgdGV4dCBpbnB1dCBmaWVsZCBmb3Igc3RyaW5nIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlVGV4dElucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlVGV4dElucHV0KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSBcInRleHRcIjtcbiAgICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy10ZXh0XCI7XG4gICAgICBjaGVja2JveC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuXG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgY29sb3IgZmllbGQgd2l0aCBhIGNvbG9yIHBpY2tlciBmb3IgY29sb3IgZmllbGRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VDb2xvckZpZWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlQ29sb3JGaWVsZChhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHRDb2xvciA9IGFyclsxXTtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrXCI7XG4gICAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9jayBub25lXCI7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuXG4gICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0Ll9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcblxuICAgICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGRpdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVzZWQgYnkgdGhlIGNvbG9yIGJ1dHRvbnMgdG8gY2FsbCB0aGUgY29sb3IgcGlja2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGl2XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zaG93Q29sb3JQaWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dDb2xvclBpY2tlcih2YWx1ZSwgZGl2LCBwYXRoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gY2xlYXIgdGhlIGNhbGxiYWNrIGZyb20gdGhpcyBkaXZcbiAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuaW5zZXJ0VG8oZGl2KTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2hvdygpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDb2xvcih2YWx1ZSk7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyLnNldFVwZGF0ZUNhbGxiYWNrKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgY29sb3JTdHJpbmcgPSBcInJnYmEoXCIgKyBjb2xvci5yICsgXCIsXCIgKyBjb2xvci5nICsgXCIsXCIgKyBjb2xvci5iICsgXCIsXCIgKyBjb2xvci5hICsgXCIpXCI7XG4gICAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvclN0cmluZztcblxuICAgICAgICBfdGhpczUuX3VwZGF0ZShjb2xvclN0cmluZywgcGF0aCk7XG4gICAgICB9KTsgLy8gb24gY2xvc2Ugb2YgdGhlIGNvbG9ycGlja2VyLCByZXN0b3JlIHRoZSBjYWxsYmFjay5cblxuICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDbG9zZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM1Ll9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcGFyc2UgYW4gb2JqZWN0IGFuZCBkcmF3IHRoZSBjb3JyZWN0IGl0ZW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhdGg9W11dICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGVja09ubHk9ZmFsc2VdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU9iamVjdChvYmopIHtcbiAgICAgIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHZhciBjaGVja09ubHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIHNob3cgPSBmYWxzZTtcblxuICAgICAgdmFyIGZpbHRlciA9IGZpbHRlciQyKHRoaXMub3B0aW9ucyk7XG5cbiAgICAgIHZhciB2aXNpYmxlSW5TZXQgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgc3ViT2JqIGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgc3ViT2JqKSkge1xuICAgICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICAgIHZhciBpdGVtID0gb2JqW3N1Yk9ial07XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBjb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgc3ViT2JqKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNob3cgPSBmaWx0ZXIoc3ViT2JqLCBwYXRoKTsgLy8gaWYgbmVlZGVkIHdlIG11c3QgZ28gZGVlcGVyIGludG8gdGhlIG9iamVjdC5cblxuICAgICAgICAgICAgaWYgKHNob3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheSQ1KGl0ZW0pICYmIHR5cGVvZiBpdGVtICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpdGVtICE9PSBcImJvb2xlYW5cIiAmJiBpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2hvdyA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBjaGVja09ubHkgPT09IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3cgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShuZXdQYXRoKTtcblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkkNShpdGVtKSkge1xuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVBcnJheShpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VUZXh0SW5wdXQoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWFrZUNoZWNrYm94KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBjb2xsYXBzZSB0aGUgcGh5c2ljcyBvcHRpb25zIHRoYXQgYXJlIG5vdCBlbmFibGVkXG4gICAgICAgICAgICAgIHZhciBkcmF3ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAoaW5kZXhPZiQzKHBhdGgpLmNhbGwocGF0aCwgXCJwaHlzaWNzXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vZHVsZU9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgIT09IHN1Yk9iaiAmJiBzdWJPYmogIT09IFwid2luZFwiKSB7XG4gICAgICAgICAgICAgICAgICBkcmF3ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsbHkgY29sbGFwc2Ugb3B0aW9ucyB3aXRoIGFuIGRpc2FibGVkIGVuYWJsZWQgb3B0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWRQYXRoID0gY29weUFuZEV4dGVuZEFycmF5KG5ld1BhdGgsIFwiZW5hYmxlZFwiKTtcblxuICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlKGVuYWJsZWRQYXRoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZWRWYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwoc3ViT2JqLCBuZXdQYXRoLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBsYWJlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCBlbmFibGVkVmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2xhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKG5ld1BhdGgsIF9sYWJlbCk7XG5cbiAgICAgICAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoKSB8fCB2aXNpYmxlSW5TZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZG9udCBrbm93IGhvdyB0byBoYW5kbGVcIiwgaXRlbSwgc3ViT2JqLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpc2libGVJblNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRoZSBhcnJheSB0eXBlIG9mIG9wdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQXJyYXkoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwic3RyaW5nXCIgJiYgYXJyWzBdID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgdGhpcy5fbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCk7XG5cbiAgICAgICAgaWYgKGFyclsxXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5fbWFrZURyb3Bkb3duKGFyciwgdmFsdWUsIHBhdGgpO1xuXG4gICAgICAgIGlmIChhcnJbMF0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMuX21ha2VSYW5nZShhcnIsIHZhbHVlLCBwYXRoKTtcblxuICAgICAgICBpZiAoYXJyWzBdICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlcih2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgdG8gdXBkYXRlIHRoZSBuZXR3b3JrIHdpdGggdGhlIG5ldyBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUodmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fY29uc3RydWN0T3B0aW9ucyh2YWx1ZSwgcGF0aCk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmVudC5ib2R5ICYmIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlciAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIuZW1pdCkge1xuICAgICAgICB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIuZW1pdChcImNvbmZpZ0NoYW5nZVwiLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLnBhcmVudC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgYm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBwYXRoXG4gICAgICogQHBhcmFtIHt7fX0gb3B0aW9uc09ialxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnN0cnVjdE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnN0cnVjdE9wdGlvbnModmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBvcHRpb25zT2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBwb2ludGVyID0gb3B0aW9uc09iajsgLy8gd2hlbiBkcm9wZG93biBib3hlcyBjYW4gYmUgc3RyaW5nIG9yIGJvb2xlYW4sIHdlIHR5cGVjYXN0IGl0IGludG8gY29ycmVjdCB0eXBlc1xuXG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSBcInRydWVcIiA/IHRydWUgOiB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogdmFsdWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aFtpXSAhPT0gXCJnbG9iYWxcIikge1xuICAgICAgICAgIGlmIChwb2ludGVyW3BhdGhbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJbcGF0aFtpXV0gPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSAhPT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlcltwYXRoW2ldXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRlcltwYXRoW2ldXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9uc09iajtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wcmludE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByaW50T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIuaW5uZXJIVE1MID0gXCI8cHJlPnZhciBvcHRpb25zID0gXCIgKyBzdHJpbmdpZnkkMihvcHRpb25zLCBudWxsLCAyKSArIFwiPC9wcmU+XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge3t9fSBvcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbmdlZE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fY29uc3RydWN0T3B0aW9ucyh0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnZhbHVlLCB0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnBhdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29uZmlndXJhdG9yO1xufSgpO1xuXG4vKipcbiAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGFsbCBwb3NzaWJsZSBvcHRpb25zLiBJdCB3aWxsIGNoZWNrIGlmIHRoZSB0eXBlcyBhcmUgY29ycmVjdCwgaWYgcmVxdWlyZWQgaWYgdGhlIG9wdGlvbiBpcyBvbmVcbiAqIG9mIHRoZSBhbGxvd2VkIHZhbHVlcy5cbiAqXG4gKiBfX2FueV9fIG1lYW5zIHRoYXQgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGRvZXMgbm90IG1hdHRlci5cbiAqIF9fdHlwZV9fIGlzIGEgcmVxdWlyZWQgZmllbGQgZm9yIGFsbCBvYmplY3RzIGFuZCBjb250YWlucyB0aGUgYWxsb3dlZCB0eXBlcyBvZiBhbGwgb2JqZWN0c1xuICovXG52YXIgc3RyaW5nID0gXCJzdHJpbmdcIjtcbnZhciBib29sID0gXCJib29sZWFuXCI7XG52YXIgbnVtYmVyID0gXCJudW1iZXJcIjtcbnZhciBhcnJheSA9IFwiYXJyYXlcIjtcbnZhciBvYmplY3QgPSBcIm9iamVjdFwiOyAvLyBzaG91bGQgb25seSBiZSBpbiBhIF9fdHlwZV9fIHByb3BlcnR5XG5cbnZhciBkb20gPSBcImRvbVwiO1xudmFyIGFueSA9IFwiYW55XCI7IC8vIExpc3Qgb2YgZW5kcG9pbnRzXG5cbnZhciBlbmRQb2ludHMgPSBbXCJhcnJvd1wiLCBcImJhclwiLCBcImJveFwiLCBcImNpcmNsZVwiLCBcImNyb3dcIiwgXCJjdXJ2ZVwiLCBcImRpYW1vbmRcIiwgXCJpbWFnZVwiLCBcImludl9jdXJ2ZVwiLCBcImludl90cmlhbmdsZVwiLCBcInRyaWFuZ2xlXCIsIFwidmVlXCJdO1xudmFyIGFsbE9wdGlvbnMkMSA9IHtcbiAgY29uZmlndXJlOiB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgZmlsdGVyOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICBhcnJheTogYXJyYXksXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBjb250YWluZXI6IHtcbiAgICAgIGRvbTogZG9tXG4gICAgfSxcbiAgICBzaG93QnV0dG9uOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICBhcnJheTogYXJyYXksXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfVxuICB9LFxuICBlZGdlczoge1xuICAgIGFycm93czoge1xuICAgICAgdG86IHtcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgc3RyaW5nOiBlbmRQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VIZWlnaHQ6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBpbWFnZVdpZHRoOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtaWRkbGU6IHtcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgc3RyaW5nOiBlbmRQb2ludHNcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VXaWR0aDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlSGVpZ2h0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmcm9tOiB7XG4gICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlRmFjdG9yOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHN0cmluZzogZW5kUG9pbnRzXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlV2lkdGg6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBpbWFnZUhlaWdodDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHNyYzoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgc3RyaW5nOiBbXCJmcm9tXCIsIFwidG9cIiwgXCJtaWRkbGVcIl0sXG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBlbmRQb2ludE9mZnNldDoge1xuICAgICAgZnJvbToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHRvOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9XG4gICAgfSxcbiAgICBhcnJvd1N0cmlrZXRocm91Z2g6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhc2hlczoge1xuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBhcnJheTogYXJyYXlcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgY2hvc2VuOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgZWRnZToge1xuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgaW5oZXJpdDoge1xuICAgICAgICBzdHJpbmc6IFtcImZyb21cIiwgXCJ0b1wiLCBcImJvdGhcIl0sXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXNoZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBhcnJheTogYXJyYXlcbiAgICB9LFxuICAgIGZvbnQ6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIC8vIHB4XG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHN0cm9rZVdpZHRoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgLy8gcHhcbiAgICAgIHN0cm9rZUNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYWxpZ246IHtcbiAgICAgICAgc3RyaW5nOiBbXCJob3Jpem9udGFsXCIsIFwidG9wXCIsIFwibWlkZGxlXCIsIFwiYm90dG9tXCJdXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG11bHRpOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYm9sZDoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICAvLyBweFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHB4XG4gICAgICAgIGZhY2U6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBtb2Q6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICB2YWRqdXN0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXRhbDoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICAvLyBweFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1vbm86IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHhcbiAgICAgICAgZmFjZToge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIG1vZDoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGRlbjoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaG92ZXJXaWR0aDoge1xuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIixcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgbGVuZ3RoOiB7XG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgcGh5c2ljczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgc2NhbGluZzoge1xuICAgICAgbWluOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbWF4OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfSxcbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgbWF4VmlzaWJsZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdUaHJlc2hvbGQ6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjoge1xuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdGlvbldpZHRoOiB7XG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiLFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHNlbGZSZWZlcmVuY2VTaXplOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgc2VsZlJlZmVyZW5jZToge1xuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGFuZ2xlOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgcmVuZGVyQmVoaW5kVGhlTm9kZToge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgeDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgc21vb3RoOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICB0eXBlOiB7XG4gICAgICAgIHN0cmluZzogW1wiZHluYW1pY1wiLCBcImNvbnRpbnVvdXNcIiwgXCJkaXNjcmV0ZVwiLCBcImRpYWdvbmFsQ3Jvc3NcIiwgXCJzdHJhaWdodENyb3NzXCIsIFwiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwiY3VydmVkQ1dcIiwgXCJjdXJ2ZWRDQ1dcIiwgXCJjdWJpY0JlemllclwiXVxuICAgICAgfSxcbiAgICAgIHJvdW5kbmVzczoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZvcmNlRGlyZWN0aW9uOiB7XG4gICAgICAgIHN0cmluZzogW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwibm9uZVwiXSxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIHdpZHRoOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgd2lkdGhDb25zdHJhaW50OiB7XG4gICAgICBtYXhpbXVtOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9XG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgZ3JvdXBzOiB7XG4gICAgdXNlRGVmYXVsdEdyb3Vwczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgX19hbnlfXzogXCJnZXQgZnJvbSBub2Rlcywgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWxvd1wiLFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBkcmFnTm9kZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGRyYWdWaWV3OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBoaWRlRWRnZXNPbkRyYWc6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhpZGVFZGdlc09uWm9vbToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaGlkZU5vZGVzT25EcmFnOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBob3Zlcjoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAga2V5Ym9hcmQ6IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIHNwZWVkOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgem9vbToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJpbmRUb1dpbmRvdzoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIG11bHRpc2VsZWN0OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBuYXZpZ2F0aW9uQnV0dG9uczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgc2VsZWN0YWJsZToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhvdmVyQ29ubmVjdGVkRWRnZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHRvb2x0aXBEZWxheToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHpvb21WaWV3OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB6b29tU3BlZWQ6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIGxheW91dDoge1xuICAgIHJhbmRvbVNlZWQ6IHtcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIixcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGltcHJvdmVkTGF5b3V0OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBjbHVzdGVyVGhyZXNob2xkOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBsZXZlbFNlcGFyYXRpb246IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBub2RlU3BhY2luZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHRyZWVTcGFjaW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYmxvY2tTaGlmdGluZzoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgZWRnZU1pbmltaXphdGlvbjoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGRpcmVjdGlvbjoge1xuICAgICAgICBzdHJpbmc6IFtcIlVEXCIsIFwiRFVcIiwgXCJMUlwiLCBcIlJMXCJdXG4gICAgICB9LFxuICAgICAgLy8gVUQsIERVLCBMUiwgUkxcbiAgICAgIHNvcnRNZXRob2Q6IHtcbiAgICAgICAgc3RyaW5nOiBbXCJodWJzaXplXCIsIFwiZGlyZWN0ZWRcIl1cbiAgICAgIH0sXG4gICAgICAvLyBodWJzaXplLCBkaXJlY3RlZFxuICAgICAgc2hha2VUb3dhcmRzOiB7XG4gICAgICAgIHN0cmluZzogW1wibGVhdmVzXCIsIFwicm9vdHNcIl1cbiAgICAgIH0sXG4gICAgICAvLyBsZWF2ZXMsIHJvb3RzXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBtYW5pcHVsYXRpb246IHtcbiAgICBlbmFibGVkOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBpbml0aWFsbHlBY3RpdmU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGFkZE5vZGU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBhZGRFZGdlOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgZWRpdE5vZGU6IHtcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGVkaXRFZGdlOiB7XG4gICAgICBlZGl0V2l0aG91dERyYWc6IHtcbiAgICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVOb2RlOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgZGVsZXRlRWRnZToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGNvbnRyb2xOb2RlU3R5bGU6IFwiZ2V0IGZyb20gbm9kZXMsIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYmVsb3dcIixcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sXG4gICAgfVxuICB9LFxuICBub2Rlczoge1xuICAgIGJvcmRlcldpZHRoOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgYm9yZGVyV2lkdGhTZWxlY3RlZDoge1xuICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIGJyb2tlbkltYWdlOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgY2hvc2VuOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgbm9kZToge1xuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBib3JkZXI6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBvcGFjaXR5OiB7XG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgZml4ZWQ6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICBhbGlnbjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIC8vIHB4XG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHN0cm9rZVdpZHRoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgLy8gcHhcbiAgICAgIHN0cm9rZUNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG11bHRpOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYm9sZDoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICAvLyBweFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvbGRpdGFsOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHB4XG4gICAgICAgIGZhY2U6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBtb2Q6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICB2YWRqdXN0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXRhbDoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICAvLyBweFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1vbm86IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHhcbiAgICAgICAgZmFjZToge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIG1vZDoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGdyb3VwOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICBoZWlnaHRDb25zdHJhaW50OiB7XG4gICAgICBtaW5pbXVtOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgdmFsaWduOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9XG4gICAgfSxcbiAgICBoaWRkZW46IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGljb246IHtcbiAgICAgIGZhY2U6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBjb2RlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgLy8nXFx1ZjAwNycsXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgLy81MCxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgd2VpZ2h0OiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBpZDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgaW1hZ2U6IHtcbiAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICAgIH0sXG4gICAgICAvLyAtLT4gVVJMXG4gICAgICB1bnNlbGVjdGVkOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICAgIH0sXG4gICAgICAvLyAtLT4gVVJMXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGltYWdlUGFkZGluZzoge1xuICAgICAgdG9wOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgcmlnaHQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBib3R0b206IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBsZWZ0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9XG4gICAgfSxcbiAgICBsYWJlbDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgICB9LFxuICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgbGV2ZWw6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICBtYXJnaW46IHtcbiAgICAgIHRvcDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYm90dG9tOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbGVmdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfVxuICAgIH0sXG4gICAgbWFzczoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHBoeXNpY3M6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHNjYWxpbmc6IHtcbiAgICAgIG1pbjoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG1heDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH0sXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIG1heDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIG1heFZpc2libGU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBkcmF3VGhyZXNob2xkOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IHtcbiAgICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYXBlOiB7XG4gICAgICBzdHJpbmc6IFtcImN1c3RvbVwiLCBcImVsbGlwc2VcIiwgXCJjaXJjbGVcIiwgXCJkYXRhYmFzZVwiLCBcImJveFwiLCBcInRleHRcIiwgXCJpbWFnZVwiLCBcImNpcmN1bGFySW1hZ2VcIiwgXCJkaWFtb25kXCIsIFwiZG90XCIsIFwic3RhclwiLCBcInRyaWFuZ2xlXCIsIFwidHJpYW5nbGVEb3duXCIsIFwic3F1YXJlXCIsIFwiaWNvblwiLCBcImhleGFnb25cIl1cbiAgICB9LFxuICAgIGN0eFJlbmRlcmVyOiB7XG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBzaGFwZVByb3BlcnRpZXM6IHtcbiAgICAgIGJvcmRlckRhc2hlczoge1xuICAgICAgICBib29sZWFuOiBib29sLFxuICAgICAgICBhcnJheTogYXJyYXlcbiAgICAgIH0sXG4gICAgICBib3JkZXJSYWRpdXM6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICB1c2VJbWFnZVNpemU6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIHVzZUJvcmRlcldpdGhJbWFnZToge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgY29vcmRpbmF0ZU9yaWdpbjoge1xuICAgICAgICBzdHJpbmc6IFtcImNlbnRlclwiLCBcInRvcC1sZWZ0XCJdXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICBkb206IGRvbSxcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICB3aWR0aENvbnN0cmFpbnQ6IHtcbiAgICAgIG1pbmltdW06IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBtYXhpbXVtOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9XG4gICAgfSxcbiAgICB4OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgeToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgcGh5c2ljczoge1xuICAgIGVuYWJsZWQ6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGJhcm5lc0h1dDoge1xuICAgICAgdGhldGE6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBjZW50cmFsR3Jhdml0eToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZGFtcGluZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGF2b2lkT3ZlcmxhcDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBmb3JjZUF0bGFzMkJhc2VkOiB7XG4gICAgICB0aGV0YToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nTGVuZ3RoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkYW1waW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYXZvaWRPdmVybGFwOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcHVsc2lvbjoge1xuICAgICAgY2VudHJhbEdyYXZpdHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdMZW5ndGg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG5vZGVEaXN0YW5jZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhbXBpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICBjZW50cmFsR3Jhdml0eToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbm9kZURpc3RhbmNlOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZGFtcGluZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGF2b2lkT3ZlcmxhcDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXhWZWxvY2l0eToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIG1pblZlbG9jaXR5OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgLy8gcHgvc1xuICAgIHNvbHZlcjoge1xuICAgICAgc3RyaW5nOiBbXCJiYXJuZXNIdXRcIiwgXCJyZXB1bHNpb25cIiwgXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIiwgXCJmb3JjZUF0bGFzMkJhc2VkXCJdXG4gICAgfSxcbiAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBpdGVyYXRpb25zOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uIHRvIHN0YWJpbGl6ZVxuICAgICAgdXBkYXRlSW50ZXJ2YWw6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBvbmx5RHluYW1pY0VkZ2VzOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBmaXQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICB0aW1lc3RlcDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGFkYXB0aXZlVGltZXN0ZXA6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHdpbmQ6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9XG4gIH0sXG4gIC8vZ2xvYmFscyA6XG4gIGF1dG9SZXNpemU6IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIGNsaWNrVG9Vc2U6IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIGxvY2FsZToge1xuICAgIHN0cmluZzogc3RyaW5nXG4gIH0sXG4gIGxvY2FsZXM6IHtcbiAgICBfX2FueV9fOiB7XG4gICAgICBhbnk6IGFueVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBoZWlnaHQ6IHtcbiAgICBzdHJpbmc6IHN0cmluZ1xuICB9LFxuICB3aWR0aDoge1xuICAgIHN0cmluZzogc3RyaW5nXG4gIH0sXG4gIF9fdHlwZV9fOiB7XG4gICAgb2JqZWN0OiBvYmplY3RcbiAgfVxufTtcbmFsbE9wdGlvbnMkMS5ncm91cHMuX19hbnlfXyA9IGFsbE9wdGlvbnMkMS5ub2RlcztcbmFsbE9wdGlvbnMkMS5tYW5pcHVsYXRpb24uY29udHJvbE5vZGVTdHlsZSA9IGFsbE9wdGlvbnMkMS5ub2Rlcztcbi8qKlxuICogVGhpcyBwcm92aWRlcyByYW5nZXMsIGluaXRpYWwgdmFsdWVzLCBzdGVwcyBhbmQgZHJvcGRvd24gbWVudSBjaG9pY2VzIGZvciB0aGVcbiAqIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIENoZWNrYm94OiBgYm9vbGVhbmBcbiAqICAgVGhlIHZhbHVlIHN1cGxsaWVkIHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqXG4gKiBUZXh0IGZpZWxkOiBgc3RyaW5nYFxuICogICBUaGUgcGFzc2VkIHRleHQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlLiBBbnkgdGV4dCB3aWxsIGJlXG4gKiAgIGFjY2VwdGVkIGFmdGVyd2FyZHMuXG4gKlxuICogTnVtYmVyIHJhbmdlOiBgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1gXG4gKiAgIFRoZSBtZWFuaW5ncyBhcmUgYFtpbml0aWFsIHZhbHVlLCBtaW4sIG1heCwgc3RlcF1gLlxuICpcbiAqIERyb3Bkb3duOiBgW0V4Y2x1ZGU8c3RyaW5nLCBcImNvbG9yXCI+LCAuLi4oc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbilbXV1gXG4gKiAgIFRyYW5zbGF0aW9ucyBmb3IgcGVvcGxlIHdpdGggcG9vciB1bmRlcnN0YW5kaW5nIG9mIFR5cGVTY3JpcHQ6IHRoZSBmaXJzdFxuICogICB2YWx1ZSBhbHdheXMgaGFzIHRvIGJlIGEgc3RyaW5nIGJ1dCBuZXZlciBgXCJjb2xvclwiYCwgdGhlIHJlc3QgY2FuIGJlIGFueVxuICogICBjb21iaW5hdGlvbiBvZiBzdHJpbmdzLCBudW1iZXJzIGFuZCBib29sZWFucy5cbiAqXG4gKiBDb2xvciBwaWNrZXI6IGBbXCJjb2xvclwiLCBzdHJpbmddYFxuICogICBUaGUgZmlyc3QgdmFsdWUgc2F5cyB0aGlzIHdpbGwgYmUgYSBjb2xvciBwaWNrZXIgbm90IGEgZHJvcGRvd24gbWVudS4gVGhlXG4gKiAgIG5leHQgdmFsdWUgaXMgdGhlIGluaXRpYWwgY29sb3IuXG4gKi9cblxudmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSB7XG4gIG5vZGVzOiB7XG4gICAgYm9yZGVyV2lkdGg6IFsxLCAwLCAxMCwgMV0sXG4gICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogWzIsIDAsIDEwLCAxXSxcbiAgICBjb2xvcjoge1xuICAgICAgYm9yZGVyOiBbXCJjb2xvclwiLCBcIiMyQjdDRTlcIl0sXG4gICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIiM5N0MyRkNcIl0sXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBbXCJjb2xvclwiLCBcIiMyQjdDRTlcIl0sXG4gICAgICAgIGJhY2tncm91bmQ6IFtcImNvbG9yXCIsIFwiI0QyRTVGRlwiXVxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogW1wiY29sb3JcIiwgXCIjMkI3Q0U5XCJdLFxuICAgICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIiNEMkU1RkZcIl1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9wYWNpdHk6IFswLCAwLCAxLCAwLjFdLFxuICAgIGZpeGVkOiB7XG4gICAgICB4OiBmYWxzZSxcbiAgICAgIHk6IGZhbHNlXG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjogW1wiY29sb3JcIiwgXCIjMzQzNDM0XCJdLFxuICAgICAgc2l6ZTogWzE0LCAwLCAxMDAsIDFdLFxuICAgICAgLy8gcHhcbiAgICAgIGZhY2U6IFtcImFyaWFsXCIsIFwidmVyZGFuYVwiLCBcInRhaG9tYVwiXSxcbiAgICAgIGJhY2tncm91bmQ6IFtcImNvbG9yXCIsIFwibm9uZVwiXSxcbiAgICAgIHN0cm9rZVdpZHRoOiBbMCwgMCwgNTAsIDFdLFxuICAgICAgLy8gcHhcbiAgICAgIHN0cm9rZUNvbG9yOiBbXCJjb2xvclwiLCBcIiNmZmZmZmZcIl1cbiAgICB9LFxuICAgIC8vZ3JvdXA6ICdzdHJpbmcnLFxuICAgIGhpZGRlbjogZmFsc2UsXG4gICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgIC8vaWNvbjoge1xuICAgIC8vICBmYWNlOiAnc3RyaW5nJywgIC8vJ0ZvbnRBd2Vzb21lJyxcbiAgICAvLyAgY29kZTogJ3N0cmluZycsICAvLydcXHVmMDA3JyxcbiAgICAvLyAgc2l6ZTogWzUwLCAwLCAyMDAsIDFdLCAgLy81MCxcbiAgICAvLyAgY29sb3I6IFsnY29sb3InLCcjMkI3Q0U5J10gICAvLycjYWEwMGZmJ1xuICAgIC8vfSxcbiAgICAvL2ltYWdlOiAnc3RyaW5nJywgLy8gLS0+IFVSTFxuICAgIHBoeXNpY3M6IHRydWUsXG4gICAgc2NhbGluZzoge1xuICAgICAgbWluOiBbMTAsIDAsIDIwMCwgMV0sXG4gICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBtaW46IFsxNCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heFZpc2libGU6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgZHJhd1RocmVzaG9sZDogWzUsIDAsIDIwLCAxXVxuICAgICAgfVxuICAgIH0sXG4gICAgc2hhZG93OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGNvbG9yOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgc2l6ZTogWzEwLCAwLCAyMCwgMV0sXG4gICAgICB4OiBbNSwgLTMwLCAzMCwgMV0sXG4gICAgICB5OiBbNSwgLTMwLCAzMCwgMV1cbiAgICB9LFxuICAgIHNoYXBlOiBbXCJlbGxpcHNlXCIsIFwiYm94XCIsIFwiY2lyY2xlXCIsIFwiZGF0YWJhc2VcIiwgXCJkaWFtb25kXCIsIFwiZG90XCIsIFwic3F1YXJlXCIsIFwic3RhclwiLCBcInRleHRcIiwgXCJ0cmlhbmdsZVwiLCBcInRyaWFuZ2xlRG93blwiLCBcImhleGFnb25cIl0sXG4gICAgc2hhcGVQcm9wZXJ0aWVzOiB7XG4gICAgICBib3JkZXJEYXNoZXM6IGZhbHNlLFxuICAgICAgYm9yZGVyUmFkaXVzOiBbNiwgMCwgMjAsIDFdLFxuICAgICAgaW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgIHVzZUltYWdlU2l6ZTogZmFsc2VcbiAgICB9LFxuICAgIHNpemU6IFsyNSwgMCwgMjAwLCAxXVxuICB9LFxuICBlZGdlczoge1xuICAgIGFycm93czoge1xuICAgICAgdG86IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNjYWxlRmFjdG9yOiBbMSwgMCwgMywgMC4wNV0sXG4gICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgfSxcbiAgICAgIG1pZGRsZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSxcbiAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICB9LFxuICAgICAgZnJvbToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc2NhbGVGYWN0b3I6IFsxLCAwLCAzLCAwLjA1XSxcbiAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBlbmRQb2ludE9mZnNldDoge1xuICAgICAgZnJvbTogWzAsIC0xMCwgMTAsIDFdLFxuICAgICAgdG86IFswLCAtMTAsIDEwLCAxXVxuICAgIH0sXG4gICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0cnVlLFxuICAgIGNvbG9yOiB7XG4gICAgICBjb2xvcjogW1wiY29sb3JcIiwgXCIjODQ4NDg0XCJdLFxuICAgICAgaGlnaGxpZ2h0OiBbXCJjb2xvclwiLCBcIiM4NDg0ODRcIl0sXG4gICAgICBob3ZlcjogW1wiY29sb3JcIiwgXCIjODQ4NDg0XCJdLFxuICAgICAgaW5oZXJpdDogW1wiZnJvbVwiLCBcInRvXCIsIFwiYm90aFwiLCB0cnVlLCBmYWxzZV0sXG4gICAgICBvcGFjaXR5OiBbMSwgMCwgMSwgMC4wNV1cbiAgICB9LFxuICAgIGRhc2hlczogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgY29sb3I6IFtcImNvbG9yXCIsIFwiIzM0MzQzNFwiXSxcbiAgICAgIHNpemU6IFsxNCwgMCwgMTAwLCAxXSxcbiAgICAgIC8vIHB4XG4gICAgICBmYWNlOiBbXCJhcmlhbFwiLCBcInZlcmRhbmFcIiwgXCJ0YWhvbWFcIl0sXG4gICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIm5vbmVcIl0sXG4gICAgICBzdHJva2VXaWR0aDogWzIsIDAsIDUwLCAxXSxcbiAgICAgIC8vIHB4XG4gICAgICBzdHJva2VDb2xvcjogW1wiY29sb3JcIiwgXCIjZmZmZmZmXCJdLFxuICAgICAgYWxpZ246IFtcImhvcml6b250YWxcIiwgXCJ0b3BcIiwgXCJtaWRkbGVcIiwgXCJib3R0b21cIl1cbiAgICB9LFxuICAgIGhpZGRlbjogZmFsc2UsXG4gICAgaG92ZXJXaWR0aDogWzEuNSwgMCwgNSwgMC4xXSxcbiAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgcGh5c2ljczogdHJ1ZSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IFsxLCAwLCAxMDAsIDFdLFxuICAgICAgbWF4OiBbMTUsIDAsIDEwMCwgMV0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBtaW46IFsxNCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heFZpc2libGU6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgZHJhd1RocmVzaG9sZDogWzUsIDAsIDIwLCAxXVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uV2lkdGg6IFsxLjUsIDAsIDUsIDAuMV0sXG4gICAgc2VsZlJlZmVyZW5jZVNpemU6IFsyMCwgMCwgMjAwLCAxXSxcbiAgICBzZWxmUmVmZXJlbmNlOiB7XG4gICAgICBzaXplOiBbMjAsIDAsIDIwMCwgMV0sXG4gICAgICBhbmdsZTogW01hdGguUEkgLyAyLCAtNiAqIE1hdGguUEksIDYgKiBNYXRoLlBJLCBNYXRoLlBJIC8gOF0sXG4gICAgICByZW5kZXJCZWhpbmRUaGVOb2RlOiB0cnVlXG4gICAgfSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgY29sb3I6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICBzaXplOiBbMTAsIDAsIDIwLCAxXSxcbiAgICAgIHg6IFs1LCAtMzAsIDMwLCAxXSxcbiAgICAgIHk6IFs1LCAtMzAsIDMwLCAxXVxuICAgIH0sXG4gICAgc21vb3RoOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgdHlwZTogW1wiZHluYW1pY1wiLCBcImNvbnRpbnVvdXNcIiwgXCJkaXNjcmV0ZVwiLCBcImRpYWdvbmFsQ3Jvc3NcIiwgXCJzdHJhaWdodENyb3NzXCIsIFwiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCIsIFwiY3VydmVkQ1dcIiwgXCJjdXJ2ZWRDQ1dcIiwgXCJjdWJpY0JlemllclwiXSxcbiAgICAgIGZvcmNlRGlyZWN0aW9uOiBbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIiwgXCJub25lXCJdLFxuICAgICAgcm91bmRuZXNzOiBbMC41LCAwLCAxLCAwLjA1XVxuICAgIH0sXG4gICAgd2lkdGg6IFsxLCAwLCAzMCwgMV1cbiAgfSxcbiAgbGF5b3V0OiB7XG4gICAgLy9yYW5kb21TZWVkOiBbMCwgMCwgNTAwLCAxXSxcbiAgICAvL2ltcHJvdmVkTGF5b3V0OiB0cnVlLFxuICAgIGhpZXJhcmNoaWNhbDoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBsZXZlbFNlcGFyYXRpb246IFsxNTAsIDIwLCA1MDAsIDVdLFxuICAgICAgbm9kZVNwYWNpbmc6IFsxMDAsIDIwLCA1MDAsIDVdLFxuICAgICAgdHJlZVNwYWNpbmc6IFsyMDAsIDIwLCA1MDAsIDVdLFxuICAgICAgYmxvY2tTaGlmdGluZzogdHJ1ZSxcbiAgICAgIGVkZ2VNaW5pbWl6YXRpb246IHRydWUsXG4gICAgICBwYXJlbnRDZW50cmFsaXphdGlvbjogdHJ1ZSxcbiAgICAgIGRpcmVjdGlvbjogW1wiVURcIiwgXCJEVVwiLCBcIkxSXCIsIFwiUkxcIl0sXG4gICAgICAvLyBVRCwgRFUsIExSLCBSTFxuICAgICAgc29ydE1ldGhvZDogW1wiaHVic2l6ZVwiLCBcImRpcmVjdGVkXCJdLFxuICAgICAgLy8gaHVic2l6ZSwgZGlyZWN0ZWRcbiAgICAgIHNoYWtlVG93YXJkczogW1wibGVhdmVzXCIsIFwicm9vdHNcIl0gLy8gbGVhdmVzLCByb290c1xuXG4gICAgfVxuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIGRyYWdOb2RlczogdHJ1ZSxcbiAgICBkcmFnVmlldzogdHJ1ZSxcbiAgICBoaWRlRWRnZXNPbkRyYWc6IGZhbHNlLFxuICAgIGhpZGVFZGdlc09uWm9vbTogZmFsc2UsXG4gICAgaGlkZU5vZGVzT25EcmFnOiBmYWxzZSxcbiAgICBob3ZlcjogZmFsc2UsXG4gICAga2V5Ym9hcmQ6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc3BlZWQ6IHtcbiAgICAgICAgeDogWzEwLCAwLCA0MCwgMV0sXG4gICAgICAgIHk6IFsxMCwgMCwgNDAsIDFdLFxuICAgICAgICB6b29tOiBbMC4wMiwgMCwgMC4xLCAwLjAwNV1cbiAgICAgIH0sXG4gICAgICBiaW5kVG9XaW5kb3c6IHRydWVcbiAgICB9LFxuICAgIG11bHRpc2VsZWN0OiBmYWxzZSxcbiAgICBuYXZpZ2F0aW9uQnV0dG9uczogZmFsc2UsXG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICBzZWxlY3RDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgIHRvb2x0aXBEZWxheTogWzMwMCwgMCwgMTAwMCwgMjVdLFxuICAgIHpvb21WaWV3OiB0cnVlLFxuICAgIHpvb21TcGVlZDogWzEsIDAuMSwgMiwgMC4xXVxuICB9LFxuICBtYW5pcHVsYXRpb246IHtcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICBpbml0aWFsbHlBY3RpdmU6IGZhbHNlXG4gIH0sXG4gIHBoeXNpY3M6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGJhcm5lc0h1dDoge1xuICAgICAgdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IFstMjAwMCwgLTMwMDAwLCAwLCA1MF0sXG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMywgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDQsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdLFxuICAgICAgYXZvaWRPdmVybGFwOiBbMCwgMCwgMSwgMC4wMV1cbiAgICB9LFxuICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgIHRoZXRhOiBbMC41LCAwLjEsIDEsIDAuMDVdLFxuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiBbLTUwLCAtNTAwLCAwLCAxXSxcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4wMSwgMCwgMSwgMC4wMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDgsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgZGFtcGluZzogWzAuNCwgMCwgMSwgMC4wMV0sXG4gICAgICBhdm9pZE92ZXJsYXA6IFswLCAwLCAxLCAwLjAxXVxuICAgIH0sXG4gICAgcmVwdWxzaW9uOiB7XG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMiwgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbMjAwLCAwLCA1MDAsIDVdLFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA1LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgIG5vZGVEaXN0YW5jZTogWzEwMCwgMCwgNTAwLCA1XSxcbiAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXVxuICAgIH0sXG4gICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMiwgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbMTAwLCAwLCA1MDAsIDVdLFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjAxLCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgIG5vZGVEaXN0YW5jZTogWzEyMCwgMCwgNTAwLCA1XSxcbiAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXSxcbiAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICBtYXhWZWxvY2l0eTogWzUwLCAwLCAxNTAsIDFdLFxuICAgIG1pblZlbG9jaXR5OiBbMC4xLCAwLjAxLCAwLjUsIDAuMDFdLFxuICAgIHNvbHZlcjogW1wiYmFybmVzSHV0XCIsIFwiZm9yY2VBdGxhczJCYXNlZFwiLCBcInJlcHVsc2lvblwiLCBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiXSxcbiAgICB0aW1lc3RlcDogWzAuNSwgMC4wMSwgMSwgMC4wMV0sXG4gICAgd2luZDoge1xuICAgICAgeDogWzAsIC0xMCwgMTAsIDAuMV0sXG4gICAgICB5OiBbMCwgLTEwLCAxMCwgMC4xXVxuICAgIH0gLy9hZGFwdGl2ZVRpbWVzdGVwOiB0cnVlXG5cbiAgfVxufTtcblxudmFyIG9wdGlvbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0YWxsT3B0aW9uczogYWxsT3B0aW9ucyQxLFxuXHRjb25maWd1cmVPcHRpb25zOiBjb25maWd1cmVPcHRpb25zXG59KTtcblxuLyoqXG4gKiAgVGhlIEZsb3lk4oCTV2Fyc2hhbGwgYWxnb3JpdGhtIGlzIGFuIGFsZ29yaXRobSBmb3IgZmluZGluZyBzaG9ydGVzdCBwYXRocyBpblxuICogIGEgd2VpZ2h0ZWQgZ3JhcGggd2l0aCBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBlZGdlIHdlaWdodHMgKGJ1dCB3aXRoIG5vIG5lZ2F0aXZlXG4gKiAgY3ljbGVzKS4gLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG95ZOKAk1dhcnNoYWxsX2FsZ29yaXRobVxuICovXG52YXIgRmxveWRXYXJzaGFsbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBGbG95ZFdhcnNoYWxsKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZsb3lkV2Fyc2hhbGwpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNBcnJheVxuICAgKiBAcGFyYW0ge0FycmF5LjxFZGdlPn0gZWRnZXNBcnJheVxuICAgKiBAcmV0dXJucyB7e319XG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoRmxveWRXYXJzaGFsbCwgW3tcbiAgICBrZXk6IFwiZ2V0RGlzdGFuY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlcyhib2R5LCBub2Rlc0FycmF5LCBlZGdlc0FycmF5KSB7XG4gICAgICB2YXIgRF9tYXRyaXggPSB7fTtcbiAgICAgIHZhciBlZGdlcyA9IGJvZHkuZWRnZXM7IC8vIHByZXBhcmUgbWF0cml4IHdpdGggbGFyZ2UgbnVtYmVyc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc0FycmF5W2ldO1xuICAgICAgICB2YXIgY2VsbCA9IHt9O1xuICAgICAgICBEX21hdHJpeFtub2RlXSA9IGNlbGw7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlc0FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY2VsbFtub2Rlc0FycmF5W2pdXSA9IGkgPT0gaiA/IDAgOiAxZTk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcHV0IHRoZSB3ZWlnaHRzIGZvciB0aGUgZWRnZXMgaW4uIFRoaXMgYXNzdW1lcyB1bmlkaXJlY3Rpb25hbGl0eS5cblxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZXNBcnJheS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlc0FycmF5W19pXV07IC8vIGVkZ2UgaGFzIHRvIGJlIGNvbm5lY3RlZCBpZiBpdCBjb3VudHMgdG8gdGhlIGRpc3RhbmNlcy4gSWYgaXQgaXMgY29ubmVjdGVkIHRvIGlubmVyIGNsdXN0ZXJzIGl0IHdpbGwgY3Jhc2ggc28gd2UgYWxzbyBjaGVjayBpZiBpdCBpcyBpbiB0aGUgRF9tYXRyaXhcblxuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUgJiYgRF9tYXRyaXhbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgRF9tYXRyaXhbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgRF9tYXRyaXhbZWRnZS5mcm9tSWRdW2VkZ2UudG9JZF0gPSAxO1xuICAgICAgICAgIERfbWF0cml4W2VkZ2UudG9JZF1bZWRnZS5mcm9tSWRdID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZUNvdW50ID0gbm9kZXNBcnJheS5sZW5ndGg7IC8vIEFkYXB0ZWQgRmxveWRXYXJzaGFsbCBiYXNlZCBvbiB1bmlkaXJlY3Rpb25hbGl0eSB0byBncmVhdGx5IHJlZHVjZSBjb21wbGV4aXR5LlxuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5vZGVDb3VudDsgaysrKSB7XG4gICAgICAgIHZhciBrbm9kZSA9IG5vZGVzQXJyYXlba107XG4gICAgICAgIHZhciBrY29sbSA9IERfbWF0cml4W2tub2RlXTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlQ291bnQgLSAxOyBfaTIrKykge1xuICAgICAgICAgIHZhciBpbm9kZSA9IG5vZGVzQXJyYXlbX2kyXTtcbiAgICAgICAgICB2YXIgaWNvbG0gPSBEX21hdHJpeFtpbm9kZV07XG5cbiAgICAgICAgICBmb3IgKHZhciBfaiA9IF9pMiArIDE7IF9qIDwgbm9kZUNvdW50OyBfaisrKSB7XG4gICAgICAgICAgICB2YXIgam5vZGUgPSBub2Rlc0FycmF5W19qXTtcbiAgICAgICAgICAgIHZhciBqY29sbSA9IERfbWF0cml4W2pub2RlXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBNYXRoLm1pbihpY29sbVtqbm9kZV0sIGljb2xtW2tub2RlXSArIGtjb2xtW2pub2RlXSk7XG4gICAgICAgICAgICBpY29sbVtqbm9kZV0gPSB2YWw7XG4gICAgICAgICAgICBqY29sbVtpbm9kZV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEX21hdHJpeDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmxveWRXYXJzaGFsbDtcbn0oKTtcblxuLyoqXG4gKiBLYW1hZGFLYXdhaSBwb3NpdGlvbnMgdGhlIG5vZGVzIGluaXRpYWxseSBiYXNlZCBvblxuICpcbiAqIFwiQU4gQUxHT1JJVEhNIEZPUiBEUkFXSU5HIEdFTkVSQUwgVU5ESVJFQ1RFRCBHUkFQSFNcIlxuICogLS0gVG9taWhpc2EgS0FNQURBIGFuZCBTYXRvcnUgS0FXQUkgaW4gMTk4OVxuICpcbiAqIFBvc3NpYmxlIG9wdGltaXphdGlvbnMgaW4gdGhlIGRpc3RhbmNlIGNhbGN1bGF0aW9uIGNhbiBiZSBpbXBsZW1lbnRlZC5cbiAqL1xuXG52YXIgS2FtYWRhS2F3YWkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VMZW5ndGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VTdHJlbmd0aFxuICAgKi9cbiAgZnVuY3Rpb24gS2FtYWRhS2F3YWkoYm9keSwgZWRnZUxlbmd0aCwgZWRnZVN0cmVuZ3RoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgS2FtYWRhS2F3YWkpO1xuXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnNwcmluZ0xlbmd0aCA9IGVkZ2VMZW5ndGg7XG4gICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IGVkZ2VTdHJlbmd0aDtcbiAgICB0aGlzLmRpc3RhbmNlU29sdmVyID0gbmV3IEZsb3lkV2Fyc2hhbGwoKTtcbiAgfVxuICAvKipcbiAgICogTm90IHN1cmUgaWYgbmVlZGVkIGJ1dCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlIHNwcmluZyBsZW5ndGggYW5kIHNwcmluZyBjb25zdGFudFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKEthbWFkYUthd2FpLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3ByaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5zcHJpbmdMZW5ndGggPSBvcHRpb25zLnNwcmluZ0xlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnNwcmluZ0NvbnN0YW50KSB7XG4gICAgICAgICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IG9wdGlvbnMuc3ByaW5nQ29uc3RhbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gdGhlIHN5c3RlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx2aXMuRWRnZT59IGVkZ2VzQXJyYXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVDbHVzdGVycz1mYWxzZV1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgIHZhciBpZ25vcmVDbHVzdGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICAvLyBnZXQgZGlzdGFuY2UgbWF0cml4XG4gICAgICB2YXIgRF9tYXRyaXggPSB0aGlzLmRpc3RhbmNlU29sdmVyLmdldERpc3RhbmNlcyh0aGlzLmJvZHksIG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpOyAvLyBkaXN0YW5jZSBtYXRyaXhcbiAgICAgIC8vIGdldCB0aGUgTCBNYXRyaXhcblxuICAgICAgdGhpcy5fY3JlYXRlTF9tYXRyaXgoRF9tYXRyaXgpOyAvLyBnZXQgdGhlIEsgTWF0cml4XG5cblxuICAgICAgdGhpcy5fY3JlYXRlS19tYXRyaXgoRF9tYXRyaXgpOyAvLyBpbml0aWFsIEUgTWF0cml4XG5cblxuICAgICAgdGhpcy5fY3JlYXRlRV9tYXRyaXgoKTsgLy8gY2FsY3VsYXRlIHBvc2l0aW9uc1xuXG5cbiAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjAxO1xuICAgICAgdmFyIGlubmVyVGhyZXNob2xkID0gMTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBtYXhJdGVyYXRpb25zID0gTWF0aC5tYXgoMTAwMCwgTWF0aC5taW4oMTAgKiB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoLCA2MDAwKSk7XG4gICAgICB2YXIgbWF4SW5uZXJJdGVyYXRpb25zID0gNTtcbiAgICAgIHZhciBtYXhFbmVyZ3kgPSAxZTk7XG4gICAgICB2YXIgaGlnaEVfbm9kZUlkID0gMCxcbiAgICAgICAgICBkRV9keCA9IDAsXG4gICAgICAgICAgZEVfZHkgPSAwLFxuICAgICAgICAgIGRlbHRhX20gPSAwLFxuICAgICAgICAgIHN1Ykl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgICB3aGlsZSAobWF4RW5lcmd5ID4gdGhyZXNob2xkICYmIGl0ZXJhdGlvbnMgPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMgKz0gMTtcblxuICAgICAgICB2YXIgX3RoaXMkX2dldEhpZ2hlc3RFbmVyID0gdGhpcy5fZ2V0SGlnaGVzdEVuZXJneU5vZGUoaWdub3JlQ2x1c3RlcnMpO1xuXG4gICAgICAgIHZhciBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyID0gc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0SGlnaGVzdEVuZXIsIDQpO1xuXG4gICAgICAgIGhpZ2hFX25vZGVJZCA9IF90aGlzJF9nZXRIaWdoZXN0RW5lcjJbMF07XG4gICAgICAgIG1heEVuZXJneSA9IF90aGlzJF9nZXRIaWdoZXN0RW5lcjJbMV07XG4gICAgICAgIGRFX2R4ID0gX3RoaXMkX2dldEhpZ2hlc3RFbmVyMlsyXTtcbiAgICAgICAgZEVfZHkgPSBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyWzNdO1xuICAgICAgICBkZWx0YV9tID0gbWF4RW5lcmd5O1xuICAgICAgICBzdWJJdGVyYXRpb25zID0gMDtcblxuICAgICAgICB3aGlsZSAoZGVsdGFfbSA+IGlubmVyVGhyZXNob2xkICYmIHN1Ykl0ZXJhdGlvbnMgPCBtYXhJbm5lckl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICBzdWJJdGVyYXRpb25zICs9IDE7XG5cbiAgICAgICAgICB0aGlzLl9tb3ZlTm9kZShoaWdoRV9ub2RlSWQsIGRFX2R4LCBkRV9keSk7XG5cbiAgICAgICAgICB2YXIgX3RoaXMkX2dldEVuZXJneSA9IHRoaXMuX2dldEVuZXJneShoaWdoRV9ub2RlSWQpO1xuXG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRFbmVyZ3kyID0gc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0RW5lcmd5LCAzKTtcblxuICAgICAgICAgIGRlbHRhX20gPSBfdGhpcyRfZ2V0RW5lcmd5MlswXTtcbiAgICAgICAgICBkRV9keCA9IF90aGlzJF9nZXRFbmVyZ3kyWzFdO1xuICAgICAgICAgIGRFX2R5ID0gX3RoaXMkX2dldEVuZXJneTJbMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBub2RlIHdpdGggdGhlIGhpZ2hlc3QgZW5lcmd5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZUNsdXN0ZXJzXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0SGlnaGVzdEVuZXJneU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEhpZ2hlc3RFbmVyZ3lOb2RlKGlnbm9yZUNsdXN0ZXJzKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBtYXhFbmVyZ3kgPSAwO1xuICAgICAgdmFyIG1heEVuZXJneU5vZGVJZCA9IG5vZGVzQXJyYXlbMF07XG4gICAgICB2YXIgZEVfZHhfbWF4ID0gMCxcbiAgICAgICAgICBkRV9keV9tYXggPSAwO1xuXG4gICAgICBmb3IgKHZhciBub2RlSWR4ID0gMDsgbm9kZUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBub2RlSWR4KyspIHtcbiAgICAgICAgdmFyIG0gPSBub2Rlc0FycmF5W25vZGVJZHhdOyAvLyBieSBub3QgZXZhbHVhdGluZyBub2RlcyB3aXRoIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHNob3VsZCBvbmx5IG1vdmUgbm9kZXMgdGhhdCBoYXZlIG5vIHBvc2l0aW9ucy5cblxuICAgICAgICBpZiAobm9kZXNbbV0ucHJlZGVmaW5lZFBvc2l0aW9uICE9PSB0cnVlIHx8IG5vZGVzW21dLmlzQ2x1c3RlciA9PT0gdHJ1ZSAmJiBpZ25vcmVDbHVzdGVycyA9PT0gdHJ1ZSB8fCBub2Rlc1ttXS5vcHRpb25zLmZpeGVkLnggIT09IHRydWUgfHwgbm9kZXNbbV0ub3B0aW9ucy5maXhlZC55ICE9PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRFbmVyZ3kzID0gdGhpcy5fZ2V0RW5lcmd5KG0pLFxuICAgICAgICAgICAgICBfdGhpcyRfZ2V0RW5lcmd5NCA9IHNsaWNlZFRvQXJyYXkoX3RoaXMkX2dldEVuZXJneTMsIDMpLFxuICAgICAgICAgICAgICBkZWx0YV9tID0gX3RoaXMkX2dldEVuZXJneTRbMF0sXG4gICAgICAgICAgICAgIGRFX2R4ID0gX3RoaXMkX2dldEVuZXJneTRbMV0sXG4gICAgICAgICAgICAgIGRFX2R5ID0gX3RoaXMkX2dldEVuZXJneTRbMl07XG5cbiAgICAgICAgICBpZiAobWF4RW5lcmd5IDwgZGVsdGFfbSkge1xuICAgICAgICAgICAgbWF4RW5lcmd5ID0gZGVsdGFfbTtcbiAgICAgICAgICAgIG1heEVuZXJneU5vZGVJZCA9IG07XG4gICAgICAgICAgICBkRV9keF9tYXggPSBkRV9keDtcbiAgICAgICAgICAgIGRFX2R5X21heCA9IGRFX2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW21heEVuZXJneU5vZGVJZCwgbWF4RW5lcmd5LCBkRV9keF9tYXgsIGRFX2R5X21heF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgZW5lcmd5IG9mIGEgc2luZ2xlIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEVuZXJneVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RW5lcmd5KG0pIHtcbiAgICAgIHZhciBfdGhpcyRFX3N1bXMkbSA9IHNsaWNlZFRvQXJyYXkodGhpcy5FX3N1bXNbbV0sIDIpLFxuICAgICAgICAgIGRFX2R4ID0gX3RoaXMkRV9zdW1zJG1bMF0sXG4gICAgICAgICAgZEVfZHkgPSBfdGhpcyRFX3N1bXMkbVsxXTtcblxuICAgICAgdmFyIGRlbHRhX20gPSBNYXRoLnNxcnQoTWF0aC5wb3coZEVfZHgsIDIpICsgTWF0aC5wb3coZEVfZHksIDIpKTtcbiAgICAgIHJldHVybiBbZGVsdGFfbSwgZEVfZHgsIGRFX2R5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbW92ZSB0aGUgbm9kZSBiYXNlZCBvbiBpdCdzIGVuZXJneVxuICAgICAqIHRoZSBkeCBhbmQgZHkgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbGluZWFyIHN5c3RlbSBwcm9wb3NlZCBieSBLYW1hZGEgYW5kIEthd2FpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkRV9keFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkRV9keVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVOb2RlKG0sIGRFX2R4LCBkRV9keSkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZDJFX2R4MiA9IDA7XG4gICAgICB2YXIgZDJFX2R4ZHkgPSAwO1xuICAgICAgdmFyIGQyRV9keTIgPSAwO1xuICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgIHZhciBrbSA9IHRoaXMuS19tYXRyaXhbbV07XG4gICAgICB2YXIgbG0gPSB0aGlzLkxfbWF0cml4W21dO1xuXG4gICAgICBmb3IgKHZhciBpSWR4ID0gMDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuXG4gICAgICAgIGlmIChpICE9PSBtKSB7XG4gICAgICAgICAgdmFyIHhfaSA9IG5vZGVzW2ldLng7XG4gICAgICAgICAgdmFyIHlfaSA9IG5vZGVzW2ldLnk7XG4gICAgICAgICAgdmFyIGttYXQgPSBrbVtpXTtcbiAgICAgICAgICB2YXIgbG1hdCA9IGxtW2ldO1xuICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGgucG93KE1hdGgucG93KHhfbSAtIHhfaSwgMikgKyBNYXRoLnBvdyh5X20gLSB5X2ksIDIpLCAxLjUpO1xuICAgICAgICAgIGQyRV9keDIgKz0ga21hdCAqICgxIC0gbG1hdCAqIE1hdGgucG93KHlfbSAtIHlfaSwgMikgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgZDJFX2R4ZHkgKz0ga21hdCAqIChsbWF0ICogKHhfbSAtIHhfaSkgKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICBkMkVfZHkyICs9IGttYXQgKiAoMSAtIGxtYXQgKiBNYXRoLnBvdyh4X20gLSB4X2ksIDIpICogZGVub21pbmF0b3IpO1xuICAgICAgICB9XG4gICAgICB9IC8vIG1ha2UgdGhlIHZhcmlhYmxlIG5hbWVzIGVhc2llciB0byBtYWtlIHRoZSBzb2x2aW5nIG9mIHRoZSBsaW5lYXIgc3lzdGVtIGVhc2llciB0byByZWFkXG5cblxuICAgICAgdmFyIEEgPSBkMkVfZHgyLFxuICAgICAgICAgIEIgPSBkMkVfZHhkeSxcbiAgICAgICAgICBDID0gZEVfZHgsXG4gICAgICAgICAgRCA9IGQyRV9keTIsXG4gICAgICAgICAgRSA9IGRFX2R5OyAvLyBzb2x2ZSB0aGUgbGluZWFyIHN5c3RlbSBmb3IgZHggYW5kIGR5XG5cbiAgICAgIHZhciBkeSA9IChDIC8gQSArIEUgLyBCKSAvIChCIC8gQSAtIEQgLyBCKTtcbiAgICAgIHZhciBkeCA9IC0oQiAqIGR5ICsgQykgLyBBOyAvLyBtb3ZlIHRoZSBub2RlXG5cbiAgICAgIG5vZGVzW21dLnggKz0gZHg7XG4gICAgICBub2Rlc1ttXS55ICs9IGR5OyAvLyBSZWNhbGN1bGF0ZSBFX21hdHJpeCAoc2hvdWxkIGJlIGluY3JlbWVudGFsKVxuXG4gICAgICB0aGlzLl91cGRhdGVFX21hdHJpeChtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBMIG1hdHJpeDogZWRnZSBsZW5ndGggdGltZXMgc2hvcnRlc3QgcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IERfbWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVMX21hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlTF9tYXRyaXgoRF9tYXRyaXgpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VMZW5ndGggPSB0aGlzLnNwcmluZ0xlbmd0aDtcbiAgICAgIHRoaXMuTF9tYXRyaXggPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuTF9tYXRyaXhbbm9kZXNBcnJheVtpXV0gPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0aGlzLkxfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dID0gZWRnZUxlbmd0aCAqIERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgSyBtYXRyaXg6IHNwcmluZyBjb25zdGFudHMgdGltZXMgc2hvcnRlc3QgcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IERfbWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVLX21hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlS19tYXRyaXgoRF9tYXRyaXgpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VTdHJlbmd0aCA9IHRoaXMuc3ByaW5nQ29uc3RhbnQ7XG4gICAgICB0aGlzLktfbWF0cml4ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLktfbWF0cml4W25vZGVzQXJyYXlbaV1dID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlc0FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGhpcy5LX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXSA9IGVkZ2VTdHJlbmd0aCAqIE1hdGgucG93KERfbWF0cml4W25vZGVzQXJyYXlbaV1dW25vZGVzQXJyYXlbal1dLCAtMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBtYXRyaXggd2l0aCBhbGwgZW5lcmdpZXMgYmV0d2VlbiBub2Rlc1xuICAgICAqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRV9tYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVfbWF0cml4KCkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB0aGlzLkVfbWF0cml4ID0ge307XG4gICAgICB0aGlzLkVfc3VtcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBtSWR4ID0gMDsgbUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBtSWR4KyspIHtcbiAgICAgICAgdGhpcy5FX21hdHJpeFtub2Rlc0FycmF5W21JZHhdXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfbUlkeCA9IDA7IF9tSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IF9tSWR4KyspIHtcbiAgICAgICAgdmFyIG0gPSBub2Rlc0FycmF5W19tSWR4XTtcbiAgICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICAgIHZhciB5X20gPSBub2Rlc1ttXS55O1xuICAgICAgICB2YXIgZEVfZHggPSAwO1xuICAgICAgICB2YXIgZEVfZHkgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGlJZHggPSBfbUlkeDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgICB2YXIgaSA9IG5vZGVzQXJyYXlbaUlkeF07XG5cbiAgICAgICAgICBpZiAoaSAhPT0gbSkge1xuICAgICAgICAgICAgdmFyIHhfaSA9IG5vZGVzW2ldLng7XG4gICAgICAgICAgICB2YXIgeV9pID0gbm9kZXNbaV0ueTtcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGguc3FydChNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSk7XG4gICAgICAgICAgICB0aGlzLkVfbWF0cml4W21dW2lJZHhdID0gW3RoaXMuS19tYXRyaXhbbV1baV0gKiAoeF9tIC0geF9pIC0gdGhpcy5MX21hdHJpeFttXVtpXSAqICh4X20gLSB4X2kpICogZGVub21pbmF0b3IpLCB0aGlzLktfbWF0cml4W21dW2ldICogKHlfbSAtIHlfaSAtIHRoaXMuTF9tYXRyaXhbbV1baV0gKiAoeV9tIC0geV9pKSAqIGRlbm9taW5hdG9yKV07XG4gICAgICAgICAgICB0aGlzLkVfbWF0cml4W2ldW19tSWR4XSA9IHRoaXMuRV9tYXRyaXhbbV1baUlkeF07XG4gICAgICAgICAgICBkRV9keCArPSB0aGlzLkVfbWF0cml4W21dW2lJZHhdWzBdO1xuICAgICAgICAgICAgZEVfZHkgKz0gdGhpcy5FX21hdHJpeFttXVtpSWR4XVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy9TdG9yZSBzdW1cblxuXG4gICAgICAgIHRoaXMuRV9zdW1zW21dID0gW2RFX2R4LCBkRV9keV07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBtZXRob2QsIGp1c3QgZG9pbmcgc2luZ2xlIGNvbHVtbiAocm93cyBhcmUgYXV0by11cGRhdGVkKSAodXBkYXRlIGFsbCBzdW1zKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUVfbWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVFX21hdHJpeChtKSB7XG4gICAgICB2YXIgbm9kZXNBcnJheSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBjb2xtID0gdGhpcy5FX21hdHJpeFttXTtcbiAgICAgIHZhciBrY29sbSA9IHRoaXMuS19tYXRyaXhbbV07XG4gICAgICB2YXIgbGNvbG0gPSB0aGlzLkxfbWF0cml4W21dO1xuICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgIHZhciBkRV9keCA9IDA7XG4gICAgICB2YXIgZEVfZHkgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpSWR4ID0gMDsgaUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpSWR4KyspIHtcbiAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuXG4gICAgICAgIGlmIChpICE9PSBtKSB7XG4gICAgICAgICAgLy9LZWVwIG9sZCBlbmVyZ3kgdmFsdWUgZm9yIHN1bSBtb2RpZmljYXRpb24gYmVsb3dcbiAgICAgICAgICB2YXIgY2VsbCA9IGNvbG1baUlkeF07XG4gICAgICAgICAgdmFyIG9sZER4ID0gY2VsbFswXTtcbiAgICAgICAgICB2YXIgb2xkRHkgPSBjZWxsWzFdOyAvL0NhbGMgbmV3IGVuZXJneTpcblxuICAgICAgICAgIHZhciB4X2kgPSBub2Rlc1tpXS54O1xuICAgICAgICAgIHZhciB5X2kgPSBub2Rlc1tpXS55O1xuICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IDEuMCAvIE1hdGguc3FydChNYXRoLnBvdyh4X20gLSB4X2ksIDIpICsgTWF0aC5wb3coeV9tIC0geV9pLCAyKSk7XG4gICAgICAgICAgdmFyIGR4ID0ga2NvbG1baV0gKiAoeF9tIC0geF9pIC0gbGNvbG1baV0gKiAoeF9tIC0geF9pKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICB2YXIgZHkgPSBrY29sbVtpXSAqICh5X20gLSB5X2kgLSBsY29sbVtpXSAqICh5X20gLSB5X2kpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIGNvbG1baUlkeF0gPSBbZHgsIGR5XTtcbiAgICAgICAgICBkRV9keCArPSBkeDtcbiAgICAgICAgICBkRV9keSArPSBkeTsgLy9hZGQgbmV3IGVuZXJneSB0byBzdW0gb2YgZWFjaCBjb2x1bW5cblxuICAgICAgICAgIHZhciBzdW0gPSB0aGlzLkVfc3Vtc1tpXTtcbiAgICAgICAgICBzdW1bMF0gKz0gZHggLSBvbGREeDtcbiAgICAgICAgICBzdW1bMV0gKz0gZHkgLSBvbGREeTtcbiAgICAgICAgfVxuICAgICAgfSAvL1N0b3JlIHN1bSBhdCAtMSBpbmRleFxuXG5cbiAgICAgIHRoaXMuRV9zdW1zW21dID0gW2RFX2R4LCBkRV9keV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEthbWFkYUthd2FpO1xufSgpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldHdvcmsgdmlzdWFsaXphdGlvbiwgZGlzcGxheWluZyBub2RlcyBhbmQgZWRnZXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgICBUaGUgRE9NIGVsZW1lbnQgaW4gd2hpY2ggdGhlIE5ldHdvcmsgd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgY3JlYXRlZC4gTm9ybWFsbHkgYSBkaXYgZWxlbWVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXl9IG5vZGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheX0gZWRnZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgT3B0aW9uc1xuICogQGNsYXNzIE5ldHdvcmtcbiAqL1xuXG5mdW5jdGlvbiBOZXR3b3JrKGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2NvbnRleHQsXG4gICAgICBfY29udGV4dDIsXG4gICAgICBfY29udGV4dDMsXG4gICAgICBfY29udGV4dDQsXG4gICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5ldHdvcmspKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yXCIpO1xuICB9IC8vIHNldCBjb25zdGFudCB2YWx1ZXNcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIGxvY2FsZTogXCJlblwiLFxuICAgIGxvY2FsZXM6IGxvY2FsZXMsXG4gICAgY2xpY2tUb1VzZTogZmFsc2VcbiAgfTtcblxuICBhc3NpZ24kMih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAvKipcbiAgICogQ29udGFpbmVycyBmb3Igbm9kZXMgYW5kIGVkZ2VzLlxuICAgKlxuICAgKiAnZWRnZXMnIGFuZCAnbm9kZXMnIGNvbnRhaW4gdGhlIGZ1bGwgZGVmaW5pdGlvbnMgb2YgYWxsIHRoZSBuZXR3b3JrIGVsZW1lbnRzLlxuICAgKiAnbm9kZUluZGljZXMnIGFuZCAnZWRnZUluZGljZXMnIGNvbnRhaW4gdGhlIGlkJ3Mgb2YgdGhlIGFjdGl2ZSBlbGVtZW50cy5cbiAgICpcbiAgICogVGhlIGRpc3RpbmN0aW9uIGlzIGltcG9ydGFudCwgYmVjYXVzZSBhIGRlZmluZWQgbm9kZSBuZWVkIG5vdCBiZSBhY3RpdmUsIGkuZS5cbiAgICogdmlzaWJsZSBvbiB0aGUgY2FudmFzLiBUaGlzIGhhcHBlbnMgaW4gcGFydGljdWxhciB3aGVuIGNsdXN0ZXJzIGFyZSBkZWZpbmVkLCBpblxuICAgKiB0aGF0IGNhc2UgdGhlcmUgd2lsbCBiZSBub2RlcyBhbmQgZWRnZXMgbm90IGRpc3BsYXllZC5cbiAgICogVGhlIGJvdHRvbSBsaW5lIGlzIHRoYXQgYWxsIGNvZGUgd2l0aCBhY3Rpb25zIHJlbGF0ZWQgdG8gdmlzaWJpbGl0eSwgKm11c3QqIHVzZVxuICAgKiAnbm9kZUluZGljZXMnIGFuZCAnZWRnZUluZGljZXMnLCBub3QgJ25vZGVzJyBhbmQgJ2VkZ2VzJyBkaXJlY3RseS5cbiAgICovXG5cblxuICB0aGlzLmJvZHkgPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUgZm9yIGZvbGxvd2luZyBmaWVsZHNcbiAgICBub2Rlczoge30sXG4gICAgbm9kZUluZGljZXM6IFtdLFxuICAgIGVkZ2VzOiB7fSxcbiAgICBlZGdlSW5kaWNlczogW10sXG4gICAgZW1pdHRlcjoge1xuICAgICAgb246IGJpbmQkMihfY29udGV4dCA9IHRoaXMub24pLmNhbGwoX2NvbnRleHQsIHRoaXMpLFxuICAgICAgb2ZmOiBiaW5kJDIoX2NvbnRleHQyID0gdGhpcy5vZmYpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSxcbiAgICAgIGVtaXQ6IGJpbmQkMihfY29udGV4dDMgPSB0aGlzLmVtaXQpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSxcbiAgICAgIG9uY2U6IGJpbmQkMihfY29udGV4dDQgPSB0aGlzLm9uY2UpLmNhbGwoX2NvbnRleHQ0LCB0aGlzKVxuICAgIH0sXG4gICAgZXZlbnRMaXN0ZW5lcnM6IHtcbiAgICAgIG9uVGFwOiBmdW5jdGlvbiBvblRhcCgpIHt9LFxuICAgICAgb25Ub3VjaDogZnVuY3Rpb24gb25Ub3VjaCgpIHt9LFxuICAgICAgb25Eb3VibGVUYXA6IGZ1bmN0aW9uIG9uRG91YmxlVGFwKCkge30sXG4gICAgICBvbkhvbGQ6IGZ1bmN0aW9uIG9uSG9sZCgpIHt9LFxuICAgICAgb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KCkge30sXG4gICAgICBvbkRyYWc6IGZ1bmN0aW9uIG9uRHJhZygpIHt9LFxuICAgICAgb25EcmFnRW5kOiBmdW5jdGlvbiBvbkRyYWdFbmQoKSB7fSxcbiAgICAgIG9uTW91c2VXaGVlbDogZnVuY3Rpb24gb25Nb3VzZVdoZWVsKCkge30sXG4gICAgICBvblBpbmNoOiBmdW5jdGlvbiBvblBpbmNoKCkge30sXG4gICAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24gb25Nb3VzZU1vdmUoKSB7fSxcbiAgICAgIG9uUmVsZWFzZTogZnVuY3Rpb24gb25SZWxlYXNlKCkge30sXG4gICAgICBvbkNvbnRleHQ6IGZ1bmN0aW9uIG9uQ29udGV4dCgpIHt9XG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICBub2RlczogbnVsbCxcbiAgICAgIC8vIEEgRGF0YVNldCBvciBEYXRhVmlld1xuICAgICAgZWRnZXM6IG51bGwgLy8gQSBEYXRhU2V0IG9yIERhdGFWaWV3XG5cbiAgICB9LFxuICAgIGZ1bmN0aW9uczoge1xuICAgICAgY3JlYXRlTm9kZTogZnVuY3Rpb24gY3JlYXRlTm9kZSgpIHt9LFxuICAgICAgY3JlYXRlRWRnZTogZnVuY3Rpb24gY3JlYXRlRWRnZSgpIHt9LFxuICAgICAgZ2V0UG9pbnRlcjogZnVuY3Rpb24gZ2V0UG9pbnRlcigpIHt9XG4gICAgfSxcbiAgICBtb2R1bGVzOiB7fSxcbiAgICB2aWV3OiB7XG4gICAgICBzY2FsZTogMSxcbiAgICAgIHRyYW5zbGF0aW9uOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdGlvbkJveDoge1xuICAgICAgc2hvdzogZmFsc2UsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gYmluZCB0aGUgZXZlbnQgbGlzdGVuZXJzXG5cbiAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTsgLy8gc2V0dGluZyB1cCBhbGwgbW9kdWxlc1xuXG4gIHRoaXMuaW1hZ2VzID0gbmV3IEltYWdlcyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gIH0pOyAvLyBvYmplY3Qgd2l0aCBpbWFnZXNcblxuICB0aGlzLmdyb3VwcyA9IG5ldyBHcm91cHMoKTsgLy8gb2JqZWN0IHdpdGggZ3JvdXBzXG5cbiAgdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzKHRoaXMuYm9keSk7IC8vIERPTSBoYW5kbGVyXG5cbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyID0gbmV3IFNlbGVjdGlvbkhhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIFNlbGVjdGlvbiBoYW5kbGVyXG5cbiAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIgPSBuZXcgSW50ZXJhY3Rpb25IYW5kbGVyKHRoaXMuYm9keSwgdGhpcy5jYW52YXMsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcik7IC8vIEludGVyYWN0aW9uIGhhbmRsZXIgaGFuZGxlcyBhbGwgdGhlIGhhbW1lciBiaW5kaW5ncyAodGhhdCBhcmUgYm91bmQgYnkgY2FudmFzKSwga2V5XG5cbiAgdGhpcy52aWV3ID0gbmV3IFZpZXcodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIGNhbWVyYSBoYW5kbGVyLCBkb2VzIGFuaW1hdGlvbnMgYW5kIHpvb21zXG5cbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBDYW52YXNSZW5kZXJlcih0aGlzLmJvZHksIHRoaXMuY2FudmFzKTsgLy8gcmVuZGVyZXIsIHN0YXJ0cyByZW5kZXJsb29wLCBoYXMgZXZlbnRzIHRoYXQgbW9kdWxlcyBjYW4gaG9vayBpbnRvXG5cbiAgdGhpcy5waHlzaWNzID0gbmV3IFBoeXNpY3NFbmdpbmUodGhpcy5ib2R5KTsgLy8gcGh5c2ljcyBlbmdpbmUsIGRvZXMgYWxsIHRoZSBzaW11bGF0aW9uc1xuXG4gIHRoaXMubGF5b3V0RW5naW5lID0gbmV3IExheW91dEVuZ2luZSh0aGlzLmJvZHkpOyAvLyBsYXlvdXQgZW5naW5lIGZvciBpbml0YWwgbGF5b3V0IGFuZCBoaWVyYXJjaGljYWwgbGF5b3V0XG5cbiAgdGhpcy5jbHVzdGVyaW5nID0gbmV3IENsdXN0ZXJFbmdpbmUodGhpcy5ib2R5KTsgLy8gY2x1c3RlcmluZyBhcGlcblxuICB0aGlzLm1hbmlwdWxhdGlvbiA9IG5ldyBNYW5pcHVsYXRpb25TeXN0ZW0odGhpcy5ib2R5LCB0aGlzLmNhbnZhcywgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcik7IC8vIGRhdGEgbWFuaXB1bGF0aW9uIHN5c3RlbVxuXG4gIHRoaXMubm9kZXNIYW5kbGVyID0gbmV3IE5vZGVzSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3VwcywgdGhpcy5sYXlvdXRFbmdpbmUpOyAvLyBIYW5kbGUgYWRkaW5nLCBkZWxldGluZyBhbmQgdXBkYXRpbmcgb2Ygbm9kZXMgYXMgd2VsbCBhcyBnbG9iYWwgb3B0aW9uc1xuXG4gIHRoaXMuZWRnZXNIYW5kbGVyID0gbmV3IEVkZ2VzSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3Vwcyk7IC8vIEhhbmRsZSBhZGRpbmcsIGRlbGV0aW5nIGFuZCB1cGRhdGluZyBvZiBlZGdlcyBhcyB3ZWxsIGFzIGdsb2JhbCBvcHRpb25zXG5cbiAgdGhpcy5ib2R5Lm1vZHVsZXNbXCJrYW1hZGFLYXdhaVwiXSA9IG5ldyBLYW1hZGFLYXdhaSh0aGlzLmJvZHksIDE1MCwgMC4wNSk7IC8vIExheW91dGluZyBhbGdvcml0aG0uXG5cbiAgdGhpcy5ib2R5Lm1vZHVsZXNbXCJjbHVzdGVyaW5nXCJdID0gdGhpcy5jbHVzdGVyaW5nOyAvLyBjcmVhdGUgdGhlIERPTSBlbGVtZW50c1xuXG4gIHRoaXMuY2FudmFzLl9jcmVhdGUoKTsgLy8gYXBwbHkgb3B0aW9uc1xuXG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpOyAvLyBsb2FkIGRhdGEgKHRoZSBkaXNhYmxlIHN0YXJ0IHZhcmlhYmxlIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIGVuYWJsZWQgY2x1c3RlcmluZylcblxuICB0aGlzLnNldERhdGEoZGF0YSk7XG59IC8vIEV4dGVuZCBOZXR3b3JrIHdpdGggYW4gRW1pdHRlciBtaXhpblxuXG5jb21wb25lbnRFbWl0dGVyKE5ldHdvcmsucHJvdG90eXBlKTtcbi8qKlxuICogU2V0IG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5cbk5ldHdvcmsucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBpZiAob3B0aW9ucyA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7IC8vIFRoaXMgZW5zdXJlcyB0aGF0IG9wdGlvbnMgaGFuZGxpbmcgZG9lc24ndCBjcmFzaCBpbiB0aGUgaGFuZGxpbmdcbiAgfVxuXG4gIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXJyb3JGb3VuZCA9IFZhbGlkYXRvci52YWxpZGF0ZShvcHRpb25zLCBhbGxPcHRpb25zJDEpO1xuXG4gICAgaWYgKGVycm9yRm91bmQgPT09IHRydWUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCIlY0Vycm9ycyBoYXZlIGJlZW4gZm91bmQgaW4gdGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0LlwiLCBwcmludFN0eWxlKTtcbiAgICB9IC8vIGNvcHkgdGhlIGdsb2JhbCBmaWVsZHMgb3ZlclxuXG5cbiAgICB2YXIgZmllbGRzID0gW1wibG9jYWxlXCIsIFwibG9jYWxlc1wiLCBcImNsaWNrVG9Vc2VcIl07XG4gICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7IC8vIG5vcm1hbGl6ZSB0aGUgbG9jYWxlIG9yIHVzZSBFbmdsaXNoXG5cbiAgICBpZiAob3B0aW9ucy5sb2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5sb2NhbGUgPSBub3JtYWxpemVMYW5ndWFnZUNvZGUob3B0aW9ucy5sb2NhbGVzIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzLCBvcHRpb25zLmxvY2FsZSk7XG4gICAgfSAvLyB0aGUgaGllcmFyY2hpY2FsIHN5c3RlbSBjYW4gYWRhcHQgdGhlIGVkZ2VzIGFuZCB0aGUgcGh5c2ljcyB0byBpdCdzIG93biBvcHRpb25zIGJlY2F1c2Ugbm90IGFsbCBjb21iaW5hdGlvbnMgd29yayB3aXRoIHRoZSBoaWVyYXJpY2hpY2FsIHN5c3RlbS5cblxuXG4gICAgb3B0aW9ucyA9IHRoaXMubGF5b3V0RW5naW5lLnNldE9wdGlvbnMob3B0aW9ucy5sYXlvdXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2FudmFzLnNldE9wdGlvbnMob3B0aW9ucyk7IC8vIG9wdGlvbnMgZm9yIGNhbnZhcyBhcmUgaW4gZ2xvYmFsc1xuICAgIC8vIHBhc3MgdGhlIG9wdGlvbnMgdG8gdGhlIG1vZHVsZXNcblxuICAgIHRoaXMuZ3JvdXBzLnNldE9wdGlvbnMob3B0aW9ucy5ncm91cHMpO1xuICAgIHRoaXMubm9kZXNIYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5ub2Rlcyk7XG4gICAgdGhpcy5lZGdlc0hhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmVkZ2VzKTtcbiAgICB0aGlzLnBoeXNpY3Muc2V0T3B0aW9ucyhvcHRpb25zLnBoeXNpY3MpO1xuICAgIHRoaXMubWFuaXB1bGF0aW9uLnNldE9wdGlvbnMob3B0aW9ucy5tYW5pcHVsYXRpb24sIG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7IC8vIG1hbmlwdWxhdGlvbiB1c2VzIHRoZSBsb2NhbGVzIGluIHRoZSBnbG9iYWxzXG5cbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMuaW50ZXJhY3Rpb24pO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTsgLy8gb3B0aW9ucyBmb3IgcmVuZGVyaW5nIGFyZSBpbiBpbnRlcmFjdGlvblxuXG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5pbnRlcmFjdGlvbik7IC8vIG9wdGlvbnMgZm9yIHNlbGVjdGlvbiBhcmUgaW4gaW50ZXJhY3Rpb25cbiAgICAvLyByZWxvYWQgdGhlIHNldHRpbmdzIG9mIHRoZSBub2RlcyB0byBhcHBseSBjaGFuZ2VzIGluIGdyb3VwcyB0aGF0IGFyZSBub3QgcmVmZXJlbmNlZCBieSBwb2ludGVyLlxuXG4gICAgaWYgKG9wdGlvbnMuZ3JvdXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZWZyZXNoTm9kZXNcIik7XG4gICAgfSAvLyB0aGVzZSB0d28gZG8gbm90IGhhdmUgb3B0aW9ucyBhdCB0aGUgbW9tZW50LCBoZXJlIGZvciBjb21wbGV0ZW5lc3NcbiAgICAvL3RoaXMudmlldy5zZXRPcHRpb25zKG9wdGlvbnMudmlldyk7XG4gICAgLy90aGlzLmNsdXN0ZXJpbmcuc2V0T3B0aW9ucyhvcHRpb25zLmNsdXN0ZXJpbmcpO1xuXG5cbiAgICBpZiAoXCJjb25maWd1cmVcIiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29uZmlndXJhdG9yKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdG9yID0gbmV3IENvbmZpZ3VyYXRvcih0aGlzLCB0aGlzLmJvZHkuY29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zLCB0aGlzLmNhbnZhcy5waXhlbFJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0T3B0aW9ucyhvcHRpb25zLmNvbmZpZ3VyZSk7XG4gICAgfSAvLyBpZiB0aGUgY29uZmlndXJhdGlvbiBzeXN0ZW0gaXMgZW5hYmxlZCwgY29weSBhbGwgb3B0aW9ucyBhbmQgcHV0IHRoZW0gaW50byB0aGUgY29uZmlnIHN5c3RlbVxuXG5cbiAgICBpZiAodGhpcy5jb25maWd1cmF0b3IgJiYgdGhpcy5jb25maWd1cmF0b3Iub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB2YXIgbmV0d29ya09wdGlvbnMgPSB7XG4gICAgICAgIG5vZGVzOiB7fSxcbiAgICAgICAgZWRnZXM6IHt9LFxuICAgICAgICBsYXlvdXQ6IHt9LFxuICAgICAgICBpbnRlcmFjdGlvbjoge30sXG4gICAgICAgIG1hbmlwdWxhdGlvbjoge30sXG4gICAgICAgIHBoeXNpY3M6IHt9LFxuICAgICAgICBnbG9iYWw6IHt9XG4gICAgICB9O1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5ub2RlcywgdGhpcy5ub2Rlc0hhbmRsZXIub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmVkZ2VzLCB0aGlzLmVkZ2VzSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubGF5b3V0LCB0aGlzLmxheW91dEVuZ2luZS5vcHRpb25zKTsgLy8gbG9hZCB0aGUgc2VsZWN0aW9uSGFuZGxlciBhbmQgcmVuZGVyIGRlZmF1bHQgb3B0aW9ucyBpbiB0byB0aGUgaW50ZXJhY3Rpb24gZ3JvdXBcblxuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5yZW5kZXJlci5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuaW50ZXJhY3Rpb24sIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5tYW5pcHVsYXRpb24sIHRoaXMubWFuaXB1bGF0aW9uLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5waHlzaWNzLCB0aGlzLnBoeXNpY3Mub3B0aW9ucyk7IC8vIGxvYWQgZ2xvYmFscyBpbnRvIHRoZSBnbG9iYWwgb2JqZWN0XG5cbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZ2xvYmFsLCB0aGlzLmNhbnZhcy5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZ2xvYmFsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0TW9kdWxlT3B0aW9ucyhuZXR3b3JrT3B0aW9ucyk7XG4gICAgfSAvLyBoYW5kbGUgbmV0d29yayBnbG9iYWwgb3B0aW9uc1xuXG5cbiAgICBpZiAob3B0aW9ucy5jbGlja1RvVXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvciA9IG5ldyBBY3RpdmF0b3IodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWN0aXZhdGVcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhY3RpdmF0ZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhcy5zZXRTaXplKCk7IC8vIHN0YXJ0IHRoZSBwaHlzaWNzIHNpbXVsYXRpb24uIENhbiBiZSBzYWZlbHkgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuXG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgfVxufTtcbi8qKlxuICogVXBkYXRlIHRoZSB2aXNpYmxlIG5vZGVzIGFuZCBlZGdlcyBsaXN0IHdpdGggdGhlIG1vc3QgcmVjZW50IG5vZGUgc3RhdGUuXG4gKlxuICogVmlzaWJsZSBub2RlcyBhcmUgc3RvcmVkIGluIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5cbiAqIFZpc2libGUgZWRnZXMgYXJlIHN0b3JlZCBpbiB0aGlzLmJvZHkuZWRnZUluZGljZXMuXG4gKiBBIG5vZGUgb3IgZWRnZXMgaXMgdmlzaWJsZSBpZiBpdCBpcyBub3QgaGlkZGVuIG9yIGNsdXN0ZXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuTmV0d29yay5wcm90b3R5cGUuX3VwZGF0ZVZpc2libGVJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzID0gW107XG4gIHRoaXMuYm9keS5lZGdlSW5kaWNlcyA9IFtdO1xuXG4gIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgIGlmICghdGhpcy5jbHVzdGVyaW5nLl9pc0NsdXN0ZXJlZE5vZGUobm9kZUlkKSAmJiBub2Rlc1tub2RlSWRdLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaChub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBlZGdlSWQgaW4gZWRnZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJZF07IC8vIEl0IGNhbiBoYXBwZW4gdGhhdCB0aGlzIGlzIGV4ZWN1dGVkICphZnRlciogYSBub2RlIGVkZ2UgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgIC8vIGJ1dCAqYmVmb3JlKiB0aGUgZWRnZSBpdHNlbGYgaGFzIGJlZW4gcmVtb3ZlZC4gVGFraW5nIHRoaXMgaW50byBhY2NvdW50LlxuXG4gICAgICB2YXIgZnJvbU5vZGUgPSBub2Rlc1tlZGdlLmZyb21JZF07XG4gICAgICB2YXIgdG9Ob2RlID0gbm9kZXNbZWRnZS50b0lkXTtcbiAgICAgIHZhciBlZGdlTm9kZXNQcmVzZW50ID0gZnJvbU5vZGUgIT09IHVuZGVmaW5lZCAmJiB0b05vZGUgIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpc1Zpc2libGUgPSAhdGhpcy5jbHVzdGVyaW5nLl9pc0NsdXN0ZXJlZEVkZ2UoZWRnZUlkKSAmJiBlZGdlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSAmJiBlZGdlTm9kZXNQcmVzZW50ICYmIGZyb21Ob2RlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSAmJiAvLyBBbHNvIGhpZGRlbiBpZiBhbnkgb2YgaXRzIGNvbm5lY3Rpbmcgbm9kZXMgYXJlIGhpZGRlblxuICAgICAgdG9Ob2RlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZTsgLy8gaWRlbVxuXG4gICAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lZGdlSW5kaWNlcy5wdXNoKGVkZ2UuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQmluZCBhbGwgZXZlbnRzXG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5iaW5kRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gIC8vIFRoaXMgZXZlbnQgd2lsbCB0cmlnZ2VyIGEgcmVidWlsZGluZyBvZiB0aGUgY2FjaGUgZXZlcnl0aGluZy5cbiAgLy8gVXNlZCB3aGVuIG5vZGVzIG9yIGVkZ2VzIGhhdmUgYmVlbiBhZGRlZCBvciByZW1vdmVkLlxuICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMzLmVkZ2VzSGFuZGxlci5fdXBkYXRlU3RhdGUoKTtcblxuICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKTtcbiAgfSk7IC8vIHRoaXMgaXMgY2FsbGVkIHdoZW4gb3B0aW9ucyBvZiBFWElTVElORyBub2RlcyBvciBlZGdlcyBoYXZlIGNoYW5nZWQuXG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YVVwZGF0ZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIC8vIE9yZGVyIGltcG9ydGFudCBpbiBmb2xsb3dpbmcgYmxvY2tcbiAgICBfdGhpczMuY2x1c3RlcmluZy5fdXBkYXRlU3RhdGUoKTtcblxuICAgIF90aGlzMy5fdXBkYXRlVmlzaWJsZUluZGljZXMoKTtcblxuICAgIF90aGlzMy5fdXBkYXRlVmFsdWVSYW5nZShfdGhpczMuYm9keS5ub2Rlcyk7XG5cbiAgICBfdGhpczMuX3VwZGF0ZVZhbHVlUmFuZ2UoX3RoaXMzLmJvZHkuZWRnZXMpOyAvLyBzdGFydCBzaW11bGF0aW9uIChjYW4gYmUgY2FsbGVkIHNhZmVseSwgZXZlbiBpZiBhbHJlYWR5IHJ1bm5pbmcpXG5cblxuICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcblxuICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICB9KTtcbn07XG4vKipcbiAqIFNldCBub2RlcyBhbmQgZWRnZXMsIGFuZCBvcHRpb25hbGx5IG9wdGlvbnMgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSAgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IFtub2Rlc10gQXJyYXkgd2l0aCBub2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gW2VkZ2VzXSBBcnJheSB3aXRoIGVkZ2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gW2RvdF0gU3RyaW5nIGNvbnRhaW5pbmcgZGF0YSBpbiBET1QgZm9ybWF0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gW2dlcGhpXSBTdHJpbmcgY29udGFpbmluZyBkYXRhIGluIGdlcGhpIEpTT04gZm9ybWF0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09wdGlvbnN9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBvcHRpb25zXG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgLy8gcmVzZXQgdGhlIHBoeXNpY3MgZW5naW5lLlxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzZXRQaHlzaWNzXCIpO1xuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3Jlc2V0RGF0YVwiKTsgLy8gdW5zZWxlY3QgYWxsIHRvIGVuc3VyZSBubyBzZWxlY3Rpb25zIGZyb20gb2xkIGRhdGEgYXJlIGNhcnJpZWQgb3Zlci5cblxuICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcblxuICBpZiAoZGF0YSAmJiBkYXRhLmRvdCAmJiAoZGF0YS5ub2RlcyB8fCBkYXRhLmVkZ2VzKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRGF0YSBtdXN0IGNvbnRhaW4gZWl0aGVyIHBhcmFtZXRlciBcImRvdFwiIG9yICcgKyAnIHBhcmFtZXRlciBwYWlyIFwibm9kZXNcIiBhbmQgXCJlZGdlc1wiLCBidXQgbm90IGJvdGguJyk7XG4gIH0gLy8gc2V0IG9wdGlvbnNcblxuXG4gIHRoaXMuc2V0T3B0aW9ucyhkYXRhICYmIGRhdGEub3B0aW9ucyk7IC8vIHNldCBhbGwgZGF0YVxuXG4gIGlmIChkYXRhICYmIGRhdGEuZG90KSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIGRvdCBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBzdGF0aWMgY29udmVydERvdCBtZXRob2QgdG8gY29udmVydCBET1QgaW50byB2aXMubmV0d29yayBmb3JtYXQgYW5kIHVzZSB0aGUgbm9ybWFsIGRhdGEgZm9ybWF0IHdpdGggbm9kZXMgYW5kIGVkZ2VzLiBUaGlzIGNvbnZlcnRlciBpcyB1c2VkIGxpa2UgdGhpczogdmFyIGRhdGEgPSB2aXMubmV0d29yay5jb252ZXJ0RG90KGRvdFN0cmluZyk7XCIpOyAvLyBwYXJzZSBET1QgZmlsZVxuXG4gICAgdmFyIGRvdERhdGEgPSBET1RUb0dyYXBoKGRhdGEuZG90KTtcbiAgICB0aGlzLnNldERhdGEoZG90RGF0YSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5nZXBoaSkge1xuICAgIC8vIHBhcnNlIERPVCBmaWxlXG4gICAgY29uc29sZS53YXJuKFwiVGhlIGdlcGhpIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0YXRpYyBjb252ZXJ0R2VwaGkgbWV0aG9kIHRvIGNvbnZlcnQgZ2VwaGkgaW50byB2aXMubmV0d29yayBmb3JtYXQgYW5kIHVzZSB0aGUgbm9ybWFsIGRhdGEgZm9ybWF0IHdpdGggbm9kZXMgYW5kIGVkZ2VzLiBUaGlzIGNvbnZlcnRlciBpcyB1c2VkIGxpa2UgdGhpczogdmFyIGRhdGEgPSB2aXMubmV0d29yay5jb252ZXJ0R2VwaGkoZ2VwaGlKc29uKTtcIik7XG4gICAgdmFyIGdlcGhpRGF0YSA9IHBhcnNlR2VwaGkoZGF0YS5nZXBoaSk7XG4gICAgdGhpcy5zZXREYXRhKGdlcGhpRGF0YSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubm9kZXNIYW5kbGVyLnNldERhdGEoZGF0YSAmJiBkYXRhLm5vZGVzLCB0cnVlKTtcbiAgICB0aGlzLmVkZ2VzSGFuZGxlci5zZXREYXRhKGRhdGEgJiYgZGF0YS5lZGdlcywgdHJ1ZSk7XG4gIH0gLy8gZW1pdCBjaGFuZ2UgaW4gZGF0YVxuXG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTsgLy8gZW1pdCBkYXRhIGxvYWRlZFxuXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUxvYWRlZFwiKTsgLy8gZmluZCBhIHN0YWJsZSBwb3NpdGlvbiBvciBzdGFydCBhbmltYXRpbmcgdG8gYSBzdGFibGUgcG9zaXRpb25cblxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiaW5pdFBoeXNpY3NcIik7XG59O1xuLyoqXG4gKiBDbGVhbnMgdXAgYWxsIGJpbmRpbmdzIG9mIHRoZSBuZXR3b3JrLCByZW1vdmluZyBpdCBmdWxseSBmcm9tIHRoZSBtZW1vcnkgSUYgdGhlIHZhcmlhYmxlIGlzIHNldCB0byBudWxsIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAqIHZhciBuZXR3b3JrID0gbmV3IHZpcy5OZXR3b3JrKC4uKTtcbiAqIG5ldHdvcmsuZGVzdHJveSgpO1xuICogbmV0d29yayA9IG51bGw7XG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZGVzdHJveVwiKTsgLy8gY2xlYXIgZXZlbnRzXG5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gIHRoaXMub2ZmKCk7IC8vIGRlbGV0ZSBtb2R1bGVzXG5cbiAgZGVsZXRlIHRoaXMuZ3JvdXBzO1xuICBkZWxldGUgdGhpcy5jYW52YXM7XG4gIGRlbGV0ZSB0aGlzLnNlbGVjdGlvbkhhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMudmlldztcbiAgZGVsZXRlIHRoaXMucmVuZGVyZXI7XG4gIGRlbGV0ZSB0aGlzLnBoeXNpY3M7XG4gIGRlbGV0ZSB0aGlzLmxheW91dEVuZ2luZTtcbiAgZGVsZXRlIHRoaXMuY2x1c3RlcmluZztcbiAgZGVsZXRlIHRoaXMubWFuaXB1bGF0aW9uO1xuICBkZWxldGUgdGhpcy5ub2Rlc0hhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLmVkZ2VzSGFuZGxlcjtcbiAgZGVsZXRlIHRoaXMuY29uZmlndXJhdG9yO1xuICBkZWxldGUgdGhpcy5pbWFnZXM7XG5cbiAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkgY29udGludWU7XG4gICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICB9XG5cbiAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcywgZWRnZUlkKSkgY29udGludWU7XG4gICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdO1xuICB9IC8vIHJlbW92ZSB0aGUgY29udGFpbmVyIGFuZCBldmVyeXRoaW5nIGluc2lkZSBpdCByZWN1cnNpdmVseVxuXG5cbiAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuYm9keS5jb250YWluZXIpO1xufTtcbi8qKlxuICogVXBkYXRlIHRoZSB2YWx1ZXMgb2YgYWxsIG9iamVjdCBpbiB0aGUgZ2l2ZW4gYXJyYXkgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50XG4gKiB2YWx1ZSByYW5nZSBvZiB0aGUgb2JqZWN0cyBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAgICBBbiBvYmplY3QgY29udGFpbmluZyBhIHNldCBvZiBFZGdlcyBvciBOb2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0cyBtdXN0IGhhdmUgYSBtZXRob2QgZ2V0VmFsdWUoKSBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVSYW5nZShtaW4sIG1heCkuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuTmV0d29yay5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlUmFuZ2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBpZDsgLy8gZGV0ZXJtaW5lIHRoZSByYW5nZSBvZiB0aGUgb2JqZWN0c1xuXG4gIHZhciB2YWx1ZU1pbiA9IHVuZGVmaW5lZDtcbiAgdmFyIHZhbHVlTWF4ID0gdW5kZWZpbmVkO1xuICB2YXIgdmFsdWVUb3RhbCA9IDA7XG5cbiAgZm9yIChpZCBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaWQpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmpbaWRdLmdldFZhbHVlKCk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlTWluID0gdmFsdWVNaW4gPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogTWF0aC5taW4odmFsdWUsIHZhbHVlTWluKTtcbiAgICAgICAgdmFsdWVNYXggPSB2YWx1ZU1heCA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBNYXRoLm1heCh2YWx1ZSwgdmFsdWVNYXgpO1xuICAgICAgICB2YWx1ZVRvdGFsICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBhZGp1c3QgdGhlIHJhbmdlIG9mIGFsbCBvYmplY3RzXG5cblxuICBpZiAodmFsdWVNaW4gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpZCBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpZCkpIHtcbiAgICAgICAgb2JqW2lkXS5zZXRWYWx1ZVJhbmdlKHZhbHVlTWluLCB2YWx1ZU1heCwgdmFsdWVUb3RhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgTmV0d29yayBpcyBhY3RpdmUuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuXG5OZXR3b3JrLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICF0aGlzLmFjdGl2YXRvciB8fCB0aGlzLmFjdGl2YXRvci5hY3RpdmU7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jYW52YXMuc2V0U2l6ZS5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmNhbnZhc1RvRE9NID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jYW52YXMuY2FudmFzVG9ET00uYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5ET010b0NhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xufTtcbi8qKlxuICogTm9kZXMgY2FuIGJlIGluIGNsdXN0ZXJzLiBDbHVzdGVycyBjYW4gYWxzbyBiZSBpbiBjbHVzdGVycy4gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuZCBhcnJheSBvZlxuICogbm9kZUlkcyBzaG93aW5nIHdoZXJlIHRoZSBub2RlIGlzLlxuICpcbiAqIElmIGFueSBub2RlSWQgaW4gdGhlIGNoYWluLCBlc3BlY2lhbGx5IHRoZSBmaXJzdCBwYXNzZWQgaW4gYXMgYSBwYXJhbWV0ZXIsIGlzIG5vdCBwcmVzZW50IGluXG4gKiB0aGUgY3VycmVudCBub2RlcyBsaXN0LCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAqXG4gKiBFeGFtcGxlOlxuICogY2x1c3RlciAnQScgY29udGFpbnMgY2x1c3RlciAnQicsXG4gKiBjbHVzdGVyICdCJyBjb250YWlucyBjbHVzdGVyICdDJyxcbiAqIGNsdXN0ZXIgJ0MnIGNvbnRhaW5zIG5vZGUgJ2ZyZWQnLlxuICogYGpzbmV0d29yay5jbHVzdGVyaW5nLmZpbmROb2RlKCdmcmVkJylgIHdpbGwgcmV0dXJuIGBbJ0EnLCdCJywnQycsJ2ZyZWQnXWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBub2RlSWRcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuXG5cbk5ldHdvcmsucHJvdG90eXBlLmZpbmROb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmZpbmROb2RlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmlzQ2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5pc0NsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUub3BlbkNsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcub3BlbkNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuY2x1c3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldE5vZGVzSW5DbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldE5vZGVzSW5DbHVzdGVyLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJCeUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3RlckJ5Q29ubmVjdGlvbi5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyQnlIdWJzaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmNsdXN0ZXJCeUh1YnNpemUuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUudXBkYXRlQ2x1c3RlcmVkTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy51cGRhdGVDbHVzdGVyZWROb2RlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldENsdXN0ZXJlZEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldENsdXN0ZXJlZEVkZ2VzLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldEJhc2VFZGdlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldEJhc2VFZGdlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldEJhc2VFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXRCYXNlRWRnZXMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUudXBkYXRlRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy51cGRhdGVFZGdlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG4vKipcbiAqIFRoaXMgbWV0aG9kIHdpbGwgY2x1c3RlciBhbGwgbm9kZXMgd2l0aCAxIGVkZ2Ugd2l0aCB0aGVpciByZXNwZWN0aXZlIGNvbm5lY3RlZCBub2RlLlxuICogVGhlIG9wdGlvbnMgb2JqZWN0IGlzIGV4cGxhaW5lZCBpbiBmdWxsIDxhIGRhdGEtc2Nyb2xsPVwiXCIgZGF0YS1vcHRpb25zPVwieyAmcXVvdDtlYXNpbmcmcXVvdDs6ICZxdW90O2Vhc2VJbkN1YmljJnF1b3Q7IH1cIiBocmVmPVwiI29wdGlvbnNPYmplY3RcIj5iZWxvdzwvYT4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5cbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJPdXRsaWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyT3V0bGllcnMuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGF5b3V0RW5naW5lLmdldFNlZWQuYXBwbHkodGhpcy5sYXlvdXRFbmdpbmUsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5lbmFibGVFZGl0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVuYWJsZUVkaXRNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZGlzYWJsZUVkaXRNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZGlzYWJsZUVkaXRNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuYWRkTm9kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5hZGROb2RlTW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmVkaXROb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdE5vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5lZGl0Tm9kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUud2FybihcIkRlcHJlY2F0ZWQ6IFBsZWFzZSB1c2UgZWRpdE5vZGUgaW5zdGVhZCBvZiBlZGl0Tm9kZU1vZGUuXCIpO1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdE5vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5hZGRFZGdlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZWRpdEVkZ2VNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZGVsZXRlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hbmlwdWxhdGlvbi5kZWxldGVTZWxlY3RlZC5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldFBvc2l0aW9ucy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0UG9zaXRpb24uYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zdG9yZVBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLnN0b3JlUG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUubW92ZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5tb3ZlTm9kZS5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Qm91bmRpbmdCb3guYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRDb25uZWN0ZWROb2RlcyA9IGZ1bmN0aW9uIChvYmplY3RJZCkge1xuICBpZiAodGhpcy5ib2R5Lm5vZGVzW29iamVjdElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldENvbm5lY3RlZE5vZGVzLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLmVkZ2VzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRDb25uZWN0ZWRFZGdlcy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnN0YXJ0U2ltdWxhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdGFydFNpbXVsYXRpb24uYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc3RvcFNpbXVsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBoeXNpY3Muc3RvcFNpbXVsYXRpb24uYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuc3RhYmlsaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5waHlzaWNzLnN0YWJpbGl6ZS5hcHBseSh0aGlzLnBoeXNpY3MsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRTZWxlY3Rpb24uYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZE5vZGVJZHMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VJZHMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUuZ2V0Tm9kZUF0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xuXG4gIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5vZGUuaWQ7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmdldEVkZ2VBdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2UgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0RWRnZUF0LmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcblxuICBpZiAoZWRnZSAhPT0gdW5kZWZpbmVkICYmIGVkZ2UuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlZGdlLmlkO1xuICB9XG5cbiAgcmV0dXJuIGVkZ2U7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zZWxlY3ROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3ROb2Rlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5zZWxlY3RFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RFZGdlcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS51bnNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVkcmF3LmFwcGx5KHRoaXMucmVuZGVyZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5nZXRTY2FsZS5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRWaWV3UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuZ2V0Vmlld1Bvc2l0aW9uLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5cbk5ldHdvcmsucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5maXQuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcblxuTmV0d29yay5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3Lm1vdmVUby5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5mb2N1cy5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5yZWxlYXNlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5yZWxlYXNlTm9kZS5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuXG5OZXR3b3JrLnByb3RvdHlwZS5nZXRPcHRpb25zRnJvbUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICBpZiAodGhpcy5jb25maWd1cmF0b3IpIHtcbiAgICBvcHRpb25zID0gdGhpcy5jb25maWd1cmF0b3IuZ2V0T3B0aW9ucy5hcHBseSh0aGlzLmNvbmZpZ3VyYXRvcik7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbnZhciBwYXJzZURPVE5ldHdvcmsgPSBET1RUb0dyYXBoO1xuLy8gb3ZlcmZsb3cgaW4gVU1EIGJ1aWxkcy4gVGhleSBhbGwgZXhwb3J0IHZpcyBuYW1lc3BhY2UgdGhlcmVmb3JlIHJlZXhwb3J0aW5nXG4vLyBsZWFkcyB0byBsb2FkaW5nIHZpcyB0byBsb2FkIHZpcyB0byBsb2FkIHZpc+KAplxuXG5leHBvcnQgeyBOZXR3b3JrLCBJbWFnZXMgYXMgTmV0d29ya0ltYWdlcywgZG90cGFyc2VyIGFzIG5ldHdvcmtET1RQYXJzZXIsIGdlcGhpUGFyc2VyIGFzIG5ldHdvcmtHZXBoaVBhcnNlciwgb3B0aW9ucyBhcyBuZXR3b3JrT3B0aW9ucywgcGFyc2VET1ROZXR3b3JrLCBwYXJzZUdlcGhpIGFzIHBhcnNlR2VwaGlOZXR3b3JrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXMtbmV0d29yay5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vis-network/peer/esm/vis-network.js\n");

/***/ })

}]);